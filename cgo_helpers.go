// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Tue, 11 May 2021 22:13:01 EDT.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package vulkan

/*
#cgo CFLAGS: -I. -DVK_NO_PROTOTYPES
#include "vulkan/vulkan.h"
#include "vulkan/vulkan_xcb.h"
#include "vulkan/vulkan_xlib.h"
#include "vulkan/vulkan_xlib_xrandr.h"
#include "vulkan/vulkan_wayland.h"
#include "vk_wrapper.h"
#include "vk_bridge.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocExtent2DMemory allocates memory for type C.VkExtent2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExtent2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExtent2DValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExtent2DValue = unsafe.Sizeof([1]C.VkExtent2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Extent2D) Ref() *C.VkExtent2D {
	if x == nil {
		return nil
	}
	return x.refe2edf56b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Extent2D) Free() {
	if x != nil && x.allocse2edf56b != nil {
		x.allocse2edf56b.(*cgoAllocMap).Free()
		x.refe2edf56b = nil
	}
}

// NewExtent2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExtent2DRef(ref unsafe.Pointer) *Extent2D {
	if ref == nil {
		return nil
	}
	obj := new(Extent2D)
	obj.refe2edf56b = (*C.VkExtent2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Extent2D) PassRef() (*C.VkExtent2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe2edf56b != nil {
		return x.refe2edf56b, nil
	}
	meme2edf56b := allocExtent2DMemory(1)
	refe2edf56b := (*C.VkExtent2D)(meme2edf56b)
	allocse2edf56b := new(cgoAllocMap)
	allocse2edf56b.Add(meme2edf56b)

	var cwidth_allocs *cgoAllocMap
	refe2edf56b.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocse2edf56b.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refe2edf56b.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocse2edf56b.Borrow(cheight_allocs)

	x.refe2edf56b = refe2edf56b
	x.allocse2edf56b = allocse2edf56b
	return refe2edf56b, allocse2edf56b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Extent2D) PassValue() (C.VkExtent2D, *cgoAllocMap) {
	if x.refe2edf56b != nil {
		return *x.refe2edf56b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Extent2D) Deref() {
	if x.refe2edf56b == nil {
		return
	}
	x.Width = (uint32)(x.refe2edf56b.width)
	x.Height = (uint32)(x.refe2edf56b.height)
}

// allocExtent3DMemory allocates memory for type C.VkExtent3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExtent3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExtent3DValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExtent3DValue = unsafe.Sizeof([1]C.VkExtent3D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Extent3D) Ref() *C.VkExtent3D {
	if x == nil {
		return nil
	}
	return x.reffbf6c42a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Extent3D) Free() {
	if x != nil && x.allocsfbf6c42a != nil {
		x.allocsfbf6c42a.(*cgoAllocMap).Free()
		x.reffbf6c42a = nil
	}
}

// NewExtent3DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExtent3DRef(ref unsafe.Pointer) *Extent3D {
	if ref == nil {
		return nil
	}
	obj := new(Extent3D)
	obj.reffbf6c42a = (*C.VkExtent3D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Extent3D) PassRef() (*C.VkExtent3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffbf6c42a != nil {
		return x.reffbf6c42a, nil
	}
	memfbf6c42a := allocExtent3DMemory(1)
	reffbf6c42a := (*C.VkExtent3D)(memfbf6c42a)
	allocsfbf6c42a := new(cgoAllocMap)
	allocsfbf6c42a.Add(memfbf6c42a)

	var cwidth_allocs *cgoAllocMap
	reffbf6c42a.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocsfbf6c42a.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	reffbf6c42a.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocsfbf6c42a.Borrow(cheight_allocs)

	var cdepth_allocs *cgoAllocMap
	reffbf6c42a.depth, cdepth_allocs = (C.uint32_t)(x.Depth), cgoAllocsUnknown
	allocsfbf6c42a.Borrow(cdepth_allocs)

	x.reffbf6c42a = reffbf6c42a
	x.allocsfbf6c42a = allocsfbf6c42a
	return reffbf6c42a, allocsfbf6c42a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Extent3D) PassValue() (C.VkExtent3D, *cgoAllocMap) {
	if x.reffbf6c42a != nil {
		return *x.reffbf6c42a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Extent3D) Deref() {
	if x.reffbf6c42a == nil {
		return
	}
	x.Width = (uint32)(x.reffbf6c42a.width)
	x.Height = (uint32)(x.reffbf6c42a.height)
	x.Depth = (uint32)(x.reffbf6c42a.depth)
}

// allocOffset2DMemory allocates memory for type C.VkOffset2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOffset2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOffset2DValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfOffset2DValue = unsafe.Sizeof([1]C.VkOffset2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Offset2D) Ref() *C.VkOffset2D {
	if x == nil {
		return nil
	}
	return x.ref32734883
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Offset2D) Free() {
	if x != nil && x.allocs32734883 != nil {
		x.allocs32734883.(*cgoAllocMap).Free()
		x.ref32734883 = nil
	}
}

// NewOffset2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOffset2DRef(ref unsafe.Pointer) *Offset2D {
	if ref == nil {
		return nil
	}
	obj := new(Offset2D)
	obj.ref32734883 = (*C.VkOffset2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Offset2D) PassRef() (*C.VkOffset2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref32734883 != nil {
		return x.ref32734883, nil
	}
	mem32734883 := allocOffset2DMemory(1)
	ref32734883 := (*C.VkOffset2D)(mem32734883)
	allocs32734883 := new(cgoAllocMap)
	allocs32734883.Add(mem32734883)

	var cx_allocs *cgoAllocMap
	ref32734883.x, cx_allocs = (C.int32_t)(x.X), cgoAllocsUnknown
	allocs32734883.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref32734883.y, cy_allocs = (C.int32_t)(x.Y), cgoAllocsUnknown
	allocs32734883.Borrow(cy_allocs)

	x.ref32734883 = ref32734883
	x.allocs32734883 = allocs32734883
	return ref32734883, allocs32734883

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Offset2D) PassValue() (C.VkOffset2D, *cgoAllocMap) {
	if x.ref32734883 != nil {
		return *x.ref32734883, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Offset2D) Deref() {
	if x.ref32734883 == nil {
		return
	}
	x.X = (int32)(x.ref32734883.x)
	x.Y = (int32)(x.ref32734883.y)
}

// allocOffset3DMemory allocates memory for type C.VkOffset3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOffset3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOffset3DValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfOffset3DValue = unsafe.Sizeof([1]C.VkOffset3D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Offset3D) Ref() *C.VkOffset3D {
	if x == nil {
		return nil
	}
	return x.ref2b6879c2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Offset3D) Free() {
	if x != nil && x.allocs2b6879c2 != nil {
		x.allocs2b6879c2.(*cgoAllocMap).Free()
		x.ref2b6879c2 = nil
	}
}

// NewOffset3DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOffset3DRef(ref unsafe.Pointer) *Offset3D {
	if ref == nil {
		return nil
	}
	obj := new(Offset3D)
	obj.ref2b6879c2 = (*C.VkOffset3D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Offset3D) PassRef() (*C.VkOffset3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2b6879c2 != nil {
		return x.ref2b6879c2, nil
	}
	mem2b6879c2 := allocOffset3DMemory(1)
	ref2b6879c2 := (*C.VkOffset3D)(mem2b6879c2)
	allocs2b6879c2 := new(cgoAllocMap)
	allocs2b6879c2.Add(mem2b6879c2)

	var cx_allocs *cgoAllocMap
	ref2b6879c2.x, cx_allocs = (C.int32_t)(x.X), cgoAllocsUnknown
	allocs2b6879c2.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref2b6879c2.y, cy_allocs = (C.int32_t)(x.Y), cgoAllocsUnknown
	allocs2b6879c2.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	ref2b6879c2.z, cz_allocs = (C.int32_t)(x.Z), cgoAllocsUnknown
	allocs2b6879c2.Borrow(cz_allocs)

	x.ref2b6879c2 = ref2b6879c2
	x.allocs2b6879c2 = allocs2b6879c2
	return ref2b6879c2, allocs2b6879c2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Offset3D) PassValue() (C.VkOffset3D, *cgoAllocMap) {
	if x.ref2b6879c2 != nil {
		return *x.ref2b6879c2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Offset3D) Deref() {
	if x.ref2b6879c2 == nil {
		return
	}
	x.X = (int32)(x.ref2b6879c2.x)
	x.Y = (int32)(x.ref2b6879c2.y)
	x.Z = (int32)(x.ref2b6879c2.z)
}

// allocRect2DMemory allocates memory for type C.VkRect2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRect2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRect2DValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRect2DValue = unsafe.Sizeof([1]C.VkRect2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Rect2D) Ref() *C.VkRect2D {
	if x == nil {
		return nil
	}
	return x.ref89e4256f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Rect2D) Free() {
	if x != nil && x.allocs89e4256f != nil {
		x.allocs89e4256f.(*cgoAllocMap).Free()
		x.ref89e4256f = nil
	}
}

// NewRect2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRect2DRef(ref unsafe.Pointer) *Rect2D {
	if ref == nil {
		return nil
	}
	obj := new(Rect2D)
	obj.ref89e4256f = (*C.VkRect2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Rect2D) PassRef() (*C.VkRect2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref89e4256f != nil {
		return x.ref89e4256f, nil
	}
	mem89e4256f := allocRect2DMemory(1)
	ref89e4256f := (*C.VkRect2D)(mem89e4256f)
	allocs89e4256f := new(cgoAllocMap)
	allocs89e4256f.Add(mem89e4256f)

	var coffset_allocs *cgoAllocMap
	ref89e4256f.offset, coffset_allocs = x.Offset.PassValue()
	allocs89e4256f.Borrow(coffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref89e4256f.extent, cextent_allocs = x.Extent.PassValue()
	allocs89e4256f.Borrow(cextent_allocs)

	x.ref89e4256f = ref89e4256f
	x.allocs89e4256f = allocs89e4256f
	return ref89e4256f, allocs89e4256f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Rect2D) PassValue() (C.VkRect2D, *cgoAllocMap) {
	if x.ref89e4256f != nil {
		return *x.ref89e4256f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Rect2D) Deref() {
	if x.ref89e4256f == nil {
		return
	}
	x.Offset = *NewOffset2DRef(unsafe.Pointer(&x.ref89e4256f.offset))
	x.Extent = *NewExtent2DRef(unsafe.Pointer(&x.ref89e4256f.extent))
}

// allocBaseInStructureMemory allocates memory for type C.VkBaseInStructure in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBaseInStructureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBaseInStructureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBaseInStructureValue = unsafe.Sizeof([1]C.VkBaseInStructure{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocStruct_VkBaseInStructureMemory allocates memory for type C.struct_VkBaseInStructure in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct_VkBaseInStructureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct_VkBaseInStructureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct_VkBaseInStructureValue = unsafe.Sizeof([1]C.struct_VkBaseInStructure{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSBaseInStructure transforms a sliced Go data structure into plain C format.
func unpackSBaseInStructure(x []BaseInStructure) (unpacked *C.struct_VkBaseInStructure, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStruct_VkBaseInStructureMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_VkBaseInStructure)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_VkBaseInStructure)(h.Data)
	return
}

// packSBaseInStructure reads sliced Go data structure out from plain C format.
func packSBaseInStructure(v []BaseInStructure, ptr0 *C.struct_VkBaseInStructure) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStruct_VkBaseInStructureValue]C.struct_VkBaseInStructure)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBaseInStructureRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BaseInStructure) Ref() *C.VkBaseInStructure {
	if x == nil {
		return nil
	}
	return x.refeae401a9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BaseInStructure) Free() {
	if x != nil && x.allocseae401a9 != nil {
		x.allocseae401a9.(*cgoAllocMap).Free()
		x.refeae401a9 = nil
	}
}

// NewBaseInStructureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBaseInStructureRef(ref unsafe.Pointer) *BaseInStructure {
	if ref == nil {
		return nil
	}
	obj := new(BaseInStructure)
	obj.refeae401a9 = (*C.VkBaseInStructure)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BaseInStructure) PassRef() (*C.VkBaseInStructure, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeae401a9 != nil {
		return x.refeae401a9, nil
	}
	memeae401a9 := allocBaseInStructureMemory(1)
	refeae401a9 := (*C.VkBaseInStructure)(memeae401a9)
	allocseae401a9 := new(cgoAllocMap)
	allocseae401a9.Add(memeae401a9)

	var csType_allocs *cgoAllocMap
	refeae401a9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseae401a9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeae401a9.pNext, cpNext_allocs = unpackSBaseInStructure(x.PNext)
	allocseae401a9.Borrow(cpNext_allocs)

	x.refeae401a9 = refeae401a9
	x.allocseae401a9 = allocseae401a9
	return refeae401a9, allocseae401a9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BaseInStructure) PassValue() (C.VkBaseInStructure, *cgoAllocMap) {
	if x.refeae401a9 != nil {
		return *x.refeae401a9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BaseInStructure) Deref() {
	if x.refeae401a9 == nil {
		return
	}
	x.SType = (StructureType)(x.refeae401a9.sType)
	packSBaseInStructure(x.PNext, x.refeae401a9.pNext)
}

// allocBaseOutStructureMemory allocates memory for type C.VkBaseOutStructure in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBaseOutStructureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBaseOutStructureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBaseOutStructureValue = unsafe.Sizeof([1]C.VkBaseOutStructure{})

// allocStruct_VkBaseOutStructureMemory allocates memory for type C.struct_VkBaseOutStructure in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct_VkBaseOutStructureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct_VkBaseOutStructureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct_VkBaseOutStructureValue = unsafe.Sizeof([1]C.struct_VkBaseOutStructure{})

// unpackSBaseOutStructure transforms a sliced Go data structure into plain C format.
func unpackSBaseOutStructure(x []BaseOutStructure) (unpacked *C.struct_VkBaseOutStructure, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStruct_VkBaseOutStructureMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_VkBaseOutStructure)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_VkBaseOutStructure)(h.Data)
	return
}

// packSBaseOutStructure reads sliced Go data structure out from plain C format.
func packSBaseOutStructure(v []BaseOutStructure, ptr0 *C.struct_VkBaseOutStructure) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStruct_VkBaseOutStructureValue]C.struct_VkBaseOutStructure)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBaseOutStructureRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BaseOutStructure) Ref() *C.VkBaseOutStructure {
	if x == nil {
		return nil
	}
	return x.refd536fcd0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BaseOutStructure) Free() {
	if x != nil && x.allocsd536fcd0 != nil {
		x.allocsd536fcd0.(*cgoAllocMap).Free()
		x.refd536fcd0 = nil
	}
}

// NewBaseOutStructureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBaseOutStructureRef(ref unsafe.Pointer) *BaseOutStructure {
	if ref == nil {
		return nil
	}
	obj := new(BaseOutStructure)
	obj.refd536fcd0 = (*C.VkBaseOutStructure)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BaseOutStructure) PassRef() (*C.VkBaseOutStructure, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd536fcd0 != nil {
		return x.refd536fcd0, nil
	}
	memd536fcd0 := allocBaseOutStructureMemory(1)
	refd536fcd0 := (*C.VkBaseOutStructure)(memd536fcd0)
	allocsd536fcd0 := new(cgoAllocMap)
	allocsd536fcd0.Add(memd536fcd0)

	var csType_allocs *cgoAllocMap
	refd536fcd0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd536fcd0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd536fcd0.pNext, cpNext_allocs = unpackSBaseOutStructure(x.PNext)
	allocsd536fcd0.Borrow(cpNext_allocs)

	x.refd536fcd0 = refd536fcd0
	x.allocsd536fcd0 = allocsd536fcd0
	return refd536fcd0, allocsd536fcd0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BaseOutStructure) PassValue() (C.VkBaseOutStructure, *cgoAllocMap) {
	if x.refd536fcd0 != nil {
		return *x.refd536fcd0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BaseOutStructure) Deref() {
	if x.refd536fcd0 == nil {
		return
	}
	x.SType = (StructureType)(x.refd536fcd0.sType)
	packSBaseOutStructure(x.PNext, x.refd536fcd0.pNext)
}

// allocBufferMemoryBarrierMemory allocates memory for type C.VkBufferMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferMemoryBarrierValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferMemoryBarrierValue = unsafe.Sizeof([1]C.VkBufferMemoryBarrier{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferMemoryBarrier) Ref() *C.VkBufferMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.refeaf4700b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferMemoryBarrier) Free() {
	if x != nil && x.allocseaf4700b != nil {
		x.allocseaf4700b.(*cgoAllocMap).Free()
		x.refeaf4700b = nil
	}
}

// NewBufferMemoryBarrierRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferMemoryBarrierRef(ref unsafe.Pointer) *BufferMemoryBarrier {
	if ref == nil {
		return nil
	}
	obj := new(BufferMemoryBarrier)
	obj.refeaf4700b = (*C.VkBufferMemoryBarrier)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferMemoryBarrier) PassRef() (*C.VkBufferMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeaf4700b != nil {
		return x.refeaf4700b, nil
	}
	memeaf4700b := allocBufferMemoryBarrierMemory(1)
	refeaf4700b := (*C.VkBufferMemoryBarrier)(memeaf4700b)
	allocseaf4700b := new(cgoAllocMap)
	allocseaf4700b.Add(memeaf4700b)

	var csType_allocs *cgoAllocMap
	refeaf4700b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseaf4700b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeaf4700b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseaf4700b.Borrow(cpNext_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refeaf4700b.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocseaf4700b.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refeaf4700b.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocseaf4700b.Borrow(cdstAccessMask_allocs)

	var csrcQueueFamilyIndex_allocs *cgoAllocMap
	refeaf4700b.srcQueueFamilyIndex, csrcQueueFamilyIndex_allocs = (C.uint32_t)(x.SrcQueueFamilyIndex), cgoAllocsUnknown
	allocseaf4700b.Borrow(csrcQueueFamilyIndex_allocs)

	var cdstQueueFamilyIndex_allocs *cgoAllocMap
	refeaf4700b.dstQueueFamilyIndex, cdstQueueFamilyIndex_allocs = (C.uint32_t)(x.DstQueueFamilyIndex), cgoAllocsUnknown
	allocseaf4700b.Borrow(cdstQueueFamilyIndex_allocs)

	var cbuffer_allocs *cgoAllocMap
	refeaf4700b.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocseaf4700b.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	refeaf4700b.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocseaf4700b.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	refeaf4700b.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocseaf4700b.Borrow(csize_allocs)

	x.refeaf4700b = refeaf4700b
	x.allocseaf4700b = allocseaf4700b
	return refeaf4700b, allocseaf4700b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferMemoryBarrier) PassValue() (C.VkBufferMemoryBarrier, *cgoAllocMap) {
	if x.refeaf4700b != nil {
		return *x.refeaf4700b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferMemoryBarrier) Deref() {
	if x.refeaf4700b == nil {
		return
	}
	x.SType = (StructureType)(x.refeaf4700b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeaf4700b.pNext))
	x.SrcAccessMask = (AccessFlags)(x.refeaf4700b.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refeaf4700b.dstAccessMask)
	x.SrcQueueFamilyIndex = (uint32)(x.refeaf4700b.srcQueueFamilyIndex)
	x.DstQueueFamilyIndex = (uint32)(x.refeaf4700b.dstQueueFamilyIndex)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refeaf4700b.buffer))
	x.Offset = (DeviceSize)(x.refeaf4700b.offset)
	x.Size = (DeviceSize)(x.refeaf4700b.size)
}

// allocDispatchIndirectCommandMemory allocates memory for type C.VkDispatchIndirectCommand in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDispatchIndirectCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDispatchIndirectCommandValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDispatchIndirectCommandValue = unsafe.Sizeof([1]C.VkDispatchIndirectCommand{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DispatchIndirectCommand) Ref() *C.VkDispatchIndirectCommand {
	if x == nil {
		return nil
	}
	return x.refd298ba27
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DispatchIndirectCommand) Free() {
	if x != nil && x.allocsd298ba27 != nil {
		x.allocsd298ba27.(*cgoAllocMap).Free()
		x.refd298ba27 = nil
	}
}

// NewDispatchIndirectCommandRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDispatchIndirectCommandRef(ref unsafe.Pointer) *DispatchIndirectCommand {
	if ref == nil {
		return nil
	}
	obj := new(DispatchIndirectCommand)
	obj.refd298ba27 = (*C.VkDispatchIndirectCommand)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DispatchIndirectCommand) PassRef() (*C.VkDispatchIndirectCommand, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd298ba27 != nil {
		return x.refd298ba27, nil
	}
	memd298ba27 := allocDispatchIndirectCommandMemory(1)
	refd298ba27 := (*C.VkDispatchIndirectCommand)(memd298ba27)
	allocsd298ba27 := new(cgoAllocMap)
	allocsd298ba27.Add(memd298ba27)

	var cx_allocs *cgoAllocMap
	refd298ba27.x, cx_allocs = (C.uint32_t)(x.X), cgoAllocsUnknown
	allocsd298ba27.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refd298ba27.y, cy_allocs = (C.uint32_t)(x.Y), cgoAllocsUnknown
	allocsd298ba27.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	refd298ba27.z, cz_allocs = (C.uint32_t)(x.Z), cgoAllocsUnknown
	allocsd298ba27.Borrow(cz_allocs)

	x.refd298ba27 = refd298ba27
	x.allocsd298ba27 = allocsd298ba27
	return refd298ba27, allocsd298ba27

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DispatchIndirectCommand) PassValue() (C.VkDispatchIndirectCommand, *cgoAllocMap) {
	if x.refd298ba27 != nil {
		return *x.refd298ba27, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DispatchIndirectCommand) Deref() {
	if x.refd298ba27 == nil {
		return
	}
	x.X = (uint32)(x.refd298ba27.x)
	x.Y = (uint32)(x.refd298ba27.y)
	x.Z = (uint32)(x.refd298ba27.z)
}

// allocDrawIndexedIndirectCommandMemory allocates memory for type C.VkDrawIndexedIndirectCommand in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrawIndexedIndirectCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrawIndexedIndirectCommandValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDrawIndexedIndirectCommandValue = unsafe.Sizeof([1]C.VkDrawIndexedIndirectCommand{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrawIndexedIndirectCommand) Ref() *C.VkDrawIndexedIndirectCommand {
	if x == nil {
		return nil
	}
	return x.ref4c78b5c3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrawIndexedIndirectCommand) Free() {
	if x != nil && x.allocs4c78b5c3 != nil {
		x.allocs4c78b5c3.(*cgoAllocMap).Free()
		x.ref4c78b5c3 = nil
	}
}

// NewDrawIndexedIndirectCommandRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrawIndexedIndirectCommandRef(ref unsafe.Pointer) *DrawIndexedIndirectCommand {
	if ref == nil {
		return nil
	}
	obj := new(DrawIndexedIndirectCommand)
	obj.ref4c78b5c3 = (*C.VkDrawIndexedIndirectCommand)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrawIndexedIndirectCommand) PassRef() (*C.VkDrawIndexedIndirectCommand, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4c78b5c3 != nil {
		return x.ref4c78b5c3, nil
	}
	mem4c78b5c3 := allocDrawIndexedIndirectCommandMemory(1)
	ref4c78b5c3 := (*C.VkDrawIndexedIndirectCommand)(mem4c78b5c3)
	allocs4c78b5c3 := new(cgoAllocMap)
	allocs4c78b5c3.Add(mem4c78b5c3)

	var cindexCount_allocs *cgoAllocMap
	ref4c78b5c3.indexCount, cindexCount_allocs = (C.uint32_t)(x.IndexCount), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cindexCount_allocs)

	var cinstanceCount_allocs *cgoAllocMap
	ref4c78b5c3.instanceCount, cinstanceCount_allocs = (C.uint32_t)(x.InstanceCount), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cinstanceCount_allocs)

	var cfirstIndex_allocs *cgoAllocMap
	ref4c78b5c3.firstIndex, cfirstIndex_allocs = (C.uint32_t)(x.FirstIndex), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cfirstIndex_allocs)

	var cvertexOffset_allocs *cgoAllocMap
	ref4c78b5c3.vertexOffset, cvertexOffset_allocs = (C.int32_t)(x.VertexOffset), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cvertexOffset_allocs)

	var cfirstInstance_allocs *cgoAllocMap
	ref4c78b5c3.firstInstance, cfirstInstance_allocs = (C.uint32_t)(x.FirstInstance), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cfirstInstance_allocs)

	x.ref4c78b5c3 = ref4c78b5c3
	x.allocs4c78b5c3 = allocs4c78b5c3
	return ref4c78b5c3, allocs4c78b5c3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrawIndexedIndirectCommand) PassValue() (C.VkDrawIndexedIndirectCommand, *cgoAllocMap) {
	if x.ref4c78b5c3 != nil {
		return *x.ref4c78b5c3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrawIndexedIndirectCommand) Deref() {
	if x.ref4c78b5c3 == nil {
		return
	}
	x.IndexCount = (uint32)(x.ref4c78b5c3.indexCount)
	x.InstanceCount = (uint32)(x.ref4c78b5c3.instanceCount)
	x.FirstIndex = (uint32)(x.ref4c78b5c3.firstIndex)
	x.VertexOffset = (int32)(x.ref4c78b5c3.vertexOffset)
	x.FirstInstance = (uint32)(x.ref4c78b5c3.firstInstance)
}

// allocDrawIndirectCommandMemory allocates memory for type C.VkDrawIndirectCommand in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrawIndirectCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrawIndirectCommandValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDrawIndirectCommandValue = unsafe.Sizeof([1]C.VkDrawIndirectCommand{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrawIndirectCommand) Ref() *C.VkDrawIndirectCommand {
	if x == nil {
		return nil
	}
	return x.ref2b5b67c4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrawIndirectCommand) Free() {
	if x != nil && x.allocs2b5b67c4 != nil {
		x.allocs2b5b67c4.(*cgoAllocMap).Free()
		x.ref2b5b67c4 = nil
	}
}

// NewDrawIndirectCommandRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrawIndirectCommandRef(ref unsafe.Pointer) *DrawIndirectCommand {
	if ref == nil {
		return nil
	}
	obj := new(DrawIndirectCommand)
	obj.ref2b5b67c4 = (*C.VkDrawIndirectCommand)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrawIndirectCommand) PassRef() (*C.VkDrawIndirectCommand, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2b5b67c4 != nil {
		return x.ref2b5b67c4, nil
	}
	mem2b5b67c4 := allocDrawIndirectCommandMemory(1)
	ref2b5b67c4 := (*C.VkDrawIndirectCommand)(mem2b5b67c4)
	allocs2b5b67c4 := new(cgoAllocMap)
	allocs2b5b67c4.Add(mem2b5b67c4)

	var cvertexCount_allocs *cgoAllocMap
	ref2b5b67c4.vertexCount, cvertexCount_allocs = (C.uint32_t)(x.VertexCount), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cvertexCount_allocs)

	var cinstanceCount_allocs *cgoAllocMap
	ref2b5b67c4.instanceCount, cinstanceCount_allocs = (C.uint32_t)(x.InstanceCount), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cinstanceCount_allocs)

	var cfirstVertex_allocs *cgoAllocMap
	ref2b5b67c4.firstVertex, cfirstVertex_allocs = (C.uint32_t)(x.FirstVertex), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cfirstVertex_allocs)

	var cfirstInstance_allocs *cgoAllocMap
	ref2b5b67c4.firstInstance, cfirstInstance_allocs = (C.uint32_t)(x.FirstInstance), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cfirstInstance_allocs)

	x.ref2b5b67c4 = ref2b5b67c4
	x.allocs2b5b67c4 = allocs2b5b67c4
	return ref2b5b67c4, allocs2b5b67c4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrawIndirectCommand) PassValue() (C.VkDrawIndirectCommand, *cgoAllocMap) {
	if x.ref2b5b67c4 != nil {
		return *x.ref2b5b67c4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrawIndirectCommand) Deref() {
	if x.ref2b5b67c4 == nil {
		return
	}
	x.VertexCount = (uint32)(x.ref2b5b67c4.vertexCount)
	x.InstanceCount = (uint32)(x.ref2b5b67c4.instanceCount)
	x.FirstVertex = (uint32)(x.ref2b5b67c4.firstVertex)
	x.FirstInstance = (uint32)(x.ref2b5b67c4.firstInstance)
}

// allocImageSubresourceRangeMemory allocates memory for type C.VkImageSubresourceRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSubresourceRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSubresourceRangeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageSubresourceRangeValue = unsafe.Sizeof([1]C.VkImageSubresourceRange{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSubresourceRange) Ref() *C.VkImageSubresourceRange {
	if x == nil {
		return nil
	}
	return x.ref5aa1126
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSubresourceRange) Free() {
	if x != nil && x.allocs5aa1126 != nil {
		x.allocs5aa1126.(*cgoAllocMap).Free()
		x.ref5aa1126 = nil
	}
}

// NewImageSubresourceRangeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSubresourceRangeRef(ref unsafe.Pointer) *ImageSubresourceRange {
	if ref == nil {
		return nil
	}
	obj := new(ImageSubresourceRange)
	obj.ref5aa1126 = (*C.VkImageSubresourceRange)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSubresourceRange) PassRef() (*C.VkImageSubresourceRange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5aa1126 != nil {
		return x.ref5aa1126, nil
	}
	mem5aa1126 := allocImageSubresourceRangeMemory(1)
	ref5aa1126 := (*C.VkImageSubresourceRange)(mem5aa1126)
	allocs5aa1126 := new(cgoAllocMap)
	allocs5aa1126.Add(mem5aa1126)

	var caspectMask_allocs *cgoAllocMap
	ref5aa1126.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs5aa1126.Borrow(caspectMask_allocs)

	var cbaseMipLevel_allocs *cgoAllocMap
	ref5aa1126.baseMipLevel, cbaseMipLevel_allocs = (C.uint32_t)(x.BaseMipLevel), cgoAllocsUnknown
	allocs5aa1126.Borrow(cbaseMipLevel_allocs)

	var clevelCount_allocs *cgoAllocMap
	ref5aa1126.levelCount, clevelCount_allocs = (C.uint32_t)(x.LevelCount), cgoAllocsUnknown
	allocs5aa1126.Borrow(clevelCount_allocs)

	var cbaseArrayLayer_allocs *cgoAllocMap
	ref5aa1126.baseArrayLayer, cbaseArrayLayer_allocs = (C.uint32_t)(x.BaseArrayLayer), cgoAllocsUnknown
	allocs5aa1126.Borrow(cbaseArrayLayer_allocs)

	var clayerCount_allocs *cgoAllocMap
	ref5aa1126.layerCount, clayerCount_allocs = (C.uint32_t)(x.LayerCount), cgoAllocsUnknown
	allocs5aa1126.Borrow(clayerCount_allocs)

	x.ref5aa1126 = ref5aa1126
	x.allocs5aa1126 = allocs5aa1126
	return ref5aa1126, allocs5aa1126

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSubresourceRange) PassValue() (C.VkImageSubresourceRange, *cgoAllocMap) {
	if x.ref5aa1126 != nil {
		return *x.ref5aa1126, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSubresourceRange) Deref() {
	if x.ref5aa1126 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.ref5aa1126.aspectMask)
	x.BaseMipLevel = (uint32)(x.ref5aa1126.baseMipLevel)
	x.LevelCount = (uint32)(x.ref5aa1126.levelCount)
	x.BaseArrayLayer = (uint32)(x.ref5aa1126.baseArrayLayer)
	x.LayerCount = (uint32)(x.ref5aa1126.layerCount)
}

// allocImageMemoryBarrierMemory allocates memory for type C.VkImageMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageMemoryBarrierValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageMemoryBarrierValue = unsafe.Sizeof([1]C.VkImageMemoryBarrier{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageMemoryBarrier) Ref() *C.VkImageMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.refd52734ec
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageMemoryBarrier) Free() {
	if x != nil && x.allocsd52734ec != nil {
		x.allocsd52734ec.(*cgoAllocMap).Free()
		x.refd52734ec = nil
	}
}

// NewImageMemoryBarrierRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageMemoryBarrierRef(ref unsafe.Pointer) *ImageMemoryBarrier {
	if ref == nil {
		return nil
	}
	obj := new(ImageMemoryBarrier)
	obj.refd52734ec = (*C.VkImageMemoryBarrier)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageMemoryBarrier) PassRef() (*C.VkImageMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd52734ec != nil {
		return x.refd52734ec, nil
	}
	memd52734ec := allocImageMemoryBarrierMemory(1)
	refd52734ec := (*C.VkImageMemoryBarrier)(memd52734ec)
	allocsd52734ec := new(cgoAllocMap)
	allocsd52734ec.Add(memd52734ec)

	var csType_allocs *cgoAllocMap
	refd52734ec.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd52734ec.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd52734ec.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd52734ec.Borrow(cpNext_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refd52734ec.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocsd52734ec.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refd52734ec.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocsd52734ec.Borrow(cdstAccessMask_allocs)

	var coldLayout_allocs *cgoAllocMap
	refd52734ec.oldLayout, coldLayout_allocs = (C.VkImageLayout)(x.OldLayout), cgoAllocsUnknown
	allocsd52734ec.Borrow(coldLayout_allocs)

	var cnewLayout_allocs *cgoAllocMap
	refd52734ec.newLayout, cnewLayout_allocs = (C.VkImageLayout)(x.NewLayout), cgoAllocsUnknown
	allocsd52734ec.Borrow(cnewLayout_allocs)

	var csrcQueueFamilyIndex_allocs *cgoAllocMap
	refd52734ec.srcQueueFamilyIndex, csrcQueueFamilyIndex_allocs = (C.uint32_t)(x.SrcQueueFamilyIndex), cgoAllocsUnknown
	allocsd52734ec.Borrow(csrcQueueFamilyIndex_allocs)

	var cdstQueueFamilyIndex_allocs *cgoAllocMap
	refd52734ec.dstQueueFamilyIndex, cdstQueueFamilyIndex_allocs = (C.uint32_t)(x.DstQueueFamilyIndex), cgoAllocsUnknown
	allocsd52734ec.Borrow(cdstQueueFamilyIndex_allocs)

	var cimage_allocs *cgoAllocMap
	refd52734ec.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocsd52734ec.Borrow(cimage_allocs)

	var csubresourceRange_allocs *cgoAllocMap
	refd52734ec.subresourceRange, csubresourceRange_allocs = x.SubresourceRange.PassValue()
	allocsd52734ec.Borrow(csubresourceRange_allocs)

	x.refd52734ec = refd52734ec
	x.allocsd52734ec = allocsd52734ec
	return refd52734ec, allocsd52734ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageMemoryBarrier) PassValue() (C.VkImageMemoryBarrier, *cgoAllocMap) {
	if x.refd52734ec != nil {
		return *x.refd52734ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageMemoryBarrier) Deref() {
	if x.refd52734ec == nil {
		return
	}
	x.SType = (StructureType)(x.refd52734ec.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd52734ec.pNext))
	x.SrcAccessMask = (AccessFlags)(x.refd52734ec.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refd52734ec.dstAccessMask)
	x.OldLayout = (ImageLayout)(x.refd52734ec.oldLayout)
	x.NewLayout = (ImageLayout)(x.refd52734ec.newLayout)
	x.SrcQueueFamilyIndex = (uint32)(x.refd52734ec.srcQueueFamilyIndex)
	x.DstQueueFamilyIndex = (uint32)(x.refd52734ec.dstQueueFamilyIndex)
	x.Image = *(*Image)(unsafe.Pointer(&x.refd52734ec.image))
	x.SubresourceRange = *NewImageSubresourceRangeRef(unsafe.Pointer(&x.refd52734ec.subresourceRange))
}

// allocMemoryBarrierMemory allocates memory for type C.VkMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryBarrierValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryBarrierValue = unsafe.Sizeof([1]C.VkMemoryBarrier{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryBarrier) Ref() *C.VkMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.ref977c944e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryBarrier) Free() {
	if x != nil && x.allocs977c944e != nil {
		x.allocs977c944e.(*cgoAllocMap).Free()
		x.ref977c944e = nil
	}
}

// NewMemoryBarrierRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryBarrierRef(ref unsafe.Pointer) *MemoryBarrier {
	if ref == nil {
		return nil
	}
	obj := new(MemoryBarrier)
	obj.ref977c944e = (*C.VkMemoryBarrier)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryBarrier) PassRef() (*C.VkMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref977c944e != nil {
		return x.ref977c944e, nil
	}
	mem977c944e := allocMemoryBarrierMemory(1)
	ref977c944e := (*C.VkMemoryBarrier)(mem977c944e)
	allocs977c944e := new(cgoAllocMap)
	allocs977c944e.Add(mem977c944e)

	var csType_allocs *cgoAllocMap
	ref977c944e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs977c944e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref977c944e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs977c944e.Borrow(cpNext_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	ref977c944e.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocs977c944e.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	ref977c944e.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocs977c944e.Borrow(cdstAccessMask_allocs)

	x.ref977c944e = ref977c944e
	x.allocs977c944e = allocs977c944e
	return ref977c944e, allocs977c944e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryBarrier) PassValue() (C.VkMemoryBarrier, *cgoAllocMap) {
	if x.ref977c944e != nil {
		return *x.ref977c944e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryBarrier) Deref() {
	if x.ref977c944e == nil {
		return
	}
	x.SType = (StructureType)(x.ref977c944e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref977c944e.pNext))
	x.SrcAccessMask = (AccessFlags)(x.ref977c944e.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.ref977c944e.dstAccessMask)
}

// Ref returns a reference to C object as it is.
func (x *AllocationCallbacks) Ref() *C.VkAllocationCallbacks {
	if x == nil {
		return nil
	}
	return (*C.VkAllocationCallbacks)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *AllocationCallbacks) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewAllocationCallbacksRef converts the C object reference into a raw struct reference without wrapping.
func NewAllocationCallbacksRef(ref unsafe.Pointer) *AllocationCallbacks {
	return (*AllocationCallbacks)(ref)
}

// NewAllocationCallbacks allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewAllocationCallbacks() *AllocationCallbacks {
	return (*AllocationCallbacks)(allocAllocationCallbacksMemory(1))
}

// allocAllocationCallbacksMemory allocates memory for type C.VkAllocationCallbacks in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAllocationCallbacksMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAllocationCallbacksValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAllocationCallbacksValue = unsafe.Sizeof([1]C.VkAllocationCallbacks{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *AllocationCallbacks) PassRef() *C.VkAllocationCallbacks {
	if x == nil {
		x = (*AllocationCallbacks)(allocAllocationCallbacksMemory(1))
	}
	return (*C.VkAllocationCallbacks)(unsafe.Pointer(x))
}

// allocApplicationInfoMemory allocates memory for type C.VkApplicationInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocApplicationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfApplicationInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfApplicationInfoValue = unsafe.Sizeof([1]C.VkApplicationInfo{})

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ApplicationInfo) Ref() *C.VkApplicationInfo {
	if x == nil {
		return nil
	}
	return x.refb0af7378
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ApplicationInfo) Free() {
	if x != nil && x.allocsb0af7378 != nil {
		x.allocsb0af7378.(*cgoAllocMap).Free()
		x.refb0af7378 = nil
	}
}

// NewApplicationInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewApplicationInfoRef(ref unsafe.Pointer) *ApplicationInfo {
	if ref == nil {
		return nil
	}
	obj := new(ApplicationInfo)
	obj.refb0af7378 = (*C.VkApplicationInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ApplicationInfo) PassRef() (*C.VkApplicationInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0af7378 != nil {
		return x.refb0af7378, nil
	}
	memb0af7378 := allocApplicationInfoMemory(1)
	refb0af7378 := (*C.VkApplicationInfo)(memb0af7378)
	allocsb0af7378 := new(cgoAllocMap)
	allocsb0af7378.Add(memb0af7378)

	var csType_allocs *cgoAllocMap
	refb0af7378.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb0af7378.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb0af7378.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb0af7378.Borrow(cpNext_allocs)

	var cpApplicationName_allocs *cgoAllocMap
	refb0af7378.pApplicationName, cpApplicationName_allocs = unpackPCharString(x.PApplicationName)
	allocsb0af7378.Borrow(cpApplicationName_allocs)

	var capplicationVersion_allocs *cgoAllocMap
	refb0af7378.applicationVersion, capplicationVersion_allocs = (C.uint32_t)(x.ApplicationVersion), cgoAllocsUnknown
	allocsb0af7378.Borrow(capplicationVersion_allocs)

	var cpEngineName_allocs *cgoAllocMap
	refb0af7378.pEngineName, cpEngineName_allocs = unpackPCharString(x.PEngineName)
	allocsb0af7378.Borrow(cpEngineName_allocs)

	var cengineVersion_allocs *cgoAllocMap
	refb0af7378.engineVersion, cengineVersion_allocs = (C.uint32_t)(x.EngineVersion), cgoAllocsUnknown
	allocsb0af7378.Borrow(cengineVersion_allocs)

	var capiVersion_allocs *cgoAllocMap
	refb0af7378.apiVersion, capiVersion_allocs = (C.uint32_t)(x.ApiVersion), cgoAllocsUnknown
	allocsb0af7378.Borrow(capiVersion_allocs)

	x.refb0af7378 = refb0af7378
	x.allocsb0af7378 = allocsb0af7378
	return refb0af7378, allocsb0af7378

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ApplicationInfo) PassValue() (C.VkApplicationInfo, *cgoAllocMap) {
	if x.refb0af7378 != nil {
		return *x.refb0af7378, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ApplicationInfo) Deref() {
	if x.refb0af7378 == nil {
		return
	}
	x.SType = (StructureType)(x.refb0af7378.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb0af7378.pNext))
	x.PApplicationName = packPCharString(x.refb0af7378.pApplicationName)
	x.ApplicationVersion = (uint32)(x.refb0af7378.applicationVersion)
	x.PEngineName = packPCharString(x.refb0af7378.pEngineName)
	x.EngineVersion = (uint32)(x.refb0af7378.engineVersion)
	x.ApiVersion = (uint32)(x.refb0af7378.apiVersion)
}

// allocFormatPropertiesMemory allocates memory for type C.VkFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFormatPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFormatPropertiesValue = unsafe.Sizeof([1]C.VkFormatProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FormatProperties) Ref() *C.VkFormatProperties {
	if x == nil {
		return nil
	}
	return x.refc4b9937b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FormatProperties) Free() {
	if x != nil && x.allocsc4b9937b != nil {
		x.allocsc4b9937b.(*cgoAllocMap).Free()
		x.refc4b9937b = nil
	}
}

// NewFormatPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFormatPropertiesRef(ref unsafe.Pointer) *FormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(FormatProperties)
	obj.refc4b9937b = (*C.VkFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FormatProperties) PassRef() (*C.VkFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc4b9937b != nil {
		return x.refc4b9937b, nil
	}
	memc4b9937b := allocFormatPropertiesMemory(1)
	refc4b9937b := (*C.VkFormatProperties)(memc4b9937b)
	allocsc4b9937b := new(cgoAllocMap)
	allocsc4b9937b.Add(memc4b9937b)

	var clinearTilingFeatures_allocs *cgoAllocMap
	refc4b9937b.linearTilingFeatures, clinearTilingFeatures_allocs = (C.VkFormatFeatureFlags)(x.LinearTilingFeatures), cgoAllocsUnknown
	allocsc4b9937b.Borrow(clinearTilingFeatures_allocs)

	var coptimalTilingFeatures_allocs *cgoAllocMap
	refc4b9937b.optimalTilingFeatures, coptimalTilingFeatures_allocs = (C.VkFormatFeatureFlags)(x.OptimalTilingFeatures), cgoAllocsUnknown
	allocsc4b9937b.Borrow(coptimalTilingFeatures_allocs)

	var cbufferFeatures_allocs *cgoAllocMap
	refc4b9937b.bufferFeatures, cbufferFeatures_allocs = (C.VkFormatFeatureFlags)(x.BufferFeatures), cgoAllocsUnknown
	allocsc4b9937b.Borrow(cbufferFeatures_allocs)

	x.refc4b9937b = refc4b9937b
	x.allocsc4b9937b = allocsc4b9937b
	return refc4b9937b, allocsc4b9937b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FormatProperties) PassValue() (C.VkFormatProperties, *cgoAllocMap) {
	if x.refc4b9937b != nil {
		return *x.refc4b9937b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FormatProperties) Deref() {
	if x.refc4b9937b == nil {
		return
	}
	x.LinearTilingFeatures = (FormatFeatureFlags)(x.refc4b9937b.linearTilingFeatures)
	x.OptimalTilingFeatures = (FormatFeatureFlags)(x.refc4b9937b.optimalTilingFeatures)
	x.BufferFeatures = (FormatFeatureFlags)(x.refc4b9937b.bufferFeatures)
}

// allocImageFormatPropertiesMemory allocates memory for type C.VkImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageFormatPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkImageFormatProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageFormatProperties) Ref() *C.VkImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.ref4cfb2ea2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageFormatProperties) Free() {
	if x != nil && x.allocs4cfb2ea2 != nil {
		x.allocs4cfb2ea2.(*cgoAllocMap).Free()
		x.ref4cfb2ea2 = nil
	}
}

// NewImageFormatPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageFormatPropertiesRef(ref unsafe.Pointer) *ImageFormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(ImageFormatProperties)
	obj.ref4cfb2ea2 = (*C.VkImageFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageFormatProperties) PassRef() (*C.VkImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4cfb2ea2 != nil {
		return x.ref4cfb2ea2, nil
	}
	mem4cfb2ea2 := allocImageFormatPropertiesMemory(1)
	ref4cfb2ea2 := (*C.VkImageFormatProperties)(mem4cfb2ea2)
	allocs4cfb2ea2 := new(cgoAllocMap)
	allocs4cfb2ea2.Add(mem4cfb2ea2)

	var cmaxExtent_allocs *cgoAllocMap
	ref4cfb2ea2.maxExtent, cmaxExtent_allocs = x.MaxExtent.PassValue()
	allocs4cfb2ea2.Borrow(cmaxExtent_allocs)

	var cmaxMipLevels_allocs *cgoAllocMap
	ref4cfb2ea2.maxMipLevels, cmaxMipLevels_allocs = (C.uint32_t)(x.MaxMipLevels), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(cmaxMipLevels_allocs)

	var cmaxArrayLayers_allocs *cgoAllocMap
	ref4cfb2ea2.maxArrayLayers, cmaxArrayLayers_allocs = (C.uint32_t)(x.MaxArrayLayers), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(cmaxArrayLayers_allocs)

	var csampleCounts_allocs *cgoAllocMap
	ref4cfb2ea2.sampleCounts, csampleCounts_allocs = (C.VkSampleCountFlags)(x.SampleCounts), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(csampleCounts_allocs)

	var cmaxResourceSize_allocs *cgoAllocMap
	ref4cfb2ea2.maxResourceSize, cmaxResourceSize_allocs = (C.VkDeviceSize)(x.MaxResourceSize), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(cmaxResourceSize_allocs)

	x.ref4cfb2ea2 = ref4cfb2ea2
	x.allocs4cfb2ea2 = allocs4cfb2ea2
	return ref4cfb2ea2, allocs4cfb2ea2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageFormatProperties) PassValue() (C.VkImageFormatProperties, *cgoAllocMap) {
	if x.ref4cfb2ea2 != nil {
		return *x.ref4cfb2ea2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageFormatProperties) Deref() {
	if x.ref4cfb2ea2 == nil {
		return
	}
	x.MaxExtent = *NewExtent3DRef(unsafe.Pointer(&x.ref4cfb2ea2.maxExtent))
	x.MaxMipLevels = (uint32)(x.ref4cfb2ea2.maxMipLevels)
	x.MaxArrayLayers = (uint32)(x.ref4cfb2ea2.maxArrayLayers)
	x.SampleCounts = (SampleCountFlags)(x.ref4cfb2ea2.sampleCounts)
	x.MaxResourceSize = (DeviceSize)(x.ref4cfb2ea2.maxResourceSize)
}

// allocInstanceCreateInfoMemory allocates memory for type C.VkInstanceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInstanceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInstanceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInstanceCreateInfoValue = unsafe.Sizeof([1]C.VkInstanceCreateInfo{})

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *InstanceCreateInfo) Ref() *C.VkInstanceCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref9b760798
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *InstanceCreateInfo) Free() {
	if x != nil && x.allocs9b760798 != nil {
		x.allocs9b760798.(*cgoAllocMap).Free()
		x.ref9b760798 = nil
	}
}

// NewInstanceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewInstanceCreateInfoRef(ref unsafe.Pointer) *InstanceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(InstanceCreateInfo)
	obj.ref9b760798 = (*C.VkInstanceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *InstanceCreateInfo) PassRef() (*C.VkInstanceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9b760798 != nil {
		return x.ref9b760798, nil
	}
	mem9b760798 := allocInstanceCreateInfoMemory(1)
	ref9b760798 := (*C.VkInstanceCreateInfo)(mem9b760798)
	allocs9b760798 := new(cgoAllocMap)
	allocs9b760798.Add(mem9b760798)

	var csType_allocs *cgoAllocMap
	ref9b760798.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9b760798.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9b760798.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9b760798.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref9b760798.flags, cflags_allocs = (C.VkInstanceCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs9b760798.Borrow(cflags_allocs)

	var cpApplicationInfo_allocs *cgoAllocMap
	ref9b760798.pApplicationInfo, cpApplicationInfo_allocs = x.PApplicationInfo.PassRef()
	allocs9b760798.Borrow(cpApplicationInfo_allocs)

	var cenabledLayerCount_allocs *cgoAllocMap
	ref9b760798.enabledLayerCount, cenabledLayerCount_allocs = (C.uint32_t)(x.EnabledLayerCount), cgoAllocsUnknown
	allocs9b760798.Borrow(cenabledLayerCount_allocs)

	var cppEnabledLayerNames_allocs *cgoAllocMap
	ref9b760798.ppEnabledLayerNames, cppEnabledLayerNames_allocs = unpackSString(x.PpEnabledLayerNames)
	allocs9b760798.Borrow(cppEnabledLayerNames_allocs)

	var cenabledExtensionCount_allocs *cgoAllocMap
	ref9b760798.enabledExtensionCount, cenabledExtensionCount_allocs = (C.uint32_t)(x.EnabledExtensionCount), cgoAllocsUnknown
	allocs9b760798.Borrow(cenabledExtensionCount_allocs)

	var cppEnabledExtensionNames_allocs *cgoAllocMap
	ref9b760798.ppEnabledExtensionNames, cppEnabledExtensionNames_allocs = unpackSString(x.PpEnabledExtensionNames)
	allocs9b760798.Borrow(cppEnabledExtensionNames_allocs)

	x.ref9b760798 = ref9b760798
	x.allocs9b760798 = allocs9b760798
	return ref9b760798, allocs9b760798

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x InstanceCreateInfo) PassValue() (C.VkInstanceCreateInfo, *cgoAllocMap) {
	if x.ref9b760798 != nil {
		return *x.ref9b760798, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *InstanceCreateInfo) Deref() {
	if x.ref9b760798 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9b760798.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9b760798.pNext))
	x.Flags = (InstanceCreateFlags)(x.ref9b760798.flags)
	x.PApplicationInfo = NewApplicationInfoRef(unsafe.Pointer(x.ref9b760798.pApplicationInfo))
	x.EnabledLayerCount = (uint32)(x.ref9b760798.enabledLayerCount)
	packSString(x.PpEnabledLayerNames, x.ref9b760798.ppEnabledLayerNames)
	x.EnabledExtensionCount = (uint32)(x.ref9b760798.enabledExtensionCount)
	packSString(x.PpEnabledExtensionNames, x.ref9b760798.ppEnabledExtensionNames)
}

// allocMemoryHeapMemory allocates memory for type C.VkMemoryHeap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryHeapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryHeapValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryHeapValue = unsafe.Sizeof([1]C.VkMemoryHeap{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryHeap) Ref() *C.VkMemoryHeap {
	if x == nil {
		return nil
	}
	return x.ref1eb195d5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryHeap) Free() {
	if x != nil && x.allocs1eb195d5 != nil {
		x.allocs1eb195d5.(*cgoAllocMap).Free()
		x.ref1eb195d5 = nil
	}
}

// NewMemoryHeapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryHeapRef(ref unsafe.Pointer) *MemoryHeap {
	if ref == nil {
		return nil
	}
	obj := new(MemoryHeap)
	obj.ref1eb195d5 = (*C.VkMemoryHeap)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryHeap) PassRef() (*C.VkMemoryHeap, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1eb195d5 != nil {
		return x.ref1eb195d5, nil
	}
	mem1eb195d5 := allocMemoryHeapMemory(1)
	ref1eb195d5 := (*C.VkMemoryHeap)(mem1eb195d5)
	allocs1eb195d5 := new(cgoAllocMap)
	allocs1eb195d5.Add(mem1eb195d5)

	var csize_allocs *cgoAllocMap
	ref1eb195d5.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs1eb195d5.Borrow(csize_allocs)

	var cflags_allocs *cgoAllocMap
	ref1eb195d5.flags, cflags_allocs = (C.VkMemoryHeapFlags)(x.Flags), cgoAllocsUnknown
	allocs1eb195d5.Borrow(cflags_allocs)

	x.ref1eb195d5 = ref1eb195d5
	x.allocs1eb195d5 = allocs1eb195d5
	return ref1eb195d5, allocs1eb195d5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryHeap) PassValue() (C.VkMemoryHeap, *cgoAllocMap) {
	if x.ref1eb195d5 != nil {
		return *x.ref1eb195d5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryHeap) Deref() {
	if x.ref1eb195d5 == nil {
		return
	}
	x.Size = (DeviceSize)(x.ref1eb195d5.size)
	x.Flags = (MemoryHeapFlags)(x.ref1eb195d5.flags)
}

// allocMemoryTypeMemory allocates memory for type C.VkMemoryType in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryTypeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryTypeValue = unsafe.Sizeof([1]C.VkMemoryType{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryType) Ref() *C.VkMemoryType {
	if x == nil {
		return nil
	}
	return x.ref2f46e01d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryType) Free() {
	if x != nil && x.allocs2f46e01d != nil {
		x.allocs2f46e01d.(*cgoAllocMap).Free()
		x.ref2f46e01d = nil
	}
}

// NewMemoryTypeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryTypeRef(ref unsafe.Pointer) *MemoryType {
	if ref == nil {
		return nil
	}
	obj := new(MemoryType)
	obj.ref2f46e01d = (*C.VkMemoryType)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryType) PassRef() (*C.VkMemoryType, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f46e01d != nil {
		return x.ref2f46e01d, nil
	}
	mem2f46e01d := allocMemoryTypeMemory(1)
	ref2f46e01d := (*C.VkMemoryType)(mem2f46e01d)
	allocs2f46e01d := new(cgoAllocMap)
	allocs2f46e01d.Add(mem2f46e01d)

	var cpropertyFlags_allocs *cgoAllocMap
	ref2f46e01d.propertyFlags, cpropertyFlags_allocs = (C.VkMemoryPropertyFlags)(x.PropertyFlags), cgoAllocsUnknown
	allocs2f46e01d.Borrow(cpropertyFlags_allocs)

	var cheapIndex_allocs *cgoAllocMap
	ref2f46e01d.heapIndex, cheapIndex_allocs = (C.uint32_t)(x.HeapIndex), cgoAllocsUnknown
	allocs2f46e01d.Borrow(cheapIndex_allocs)

	x.ref2f46e01d = ref2f46e01d
	x.allocs2f46e01d = allocs2f46e01d
	return ref2f46e01d, allocs2f46e01d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryType) PassValue() (C.VkMemoryType, *cgoAllocMap) {
	if x.ref2f46e01d != nil {
		return *x.ref2f46e01d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryType) Deref() {
	if x.ref2f46e01d == nil {
		return
	}
	x.PropertyFlags = (MemoryPropertyFlags)(x.ref2f46e01d.propertyFlags)
	x.HeapIndex = (uint32)(x.ref2f46e01d.heapIndex)
}

// allocPhysicalDeviceFeaturesMemory allocates memory for type C.VkPhysicalDeviceFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFeatures) Ref() *C.VkPhysicalDeviceFeatures {
	if x == nil {
		return nil
	}
	return x.reff97e405d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFeatures) Free() {
	if x != nil && x.allocsf97e405d != nil {
		x.allocsf97e405d.(*cgoAllocMap).Free()
		x.reff97e405d = nil
	}
}

// NewPhysicalDeviceFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFeatures)
	obj.reff97e405d = (*C.VkPhysicalDeviceFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFeatures) PassRef() (*C.VkPhysicalDeviceFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff97e405d != nil {
		return x.reff97e405d, nil
	}
	memf97e405d := allocPhysicalDeviceFeaturesMemory(1)
	reff97e405d := (*C.VkPhysicalDeviceFeatures)(memf97e405d)
	allocsf97e405d := new(cgoAllocMap)
	allocsf97e405d.Add(memf97e405d)

	var crobustBufferAccess_allocs *cgoAllocMap
	reff97e405d.robustBufferAccess, crobustBufferAccess_allocs = (C.VkBool32)(x.RobustBufferAccess), cgoAllocsUnknown
	allocsf97e405d.Borrow(crobustBufferAccess_allocs)

	var cfullDrawIndexUint32_allocs *cgoAllocMap
	reff97e405d.fullDrawIndexUint32, cfullDrawIndexUint32_allocs = (C.VkBool32)(x.FullDrawIndexUint32), cgoAllocsUnknown
	allocsf97e405d.Borrow(cfullDrawIndexUint32_allocs)

	var cimageCubeArray_allocs *cgoAllocMap
	reff97e405d.imageCubeArray, cimageCubeArray_allocs = (C.VkBool32)(x.ImageCubeArray), cgoAllocsUnknown
	allocsf97e405d.Borrow(cimageCubeArray_allocs)

	var cindependentBlend_allocs *cgoAllocMap
	reff97e405d.independentBlend, cindependentBlend_allocs = (C.VkBool32)(x.IndependentBlend), cgoAllocsUnknown
	allocsf97e405d.Borrow(cindependentBlend_allocs)

	var cgeometryShader_allocs *cgoAllocMap
	reff97e405d.geometryShader, cgeometryShader_allocs = (C.VkBool32)(x.GeometryShader), cgoAllocsUnknown
	allocsf97e405d.Borrow(cgeometryShader_allocs)

	var ctessellationShader_allocs *cgoAllocMap
	reff97e405d.tessellationShader, ctessellationShader_allocs = (C.VkBool32)(x.TessellationShader), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctessellationShader_allocs)

	var csampleRateShading_allocs *cgoAllocMap
	reff97e405d.sampleRateShading, csampleRateShading_allocs = (C.VkBool32)(x.SampleRateShading), cgoAllocsUnknown
	allocsf97e405d.Borrow(csampleRateShading_allocs)

	var cdualSrcBlend_allocs *cgoAllocMap
	reff97e405d.dualSrcBlend, cdualSrcBlend_allocs = (C.VkBool32)(x.DualSrcBlend), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdualSrcBlend_allocs)

	var clogicOp_allocs *cgoAllocMap
	reff97e405d.logicOp, clogicOp_allocs = (C.VkBool32)(x.LogicOp), cgoAllocsUnknown
	allocsf97e405d.Borrow(clogicOp_allocs)

	var cmultiDrawIndirect_allocs *cgoAllocMap
	reff97e405d.multiDrawIndirect, cmultiDrawIndirect_allocs = (C.VkBool32)(x.MultiDrawIndirect), cgoAllocsUnknown
	allocsf97e405d.Borrow(cmultiDrawIndirect_allocs)

	var cdrawIndirectFirstInstance_allocs *cgoAllocMap
	reff97e405d.drawIndirectFirstInstance, cdrawIndirectFirstInstance_allocs = (C.VkBool32)(x.DrawIndirectFirstInstance), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdrawIndirectFirstInstance_allocs)

	var cdepthClamp_allocs *cgoAllocMap
	reff97e405d.depthClamp, cdepthClamp_allocs = (C.VkBool32)(x.DepthClamp), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdepthClamp_allocs)

	var cdepthBiasClamp_allocs *cgoAllocMap
	reff97e405d.depthBiasClamp, cdepthBiasClamp_allocs = (C.VkBool32)(x.DepthBiasClamp), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdepthBiasClamp_allocs)

	var cfillModeNonSolid_allocs *cgoAllocMap
	reff97e405d.fillModeNonSolid, cfillModeNonSolid_allocs = (C.VkBool32)(x.FillModeNonSolid), cgoAllocsUnknown
	allocsf97e405d.Borrow(cfillModeNonSolid_allocs)

	var cdepthBounds_allocs *cgoAllocMap
	reff97e405d.depthBounds, cdepthBounds_allocs = (C.VkBool32)(x.DepthBounds), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdepthBounds_allocs)

	var cwideLines_allocs *cgoAllocMap
	reff97e405d.wideLines, cwideLines_allocs = (C.VkBool32)(x.WideLines), cgoAllocsUnknown
	allocsf97e405d.Borrow(cwideLines_allocs)

	var clargePoints_allocs *cgoAllocMap
	reff97e405d.largePoints, clargePoints_allocs = (C.VkBool32)(x.LargePoints), cgoAllocsUnknown
	allocsf97e405d.Borrow(clargePoints_allocs)

	var calphaToOne_allocs *cgoAllocMap
	reff97e405d.alphaToOne, calphaToOne_allocs = (C.VkBool32)(x.AlphaToOne), cgoAllocsUnknown
	allocsf97e405d.Borrow(calphaToOne_allocs)

	var cmultiViewport_allocs *cgoAllocMap
	reff97e405d.multiViewport, cmultiViewport_allocs = (C.VkBool32)(x.MultiViewport), cgoAllocsUnknown
	allocsf97e405d.Borrow(cmultiViewport_allocs)

	var csamplerAnisotropy_allocs *cgoAllocMap
	reff97e405d.samplerAnisotropy, csamplerAnisotropy_allocs = (C.VkBool32)(x.SamplerAnisotropy), cgoAllocsUnknown
	allocsf97e405d.Borrow(csamplerAnisotropy_allocs)

	var ctextureCompressionETC2_allocs *cgoAllocMap
	reff97e405d.textureCompressionETC2, ctextureCompressionETC2_allocs = (C.VkBool32)(x.TextureCompressionETC2), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctextureCompressionETC2_allocs)

	var ctextureCompressionASTC_LDR_allocs *cgoAllocMap
	reff97e405d.textureCompressionASTC_LDR, ctextureCompressionASTC_LDR_allocs = (C.VkBool32)(x.TextureCompressionASTC_LDR), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctextureCompressionASTC_LDR_allocs)

	var ctextureCompressionBC_allocs *cgoAllocMap
	reff97e405d.textureCompressionBC, ctextureCompressionBC_allocs = (C.VkBool32)(x.TextureCompressionBC), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctextureCompressionBC_allocs)

	var cocclusionQueryPrecise_allocs *cgoAllocMap
	reff97e405d.occlusionQueryPrecise, cocclusionQueryPrecise_allocs = (C.VkBool32)(x.OcclusionQueryPrecise), cgoAllocsUnknown
	allocsf97e405d.Borrow(cocclusionQueryPrecise_allocs)

	var cpipelineStatisticsQuery_allocs *cgoAllocMap
	reff97e405d.pipelineStatisticsQuery, cpipelineStatisticsQuery_allocs = (C.VkBool32)(x.PipelineStatisticsQuery), cgoAllocsUnknown
	allocsf97e405d.Borrow(cpipelineStatisticsQuery_allocs)

	var cvertexPipelineStoresAndAtomics_allocs *cgoAllocMap
	reff97e405d.vertexPipelineStoresAndAtomics, cvertexPipelineStoresAndAtomics_allocs = (C.VkBool32)(x.VertexPipelineStoresAndAtomics), cgoAllocsUnknown
	allocsf97e405d.Borrow(cvertexPipelineStoresAndAtomics_allocs)

	var cfragmentStoresAndAtomics_allocs *cgoAllocMap
	reff97e405d.fragmentStoresAndAtomics, cfragmentStoresAndAtomics_allocs = (C.VkBool32)(x.FragmentStoresAndAtomics), cgoAllocsUnknown
	allocsf97e405d.Borrow(cfragmentStoresAndAtomics_allocs)

	var cshaderTessellationAndGeometryPointSize_allocs *cgoAllocMap
	reff97e405d.shaderTessellationAndGeometryPointSize, cshaderTessellationAndGeometryPointSize_allocs = (C.VkBool32)(x.ShaderTessellationAndGeometryPointSize), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderTessellationAndGeometryPointSize_allocs)

	var cshaderImageGatherExtended_allocs *cgoAllocMap
	reff97e405d.shaderImageGatherExtended, cshaderImageGatherExtended_allocs = (C.VkBool32)(x.ShaderImageGatherExtended), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderImageGatherExtended_allocs)

	var cshaderStorageImageExtendedFormats_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageExtendedFormats, cshaderStorageImageExtendedFormats_allocs = (C.VkBool32)(x.ShaderStorageImageExtendedFormats), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageExtendedFormats_allocs)

	var cshaderStorageImageMultisample_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageMultisample, cshaderStorageImageMultisample_allocs = (C.VkBool32)(x.ShaderStorageImageMultisample), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageMultisample_allocs)

	var cshaderStorageImageReadWithoutFormat_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageReadWithoutFormat, cshaderStorageImageReadWithoutFormat_allocs = (C.VkBool32)(x.ShaderStorageImageReadWithoutFormat), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageReadWithoutFormat_allocs)

	var cshaderStorageImageWriteWithoutFormat_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageWriteWithoutFormat, cshaderStorageImageWriteWithoutFormat_allocs = (C.VkBool32)(x.ShaderStorageImageWriteWithoutFormat), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageWriteWithoutFormat_allocs)

	var cshaderUniformBufferArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderUniformBufferArrayDynamicIndexing, cshaderUniformBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderUniformBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderUniformBufferArrayDynamicIndexing_allocs)

	var cshaderSampledImageArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderSampledImageArrayDynamicIndexing, cshaderSampledImageArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderSampledImageArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderSampledImageArrayDynamicIndexing_allocs)

	var cshaderStorageBufferArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderStorageBufferArrayDynamicIndexing, cshaderStorageBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderStorageBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageBufferArrayDynamicIndexing_allocs)

	var cshaderStorageImageArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageArrayDynamicIndexing, cshaderStorageImageArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderStorageImageArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageArrayDynamicIndexing_allocs)

	var cshaderClipDistance_allocs *cgoAllocMap
	reff97e405d.shaderClipDistance, cshaderClipDistance_allocs = (C.VkBool32)(x.ShaderClipDistance), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderClipDistance_allocs)

	var cshaderCullDistance_allocs *cgoAllocMap
	reff97e405d.shaderCullDistance, cshaderCullDistance_allocs = (C.VkBool32)(x.ShaderCullDistance), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderCullDistance_allocs)

	var cshaderFloat64_allocs *cgoAllocMap
	reff97e405d.shaderFloat64, cshaderFloat64_allocs = (C.VkBool32)(x.ShaderFloat64), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderFloat64_allocs)

	var cshaderInt64_allocs *cgoAllocMap
	reff97e405d.shaderInt64, cshaderInt64_allocs = (C.VkBool32)(x.ShaderInt64), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderInt64_allocs)

	var cshaderInt16_allocs *cgoAllocMap
	reff97e405d.shaderInt16, cshaderInt16_allocs = (C.VkBool32)(x.ShaderInt16), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderInt16_allocs)

	var cshaderResourceResidency_allocs *cgoAllocMap
	reff97e405d.shaderResourceResidency, cshaderResourceResidency_allocs = (C.VkBool32)(x.ShaderResourceResidency), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderResourceResidency_allocs)

	var cshaderResourceMinLod_allocs *cgoAllocMap
	reff97e405d.shaderResourceMinLod, cshaderResourceMinLod_allocs = (C.VkBool32)(x.ShaderResourceMinLod), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderResourceMinLod_allocs)

	var csparseBinding_allocs *cgoAllocMap
	reff97e405d.sparseBinding, csparseBinding_allocs = (C.VkBool32)(x.SparseBinding), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseBinding_allocs)

	var csparseResidencyBuffer_allocs *cgoAllocMap
	reff97e405d.sparseResidencyBuffer, csparseResidencyBuffer_allocs = (C.VkBool32)(x.SparseResidencyBuffer), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyBuffer_allocs)

	var csparseResidencyImage2D_allocs *cgoAllocMap
	reff97e405d.sparseResidencyImage2D, csparseResidencyImage2D_allocs = (C.VkBool32)(x.SparseResidencyImage2D), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyImage2D_allocs)

	var csparseResidencyImage3D_allocs *cgoAllocMap
	reff97e405d.sparseResidencyImage3D, csparseResidencyImage3D_allocs = (C.VkBool32)(x.SparseResidencyImage3D), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyImage3D_allocs)

	var csparseResidency2Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency2Samples, csparseResidency2Samples_allocs = (C.VkBool32)(x.SparseResidency2Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency2Samples_allocs)

	var csparseResidency4Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency4Samples, csparseResidency4Samples_allocs = (C.VkBool32)(x.SparseResidency4Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency4Samples_allocs)

	var csparseResidency8Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency8Samples, csparseResidency8Samples_allocs = (C.VkBool32)(x.SparseResidency8Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency8Samples_allocs)

	var csparseResidency16Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency16Samples, csparseResidency16Samples_allocs = (C.VkBool32)(x.SparseResidency16Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency16Samples_allocs)

	var csparseResidencyAliased_allocs *cgoAllocMap
	reff97e405d.sparseResidencyAliased, csparseResidencyAliased_allocs = (C.VkBool32)(x.SparseResidencyAliased), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyAliased_allocs)

	var cvariableMultisampleRate_allocs *cgoAllocMap
	reff97e405d.variableMultisampleRate, cvariableMultisampleRate_allocs = (C.VkBool32)(x.VariableMultisampleRate), cgoAllocsUnknown
	allocsf97e405d.Borrow(cvariableMultisampleRate_allocs)

	var cinheritedQueries_allocs *cgoAllocMap
	reff97e405d.inheritedQueries, cinheritedQueries_allocs = (C.VkBool32)(x.InheritedQueries), cgoAllocsUnknown
	allocsf97e405d.Borrow(cinheritedQueries_allocs)

	x.reff97e405d = reff97e405d
	x.allocsf97e405d = allocsf97e405d
	return reff97e405d, allocsf97e405d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFeatures) PassValue() (C.VkPhysicalDeviceFeatures, *cgoAllocMap) {
	if x.reff97e405d != nil {
		return *x.reff97e405d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFeatures) Deref() {
	if x.reff97e405d == nil {
		return
	}
	x.RobustBufferAccess = (Bool32)(x.reff97e405d.robustBufferAccess)
	x.FullDrawIndexUint32 = (Bool32)(x.reff97e405d.fullDrawIndexUint32)
	x.ImageCubeArray = (Bool32)(x.reff97e405d.imageCubeArray)
	x.IndependentBlend = (Bool32)(x.reff97e405d.independentBlend)
	x.GeometryShader = (Bool32)(x.reff97e405d.geometryShader)
	x.TessellationShader = (Bool32)(x.reff97e405d.tessellationShader)
	x.SampleRateShading = (Bool32)(x.reff97e405d.sampleRateShading)
	x.DualSrcBlend = (Bool32)(x.reff97e405d.dualSrcBlend)
	x.LogicOp = (Bool32)(x.reff97e405d.logicOp)
	x.MultiDrawIndirect = (Bool32)(x.reff97e405d.multiDrawIndirect)
	x.DrawIndirectFirstInstance = (Bool32)(x.reff97e405d.drawIndirectFirstInstance)
	x.DepthClamp = (Bool32)(x.reff97e405d.depthClamp)
	x.DepthBiasClamp = (Bool32)(x.reff97e405d.depthBiasClamp)
	x.FillModeNonSolid = (Bool32)(x.reff97e405d.fillModeNonSolid)
	x.DepthBounds = (Bool32)(x.reff97e405d.depthBounds)
	x.WideLines = (Bool32)(x.reff97e405d.wideLines)
	x.LargePoints = (Bool32)(x.reff97e405d.largePoints)
	x.AlphaToOne = (Bool32)(x.reff97e405d.alphaToOne)
	x.MultiViewport = (Bool32)(x.reff97e405d.multiViewport)
	x.SamplerAnisotropy = (Bool32)(x.reff97e405d.samplerAnisotropy)
	x.TextureCompressionETC2 = (Bool32)(x.reff97e405d.textureCompressionETC2)
	x.TextureCompressionASTC_LDR = (Bool32)(x.reff97e405d.textureCompressionASTC_LDR)
	x.TextureCompressionBC = (Bool32)(x.reff97e405d.textureCompressionBC)
	x.OcclusionQueryPrecise = (Bool32)(x.reff97e405d.occlusionQueryPrecise)
	x.PipelineStatisticsQuery = (Bool32)(x.reff97e405d.pipelineStatisticsQuery)
	x.VertexPipelineStoresAndAtomics = (Bool32)(x.reff97e405d.vertexPipelineStoresAndAtomics)
	x.FragmentStoresAndAtomics = (Bool32)(x.reff97e405d.fragmentStoresAndAtomics)
	x.ShaderTessellationAndGeometryPointSize = (Bool32)(x.reff97e405d.shaderTessellationAndGeometryPointSize)
	x.ShaderImageGatherExtended = (Bool32)(x.reff97e405d.shaderImageGatherExtended)
	x.ShaderStorageImageExtendedFormats = (Bool32)(x.reff97e405d.shaderStorageImageExtendedFormats)
	x.ShaderStorageImageMultisample = (Bool32)(x.reff97e405d.shaderStorageImageMultisample)
	x.ShaderStorageImageReadWithoutFormat = (Bool32)(x.reff97e405d.shaderStorageImageReadWithoutFormat)
	x.ShaderStorageImageWriteWithoutFormat = (Bool32)(x.reff97e405d.shaderStorageImageWriteWithoutFormat)
	x.ShaderUniformBufferArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderUniformBufferArrayDynamicIndexing)
	x.ShaderSampledImageArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderSampledImageArrayDynamicIndexing)
	x.ShaderStorageBufferArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderStorageBufferArrayDynamicIndexing)
	x.ShaderStorageImageArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderStorageImageArrayDynamicIndexing)
	x.ShaderClipDistance = (Bool32)(x.reff97e405d.shaderClipDistance)
	x.ShaderCullDistance = (Bool32)(x.reff97e405d.shaderCullDistance)
	x.ShaderFloat64 = (Bool32)(x.reff97e405d.shaderFloat64)
	x.ShaderInt64 = (Bool32)(x.reff97e405d.shaderInt64)
	x.ShaderInt16 = (Bool32)(x.reff97e405d.shaderInt16)
	x.ShaderResourceResidency = (Bool32)(x.reff97e405d.shaderResourceResidency)
	x.ShaderResourceMinLod = (Bool32)(x.reff97e405d.shaderResourceMinLod)
	x.SparseBinding = (Bool32)(x.reff97e405d.sparseBinding)
	x.SparseResidencyBuffer = (Bool32)(x.reff97e405d.sparseResidencyBuffer)
	x.SparseResidencyImage2D = (Bool32)(x.reff97e405d.sparseResidencyImage2D)
	x.SparseResidencyImage3D = (Bool32)(x.reff97e405d.sparseResidencyImage3D)
	x.SparseResidency2Samples = (Bool32)(x.reff97e405d.sparseResidency2Samples)
	x.SparseResidency4Samples = (Bool32)(x.reff97e405d.sparseResidency4Samples)
	x.SparseResidency8Samples = (Bool32)(x.reff97e405d.sparseResidency8Samples)
	x.SparseResidency16Samples = (Bool32)(x.reff97e405d.sparseResidency16Samples)
	x.SparseResidencyAliased = (Bool32)(x.reff97e405d.sparseResidencyAliased)
	x.VariableMultisampleRate = (Bool32)(x.reff97e405d.variableMultisampleRate)
	x.InheritedQueries = (Bool32)(x.reff97e405d.inheritedQueries)
}

// allocPhysicalDeviceLimitsMemory allocates memory for type C.VkPhysicalDeviceLimits in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceLimitsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceLimitsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceLimitsValue = unsafe.Sizeof([1]C.VkPhysicalDeviceLimits{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceLimits) Ref() *C.VkPhysicalDeviceLimits {
	if x == nil {
		return nil
	}
	return x.ref7926795a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceLimits) Free() {
	if x != nil && x.allocs7926795a != nil {
		x.allocs7926795a.(*cgoAllocMap).Free()
		x.ref7926795a = nil
	}
}

// NewPhysicalDeviceLimitsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceLimitsRef(ref unsafe.Pointer) *PhysicalDeviceLimits {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceLimits)
	obj.ref7926795a = (*C.VkPhysicalDeviceLimits)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceLimits) PassRef() (*C.VkPhysicalDeviceLimits, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7926795a != nil {
		return x.ref7926795a, nil
	}
	mem7926795a := allocPhysicalDeviceLimitsMemory(1)
	ref7926795a := (*C.VkPhysicalDeviceLimits)(mem7926795a)
	allocs7926795a := new(cgoAllocMap)
	allocs7926795a.Add(mem7926795a)

	var cmaxImageDimension1D_allocs *cgoAllocMap
	ref7926795a.maxImageDimension1D, cmaxImageDimension1D_allocs = (C.uint32_t)(x.MaxImageDimension1D), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimension1D_allocs)

	var cmaxImageDimension2D_allocs *cgoAllocMap
	ref7926795a.maxImageDimension2D, cmaxImageDimension2D_allocs = (C.uint32_t)(x.MaxImageDimension2D), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimension2D_allocs)

	var cmaxImageDimension3D_allocs *cgoAllocMap
	ref7926795a.maxImageDimension3D, cmaxImageDimension3D_allocs = (C.uint32_t)(x.MaxImageDimension3D), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimension3D_allocs)

	var cmaxImageDimensionCube_allocs *cgoAllocMap
	ref7926795a.maxImageDimensionCube, cmaxImageDimensionCube_allocs = (C.uint32_t)(x.MaxImageDimensionCube), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimensionCube_allocs)

	var cmaxImageArrayLayers_allocs *cgoAllocMap
	ref7926795a.maxImageArrayLayers, cmaxImageArrayLayers_allocs = (C.uint32_t)(x.MaxImageArrayLayers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageArrayLayers_allocs)

	var cmaxTexelBufferElements_allocs *cgoAllocMap
	ref7926795a.maxTexelBufferElements, cmaxTexelBufferElements_allocs = (C.uint32_t)(x.MaxTexelBufferElements), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTexelBufferElements_allocs)

	var cmaxUniformBufferRange_allocs *cgoAllocMap
	ref7926795a.maxUniformBufferRange, cmaxUniformBufferRange_allocs = (C.uint32_t)(x.MaxUniformBufferRange), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxUniformBufferRange_allocs)

	var cmaxStorageBufferRange_allocs *cgoAllocMap
	ref7926795a.maxStorageBufferRange, cmaxStorageBufferRange_allocs = (C.uint32_t)(x.MaxStorageBufferRange), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxStorageBufferRange_allocs)

	var cmaxPushConstantsSize_allocs *cgoAllocMap
	ref7926795a.maxPushConstantsSize, cmaxPushConstantsSize_allocs = (C.uint32_t)(x.MaxPushConstantsSize), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPushConstantsSize_allocs)

	var cmaxMemoryAllocationCount_allocs *cgoAllocMap
	ref7926795a.maxMemoryAllocationCount, cmaxMemoryAllocationCount_allocs = (C.uint32_t)(x.MaxMemoryAllocationCount), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxMemoryAllocationCount_allocs)

	var cmaxSamplerAllocationCount_allocs *cgoAllocMap
	ref7926795a.maxSamplerAllocationCount, cmaxSamplerAllocationCount_allocs = (C.uint32_t)(x.MaxSamplerAllocationCount), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSamplerAllocationCount_allocs)

	var cbufferImageGranularity_allocs *cgoAllocMap
	ref7926795a.bufferImageGranularity, cbufferImageGranularity_allocs = (C.VkDeviceSize)(x.BufferImageGranularity), cgoAllocsUnknown
	allocs7926795a.Borrow(cbufferImageGranularity_allocs)

	var csparseAddressSpaceSize_allocs *cgoAllocMap
	ref7926795a.sparseAddressSpaceSize, csparseAddressSpaceSize_allocs = (C.VkDeviceSize)(x.SparseAddressSpaceSize), cgoAllocsUnknown
	allocs7926795a.Borrow(csparseAddressSpaceSize_allocs)

	var cmaxBoundDescriptorSets_allocs *cgoAllocMap
	ref7926795a.maxBoundDescriptorSets, cmaxBoundDescriptorSets_allocs = (C.uint32_t)(x.MaxBoundDescriptorSets), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxBoundDescriptorSets_allocs)

	var cmaxPerStageDescriptorSamplers_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorSamplers, cmaxPerStageDescriptorSamplers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorSamplers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorSamplers_allocs)

	var cmaxPerStageDescriptorUniformBuffers_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorUniformBuffers, cmaxPerStageDescriptorUniformBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUniformBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorUniformBuffers_allocs)

	var cmaxPerStageDescriptorStorageBuffers_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorStorageBuffers, cmaxPerStageDescriptorStorageBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorStorageBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorStorageBuffers_allocs)

	var cmaxPerStageDescriptorSampledImages_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorSampledImages, cmaxPerStageDescriptorSampledImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorSampledImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorSampledImages_allocs)

	var cmaxPerStageDescriptorStorageImages_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorStorageImages, cmaxPerStageDescriptorStorageImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorStorageImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorStorageImages_allocs)

	var cmaxPerStageDescriptorInputAttachments_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorInputAttachments, cmaxPerStageDescriptorInputAttachments_allocs = (C.uint32_t)(x.MaxPerStageDescriptorInputAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorInputAttachments_allocs)

	var cmaxPerStageResources_allocs *cgoAllocMap
	ref7926795a.maxPerStageResources, cmaxPerStageResources_allocs = (C.uint32_t)(x.MaxPerStageResources), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageResources_allocs)

	var cmaxDescriptorSetSamplers_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetSamplers, cmaxDescriptorSetSamplers_allocs = (C.uint32_t)(x.MaxDescriptorSetSamplers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetSamplers_allocs)

	var cmaxDescriptorSetUniformBuffers_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetUniformBuffers, cmaxDescriptorSetUniformBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetUniformBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetUniformBuffers_allocs)

	var cmaxDescriptorSetUniformBuffersDynamic_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetUniformBuffersDynamic, cmaxDescriptorSetUniformBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetUniformBuffersDynamic), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetUniformBuffersDynamic_allocs)

	var cmaxDescriptorSetStorageBuffers_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetStorageBuffers, cmaxDescriptorSetStorageBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetStorageBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetStorageBuffers_allocs)

	var cmaxDescriptorSetStorageBuffersDynamic_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetStorageBuffersDynamic, cmaxDescriptorSetStorageBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetStorageBuffersDynamic), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetStorageBuffersDynamic_allocs)

	var cmaxDescriptorSetSampledImages_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetSampledImages, cmaxDescriptorSetSampledImages_allocs = (C.uint32_t)(x.MaxDescriptorSetSampledImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetSampledImages_allocs)

	var cmaxDescriptorSetStorageImages_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetStorageImages, cmaxDescriptorSetStorageImages_allocs = (C.uint32_t)(x.MaxDescriptorSetStorageImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetStorageImages_allocs)

	var cmaxDescriptorSetInputAttachments_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetInputAttachments, cmaxDescriptorSetInputAttachments_allocs = (C.uint32_t)(x.MaxDescriptorSetInputAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetInputAttachments_allocs)

	var cmaxVertexInputAttributes_allocs *cgoAllocMap
	ref7926795a.maxVertexInputAttributes, cmaxVertexInputAttributes_allocs = (C.uint32_t)(x.MaxVertexInputAttributes), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputAttributes_allocs)

	var cmaxVertexInputBindings_allocs *cgoAllocMap
	ref7926795a.maxVertexInputBindings, cmaxVertexInputBindings_allocs = (C.uint32_t)(x.MaxVertexInputBindings), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputBindings_allocs)

	var cmaxVertexInputAttributeOffset_allocs *cgoAllocMap
	ref7926795a.maxVertexInputAttributeOffset, cmaxVertexInputAttributeOffset_allocs = (C.uint32_t)(x.MaxVertexInputAttributeOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputAttributeOffset_allocs)

	var cmaxVertexInputBindingStride_allocs *cgoAllocMap
	ref7926795a.maxVertexInputBindingStride, cmaxVertexInputBindingStride_allocs = (C.uint32_t)(x.MaxVertexInputBindingStride), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputBindingStride_allocs)

	var cmaxVertexOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxVertexOutputComponents, cmaxVertexOutputComponents_allocs = (C.uint32_t)(x.MaxVertexOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexOutputComponents_allocs)

	var cmaxTessellationGenerationLevel_allocs *cgoAllocMap
	ref7926795a.maxTessellationGenerationLevel, cmaxTessellationGenerationLevel_allocs = (C.uint32_t)(x.MaxTessellationGenerationLevel), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationGenerationLevel_allocs)

	var cmaxTessellationPatchSize_allocs *cgoAllocMap
	ref7926795a.maxTessellationPatchSize, cmaxTessellationPatchSize_allocs = (C.uint32_t)(x.MaxTessellationPatchSize), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationPatchSize_allocs)

	var cmaxTessellationControlPerVertexInputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlPerVertexInputComponents, cmaxTessellationControlPerVertexInputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlPerVertexInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlPerVertexInputComponents_allocs)

	var cmaxTessellationControlPerVertexOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlPerVertexOutputComponents, cmaxTessellationControlPerVertexOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlPerVertexOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlPerVertexOutputComponents_allocs)

	var cmaxTessellationControlPerPatchOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlPerPatchOutputComponents, cmaxTessellationControlPerPatchOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlPerPatchOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlPerPatchOutputComponents_allocs)

	var cmaxTessellationControlTotalOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlTotalOutputComponents, cmaxTessellationControlTotalOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlTotalOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlTotalOutputComponents_allocs)

	var cmaxTessellationEvaluationInputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationEvaluationInputComponents, cmaxTessellationEvaluationInputComponents_allocs = (C.uint32_t)(x.MaxTessellationEvaluationInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationEvaluationInputComponents_allocs)

	var cmaxTessellationEvaluationOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationEvaluationOutputComponents, cmaxTessellationEvaluationOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationEvaluationOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationEvaluationOutputComponents_allocs)

	var cmaxGeometryShaderInvocations_allocs *cgoAllocMap
	ref7926795a.maxGeometryShaderInvocations, cmaxGeometryShaderInvocations_allocs = (C.uint32_t)(x.MaxGeometryShaderInvocations), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryShaderInvocations_allocs)

	var cmaxGeometryInputComponents_allocs *cgoAllocMap
	ref7926795a.maxGeometryInputComponents, cmaxGeometryInputComponents_allocs = (C.uint32_t)(x.MaxGeometryInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryInputComponents_allocs)

	var cmaxGeometryOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxGeometryOutputComponents, cmaxGeometryOutputComponents_allocs = (C.uint32_t)(x.MaxGeometryOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryOutputComponents_allocs)

	var cmaxGeometryOutputVertices_allocs *cgoAllocMap
	ref7926795a.maxGeometryOutputVertices, cmaxGeometryOutputVertices_allocs = (C.uint32_t)(x.MaxGeometryOutputVertices), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryOutputVertices_allocs)

	var cmaxGeometryTotalOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxGeometryTotalOutputComponents, cmaxGeometryTotalOutputComponents_allocs = (C.uint32_t)(x.MaxGeometryTotalOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryTotalOutputComponents_allocs)

	var cmaxFragmentInputComponents_allocs *cgoAllocMap
	ref7926795a.maxFragmentInputComponents, cmaxFragmentInputComponents_allocs = (C.uint32_t)(x.MaxFragmentInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentInputComponents_allocs)

	var cmaxFragmentOutputAttachments_allocs *cgoAllocMap
	ref7926795a.maxFragmentOutputAttachments, cmaxFragmentOutputAttachments_allocs = (C.uint32_t)(x.MaxFragmentOutputAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentOutputAttachments_allocs)

	var cmaxFragmentDualSrcAttachments_allocs *cgoAllocMap
	ref7926795a.maxFragmentDualSrcAttachments, cmaxFragmentDualSrcAttachments_allocs = (C.uint32_t)(x.MaxFragmentDualSrcAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentDualSrcAttachments_allocs)

	var cmaxFragmentCombinedOutputResources_allocs *cgoAllocMap
	ref7926795a.maxFragmentCombinedOutputResources, cmaxFragmentCombinedOutputResources_allocs = (C.uint32_t)(x.MaxFragmentCombinedOutputResources), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentCombinedOutputResources_allocs)

	var cmaxComputeSharedMemorySize_allocs *cgoAllocMap
	ref7926795a.maxComputeSharedMemorySize, cmaxComputeSharedMemorySize_allocs = (C.uint32_t)(x.MaxComputeSharedMemorySize), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeSharedMemorySize_allocs)

	var cmaxComputeWorkGroupCount_allocs *cgoAllocMap
	ref7926795a.maxComputeWorkGroupCount, cmaxComputeWorkGroupCount_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.MaxComputeWorkGroupCount)), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeWorkGroupCount_allocs)

	var cmaxComputeWorkGroupInvocations_allocs *cgoAllocMap
	ref7926795a.maxComputeWorkGroupInvocations, cmaxComputeWorkGroupInvocations_allocs = (C.uint32_t)(x.MaxComputeWorkGroupInvocations), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeWorkGroupInvocations_allocs)

	var cmaxComputeWorkGroupSize_allocs *cgoAllocMap
	ref7926795a.maxComputeWorkGroupSize, cmaxComputeWorkGroupSize_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.MaxComputeWorkGroupSize)), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeWorkGroupSize_allocs)

	var csubPixelPrecisionBits_allocs *cgoAllocMap
	ref7926795a.subPixelPrecisionBits, csubPixelPrecisionBits_allocs = (C.uint32_t)(x.SubPixelPrecisionBits), cgoAllocsUnknown
	allocs7926795a.Borrow(csubPixelPrecisionBits_allocs)

	var csubTexelPrecisionBits_allocs *cgoAllocMap
	ref7926795a.subTexelPrecisionBits, csubTexelPrecisionBits_allocs = (C.uint32_t)(x.SubTexelPrecisionBits), cgoAllocsUnknown
	allocs7926795a.Borrow(csubTexelPrecisionBits_allocs)

	var cmipmapPrecisionBits_allocs *cgoAllocMap
	ref7926795a.mipmapPrecisionBits, cmipmapPrecisionBits_allocs = (C.uint32_t)(x.MipmapPrecisionBits), cgoAllocsUnknown
	allocs7926795a.Borrow(cmipmapPrecisionBits_allocs)

	var cmaxDrawIndexedIndexValue_allocs *cgoAllocMap
	ref7926795a.maxDrawIndexedIndexValue, cmaxDrawIndexedIndexValue_allocs = (C.uint32_t)(x.MaxDrawIndexedIndexValue), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDrawIndexedIndexValue_allocs)

	var cmaxDrawIndirectCount_allocs *cgoAllocMap
	ref7926795a.maxDrawIndirectCount, cmaxDrawIndirectCount_allocs = (C.uint32_t)(x.MaxDrawIndirectCount), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDrawIndirectCount_allocs)

	var cmaxSamplerLodBias_allocs *cgoAllocMap
	ref7926795a.maxSamplerLodBias, cmaxSamplerLodBias_allocs = (C.float)(x.MaxSamplerLodBias), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSamplerLodBias_allocs)

	var cmaxSamplerAnisotropy_allocs *cgoAllocMap
	ref7926795a.maxSamplerAnisotropy, cmaxSamplerAnisotropy_allocs = (C.float)(x.MaxSamplerAnisotropy), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSamplerAnisotropy_allocs)

	var cmaxViewports_allocs *cgoAllocMap
	ref7926795a.maxViewports, cmaxViewports_allocs = (C.uint32_t)(x.MaxViewports), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxViewports_allocs)

	var cmaxViewportDimensions_allocs *cgoAllocMap
	ref7926795a.maxViewportDimensions, cmaxViewportDimensions_allocs = *(*[2]C.uint32_t)(unsafe.Pointer(&x.MaxViewportDimensions)), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxViewportDimensions_allocs)

	var cviewportBoundsRange_allocs *cgoAllocMap
	ref7926795a.viewportBoundsRange, cviewportBoundsRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.ViewportBoundsRange)), cgoAllocsUnknown
	allocs7926795a.Borrow(cviewportBoundsRange_allocs)

	var cviewportSubPixelBits_allocs *cgoAllocMap
	ref7926795a.viewportSubPixelBits, cviewportSubPixelBits_allocs = (C.uint32_t)(x.ViewportSubPixelBits), cgoAllocsUnknown
	allocs7926795a.Borrow(cviewportSubPixelBits_allocs)

	var cminMemoryMapAlignment_allocs *cgoAllocMap
	ref7926795a.minMemoryMapAlignment, cminMemoryMapAlignment_allocs = (C.size_t)(x.MinMemoryMapAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminMemoryMapAlignment_allocs)

	var cminTexelBufferOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.minTexelBufferOffsetAlignment, cminTexelBufferOffsetAlignment_allocs = (C.VkDeviceSize)(x.MinTexelBufferOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminTexelBufferOffsetAlignment_allocs)

	var cminUniformBufferOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.minUniformBufferOffsetAlignment, cminUniformBufferOffsetAlignment_allocs = (C.VkDeviceSize)(x.MinUniformBufferOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminUniformBufferOffsetAlignment_allocs)

	var cminStorageBufferOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.minStorageBufferOffsetAlignment, cminStorageBufferOffsetAlignment_allocs = (C.VkDeviceSize)(x.MinStorageBufferOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminStorageBufferOffsetAlignment_allocs)

	var cminTexelOffset_allocs *cgoAllocMap
	ref7926795a.minTexelOffset, cminTexelOffset_allocs = (C.int32_t)(x.MinTexelOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cminTexelOffset_allocs)

	var cmaxTexelOffset_allocs *cgoAllocMap
	ref7926795a.maxTexelOffset, cmaxTexelOffset_allocs = (C.uint32_t)(x.MaxTexelOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTexelOffset_allocs)

	var cminTexelGatherOffset_allocs *cgoAllocMap
	ref7926795a.minTexelGatherOffset, cminTexelGatherOffset_allocs = (C.int32_t)(x.MinTexelGatherOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cminTexelGatherOffset_allocs)

	var cmaxTexelGatherOffset_allocs *cgoAllocMap
	ref7926795a.maxTexelGatherOffset, cmaxTexelGatherOffset_allocs = (C.uint32_t)(x.MaxTexelGatherOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTexelGatherOffset_allocs)

	var cminInterpolationOffset_allocs *cgoAllocMap
	ref7926795a.minInterpolationOffset, cminInterpolationOffset_allocs = (C.float)(x.MinInterpolationOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cminInterpolationOffset_allocs)

	var cmaxInterpolationOffset_allocs *cgoAllocMap
	ref7926795a.maxInterpolationOffset, cmaxInterpolationOffset_allocs = (C.float)(x.MaxInterpolationOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxInterpolationOffset_allocs)

	var csubPixelInterpolationOffsetBits_allocs *cgoAllocMap
	ref7926795a.subPixelInterpolationOffsetBits, csubPixelInterpolationOffsetBits_allocs = (C.uint32_t)(x.SubPixelInterpolationOffsetBits), cgoAllocsUnknown
	allocs7926795a.Borrow(csubPixelInterpolationOffsetBits_allocs)

	var cmaxFramebufferWidth_allocs *cgoAllocMap
	ref7926795a.maxFramebufferWidth, cmaxFramebufferWidth_allocs = (C.uint32_t)(x.MaxFramebufferWidth), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFramebufferWidth_allocs)

	var cmaxFramebufferHeight_allocs *cgoAllocMap
	ref7926795a.maxFramebufferHeight, cmaxFramebufferHeight_allocs = (C.uint32_t)(x.MaxFramebufferHeight), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFramebufferHeight_allocs)

	var cmaxFramebufferLayers_allocs *cgoAllocMap
	ref7926795a.maxFramebufferLayers, cmaxFramebufferLayers_allocs = (C.uint32_t)(x.MaxFramebufferLayers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFramebufferLayers_allocs)

	var cframebufferColorSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferColorSampleCounts, cframebufferColorSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferColorSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferColorSampleCounts_allocs)

	var cframebufferDepthSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferDepthSampleCounts, cframebufferDepthSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferDepthSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferDepthSampleCounts_allocs)

	var cframebufferStencilSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferStencilSampleCounts, cframebufferStencilSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferStencilSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferStencilSampleCounts_allocs)

	var cframebufferNoAttachmentsSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferNoAttachmentsSampleCounts, cframebufferNoAttachmentsSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferNoAttachmentsSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferNoAttachmentsSampleCounts_allocs)

	var cmaxColorAttachments_allocs *cgoAllocMap
	ref7926795a.maxColorAttachments, cmaxColorAttachments_allocs = (C.uint32_t)(x.MaxColorAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxColorAttachments_allocs)

	var csampledImageColorSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageColorSampleCounts, csampledImageColorSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageColorSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageColorSampleCounts_allocs)

	var csampledImageIntegerSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageIntegerSampleCounts, csampledImageIntegerSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageIntegerSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageIntegerSampleCounts_allocs)

	var csampledImageDepthSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageDepthSampleCounts, csampledImageDepthSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageDepthSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageDepthSampleCounts_allocs)

	var csampledImageStencilSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageStencilSampleCounts, csampledImageStencilSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageStencilSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageStencilSampleCounts_allocs)

	var cstorageImageSampleCounts_allocs *cgoAllocMap
	ref7926795a.storageImageSampleCounts, cstorageImageSampleCounts_allocs = (C.VkSampleCountFlags)(x.StorageImageSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cstorageImageSampleCounts_allocs)

	var cmaxSampleMaskWords_allocs *cgoAllocMap
	ref7926795a.maxSampleMaskWords, cmaxSampleMaskWords_allocs = (C.uint32_t)(x.MaxSampleMaskWords), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSampleMaskWords_allocs)

	var ctimestampComputeAndGraphics_allocs *cgoAllocMap
	ref7926795a.timestampComputeAndGraphics, ctimestampComputeAndGraphics_allocs = (C.VkBool32)(x.TimestampComputeAndGraphics), cgoAllocsUnknown
	allocs7926795a.Borrow(ctimestampComputeAndGraphics_allocs)

	var ctimestampPeriod_allocs *cgoAllocMap
	ref7926795a.timestampPeriod, ctimestampPeriod_allocs = (C.float)(x.TimestampPeriod), cgoAllocsUnknown
	allocs7926795a.Borrow(ctimestampPeriod_allocs)

	var cmaxClipDistances_allocs *cgoAllocMap
	ref7926795a.maxClipDistances, cmaxClipDistances_allocs = (C.uint32_t)(x.MaxClipDistances), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxClipDistances_allocs)

	var cmaxCullDistances_allocs *cgoAllocMap
	ref7926795a.maxCullDistances, cmaxCullDistances_allocs = (C.uint32_t)(x.MaxCullDistances), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxCullDistances_allocs)

	var cmaxCombinedClipAndCullDistances_allocs *cgoAllocMap
	ref7926795a.maxCombinedClipAndCullDistances, cmaxCombinedClipAndCullDistances_allocs = (C.uint32_t)(x.MaxCombinedClipAndCullDistances), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxCombinedClipAndCullDistances_allocs)

	var cdiscreteQueuePriorities_allocs *cgoAllocMap
	ref7926795a.discreteQueuePriorities, cdiscreteQueuePriorities_allocs = (C.uint32_t)(x.DiscreteQueuePriorities), cgoAllocsUnknown
	allocs7926795a.Borrow(cdiscreteQueuePriorities_allocs)

	var cpointSizeRange_allocs *cgoAllocMap
	ref7926795a.pointSizeRange, cpointSizeRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.PointSizeRange)), cgoAllocsUnknown
	allocs7926795a.Borrow(cpointSizeRange_allocs)

	var clineWidthRange_allocs *cgoAllocMap
	ref7926795a.lineWidthRange, clineWidthRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.LineWidthRange)), cgoAllocsUnknown
	allocs7926795a.Borrow(clineWidthRange_allocs)

	var cpointSizeGranularity_allocs *cgoAllocMap
	ref7926795a.pointSizeGranularity, cpointSizeGranularity_allocs = (C.float)(x.PointSizeGranularity), cgoAllocsUnknown
	allocs7926795a.Borrow(cpointSizeGranularity_allocs)

	var clineWidthGranularity_allocs *cgoAllocMap
	ref7926795a.lineWidthGranularity, clineWidthGranularity_allocs = (C.float)(x.LineWidthGranularity), cgoAllocsUnknown
	allocs7926795a.Borrow(clineWidthGranularity_allocs)

	var cstrictLines_allocs *cgoAllocMap
	ref7926795a.strictLines, cstrictLines_allocs = (C.VkBool32)(x.StrictLines), cgoAllocsUnknown
	allocs7926795a.Borrow(cstrictLines_allocs)

	var cstandardSampleLocations_allocs *cgoAllocMap
	ref7926795a.standardSampleLocations, cstandardSampleLocations_allocs = (C.VkBool32)(x.StandardSampleLocations), cgoAllocsUnknown
	allocs7926795a.Borrow(cstandardSampleLocations_allocs)

	var coptimalBufferCopyOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.optimalBufferCopyOffsetAlignment, coptimalBufferCopyOffsetAlignment_allocs = (C.VkDeviceSize)(x.OptimalBufferCopyOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(coptimalBufferCopyOffsetAlignment_allocs)

	var coptimalBufferCopyRowPitchAlignment_allocs *cgoAllocMap
	ref7926795a.optimalBufferCopyRowPitchAlignment, coptimalBufferCopyRowPitchAlignment_allocs = (C.VkDeviceSize)(x.OptimalBufferCopyRowPitchAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(coptimalBufferCopyRowPitchAlignment_allocs)

	var cnonCoherentAtomSize_allocs *cgoAllocMap
	ref7926795a.nonCoherentAtomSize, cnonCoherentAtomSize_allocs = (C.VkDeviceSize)(x.NonCoherentAtomSize), cgoAllocsUnknown
	allocs7926795a.Borrow(cnonCoherentAtomSize_allocs)

	x.ref7926795a = ref7926795a
	x.allocs7926795a = allocs7926795a
	return ref7926795a, allocs7926795a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceLimits) PassValue() (C.VkPhysicalDeviceLimits, *cgoAllocMap) {
	if x.ref7926795a != nil {
		return *x.ref7926795a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceLimits) Deref() {
	if x.ref7926795a == nil {
		return
	}
	x.MaxImageDimension1D = (uint32)(x.ref7926795a.maxImageDimension1D)
	x.MaxImageDimension2D = (uint32)(x.ref7926795a.maxImageDimension2D)
	x.MaxImageDimension3D = (uint32)(x.ref7926795a.maxImageDimension3D)
	x.MaxImageDimensionCube = (uint32)(x.ref7926795a.maxImageDimensionCube)
	x.MaxImageArrayLayers = (uint32)(x.ref7926795a.maxImageArrayLayers)
	x.MaxTexelBufferElements = (uint32)(x.ref7926795a.maxTexelBufferElements)
	x.MaxUniformBufferRange = (uint32)(x.ref7926795a.maxUniformBufferRange)
	x.MaxStorageBufferRange = (uint32)(x.ref7926795a.maxStorageBufferRange)
	x.MaxPushConstantsSize = (uint32)(x.ref7926795a.maxPushConstantsSize)
	x.MaxMemoryAllocationCount = (uint32)(x.ref7926795a.maxMemoryAllocationCount)
	x.MaxSamplerAllocationCount = (uint32)(x.ref7926795a.maxSamplerAllocationCount)
	x.BufferImageGranularity = (DeviceSize)(x.ref7926795a.bufferImageGranularity)
	x.SparseAddressSpaceSize = (DeviceSize)(x.ref7926795a.sparseAddressSpaceSize)
	x.MaxBoundDescriptorSets = (uint32)(x.ref7926795a.maxBoundDescriptorSets)
	x.MaxPerStageDescriptorSamplers = (uint32)(x.ref7926795a.maxPerStageDescriptorSamplers)
	x.MaxPerStageDescriptorUniformBuffers = (uint32)(x.ref7926795a.maxPerStageDescriptorUniformBuffers)
	x.MaxPerStageDescriptorStorageBuffers = (uint32)(x.ref7926795a.maxPerStageDescriptorStorageBuffers)
	x.MaxPerStageDescriptorSampledImages = (uint32)(x.ref7926795a.maxPerStageDescriptorSampledImages)
	x.MaxPerStageDescriptorStorageImages = (uint32)(x.ref7926795a.maxPerStageDescriptorStorageImages)
	x.MaxPerStageDescriptorInputAttachments = (uint32)(x.ref7926795a.maxPerStageDescriptorInputAttachments)
	x.MaxPerStageResources = (uint32)(x.ref7926795a.maxPerStageResources)
	x.MaxDescriptorSetSamplers = (uint32)(x.ref7926795a.maxDescriptorSetSamplers)
	x.MaxDescriptorSetUniformBuffers = (uint32)(x.ref7926795a.maxDescriptorSetUniformBuffers)
	x.MaxDescriptorSetUniformBuffersDynamic = (uint32)(x.ref7926795a.maxDescriptorSetUniformBuffersDynamic)
	x.MaxDescriptorSetStorageBuffers = (uint32)(x.ref7926795a.maxDescriptorSetStorageBuffers)
	x.MaxDescriptorSetStorageBuffersDynamic = (uint32)(x.ref7926795a.maxDescriptorSetStorageBuffersDynamic)
	x.MaxDescriptorSetSampledImages = (uint32)(x.ref7926795a.maxDescriptorSetSampledImages)
	x.MaxDescriptorSetStorageImages = (uint32)(x.ref7926795a.maxDescriptorSetStorageImages)
	x.MaxDescriptorSetInputAttachments = (uint32)(x.ref7926795a.maxDescriptorSetInputAttachments)
	x.MaxVertexInputAttributes = (uint32)(x.ref7926795a.maxVertexInputAttributes)
	x.MaxVertexInputBindings = (uint32)(x.ref7926795a.maxVertexInputBindings)
	x.MaxVertexInputAttributeOffset = (uint32)(x.ref7926795a.maxVertexInputAttributeOffset)
	x.MaxVertexInputBindingStride = (uint32)(x.ref7926795a.maxVertexInputBindingStride)
	x.MaxVertexOutputComponents = (uint32)(x.ref7926795a.maxVertexOutputComponents)
	x.MaxTessellationGenerationLevel = (uint32)(x.ref7926795a.maxTessellationGenerationLevel)
	x.MaxTessellationPatchSize = (uint32)(x.ref7926795a.maxTessellationPatchSize)
	x.MaxTessellationControlPerVertexInputComponents = (uint32)(x.ref7926795a.maxTessellationControlPerVertexInputComponents)
	x.MaxTessellationControlPerVertexOutputComponents = (uint32)(x.ref7926795a.maxTessellationControlPerVertexOutputComponents)
	x.MaxTessellationControlPerPatchOutputComponents = (uint32)(x.ref7926795a.maxTessellationControlPerPatchOutputComponents)
	x.MaxTessellationControlTotalOutputComponents = (uint32)(x.ref7926795a.maxTessellationControlTotalOutputComponents)
	x.MaxTessellationEvaluationInputComponents = (uint32)(x.ref7926795a.maxTessellationEvaluationInputComponents)
	x.MaxTessellationEvaluationOutputComponents = (uint32)(x.ref7926795a.maxTessellationEvaluationOutputComponents)
	x.MaxGeometryShaderInvocations = (uint32)(x.ref7926795a.maxGeometryShaderInvocations)
	x.MaxGeometryInputComponents = (uint32)(x.ref7926795a.maxGeometryInputComponents)
	x.MaxGeometryOutputComponents = (uint32)(x.ref7926795a.maxGeometryOutputComponents)
	x.MaxGeometryOutputVertices = (uint32)(x.ref7926795a.maxGeometryOutputVertices)
	x.MaxGeometryTotalOutputComponents = (uint32)(x.ref7926795a.maxGeometryTotalOutputComponents)
	x.MaxFragmentInputComponents = (uint32)(x.ref7926795a.maxFragmentInputComponents)
	x.MaxFragmentOutputAttachments = (uint32)(x.ref7926795a.maxFragmentOutputAttachments)
	x.MaxFragmentDualSrcAttachments = (uint32)(x.ref7926795a.maxFragmentDualSrcAttachments)
	x.MaxFragmentCombinedOutputResources = (uint32)(x.ref7926795a.maxFragmentCombinedOutputResources)
	x.MaxComputeSharedMemorySize = (uint32)(x.ref7926795a.maxComputeSharedMemorySize)
	x.MaxComputeWorkGroupCount = *(*[3]uint32)(unsafe.Pointer(&x.ref7926795a.maxComputeWorkGroupCount))
	x.MaxComputeWorkGroupInvocations = (uint32)(x.ref7926795a.maxComputeWorkGroupInvocations)
	x.MaxComputeWorkGroupSize = *(*[3]uint32)(unsafe.Pointer(&x.ref7926795a.maxComputeWorkGroupSize))
	x.SubPixelPrecisionBits = (uint32)(x.ref7926795a.subPixelPrecisionBits)
	x.SubTexelPrecisionBits = (uint32)(x.ref7926795a.subTexelPrecisionBits)
	x.MipmapPrecisionBits = (uint32)(x.ref7926795a.mipmapPrecisionBits)
	x.MaxDrawIndexedIndexValue = (uint32)(x.ref7926795a.maxDrawIndexedIndexValue)
	x.MaxDrawIndirectCount = (uint32)(x.ref7926795a.maxDrawIndirectCount)
	x.MaxSamplerLodBias = (float32)(x.ref7926795a.maxSamplerLodBias)
	x.MaxSamplerAnisotropy = (float32)(x.ref7926795a.maxSamplerAnisotropy)
	x.MaxViewports = (uint32)(x.ref7926795a.maxViewports)
	x.MaxViewportDimensions = *(*[2]uint32)(unsafe.Pointer(&x.ref7926795a.maxViewportDimensions))
	x.ViewportBoundsRange = *(*[2]float32)(unsafe.Pointer(&x.ref7926795a.viewportBoundsRange))
	x.ViewportSubPixelBits = (uint32)(x.ref7926795a.viewportSubPixelBits)
	x.MinMemoryMapAlignment = (uint32)(x.ref7926795a.minMemoryMapAlignment)
	x.MinTexelBufferOffsetAlignment = (DeviceSize)(x.ref7926795a.minTexelBufferOffsetAlignment)
	x.MinUniformBufferOffsetAlignment = (DeviceSize)(x.ref7926795a.minUniformBufferOffsetAlignment)
	x.MinStorageBufferOffsetAlignment = (DeviceSize)(x.ref7926795a.minStorageBufferOffsetAlignment)
	x.MinTexelOffset = (int32)(x.ref7926795a.minTexelOffset)
	x.MaxTexelOffset = (uint32)(x.ref7926795a.maxTexelOffset)
	x.MinTexelGatherOffset = (int32)(x.ref7926795a.minTexelGatherOffset)
	x.MaxTexelGatherOffset = (uint32)(x.ref7926795a.maxTexelGatherOffset)
	x.MinInterpolationOffset = (float32)(x.ref7926795a.minInterpolationOffset)
	x.MaxInterpolationOffset = (float32)(x.ref7926795a.maxInterpolationOffset)
	x.SubPixelInterpolationOffsetBits = (uint32)(x.ref7926795a.subPixelInterpolationOffsetBits)
	x.MaxFramebufferWidth = (uint32)(x.ref7926795a.maxFramebufferWidth)
	x.MaxFramebufferHeight = (uint32)(x.ref7926795a.maxFramebufferHeight)
	x.MaxFramebufferLayers = (uint32)(x.ref7926795a.maxFramebufferLayers)
	x.FramebufferColorSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferColorSampleCounts)
	x.FramebufferDepthSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferDepthSampleCounts)
	x.FramebufferStencilSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferStencilSampleCounts)
	x.FramebufferNoAttachmentsSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferNoAttachmentsSampleCounts)
	x.MaxColorAttachments = (uint32)(x.ref7926795a.maxColorAttachments)
	x.SampledImageColorSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageColorSampleCounts)
	x.SampledImageIntegerSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageIntegerSampleCounts)
	x.SampledImageDepthSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageDepthSampleCounts)
	x.SampledImageStencilSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageStencilSampleCounts)
	x.StorageImageSampleCounts = (SampleCountFlags)(x.ref7926795a.storageImageSampleCounts)
	x.MaxSampleMaskWords = (uint32)(x.ref7926795a.maxSampleMaskWords)
	x.TimestampComputeAndGraphics = (Bool32)(x.ref7926795a.timestampComputeAndGraphics)
	x.TimestampPeriod = (float32)(x.ref7926795a.timestampPeriod)
	x.MaxClipDistances = (uint32)(x.ref7926795a.maxClipDistances)
	x.MaxCullDistances = (uint32)(x.ref7926795a.maxCullDistances)
	x.MaxCombinedClipAndCullDistances = (uint32)(x.ref7926795a.maxCombinedClipAndCullDistances)
	x.DiscreteQueuePriorities = (uint32)(x.ref7926795a.discreteQueuePriorities)
	x.PointSizeRange = *(*[2]float32)(unsafe.Pointer(&x.ref7926795a.pointSizeRange))
	x.LineWidthRange = *(*[2]float32)(unsafe.Pointer(&x.ref7926795a.lineWidthRange))
	x.PointSizeGranularity = (float32)(x.ref7926795a.pointSizeGranularity)
	x.LineWidthGranularity = (float32)(x.ref7926795a.lineWidthGranularity)
	x.StrictLines = (Bool32)(x.ref7926795a.strictLines)
	x.StandardSampleLocations = (Bool32)(x.ref7926795a.standardSampleLocations)
	x.OptimalBufferCopyOffsetAlignment = (DeviceSize)(x.ref7926795a.optimalBufferCopyOffsetAlignment)
	x.OptimalBufferCopyRowPitchAlignment = (DeviceSize)(x.ref7926795a.optimalBufferCopyRowPitchAlignment)
	x.NonCoherentAtomSize = (DeviceSize)(x.ref7926795a.nonCoherentAtomSize)
}

// allocPhysicalDeviceMemoryPropertiesMemory allocates memory for type C.VkPhysicalDeviceMemoryProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMemoryPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMemoryPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceMemoryPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMemoryProperties{})

// allocA32MemoryTypeMemory allocates memory for type [32]C.VkMemoryType in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA32MemoryTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA32MemoryTypeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA32MemoryTypeValue = unsafe.Sizeof([1][32]C.VkMemoryType{})

// unpackA32MemoryType transforms a sliced Go data structure into plain C format.
func unpackA32MemoryType(x [32]MemoryType) (unpacked [32]C.VkMemoryType, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA32MemoryTypeMemory(1)
	allocs.Add(mem0)
	v0 := (*[32]C.VkMemoryType)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[32]C.VkMemoryType)(mem0)
	return
}

// allocA16MemoryHeapMemory allocates memory for type [16]C.VkMemoryHeap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA16MemoryHeapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA16MemoryHeapValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA16MemoryHeapValue = unsafe.Sizeof([1][16]C.VkMemoryHeap{})

// unpackA16MemoryHeap transforms a sliced Go data structure into plain C format.
func unpackA16MemoryHeap(x [16]MemoryHeap) (unpacked [16]C.VkMemoryHeap, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA16MemoryHeapMemory(1)
	allocs.Add(mem0)
	v0 := (*[16]C.VkMemoryHeap)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[16]C.VkMemoryHeap)(mem0)
	return
}

// packA32MemoryType reads sliced Go data structure out from plain C format.
func packA32MemoryType(v *[32]MemoryType, ptr0 *[32]C.VkMemoryType) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewMemoryTypeRef(unsafe.Pointer(&ptr1))
	}
}

// packA16MemoryHeap reads sliced Go data structure out from plain C format.
func packA16MemoryHeap(v *[16]MemoryHeap, ptr0 *[16]C.VkMemoryHeap) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewMemoryHeapRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMemoryProperties) Ref() *C.VkPhysicalDeviceMemoryProperties {
	if x == nil {
		return nil
	}
	return x.ref3aabb5fd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMemoryProperties) Free() {
	if x != nil && x.allocs3aabb5fd != nil {
		x.allocs3aabb5fd.(*cgoAllocMap).Free()
		x.ref3aabb5fd = nil
	}
}

// NewPhysicalDeviceMemoryPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMemoryPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceMemoryProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMemoryProperties)
	obj.ref3aabb5fd = (*C.VkPhysicalDeviceMemoryProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMemoryProperties) PassRef() (*C.VkPhysicalDeviceMemoryProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3aabb5fd != nil {
		return x.ref3aabb5fd, nil
	}
	mem3aabb5fd := allocPhysicalDeviceMemoryPropertiesMemory(1)
	ref3aabb5fd := (*C.VkPhysicalDeviceMemoryProperties)(mem3aabb5fd)
	allocs3aabb5fd := new(cgoAllocMap)
	allocs3aabb5fd.Add(mem3aabb5fd)

	var cmemoryTypeCount_allocs *cgoAllocMap
	ref3aabb5fd.memoryTypeCount, cmemoryTypeCount_allocs = (C.uint32_t)(x.MemoryTypeCount), cgoAllocsUnknown
	allocs3aabb5fd.Borrow(cmemoryTypeCount_allocs)

	var cmemoryTypes_allocs *cgoAllocMap
	ref3aabb5fd.memoryTypes, cmemoryTypes_allocs = unpackA32MemoryType(x.MemoryTypes)
	allocs3aabb5fd.Borrow(cmemoryTypes_allocs)

	var cmemoryHeapCount_allocs *cgoAllocMap
	ref3aabb5fd.memoryHeapCount, cmemoryHeapCount_allocs = (C.uint32_t)(x.MemoryHeapCount), cgoAllocsUnknown
	allocs3aabb5fd.Borrow(cmemoryHeapCount_allocs)

	var cmemoryHeaps_allocs *cgoAllocMap
	ref3aabb5fd.memoryHeaps, cmemoryHeaps_allocs = unpackA16MemoryHeap(x.MemoryHeaps)
	allocs3aabb5fd.Borrow(cmemoryHeaps_allocs)

	x.ref3aabb5fd = ref3aabb5fd
	x.allocs3aabb5fd = allocs3aabb5fd
	return ref3aabb5fd, allocs3aabb5fd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMemoryProperties) PassValue() (C.VkPhysicalDeviceMemoryProperties, *cgoAllocMap) {
	if x.ref3aabb5fd != nil {
		return *x.ref3aabb5fd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMemoryProperties) Deref() {
	if x.ref3aabb5fd == nil {
		return
	}
	x.MemoryTypeCount = (uint32)(x.ref3aabb5fd.memoryTypeCount)
	packA32MemoryType(&x.MemoryTypes, (*[32]C.VkMemoryType)(unsafe.Pointer(&x.ref3aabb5fd.memoryTypes)))
	x.MemoryHeapCount = (uint32)(x.ref3aabb5fd.memoryHeapCount)
	packA16MemoryHeap(&x.MemoryHeaps, (*[16]C.VkMemoryHeap)(unsafe.Pointer(&x.ref3aabb5fd.memoryHeaps)))
}

// allocPhysicalDeviceSparsePropertiesMemory allocates memory for type C.VkPhysicalDeviceSparseProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSparsePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSparsePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceSparsePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSparseProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSparseProperties) Ref() *C.VkPhysicalDeviceSparseProperties {
	if x == nil {
		return nil
	}
	return x.ref6d7c11e6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSparseProperties) Free() {
	if x != nil && x.allocs6d7c11e6 != nil {
		x.allocs6d7c11e6.(*cgoAllocMap).Free()
		x.ref6d7c11e6 = nil
	}
}

// NewPhysicalDeviceSparsePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSparsePropertiesRef(ref unsafe.Pointer) *PhysicalDeviceSparseProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSparseProperties)
	obj.ref6d7c11e6 = (*C.VkPhysicalDeviceSparseProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSparseProperties) PassRef() (*C.VkPhysicalDeviceSparseProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6d7c11e6 != nil {
		return x.ref6d7c11e6, nil
	}
	mem6d7c11e6 := allocPhysicalDeviceSparsePropertiesMemory(1)
	ref6d7c11e6 := (*C.VkPhysicalDeviceSparseProperties)(mem6d7c11e6)
	allocs6d7c11e6 := new(cgoAllocMap)
	allocs6d7c11e6.Add(mem6d7c11e6)

	var cresidencyStandard2DBlockShape_allocs *cgoAllocMap
	ref6d7c11e6.residencyStandard2DBlockShape, cresidencyStandard2DBlockShape_allocs = (C.VkBool32)(x.ResidencyStandard2DBlockShape), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyStandard2DBlockShape_allocs)

	var cresidencyStandard2DMultisampleBlockShape_allocs *cgoAllocMap
	ref6d7c11e6.residencyStandard2DMultisampleBlockShape, cresidencyStandard2DMultisampleBlockShape_allocs = (C.VkBool32)(x.ResidencyStandard2DMultisampleBlockShape), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyStandard2DMultisampleBlockShape_allocs)

	var cresidencyStandard3DBlockShape_allocs *cgoAllocMap
	ref6d7c11e6.residencyStandard3DBlockShape, cresidencyStandard3DBlockShape_allocs = (C.VkBool32)(x.ResidencyStandard3DBlockShape), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyStandard3DBlockShape_allocs)

	var cresidencyAlignedMipSize_allocs *cgoAllocMap
	ref6d7c11e6.residencyAlignedMipSize, cresidencyAlignedMipSize_allocs = (C.VkBool32)(x.ResidencyAlignedMipSize), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyAlignedMipSize_allocs)

	var cresidencyNonResidentStrict_allocs *cgoAllocMap
	ref6d7c11e6.residencyNonResidentStrict, cresidencyNonResidentStrict_allocs = (C.VkBool32)(x.ResidencyNonResidentStrict), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyNonResidentStrict_allocs)

	x.ref6d7c11e6 = ref6d7c11e6
	x.allocs6d7c11e6 = allocs6d7c11e6
	return ref6d7c11e6, allocs6d7c11e6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSparseProperties) PassValue() (C.VkPhysicalDeviceSparseProperties, *cgoAllocMap) {
	if x.ref6d7c11e6 != nil {
		return *x.ref6d7c11e6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSparseProperties) Deref() {
	if x.ref6d7c11e6 == nil {
		return
	}
	x.ResidencyStandard2DBlockShape = (Bool32)(x.ref6d7c11e6.residencyStandard2DBlockShape)
	x.ResidencyStandard2DMultisampleBlockShape = (Bool32)(x.ref6d7c11e6.residencyStandard2DMultisampleBlockShape)
	x.ResidencyStandard3DBlockShape = (Bool32)(x.ref6d7c11e6.residencyStandard3DBlockShape)
	x.ResidencyAlignedMipSize = (Bool32)(x.ref6d7c11e6.residencyAlignedMipSize)
	x.ResidencyNonResidentStrict = (Bool32)(x.ref6d7c11e6.residencyNonResidentStrict)
}

// allocPhysicalDevicePropertiesMemory allocates memory for type C.VkPhysicalDeviceProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDevicePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProperties) Ref() *C.VkPhysicalDeviceProperties {
	if x == nil {
		return nil
	}
	return x.ref1080ca9d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProperties) Free() {
	if x != nil && x.allocs1080ca9d != nil {
		x.allocs1080ca9d.(*cgoAllocMap).Free()
		x.ref1080ca9d = nil
	}
}

// NewPhysicalDevicePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePropertiesRef(ref unsafe.Pointer) *PhysicalDeviceProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProperties)
	obj.ref1080ca9d = (*C.VkPhysicalDeviceProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProperties) PassRef() (*C.VkPhysicalDeviceProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1080ca9d != nil {
		return x.ref1080ca9d, nil
	}
	mem1080ca9d := allocPhysicalDevicePropertiesMemory(1)
	ref1080ca9d := (*C.VkPhysicalDeviceProperties)(mem1080ca9d)
	allocs1080ca9d := new(cgoAllocMap)
	allocs1080ca9d.Add(mem1080ca9d)

	var capiVersion_allocs *cgoAllocMap
	ref1080ca9d.apiVersion, capiVersion_allocs = (C.uint32_t)(x.ApiVersion), cgoAllocsUnknown
	allocs1080ca9d.Borrow(capiVersion_allocs)

	var cdriverVersion_allocs *cgoAllocMap
	ref1080ca9d.driverVersion, cdriverVersion_allocs = (C.uint32_t)(x.DriverVersion), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdriverVersion_allocs)

	var cvendorID_allocs *cgoAllocMap
	ref1080ca9d.vendorID, cvendorID_allocs = (C.uint32_t)(x.VendorID), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cvendorID_allocs)

	var cdeviceID_allocs *cgoAllocMap
	ref1080ca9d.deviceID, cdeviceID_allocs = (C.uint32_t)(x.DeviceID), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdeviceID_allocs)

	var cdeviceType_allocs *cgoAllocMap
	ref1080ca9d.deviceType, cdeviceType_allocs = (C.VkPhysicalDeviceType)(x.DeviceType), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdeviceType_allocs)

	var cdeviceName_allocs *cgoAllocMap
	ref1080ca9d.deviceName, cdeviceName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.DeviceName)), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdeviceName_allocs)

	var cpipelineCacheUUID_allocs *cgoAllocMap
	ref1080ca9d.pipelineCacheUUID, cpipelineCacheUUID_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.PipelineCacheUUID)), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cpipelineCacheUUID_allocs)

	var climits_allocs *cgoAllocMap
	ref1080ca9d.limits, climits_allocs = x.Limits.PassValue()
	allocs1080ca9d.Borrow(climits_allocs)

	var csparseProperties_allocs *cgoAllocMap
	ref1080ca9d.sparseProperties, csparseProperties_allocs = x.SparseProperties.PassValue()
	allocs1080ca9d.Borrow(csparseProperties_allocs)

	x.ref1080ca9d = ref1080ca9d
	x.allocs1080ca9d = allocs1080ca9d
	return ref1080ca9d, allocs1080ca9d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProperties) PassValue() (C.VkPhysicalDeviceProperties, *cgoAllocMap) {
	if x.ref1080ca9d != nil {
		return *x.ref1080ca9d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProperties) Deref() {
	if x.ref1080ca9d == nil {
		return
	}
	x.ApiVersion = (uint32)(x.ref1080ca9d.apiVersion)
	x.DriverVersion = (uint32)(x.ref1080ca9d.driverVersion)
	x.VendorID = (uint32)(x.ref1080ca9d.vendorID)
	x.DeviceID = (uint32)(x.ref1080ca9d.deviceID)
	x.DeviceType = (PhysicalDeviceType)(x.ref1080ca9d.deviceType)
	x.DeviceName = *(*[256]byte)(unsafe.Pointer(&x.ref1080ca9d.deviceName))
	x.PipelineCacheUUID = *(*[16]byte)(unsafe.Pointer(&x.ref1080ca9d.pipelineCacheUUID))
	x.Limits = *NewPhysicalDeviceLimitsRef(unsafe.Pointer(&x.ref1080ca9d.limits))
	x.SparseProperties = *NewPhysicalDeviceSparsePropertiesRef(unsafe.Pointer(&x.ref1080ca9d.sparseProperties))
}

// allocQueueFamilyPropertiesMemory allocates memory for type C.VkQueueFamilyProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueueFamilyPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueueFamilyPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfQueueFamilyPropertiesValue = unsafe.Sizeof([1]C.VkQueueFamilyProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueueFamilyProperties) Ref() *C.VkQueueFamilyProperties {
	if x == nil {
		return nil
	}
	return x.refd538c446
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueueFamilyProperties) Free() {
	if x != nil && x.allocsd538c446 != nil {
		x.allocsd538c446.(*cgoAllocMap).Free()
		x.refd538c446 = nil
	}
}

// NewQueueFamilyPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueueFamilyPropertiesRef(ref unsafe.Pointer) *QueueFamilyProperties {
	if ref == nil {
		return nil
	}
	obj := new(QueueFamilyProperties)
	obj.refd538c446 = (*C.VkQueueFamilyProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueueFamilyProperties) PassRef() (*C.VkQueueFamilyProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd538c446 != nil {
		return x.refd538c446, nil
	}
	memd538c446 := allocQueueFamilyPropertiesMemory(1)
	refd538c446 := (*C.VkQueueFamilyProperties)(memd538c446)
	allocsd538c446 := new(cgoAllocMap)
	allocsd538c446.Add(memd538c446)

	var cqueueFlags_allocs *cgoAllocMap
	refd538c446.queueFlags, cqueueFlags_allocs = (C.VkQueueFlags)(x.QueueFlags), cgoAllocsUnknown
	allocsd538c446.Borrow(cqueueFlags_allocs)

	var cqueueCount_allocs *cgoAllocMap
	refd538c446.queueCount, cqueueCount_allocs = (C.uint32_t)(x.QueueCount), cgoAllocsUnknown
	allocsd538c446.Borrow(cqueueCount_allocs)

	var ctimestampValidBits_allocs *cgoAllocMap
	refd538c446.timestampValidBits, ctimestampValidBits_allocs = (C.uint32_t)(x.TimestampValidBits), cgoAllocsUnknown
	allocsd538c446.Borrow(ctimestampValidBits_allocs)

	var cminImageTransferGranularity_allocs *cgoAllocMap
	refd538c446.minImageTransferGranularity, cminImageTransferGranularity_allocs = x.MinImageTransferGranularity.PassValue()
	allocsd538c446.Borrow(cminImageTransferGranularity_allocs)

	x.refd538c446 = refd538c446
	x.allocsd538c446 = allocsd538c446
	return refd538c446, allocsd538c446

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueueFamilyProperties) PassValue() (C.VkQueueFamilyProperties, *cgoAllocMap) {
	if x.refd538c446 != nil {
		return *x.refd538c446, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueueFamilyProperties) Deref() {
	if x.refd538c446 == nil {
		return
	}
	x.QueueFlags = (QueueFlags)(x.refd538c446.queueFlags)
	x.QueueCount = (uint32)(x.refd538c446.queueCount)
	x.TimestampValidBits = (uint32)(x.refd538c446.timestampValidBits)
	x.MinImageTransferGranularity = *NewExtent3DRef(unsafe.Pointer(&x.refd538c446.minImageTransferGranularity))
}

// allocDeviceQueueCreateInfoMemory allocates memory for type C.VkDeviceQueueCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceQueueCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceQueueCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceQueueCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceQueueCreateInfo{})

// copyPFloatBytes copies the data from Go slice as *C.float.
func copyPFloatBytes(slice *sliceHeader) (*C.float, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfFloatValue) * slice.Len,
		Cap:  int(sizeOfFloatValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.float)(mem0), allocs
}

// allocFloatMemory allocates memory for type C.float in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFloatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFloatValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFloatValue = unsafe.Sizeof([1]C.float{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceQueueCreateInfo) Ref() *C.VkDeviceQueueCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref6087b30d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceQueueCreateInfo) Free() {
	if x != nil && x.allocs6087b30d != nil {
		x.allocs6087b30d.(*cgoAllocMap).Free()
		x.ref6087b30d = nil
	}
}

// NewDeviceQueueCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceQueueCreateInfoRef(ref unsafe.Pointer) *DeviceQueueCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceQueueCreateInfo)
	obj.ref6087b30d = (*C.VkDeviceQueueCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceQueueCreateInfo) PassRef() (*C.VkDeviceQueueCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6087b30d != nil {
		return x.ref6087b30d, nil
	}
	mem6087b30d := allocDeviceQueueCreateInfoMemory(1)
	ref6087b30d := (*C.VkDeviceQueueCreateInfo)(mem6087b30d)
	allocs6087b30d := new(cgoAllocMap)
	allocs6087b30d.Add(mem6087b30d)

	var csType_allocs *cgoAllocMap
	ref6087b30d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6087b30d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6087b30d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6087b30d.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref6087b30d.flags, cflags_allocs = (C.VkDeviceQueueCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs6087b30d.Borrow(cflags_allocs)

	var cqueueFamilyIndex_allocs *cgoAllocMap
	ref6087b30d.queueFamilyIndex, cqueueFamilyIndex_allocs = (C.uint32_t)(x.QueueFamilyIndex), cgoAllocsUnknown
	allocs6087b30d.Borrow(cqueueFamilyIndex_allocs)

	var cqueueCount_allocs *cgoAllocMap
	ref6087b30d.queueCount, cqueueCount_allocs = (C.uint32_t)(x.QueueCount), cgoAllocsUnknown
	allocs6087b30d.Borrow(cqueueCount_allocs)

	var cpQueuePriorities_allocs *cgoAllocMap
	ref6087b30d.pQueuePriorities, cpQueuePriorities_allocs = copyPFloatBytes((*sliceHeader)(unsafe.Pointer(&x.PQueuePriorities)))
	allocs6087b30d.Borrow(cpQueuePriorities_allocs)

	x.ref6087b30d = ref6087b30d
	x.allocs6087b30d = allocs6087b30d
	return ref6087b30d, allocs6087b30d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceQueueCreateInfo) PassValue() (C.VkDeviceQueueCreateInfo, *cgoAllocMap) {
	if x.ref6087b30d != nil {
		return *x.ref6087b30d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceQueueCreateInfo) Deref() {
	if x.ref6087b30d == nil {
		return
	}
	x.SType = (StructureType)(x.ref6087b30d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6087b30d.pNext))
	x.Flags = (DeviceQueueCreateFlags)(x.ref6087b30d.flags)
	x.QueueFamilyIndex = (uint32)(x.ref6087b30d.queueFamilyIndex)
	x.QueueCount = (uint32)(x.ref6087b30d.queueCount)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.PQueuePriorities))
	hxfc4425b.Data = unsafe.Pointer(x.ref6087b30d.pQueuePriorities)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

}

// allocDeviceCreateInfoMemory allocates memory for type C.VkDeviceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceCreateInfo{})

// unpackSDeviceQueueCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSDeviceQueueCreateInfo(x []DeviceQueueCreateInfo) (unpacked *C.VkDeviceQueueCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDeviceQueueCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDeviceQueueCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDeviceQueueCreateInfo)(h.Data)
	return
}

// unpackSPhysicalDeviceFeatures transforms a sliced Go data structure into plain C format.
func unpackSPhysicalDeviceFeatures(x []PhysicalDeviceFeatures) (unpacked *C.VkPhysicalDeviceFeatures, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceFeaturesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceFeatures)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceFeatures)(h.Data)
	return
}

// packSDeviceQueueCreateInfo reads sliced Go data structure out from plain C format.
func packSDeviceQueueCreateInfo(v []DeviceQueueCreateInfo, ptr0 *C.VkDeviceQueueCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDeviceQueueCreateInfoValue]C.VkDeviceQueueCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDeviceQueueCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPhysicalDeviceFeatures reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceFeatures(v []PhysicalDeviceFeatures, ptr0 *C.VkPhysicalDeviceFeatures) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceFeaturesValue]C.VkPhysicalDeviceFeatures)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceFeaturesRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceCreateInfo) Ref() *C.VkDeviceCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc0d8b997
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceCreateInfo) Free() {
	if x != nil && x.allocsc0d8b997 != nil {
		x.allocsc0d8b997.(*cgoAllocMap).Free()
		x.refc0d8b997 = nil
	}
}

// NewDeviceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceCreateInfoRef(ref unsafe.Pointer) *DeviceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceCreateInfo)
	obj.refc0d8b997 = (*C.VkDeviceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceCreateInfo) PassRef() (*C.VkDeviceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0d8b997 != nil {
		return x.refc0d8b997, nil
	}
	memc0d8b997 := allocDeviceCreateInfoMemory(1)
	refc0d8b997 := (*C.VkDeviceCreateInfo)(memc0d8b997)
	allocsc0d8b997 := new(cgoAllocMap)
	allocsc0d8b997.Add(memc0d8b997)

	var csType_allocs *cgoAllocMap
	refc0d8b997.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc0d8b997.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc0d8b997.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc0d8b997.flags, cflags_allocs = (C.VkDeviceCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cflags_allocs)

	var cqueueCreateInfoCount_allocs *cgoAllocMap
	refc0d8b997.queueCreateInfoCount, cqueueCreateInfoCount_allocs = (C.uint32_t)(x.QueueCreateInfoCount), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cqueueCreateInfoCount_allocs)

	var cpQueueCreateInfos_allocs *cgoAllocMap
	refc0d8b997.pQueueCreateInfos, cpQueueCreateInfos_allocs = unpackSDeviceQueueCreateInfo(x.PQueueCreateInfos)
	allocsc0d8b997.Borrow(cpQueueCreateInfos_allocs)

	var cenabledLayerCount_allocs *cgoAllocMap
	refc0d8b997.enabledLayerCount, cenabledLayerCount_allocs = (C.uint32_t)(x.EnabledLayerCount), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cenabledLayerCount_allocs)

	var cppEnabledLayerNames_allocs *cgoAllocMap
	refc0d8b997.ppEnabledLayerNames, cppEnabledLayerNames_allocs = unpackSString(x.PpEnabledLayerNames)
	allocsc0d8b997.Borrow(cppEnabledLayerNames_allocs)

	var cenabledExtensionCount_allocs *cgoAllocMap
	refc0d8b997.enabledExtensionCount, cenabledExtensionCount_allocs = (C.uint32_t)(x.EnabledExtensionCount), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cenabledExtensionCount_allocs)

	var cppEnabledExtensionNames_allocs *cgoAllocMap
	refc0d8b997.ppEnabledExtensionNames, cppEnabledExtensionNames_allocs = unpackSString(x.PpEnabledExtensionNames)
	allocsc0d8b997.Borrow(cppEnabledExtensionNames_allocs)

	var cpEnabledFeatures_allocs *cgoAllocMap
	refc0d8b997.pEnabledFeatures, cpEnabledFeatures_allocs = unpackSPhysicalDeviceFeatures(x.PEnabledFeatures)
	allocsc0d8b997.Borrow(cpEnabledFeatures_allocs)

	x.refc0d8b997 = refc0d8b997
	x.allocsc0d8b997 = allocsc0d8b997
	return refc0d8b997, allocsc0d8b997

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceCreateInfo) PassValue() (C.VkDeviceCreateInfo, *cgoAllocMap) {
	if x.refc0d8b997 != nil {
		return *x.refc0d8b997, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceCreateInfo) Deref() {
	if x.refc0d8b997 == nil {
		return
	}
	x.SType = (StructureType)(x.refc0d8b997.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc0d8b997.pNext))
	x.Flags = (DeviceCreateFlags)(x.refc0d8b997.flags)
	x.QueueCreateInfoCount = (uint32)(x.refc0d8b997.queueCreateInfoCount)
	packSDeviceQueueCreateInfo(x.PQueueCreateInfos, x.refc0d8b997.pQueueCreateInfos)
	x.EnabledLayerCount = (uint32)(x.refc0d8b997.enabledLayerCount)
	packSString(x.PpEnabledLayerNames, x.refc0d8b997.ppEnabledLayerNames)
	x.EnabledExtensionCount = (uint32)(x.refc0d8b997.enabledExtensionCount)
	packSString(x.PpEnabledExtensionNames, x.refc0d8b997.ppEnabledExtensionNames)
	packSPhysicalDeviceFeatures(x.PEnabledFeatures, x.refc0d8b997.pEnabledFeatures)
}

// allocExtensionPropertiesMemory allocates memory for type C.VkExtensionProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExtensionPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExtensionPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExtensionPropertiesValue = unsafe.Sizeof([1]C.VkExtensionProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExtensionProperties) Ref() *C.VkExtensionProperties {
	if x == nil {
		return nil
	}
	return x.ref2f001956
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExtensionProperties) Free() {
	if x != nil && x.allocs2f001956 != nil {
		x.allocs2f001956.(*cgoAllocMap).Free()
		x.ref2f001956 = nil
	}
}

// NewExtensionPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExtensionPropertiesRef(ref unsafe.Pointer) *ExtensionProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExtensionProperties)
	obj.ref2f001956 = (*C.VkExtensionProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExtensionProperties) PassRef() (*C.VkExtensionProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f001956 != nil {
		return x.ref2f001956, nil
	}
	mem2f001956 := allocExtensionPropertiesMemory(1)
	ref2f001956 := (*C.VkExtensionProperties)(mem2f001956)
	allocs2f001956 := new(cgoAllocMap)
	allocs2f001956.Add(mem2f001956)

	var cextensionName_allocs *cgoAllocMap
	ref2f001956.extensionName, cextensionName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.ExtensionName)), cgoAllocsUnknown
	allocs2f001956.Borrow(cextensionName_allocs)

	var cspecVersion_allocs *cgoAllocMap
	ref2f001956.specVersion, cspecVersion_allocs = (C.uint32_t)(x.SpecVersion), cgoAllocsUnknown
	allocs2f001956.Borrow(cspecVersion_allocs)

	x.ref2f001956 = ref2f001956
	x.allocs2f001956 = allocs2f001956
	return ref2f001956, allocs2f001956

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExtensionProperties) PassValue() (C.VkExtensionProperties, *cgoAllocMap) {
	if x.ref2f001956 != nil {
		return *x.ref2f001956, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExtensionProperties) Deref() {
	if x.ref2f001956 == nil {
		return
	}
	x.ExtensionName = *(*[256]byte)(unsafe.Pointer(&x.ref2f001956.extensionName))
	x.SpecVersion = (uint32)(x.ref2f001956.specVersion)
}

// allocLayerPropertiesMemory allocates memory for type C.VkLayerProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLayerPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLayerPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLayerPropertiesValue = unsafe.Sizeof([1]C.VkLayerProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LayerProperties) Ref() *C.VkLayerProperties {
	if x == nil {
		return nil
	}
	return x.refd9407ce7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LayerProperties) Free() {
	if x != nil && x.allocsd9407ce7 != nil {
		x.allocsd9407ce7.(*cgoAllocMap).Free()
		x.refd9407ce7 = nil
	}
}

// NewLayerPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLayerPropertiesRef(ref unsafe.Pointer) *LayerProperties {
	if ref == nil {
		return nil
	}
	obj := new(LayerProperties)
	obj.refd9407ce7 = (*C.VkLayerProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LayerProperties) PassRef() (*C.VkLayerProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9407ce7 != nil {
		return x.refd9407ce7, nil
	}
	memd9407ce7 := allocLayerPropertiesMemory(1)
	refd9407ce7 := (*C.VkLayerProperties)(memd9407ce7)
	allocsd9407ce7 := new(cgoAllocMap)
	allocsd9407ce7.Add(memd9407ce7)

	var clayerName_allocs *cgoAllocMap
	refd9407ce7.layerName, clayerName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.LayerName)), cgoAllocsUnknown
	allocsd9407ce7.Borrow(clayerName_allocs)

	var cspecVersion_allocs *cgoAllocMap
	refd9407ce7.specVersion, cspecVersion_allocs = (C.uint32_t)(x.SpecVersion), cgoAllocsUnknown
	allocsd9407ce7.Borrow(cspecVersion_allocs)

	var cimplementationVersion_allocs *cgoAllocMap
	refd9407ce7.implementationVersion, cimplementationVersion_allocs = (C.uint32_t)(x.ImplementationVersion), cgoAllocsUnknown
	allocsd9407ce7.Borrow(cimplementationVersion_allocs)

	var cdescription_allocs *cgoAllocMap
	refd9407ce7.description, cdescription_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Description)), cgoAllocsUnknown
	allocsd9407ce7.Borrow(cdescription_allocs)

	x.refd9407ce7 = refd9407ce7
	x.allocsd9407ce7 = allocsd9407ce7
	return refd9407ce7, allocsd9407ce7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LayerProperties) PassValue() (C.VkLayerProperties, *cgoAllocMap) {
	if x.refd9407ce7 != nil {
		return *x.refd9407ce7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LayerProperties) Deref() {
	if x.refd9407ce7 == nil {
		return
	}
	x.LayerName = *(*[256]byte)(unsafe.Pointer(&x.refd9407ce7.layerName))
	x.SpecVersion = (uint32)(x.refd9407ce7.specVersion)
	x.ImplementationVersion = (uint32)(x.refd9407ce7.implementationVersion)
	x.Description = *(*[256]byte)(unsafe.Pointer(&x.refd9407ce7.description))
}

// allocSubmitInfoMemory allocates memory for type C.VkSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubmitInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubmitInfoValue = unsafe.Sizeof([1]C.VkSubmitInfo{})

// copyPSemaphoreBytes copies the data from Go slice as *C.VkSemaphore.
func copyPSemaphoreBytes(slice *sliceHeader) (*C.VkSemaphore, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSemaphoreValue) * slice.Len,
		Cap:  int(sizeOfSemaphoreValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSemaphore)(mem0), allocs
}

// allocSemaphoreMemory allocates memory for type C.VkSemaphore in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSemaphoreValue = unsafe.Sizeof([1]C.VkSemaphore{})

// copyPPipelineStageFlagsBytes copies the data from Go slice as *C.VkPipelineStageFlags.
func copyPPipelineStageFlagsBytes(slice *sliceHeader) (*C.VkPipelineStageFlags, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPipelineStageFlagsValue) * slice.Len,
		Cap:  int(sizeOfPipelineStageFlagsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkPipelineStageFlags)(mem0), allocs
}

// allocPipelineStageFlagsMemory allocates memory for type C.VkPipelineStageFlags in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineStageFlagsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineStageFlagsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineStageFlagsValue = unsafe.Sizeof([1]C.VkPipelineStageFlags{})

// copyPCommandBufferBytes copies the data from Go slice as *C.VkCommandBuffer.
func copyPCommandBufferBytes(slice *sliceHeader) (*C.VkCommandBuffer, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCommandBufferValue) * slice.Len,
		Cap:  int(sizeOfCommandBufferValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkCommandBuffer)(mem0), allocs
}

// allocCommandBufferMemory allocates memory for type C.VkCommandBuffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCommandBufferValue = unsafe.Sizeof([1]C.VkCommandBuffer{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubmitInfo) Ref() *C.VkSubmitInfo {
	if x == nil {
		return nil
	}
	return x.ref22884025
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubmitInfo) Free() {
	if x != nil && x.allocs22884025 != nil {
		x.allocs22884025.(*cgoAllocMap).Free()
		x.ref22884025 = nil
	}
}

// NewSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubmitInfoRef(ref unsafe.Pointer) *SubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(SubmitInfo)
	obj.ref22884025 = (*C.VkSubmitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubmitInfo) PassRef() (*C.VkSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref22884025 != nil {
		return x.ref22884025, nil
	}
	mem22884025 := allocSubmitInfoMemory(1)
	ref22884025 := (*C.VkSubmitInfo)(mem22884025)
	allocs22884025 := new(cgoAllocMap)
	allocs22884025.Add(mem22884025)

	var csType_allocs *cgoAllocMap
	ref22884025.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs22884025.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref22884025.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs22884025.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	ref22884025.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocs22884025.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphores_allocs *cgoAllocMap
	ref22884025.pWaitSemaphores, cpWaitSemaphores_allocs = copyPSemaphoreBytes((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)))
	allocs22884025.Borrow(cpWaitSemaphores_allocs)

	var cpWaitDstStageMask_allocs *cgoAllocMap
	ref22884025.pWaitDstStageMask, cpWaitDstStageMask_allocs = copyPPipelineStageFlagsBytes((*sliceHeader)(unsafe.Pointer(&x.PWaitDstStageMask)))
	allocs22884025.Borrow(cpWaitDstStageMask_allocs)

	var ccommandBufferCount_allocs *cgoAllocMap
	ref22884025.commandBufferCount, ccommandBufferCount_allocs = (C.uint32_t)(x.CommandBufferCount), cgoAllocsUnknown
	allocs22884025.Borrow(ccommandBufferCount_allocs)

	var cpCommandBuffers_allocs *cgoAllocMap
	ref22884025.pCommandBuffers, cpCommandBuffers_allocs = copyPCommandBufferBytes((*sliceHeader)(unsafe.Pointer(&x.PCommandBuffers)))
	allocs22884025.Borrow(cpCommandBuffers_allocs)

	var csignalSemaphoreCount_allocs *cgoAllocMap
	ref22884025.signalSemaphoreCount, csignalSemaphoreCount_allocs = (C.uint32_t)(x.SignalSemaphoreCount), cgoAllocsUnknown
	allocs22884025.Borrow(csignalSemaphoreCount_allocs)

	var cpSignalSemaphores_allocs *cgoAllocMap
	ref22884025.pSignalSemaphores, cpSignalSemaphores_allocs = copyPSemaphoreBytes((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores)))
	allocs22884025.Borrow(cpSignalSemaphores_allocs)

	x.ref22884025 = ref22884025
	x.allocs22884025 = allocs22884025
	return ref22884025, allocs22884025

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubmitInfo) PassValue() (C.VkSubmitInfo, *cgoAllocMap) {
	if x.ref22884025 != nil {
		return *x.ref22884025, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubmitInfo) Deref() {
	if x.ref22884025 == nil {
		return
	}
	x.SType = (StructureType)(x.ref22884025.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref22884025.pNext))
	x.WaitSemaphoreCount = (uint32)(x.ref22884025.waitSemaphoreCount)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxf95e7c8.Data = unsafe.Pointer(x.ref22884025.pWaitSemaphores)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.PWaitDstStageMask))
	hxff2234b.Data = unsafe.Pointer(x.ref22884025.pWaitDstStageMask)
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	x.CommandBufferCount = (uint32)(x.ref22884025.commandBufferCount)
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.PCommandBuffers))
	hxff73280.Data = unsafe.Pointer(x.ref22884025.pCommandBuffers)
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	x.SignalSemaphoreCount = (uint32)(x.ref22884025.signalSemaphoreCount)
	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores))
	hxfa9955c.Data = unsafe.Pointer(x.ref22884025.pSignalSemaphores)
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ?

}

// allocMappedMemoryRangeMemory allocates memory for type C.VkMappedMemoryRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMappedMemoryRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMappedMemoryRangeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMappedMemoryRangeValue = unsafe.Sizeof([1]C.VkMappedMemoryRange{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MappedMemoryRange) Ref() *C.VkMappedMemoryRange {
	if x == nil {
		return nil
	}
	return x.ref42a37320
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MappedMemoryRange) Free() {
	if x != nil && x.allocs42a37320 != nil {
		x.allocs42a37320.(*cgoAllocMap).Free()
		x.ref42a37320 = nil
	}
}

// NewMappedMemoryRangeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMappedMemoryRangeRef(ref unsafe.Pointer) *MappedMemoryRange {
	if ref == nil {
		return nil
	}
	obj := new(MappedMemoryRange)
	obj.ref42a37320 = (*C.VkMappedMemoryRange)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MappedMemoryRange) PassRef() (*C.VkMappedMemoryRange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref42a37320 != nil {
		return x.ref42a37320, nil
	}
	mem42a37320 := allocMappedMemoryRangeMemory(1)
	ref42a37320 := (*C.VkMappedMemoryRange)(mem42a37320)
	allocs42a37320 := new(cgoAllocMap)
	allocs42a37320.Add(mem42a37320)

	var csType_allocs *cgoAllocMap
	ref42a37320.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs42a37320.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref42a37320.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs42a37320.Borrow(cpNext_allocs)

	var cmemory_allocs *cgoAllocMap
	ref42a37320.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs42a37320.Borrow(cmemory_allocs)

	var coffset_allocs *cgoAllocMap
	ref42a37320.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs42a37320.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref42a37320.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs42a37320.Borrow(csize_allocs)

	x.ref42a37320 = ref42a37320
	x.allocs42a37320 = allocs42a37320
	return ref42a37320, allocs42a37320

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MappedMemoryRange) PassValue() (C.VkMappedMemoryRange, *cgoAllocMap) {
	if x.ref42a37320 != nil {
		return *x.ref42a37320, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MappedMemoryRange) Deref() {
	if x.ref42a37320 == nil {
		return
	}
	x.SType = (StructureType)(x.ref42a37320.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref42a37320.pNext))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref42a37320.memory))
	x.Offset = (DeviceSize)(x.ref42a37320.offset)
	x.Size = (DeviceSize)(x.ref42a37320.size)
}

// allocMemoryAllocateInfoMemory allocates memory for type C.VkMemoryAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryAllocateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryAllocateInfoValue = unsafe.Sizeof([1]C.VkMemoryAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryAllocateInfo) Ref() *C.VkMemoryAllocateInfo {
	if x == nil {
		return nil
	}
	return x.ref31032b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryAllocateInfo) Free() {
	if x != nil && x.allocs31032b != nil {
		x.allocs31032b.(*cgoAllocMap).Free()
		x.ref31032b = nil
	}
}

// NewMemoryAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryAllocateInfoRef(ref unsafe.Pointer) *MemoryAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(MemoryAllocateInfo)
	obj.ref31032b = (*C.VkMemoryAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryAllocateInfo) PassRef() (*C.VkMemoryAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref31032b != nil {
		return x.ref31032b, nil
	}
	mem31032b := allocMemoryAllocateInfoMemory(1)
	ref31032b := (*C.VkMemoryAllocateInfo)(mem31032b)
	allocs31032b := new(cgoAllocMap)
	allocs31032b.Add(mem31032b)

	var csType_allocs *cgoAllocMap
	ref31032b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs31032b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref31032b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs31032b.Borrow(cpNext_allocs)

	var callocationSize_allocs *cgoAllocMap
	ref31032b.allocationSize, callocationSize_allocs = (C.VkDeviceSize)(x.AllocationSize), cgoAllocsUnknown
	allocs31032b.Borrow(callocationSize_allocs)

	var cmemoryTypeIndex_allocs *cgoAllocMap
	ref31032b.memoryTypeIndex, cmemoryTypeIndex_allocs = (C.uint32_t)(x.MemoryTypeIndex), cgoAllocsUnknown
	allocs31032b.Borrow(cmemoryTypeIndex_allocs)

	x.ref31032b = ref31032b
	x.allocs31032b = allocs31032b
	return ref31032b, allocs31032b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryAllocateInfo) PassValue() (C.VkMemoryAllocateInfo, *cgoAllocMap) {
	if x.ref31032b != nil {
		return *x.ref31032b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryAllocateInfo) Deref() {
	if x.ref31032b == nil {
		return
	}
	x.SType = (StructureType)(x.ref31032b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref31032b.pNext))
	x.AllocationSize = (DeviceSize)(x.ref31032b.allocationSize)
	x.MemoryTypeIndex = (uint32)(x.ref31032b.memoryTypeIndex)
}

// allocMemoryRequirementsMemory allocates memory for type C.VkMemoryRequirements in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryRequirementsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryRequirementsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryRequirementsValue = unsafe.Sizeof([1]C.VkMemoryRequirements{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryRequirements) Ref() *C.VkMemoryRequirements {
	if x == nil {
		return nil
	}
	return x.ref5259fc6b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryRequirements) Free() {
	if x != nil && x.allocs5259fc6b != nil {
		x.allocs5259fc6b.(*cgoAllocMap).Free()
		x.ref5259fc6b = nil
	}
}

// NewMemoryRequirementsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryRequirementsRef(ref unsafe.Pointer) *MemoryRequirements {
	if ref == nil {
		return nil
	}
	obj := new(MemoryRequirements)
	obj.ref5259fc6b = (*C.VkMemoryRequirements)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryRequirements) PassRef() (*C.VkMemoryRequirements, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5259fc6b != nil {
		return x.ref5259fc6b, nil
	}
	mem5259fc6b := allocMemoryRequirementsMemory(1)
	ref5259fc6b := (*C.VkMemoryRequirements)(mem5259fc6b)
	allocs5259fc6b := new(cgoAllocMap)
	allocs5259fc6b.Add(mem5259fc6b)

	var csize_allocs *cgoAllocMap
	ref5259fc6b.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs5259fc6b.Borrow(csize_allocs)

	var calignment_allocs *cgoAllocMap
	ref5259fc6b.alignment, calignment_allocs = (C.VkDeviceSize)(x.Alignment), cgoAllocsUnknown
	allocs5259fc6b.Borrow(calignment_allocs)

	var cmemoryTypeBits_allocs *cgoAllocMap
	ref5259fc6b.memoryTypeBits, cmemoryTypeBits_allocs = (C.uint32_t)(x.MemoryTypeBits), cgoAllocsUnknown
	allocs5259fc6b.Borrow(cmemoryTypeBits_allocs)

	x.ref5259fc6b = ref5259fc6b
	x.allocs5259fc6b = allocs5259fc6b
	return ref5259fc6b, allocs5259fc6b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryRequirements) PassValue() (C.VkMemoryRequirements, *cgoAllocMap) {
	if x.ref5259fc6b != nil {
		return *x.ref5259fc6b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryRequirements) Deref() {
	if x.ref5259fc6b == nil {
		return
	}
	x.Size = (DeviceSize)(x.ref5259fc6b.size)
	x.Alignment = (DeviceSize)(x.ref5259fc6b.alignment)
	x.MemoryTypeBits = (uint32)(x.ref5259fc6b.memoryTypeBits)
}

// allocSparseMemoryBindMemory allocates memory for type C.VkSparseMemoryBind in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseMemoryBindMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseMemoryBindValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSparseMemoryBindValue = unsafe.Sizeof([1]C.VkSparseMemoryBind{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseMemoryBind) Ref() *C.VkSparseMemoryBind {
	if x == nil {
		return nil
	}
	return x.ref5bf418e8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseMemoryBind) Free() {
	if x != nil && x.allocs5bf418e8 != nil {
		x.allocs5bf418e8.(*cgoAllocMap).Free()
		x.ref5bf418e8 = nil
	}
}

// NewSparseMemoryBindRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseMemoryBindRef(ref unsafe.Pointer) *SparseMemoryBind {
	if ref == nil {
		return nil
	}
	obj := new(SparseMemoryBind)
	obj.ref5bf418e8 = (*C.VkSparseMemoryBind)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseMemoryBind) PassRef() (*C.VkSparseMemoryBind, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5bf418e8 != nil {
		return x.ref5bf418e8, nil
	}
	mem5bf418e8 := allocSparseMemoryBindMemory(1)
	ref5bf418e8 := (*C.VkSparseMemoryBind)(mem5bf418e8)
	allocs5bf418e8 := new(cgoAllocMap)
	allocs5bf418e8.Add(mem5bf418e8)

	var cresourceOffset_allocs *cgoAllocMap
	ref5bf418e8.resourceOffset, cresourceOffset_allocs = (C.VkDeviceSize)(x.ResourceOffset), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cresourceOffset_allocs)

	var csize_allocs *cgoAllocMap
	ref5bf418e8.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs5bf418e8.Borrow(csize_allocs)

	var cmemory_allocs *cgoAllocMap
	ref5bf418e8.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	ref5bf418e8.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cmemoryOffset_allocs)

	var cflags_allocs *cgoAllocMap
	ref5bf418e8.flags, cflags_allocs = (C.VkSparseMemoryBindFlags)(x.Flags), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cflags_allocs)

	x.ref5bf418e8 = ref5bf418e8
	x.allocs5bf418e8 = allocs5bf418e8
	return ref5bf418e8, allocs5bf418e8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseMemoryBind) PassValue() (C.VkSparseMemoryBind, *cgoAllocMap) {
	if x.ref5bf418e8 != nil {
		return *x.ref5bf418e8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseMemoryBind) Deref() {
	if x.ref5bf418e8 == nil {
		return
	}
	x.ResourceOffset = (DeviceSize)(x.ref5bf418e8.resourceOffset)
	x.Size = (DeviceSize)(x.ref5bf418e8.size)
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref5bf418e8.memory))
	x.MemoryOffset = (DeviceSize)(x.ref5bf418e8.memoryOffset)
	x.Flags = (SparseMemoryBindFlags)(x.ref5bf418e8.flags)
}

// allocSparseBufferMemoryBindInfoMemory allocates memory for type C.VkSparseBufferMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseBufferMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseBufferMemoryBindInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSparseBufferMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseBufferMemoryBindInfo{})

// unpackSSparseMemoryBind transforms a sliced Go data structure into plain C format.
func unpackSSparseMemoryBind(x []SparseMemoryBind) (unpacked *C.VkSparseMemoryBind, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSparseMemoryBindMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseMemoryBind)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseMemoryBind)(h.Data)
	return
}

// packSSparseMemoryBind reads sliced Go data structure out from plain C format.
func packSSparseMemoryBind(v []SparseMemoryBind, ptr0 *C.VkSparseMemoryBind) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseMemoryBindValue]C.VkSparseMemoryBind)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseMemoryBindRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseBufferMemoryBindInfo) Ref() *C.VkSparseBufferMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.refebcaf40c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseBufferMemoryBindInfo) Free() {
	if x != nil && x.allocsebcaf40c != nil {
		x.allocsebcaf40c.(*cgoAllocMap).Free()
		x.refebcaf40c = nil
	}
}

// NewSparseBufferMemoryBindInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseBufferMemoryBindInfoRef(ref unsafe.Pointer) *SparseBufferMemoryBindInfo {
	if ref == nil {
		return nil
	}
	obj := new(SparseBufferMemoryBindInfo)
	obj.refebcaf40c = (*C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseBufferMemoryBindInfo) PassRef() (*C.VkSparseBufferMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refebcaf40c != nil {
		return x.refebcaf40c, nil
	}
	memebcaf40c := allocSparseBufferMemoryBindInfoMemory(1)
	refebcaf40c := (*C.VkSparseBufferMemoryBindInfo)(memebcaf40c)
	allocsebcaf40c := new(cgoAllocMap)
	allocsebcaf40c.Add(memebcaf40c)

	var cbuffer_allocs *cgoAllocMap
	refebcaf40c.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsebcaf40c.Borrow(cbuffer_allocs)

	var cbindCount_allocs *cgoAllocMap
	refebcaf40c.bindCount, cbindCount_allocs = (C.uint32_t)(x.BindCount), cgoAllocsUnknown
	allocsebcaf40c.Borrow(cbindCount_allocs)

	var cpBinds_allocs *cgoAllocMap
	refebcaf40c.pBinds, cpBinds_allocs = unpackSSparseMemoryBind(x.PBinds)
	allocsebcaf40c.Borrow(cpBinds_allocs)

	x.refebcaf40c = refebcaf40c
	x.allocsebcaf40c = allocsebcaf40c
	return refebcaf40c, allocsebcaf40c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseBufferMemoryBindInfo) PassValue() (C.VkSparseBufferMemoryBindInfo, *cgoAllocMap) {
	if x.refebcaf40c != nil {
		return *x.refebcaf40c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseBufferMemoryBindInfo) Deref() {
	if x.refebcaf40c == nil {
		return
	}
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refebcaf40c.buffer))
	x.BindCount = (uint32)(x.refebcaf40c.bindCount)
	packSSparseMemoryBind(x.PBinds, x.refebcaf40c.pBinds)
}

// allocSparseImageOpaqueMemoryBindInfoMemory allocates memory for type C.VkSparseImageOpaqueMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageOpaqueMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageOpaqueMemoryBindInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSparseImageOpaqueMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseImageOpaqueMemoryBindInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageOpaqueMemoryBindInfo) Ref() *C.VkSparseImageOpaqueMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.reffb1b3d56
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageOpaqueMemoryBindInfo) Free() {
	if x != nil && x.allocsfb1b3d56 != nil {
		x.allocsfb1b3d56.(*cgoAllocMap).Free()
		x.reffb1b3d56 = nil
	}
}

// NewSparseImageOpaqueMemoryBindInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageOpaqueMemoryBindInfoRef(ref unsafe.Pointer) *SparseImageOpaqueMemoryBindInfo {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageOpaqueMemoryBindInfo)
	obj.reffb1b3d56 = (*C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageOpaqueMemoryBindInfo) PassRef() (*C.VkSparseImageOpaqueMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffb1b3d56 != nil {
		return x.reffb1b3d56, nil
	}
	memfb1b3d56 := allocSparseImageOpaqueMemoryBindInfoMemory(1)
	reffb1b3d56 := (*C.VkSparseImageOpaqueMemoryBindInfo)(memfb1b3d56)
	allocsfb1b3d56 := new(cgoAllocMap)
	allocsfb1b3d56.Add(memfb1b3d56)

	var cimage_allocs *cgoAllocMap
	reffb1b3d56.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocsfb1b3d56.Borrow(cimage_allocs)

	var cbindCount_allocs *cgoAllocMap
	reffb1b3d56.bindCount, cbindCount_allocs = (C.uint32_t)(x.BindCount), cgoAllocsUnknown
	allocsfb1b3d56.Borrow(cbindCount_allocs)

	var cpBinds_allocs *cgoAllocMap
	reffb1b3d56.pBinds, cpBinds_allocs = unpackSSparseMemoryBind(x.PBinds)
	allocsfb1b3d56.Borrow(cpBinds_allocs)

	x.reffb1b3d56 = reffb1b3d56
	x.allocsfb1b3d56 = allocsfb1b3d56
	return reffb1b3d56, allocsfb1b3d56

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageOpaqueMemoryBindInfo) PassValue() (C.VkSparseImageOpaqueMemoryBindInfo, *cgoAllocMap) {
	if x.reffb1b3d56 != nil {
		return *x.reffb1b3d56, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageOpaqueMemoryBindInfo) Deref() {
	if x.reffb1b3d56 == nil {
		return
	}
	x.Image = *(*Image)(unsafe.Pointer(&x.reffb1b3d56.image))
	x.BindCount = (uint32)(x.reffb1b3d56.bindCount)
	packSSparseMemoryBind(x.PBinds, x.reffb1b3d56.pBinds)
}

// allocImageSubresourceMemory allocates memory for type C.VkImageSubresource in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSubresourceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSubresourceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageSubresourceValue = unsafe.Sizeof([1]C.VkImageSubresource{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSubresource) Ref() *C.VkImageSubresource {
	if x == nil {
		return nil
	}
	return x.reffeaa0d8a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSubresource) Free() {
	if x != nil && x.allocsfeaa0d8a != nil {
		x.allocsfeaa0d8a.(*cgoAllocMap).Free()
		x.reffeaa0d8a = nil
	}
}

// NewImageSubresourceRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSubresourceRef(ref unsafe.Pointer) *ImageSubresource {
	if ref == nil {
		return nil
	}
	obj := new(ImageSubresource)
	obj.reffeaa0d8a = (*C.VkImageSubresource)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSubresource) PassRef() (*C.VkImageSubresource, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffeaa0d8a != nil {
		return x.reffeaa0d8a, nil
	}
	memfeaa0d8a := allocImageSubresourceMemory(1)
	reffeaa0d8a := (*C.VkImageSubresource)(memfeaa0d8a)
	allocsfeaa0d8a := new(cgoAllocMap)
	allocsfeaa0d8a.Add(memfeaa0d8a)

	var caspectMask_allocs *cgoAllocMap
	reffeaa0d8a.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocsfeaa0d8a.Borrow(caspectMask_allocs)

	var cmipLevel_allocs *cgoAllocMap
	reffeaa0d8a.mipLevel, cmipLevel_allocs = (C.uint32_t)(x.MipLevel), cgoAllocsUnknown
	allocsfeaa0d8a.Borrow(cmipLevel_allocs)

	var carrayLayer_allocs *cgoAllocMap
	reffeaa0d8a.arrayLayer, carrayLayer_allocs = (C.uint32_t)(x.ArrayLayer), cgoAllocsUnknown
	allocsfeaa0d8a.Borrow(carrayLayer_allocs)

	x.reffeaa0d8a = reffeaa0d8a
	x.allocsfeaa0d8a = allocsfeaa0d8a
	return reffeaa0d8a, allocsfeaa0d8a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSubresource) PassValue() (C.VkImageSubresource, *cgoAllocMap) {
	if x.reffeaa0d8a != nil {
		return *x.reffeaa0d8a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSubresource) Deref() {
	if x.reffeaa0d8a == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.reffeaa0d8a.aspectMask)
	x.MipLevel = (uint32)(x.reffeaa0d8a.mipLevel)
	x.ArrayLayer = (uint32)(x.reffeaa0d8a.arrayLayer)
}

// allocSparseImageMemoryBindMemory allocates memory for type C.VkSparseImageMemoryBind in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryBindMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryBindValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSparseImageMemoryBindValue = unsafe.Sizeof([1]C.VkSparseImageMemoryBind{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageMemoryBind) Ref() *C.VkSparseImageMemoryBind {
	if x == nil {
		return nil
	}
	return x.ref41b516d7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageMemoryBind) Free() {
	if x != nil && x.allocs41b516d7 != nil {
		x.allocs41b516d7.(*cgoAllocMap).Free()
		x.ref41b516d7 = nil
	}
}

// NewSparseImageMemoryBindRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageMemoryBindRef(ref unsafe.Pointer) *SparseImageMemoryBind {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryBind)
	obj.ref41b516d7 = (*C.VkSparseImageMemoryBind)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageMemoryBind) PassRef() (*C.VkSparseImageMemoryBind, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref41b516d7 != nil {
		return x.ref41b516d7, nil
	}
	mem41b516d7 := allocSparseImageMemoryBindMemory(1)
	ref41b516d7 := (*C.VkSparseImageMemoryBind)(mem41b516d7)
	allocs41b516d7 := new(cgoAllocMap)
	allocs41b516d7.Add(mem41b516d7)

	var csubresource_allocs *cgoAllocMap
	ref41b516d7.subresource, csubresource_allocs = x.Subresource.PassValue()
	allocs41b516d7.Borrow(csubresource_allocs)

	var coffset_allocs *cgoAllocMap
	ref41b516d7.offset, coffset_allocs = x.Offset.PassValue()
	allocs41b516d7.Borrow(coffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref41b516d7.extent, cextent_allocs = x.Extent.PassValue()
	allocs41b516d7.Borrow(cextent_allocs)

	var cmemory_allocs *cgoAllocMap
	ref41b516d7.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs41b516d7.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	ref41b516d7.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocs41b516d7.Borrow(cmemoryOffset_allocs)

	var cflags_allocs *cgoAllocMap
	ref41b516d7.flags, cflags_allocs = (C.VkSparseMemoryBindFlags)(x.Flags), cgoAllocsUnknown
	allocs41b516d7.Borrow(cflags_allocs)

	x.ref41b516d7 = ref41b516d7
	x.allocs41b516d7 = allocs41b516d7
	return ref41b516d7, allocs41b516d7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageMemoryBind) PassValue() (C.VkSparseImageMemoryBind, *cgoAllocMap) {
	if x.ref41b516d7 != nil {
		return *x.ref41b516d7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageMemoryBind) Deref() {
	if x.ref41b516d7 == nil {
		return
	}
	x.Subresource = *NewImageSubresourceRef(unsafe.Pointer(&x.ref41b516d7.subresource))
	x.Offset = *NewOffset3DRef(unsafe.Pointer(&x.ref41b516d7.offset))
	x.Extent = *NewExtent3DRef(unsafe.Pointer(&x.ref41b516d7.extent))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref41b516d7.memory))
	x.MemoryOffset = (DeviceSize)(x.ref41b516d7.memoryOffset)
	x.Flags = (SparseMemoryBindFlags)(x.ref41b516d7.flags)
}

// allocSparseImageMemoryBindInfoMemory allocates memory for type C.VkSparseImageMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryBindInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSparseImageMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseImageMemoryBindInfo{})

// unpackSSparseImageMemoryBind transforms a sliced Go data structure into plain C format.
func unpackSSparseImageMemoryBind(x []SparseImageMemoryBind) (unpacked *C.VkSparseImageMemoryBind, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryBindMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryBind)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryBind)(h.Data)
	return
}

// packSSparseImageMemoryBind reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryBind(v []SparseImageMemoryBind, ptr0 *C.VkSparseImageMemoryBind) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryBindValue]C.VkSparseImageMemoryBind)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryBindRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageMemoryBindInfo) Ref() *C.VkSparseImageMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.ref50faeb70
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageMemoryBindInfo) Free() {
	if x != nil && x.allocs50faeb70 != nil {
		x.allocs50faeb70.(*cgoAllocMap).Free()
		x.ref50faeb70 = nil
	}
}

// NewSparseImageMemoryBindInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageMemoryBindInfoRef(ref unsafe.Pointer) *SparseImageMemoryBindInfo {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryBindInfo)
	obj.ref50faeb70 = (*C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageMemoryBindInfo) PassRef() (*C.VkSparseImageMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref50faeb70 != nil {
		return x.ref50faeb70, nil
	}
	mem50faeb70 := allocSparseImageMemoryBindInfoMemory(1)
	ref50faeb70 := (*C.VkSparseImageMemoryBindInfo)(mem50faeb70)
	allocs50faeb70 := new(cgoAllocMap)
	allocs50faeb70.Add(mem50faeb70)

	var cimage_allocs *cgoAllocMap
	ref50faeb70.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs50faeb70.Borrow(cimage_allocs)

	var cbindCount_allocs *cgoAllocMap
	ref50faeb70.bindCount, cbindCount_allocs = (C.uint32_t)(x.BindCount), cgoAllocsUnknown
	allocs50faeb70.Borrow(cbindCount_allocs)

	var cpBinds_allocs *cgoAllocMap
	ref50faeb70.pBinds, cpBinds_allocs = unpackSSparseImageMemoryBind(x.PBinds)
	allocs50faeb70.Borrow(cpBinds_allocs)

	x.ref50faeb70 = ref50faeb70
	x.allocs50faeb70 = allocs50faeb70
	return ref50faeb70, allocs50faeb70

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageMemoryBindInfo) PassValue() (C.VkSparseImageMemoryBindInfo, *cgoAllocMap) {
	if x.ref50faeb70 != nil {
		return *x.ref50faeb70, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageMemoryBindInfo) Deref() {
	if x.ref50faeb70 == nil {
		return
	}
	x.Image = *(*Image)(unsafe.Pointer(&x.ref50faeb70.image))
	x.BindCount = (uint32)(x.ref50faeb70.bindCount)
	packSSparseImageMemoryBind(x.PBinds, x.ref50faeb70.pBinds)
}

// allocBindSparseInfoMemory allocates memory for type C.VkBindSparseInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindSparseInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindSparseInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindSparseInfoValue = unsafe.Sizeof([1]C.VkBindSparseInfo{})

// unpackSSparseBufferMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseBufferMemoryBindInfo(x []SparseBufferMemoryBindInfo) (unpacked *C.VkSparseBufferMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSparseBufferMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseBufferMemoryBindInfo)(h.Data)
	return
}

// unpackSSparseImageOpaqueMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseImageOpaqueMemoryBindInfo(x []SparseImageOpaqueMemoryBindInfo) (unpacked *C.VkSparseImageOpaqueMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageOpaqueMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageOpaqueMemoryBindInfo)(h.Data)
	return
}

// unpackSSparseImageMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseImageMemoryBindInfo(x []SparseImageMemoryBindInfo) (unpacked *C.VkSparseImageMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryBindInfo)(h.Data)
	return
}

// packSSparseBufferMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseBufferMemoryBindInfo(v []SparseBufferMemoryBindInfo, ptr0 *C.VkSparseBufferMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseBufferMemoryBindInfoValue]C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseBufferMemoryBindInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSSparseImageOpaqueMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseImageOpaqueMemoryBindInfo(v []SparseImageOpaqueMemoryBindInfo, ptr0 *C.VkSparseImageOpaqueMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageOpaqueMemoryBindInfoValue]C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageOpaqueMemoryBindInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSSparseImageMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryBindInfo(v []SparseImageMemoryBindInfo, ptr0 *C.VkSparseImageMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryBindInfoValue]C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryBindInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindSparseInfo) Ref() *C.VkBindSparseInfo {
	if x == nil {
		return nil
	}
	return x.refb0cbe910
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindSparseInfo) Free() {
	if x != nil && x.allocsb0cbe910 != nil {
		x.allocsb0cbe910.(*cgoAllocMap).Free()
		x.refb0cbe910 = nil
	}
}

// NewBindSparseInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindSparseInfoRef(ref unsafe.Pointer) *BindSparseInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindSparseInfo)
	obj.refb0cbe910 = (*C.VkBindSparseInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindSparseInfo) PassRef() (*C.VkBindSparseInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0cbe910 != nil {
		return x.refb0cbe910, nil
	}
	memb0cbe910 := allocBindSparseInfoMemory(1)
	refb0cbe910 := (*C.VkBindSparseInfo)(memb0cbe910)
	allocsb0cbe910 := new(cgoAllocMap)
	allocsb0cbe910.Add(memb0cbe910)

	var csType_allocs *cgoAllocMap
	refb0cbe910.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb0cbe910.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb0cbe910.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	refb0cbe910.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphores_allocs *cgoAllocMap
	refb0cbe910.pWaitSemaphores, cpWaitSemaphores_allocs = copyPSemaphoreBytes((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)))
	allocsb0cbe910.Borrow(cpWaitSemaphores_allocs)

	var cbufferBindCount_allocs *cgoAllocMap
	refb0cbe910.bufferBindCount, cbufferBindCount_allocs = (C.uint32_t)(x.BufferBindCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cbufferBindCount_allocs)

	var cpBufferBinds_allocs *cgoAllocMap
	refb0cbe910.pBufferBinds, cpBufferBinds_allocs = unpackSSparseBufferMemoryBindInfo(x.PBufferBinds)
	allocsb0cbe910.Borrow(cpBufferBinds_allocs)

	var cimageOpaqueBindCount_allocs *cgoAllocMap
	refb0cbe910.imageOpaqueBindCount, cimageOpaqueBindCount_allocs = (C.uint32_t)(x.ImageOpaqueBindCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cimageOpaqueBindCount_allocs)

	var cpImageOpaqueBinds_allocs *cgoAllocMap
	refb0cbe910.pImageOpaqueBinds, cpImageOpaqueBinds_allocs = unpackSSparseImageOpaqueMemoryBindInfo(x.PImageOpaqueBinds)
	allocsb0cbe910.Borrow(cpImageOpaqueBinds_allocs)

	var cimageBindCount_allocs *cgoAllocMap
	refb0cbe910.imageBindCount, cimageBindCount_allocs = (C.uint32_t)(x.ImageBindCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cimageBindCount_allocs)

	var cpImageBinds_allocs *cgoAllocMap
	refb0cbe910.pImageBinds, cpImageBinds_allocs = unpackSSparseImageMemoryBindInfo(x.PImageBinds)
	allocsb0cbe910.Borrow(cpImageBinds_allocs)

	var csignalSemaphoreCount_allocs *cgoAllocMap
	refb0cbe910.signalSemaphoreCount, csignalSemaphoreCount_allocs = (C.uint32_t)(x.SignalSemaphoreCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(csignalSemaphoreCount_allocs)

	var cpSignalSemaphores_allocs *cgoAllocMap
	refb0cbe910.pSignalSemaphores, cpSignalSemaphores_allocs = copyPSemaphoreBytes((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores)))
	allocsb0cbe910.Borrow(cpSignalSemaphores_allocs)

	x.refb0cbe910 = refb0cbe910
	x.allocsb0cbe910 = allocsb0cbe910
	return refb0cbe910, allocsb0cbe910

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindSparseInfo) PassValue() (C.VkBindSparseInfo, *cgoAllocMap) {
	if x.refb0cbe910 != nil {
		return *x.refb0cbe910, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindSparseInfo) Deref() {
	if x.refb0cbe910 == nil {
		return
	}
	x.SType = (StructureType)(x.refb0cbe910.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb0cbe910.pNext))
	x.WaitSemaphoreCount = (uint32)(x.refb0cbe910.waitSemaphoreCount)
	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxfa3f05c.Data = unsafe.Pointer(x.refb0cbe910.pWaitSemaphores)
	hxfa3f05c.Cap = 0x7fffffff
	// hxfa3f05c.Len = ?

	x.BufferBindCount = (uint32)(x.refb0cbe910.bufferBindCount)
	packSSparseBufferMemoryBindInfo(x.PBufferBinds, x.refb0cbe910.pBufferBinds)
	x.ImageOpaqueBindCount = (uint32)(x.refb0cbe910.imageOpaqueBindCount)
	packSSparseImageOpaqueMemoryBindInfo(x.PImageOpaqueBinds, x.refb0cbe910.pImageOpaqueBinds)
	x.ImageBindCount = (uint32)(x.refb0cbe910.imageBindCount)
	packSSparseImageMemoryBindInfo(x.PImageBinds, x.refb0cbe910.pImageBinds)
	x.SignalSemaphoreCount = (uint32)(x.refb0cbe910.signalSemaphoreCount)
	hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores))
	hxf0d18b7.Data = unsafe.Pointer(x.refb0cbe910.pSignalSemaphores)
	hxf0d18b7.Cap = 0x7fffffff
	// hxf0d18b7.Len = ?

}

// allocSparseImageFormatPropertiesMemory allocates memory for type C.VkSparseImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageFormatPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSparseImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkSparseImageFormatProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageFormatProperties) Ref() *C.VkSparseImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.ref2c12cf44
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageFormatProperties) Free() {
	if x != nil && x.allocs2c12cf44 != nil {
		x.allocs2c12cf44.(*cgoAllocMap).Free()
		x.ref2c12cf44 = nil
	}
}

// NewSparseImageFormatPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageFormatPropertiesRef(ref unsafe.Pointer) *SparseImageFormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageFormatProperties)
	obj.ref2c12cf44 = (*C.VkSparseImageFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageFormatProperties) PassRef() (*C.VkSparseImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2c12cf44 != nil {
		return x.ref2c12cf44, nil
	}
	mem2c12cf44 := allocSparseImageFormatPropertiesMemory(1)
	ref2c12cf44 := (*C.VkSparseImageFormatProperties)(mem2c12cf44)
	allocs2c12cf44 := new(cgoAllocMap)
	allocs2c12cf44.Add(mem2c12cf44)

	var caspectMask_allocs *cgoAllocMap
	ref2c12cf44.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs2c12cf44.Borrow(caspectMask_allocs)

	var cimageGranularity_allocs *cgoAllocMap
	ref2c12cf44.imageGranularity, cimageGranularity_allocs = x.ImageGranularity.PassValue()
	allocs2c12cf44.Borrow(cimageGranularity_allocs)

	var cflags_allocs *cgoAllocMap
	ref2c12cf44.flags, cflags_allocs = (C.VkSparseImageFormatFlags)(x.Flags), cgoAllocsUnknown
	allocs2c12cf44.Borrow(cflags_allocs)

	x.ref2c12cf44 = ref2c12cf44
	x.allocs2c12cf44 = allocs2c12cf44
	return ref2c12cf44, allocs2c12cf44

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageFormatProperties) PassValue() (C.VkSparseImageFormatProperties, *cgoAllocMap) {
	if x.ref2c12cf44 != nil {
		return *x.ref2c12cf44, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageFormatProperties) Deref() {
	if x.ref2c12cf44 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.ref2c12cf44.aspectMask)
	x.ImageGranularity = *NewExtent3DRef(unsafe.Pointer(&x.ref2c12cf44.imageGranularity))
	x.Flags = (SparseImageFormatFlags)(x.ref2c12cf44.flags)
}

// allocSparseImageMemoryRequirementsMemory allocates memory for type C.VkSparseImageMemoryRequirements in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryRequirementsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryRequirementsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSparseImageMemoryRequirementsValue = unsafe.Sizeof([1]C.VkSparseImageMemoryRequirements{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageMemoryRequirements) Ref() *C.VkSparseImageMemoryRequirements {
	if x == nil {
		return nil
	}
	return x.ref685a2323
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageMemoryRequirements) Free() {
	if x != nil && x.allocs685a2323 != nil {
		x.allocs685a2323.(*cgoAllocMap).Free()
		x.ref685a2323 = nil
	}
}

// NewSparseImageMemoryRequirementsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageMemoryRequirementsRef(ref unsafe.Pointer) *SparseImageMemoryRequirements {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryRequirements)
	obj.ref685a2323 = (*C.VkSparseImageMemoryRequirements)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageMemoryRequirements) PassRef() (*C.VkSparseImageMemoryRequirements, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref685a2323 != nil {
		return x.ref685a2323, nil
	}
	mem685a2323 := allocSparseImageMemoryRequirementsMemory(1)
	ref685a2323 := (*C.VkSparseImageMemoryRequirements)(mem685a2323)
	allocs685a2323 := new(cgoAllocMap)
	allocs685a2323.Add(mem685a2323)

	var cformatProperties_allocs *cgoAllocMap
	ref685a2323.formatProperties, cformatProperties_allocs = x.FormatProperties.PassValue()
	allocs685a2323.Borrow(cformatProperties_allocs)

	var cimageMipTailFirstLod_allocs *cgoAllocMap
	ref685a2323.imageMipTailFirstLod, cimageMipTailFirstLod_allocs = (C.uint32_t)(x.ImageMipTailFirstLod), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailFirstLod_allocs)

	var cimageMipTailSize_allocs *cgoAllocMap
	ref685a2323.imageMipTailSize, cimageMipTailSize_allocs = (C.VkDeviceSize)(x.ImageMipTailSize), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailSize_allocs)

	var cimageMipTailOffset_allocs *cgoAllocMap
	ref685a2323.imageMipTailOffset, cimageMipTailOffset_allocs = (C.VkDeviceSize)(x.ImageMipTailOffset), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailOffset_allocs)

	var cimageMipTailStride_allocs *cgoAllocMap
	ref685a2323.imageMipTailStride, cimageMipTailStride_allocs = (C.VkDeviceSize)(x.ImageMipTailStride), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailStride_allocs)

	x.ref685a2323 = ref685a2323
	x.allocs685a2323 = allocs685a2323
	return ref685a2323, allocs685a2323

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageMemoryRequirements) PassValue() (C.VkSparseImageMemoryRequirements, *cgoAllocMap) {
	if x.ref685a2323 != nil {
		return *x.ref685a2323, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageMemoryRequirements) Deref() {
	if x.ref685a2323 == nil {
		return
	}
	x.FormatProperties = *NewSparseImageFormatPropertiesRef(unsafe.Pointer(&x.ref685a2323.formatProperties))
	x.ImageMipTailFirstLod = (uint32)(x.ref685a2323.imageMipTailFirstLod)
	x.ImageMipTailSize = (DeviceSize)(x.ref685a2323.imageMipTailSize)
	x.ImageMipTailOffset = (DeviceSize)(x.ref685a2323.imageMipTailOffset)
	x.ImageMipTailStride = (DeviceSize)(x.ref685a2323.imageMipTailStride)
}

// allocFenceCreateInfoMemory allocates memory for type C.VkFenceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFenceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFenceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFenceCreateInfoValue = unsafe.Sizeof([1]C.VkFenceCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FenceCreateInfo) Ref() *C.VkFenceCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb8ff4840
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FenceCreateInfo) Free() {
	if x != nil && x.allocsb8ff4840 != nil {
		x.allocsb8ff4840.(*cgoAllocMap).Free()
		x.refb8ff4840 = nil
	}
}

// NewFenceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFenceCreateInfoRef(ref unsafe.Pointer) *FenceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(FenceCreateInfo)
	obj.refb8ff4840 = (*C.VkFenceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FenceCreateInfo) PassRef() (*C.VkFenceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8ff4840 != nil {
		return x.refb8ff4840, nil
	}
	memb8ff4840 := allocFenceCreateInfoMemory(1)
	refb8ff4840 := (*C.VkFenceCreateInfo)(memb8ff4840)
	allocsb8ff4840 := new(cgoAllocMap)
	allocsb8ff4840.Add(memb8ff4840)

	var csType_allocs *cgoAllocMap
	refb8ff4840.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb8ff4840.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb8ff4840.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb8ff4840.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refb8ff4840.flags, cflags_allocs = (C.VkFenceCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsb8ff4840.Borrow(cflags_allocs)

	x.refb8ff4840 = refb8ff4840
	x.allocsb8ff4840 = allocsb8ff4840
	return refb8ff4840, allocsb8ff4840

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FenceCreateInfo) PassValue() (C.VkFenceCreateInfo, *cgoAllocMap) {
	if x.refb8ff4840 != nil {
		return *x.refb8ff4840, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FenceCreateInfo) Deref() {
	if x.refb8ff4840 == nil {
		return
	}
	x.SType = (StructureType)(x.refb8ff4840.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb8ff4840.pNext))
	x.Flags = (FenceCreateFlags)(x.refb8ff4840.flags)
}

// allocSemaphoreCreateInfoMemory allocates memory for type C.VkSemaphoreCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSemaphoreCreateInfoValue = unsafe.Sizeof([1]C.VkSemaphoreCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SemaphoreCreateInfo) Ref() *C.VkSemaphoreCreateInfo {
	if x == nil {
		return nil
	}
	return x.reff130cd2b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SemaphoreCreateInfo) Free() {
	if x != nil && x.allocsf130cd2b != nil {
		x.allocsf130cd2b.(*cgoAllocMap).Free()
		x.reff130cd2b = nil
	}
}

// NewSemaphoreCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSemaphoreCreateInfoRef(ref unsafe.Pointer) *SemaphoreCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SemaphoreCreateInfo)
	obj.reff130cd2b = (*C.VkSemaphoreCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SemaphoreCreateInfo) PassRef() (*C.VkSemaphoreCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff130cd2b != nil {
		return x.reff130cd2b, nil
	}
	memf130cd2b := allocSemaphoreCreateInfoMemory(1)
	reff130cd2b := (*C.VkSemaphoreCreateInfo)(memf130cd2b)
	allocsf130cd2b := new(cgoAllocMap)
	allocsf130cd2b.Add(memf130cd2b)

	var csType_allocs *cgoAllocMap
	reff130cd2b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf130cd2b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff130cd2b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf130cd2b.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reff130cd2b.flags, cflags_allocs = (C.VkSemaphoreCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsf130cd2b.Borrow(cflags_allocs)

	x.reff130cd2b = reff130cd2b
	x.allocsf130cd2b = allocsf130cd2b
	return reff130cd2b, allocsf130cd2b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SemaphoreCreateInfo) PassValue() (C.VkSemaphoreCreateInfo, *cgoAllocMap) {
	if x.reff130cd2b != nil {
		return *x.reff130cd2b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SemaphoreCreateInfo) Deref() {
	if x.reff130cd2b == nil {
		return
	}
	x.SType = (StructureType)(x.reff130cd2b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff130cd2b.pNext))
	x.Flags = (SemaphoreCreateFlags)(x.reff130cd2b.flags)
}

// allocEventCreateInfoMemory allocates memory for type C.VkEventCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfEventCreateInfoValue = unsafe.Sizeof([1]C.VkEventCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventCreateInfo) Ref() *C.VkEventCreateInfo {
	if x == nil {
		return nil
	}
	return x.refa54f9ec8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventCreateInfo) Free() {
	if x != nil && x.allocsa54f9ec8 != nil {
		x.allocsa54f9ec8.(*cgoAllocMap).Free()
		x.refa54f9ec8 = nil
	}
}

// NewEventCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventCreateInfoRef(ref unsafe.Pointer) *EventCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(EventCreateInfo)
	obj.refa54f9ec8 = (*C.VkEventCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventCreateInfo) PassRef() (*C.VkEventCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa54f9ec8 != nil {
		return x.refa54f9ec8, nil
	}
	mema54f9ec8 := allocEventCreateInfoMemory(1)
	refa54f9ec8 := (*C.VkEventCreateInfo)(mema54f9ec8)
	allocsa54f9ec8 := new(cgoAllocMap)
	allocsa54f9ec8.Add(mema54f9ec8)

	var csType_allocs *cgoAllocMap
	refa54f9ec8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa54f9ec8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa54f9ec8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa54f9ec8.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refa54f9ec8.flags, cflags_allocs = (C.VkEventCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsa54f9ec8.Borrow(cflags_allocs)

	x.refa54f9ec8 = refa54f9ec8
	x.allocsa54f9ec8 = allocsa54f9ec8
	return refa54f9ec8, allocsa54f9ec8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventCreateInfo) PassValue() (C.VkEventCreateInfo, *cgoAllocMap) {
	if x.refa54f9ec8 != nil {
		return *x.refa54f9ec8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventCreateInfo) Deref() {
	if x.refa54f9ec8 == nil {
		return
	}
	x.SType = (StructureType)(x.refa54f9ec8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa54f9ec8.pNext))
	x.Flags = (EventCreateFlags)(x.refa54f9ec8.flags)
}

// allocQueryPoolCreateInfoMemory allocates memory for type C.VkQueryPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueryPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueryPoolCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfQueryPoolCreateInfoValue = unsafe.Sizeof([1]C.VkQueryPoolCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueryPoolCreateInfo) Ref() *C.VkQueryPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref85dfcd4a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueryPoolCreateInfo) Free() {
	if x != nil && x.allocs85dfcd4a != nil {
		x.allocs85dfcd4a.(*cgoAllocMap).Free()
		x.ref85dfcd4a = nil
	}
}

// NewQueryPoolCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueryPoolCreateInfoRef(ref unsafe.Pointer) *QueryPoolCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(QueryPoolCreateInfo)
	obj.ref85dfcd4a = (*C.VkQueryPoolCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueryPoolCreateInfo) PassRef() (*C.VkQueryPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85dfcd4a != nil {
		return x.ref85dfcd4a, nil
	}
	mem85dfcd4a := allocQueryPoolCreateInfoMemory(1)
	ref85dfcd4a := (*C.VkQueryPoolCreateInfo)(mem85dfcd4a)
	allocs85dfcd4a := new(cgoAllocMap)
	allocs85dfcd4a.Add(mem85dfcd4a)

	var csType_allocs *cgoAllocMap
	ref85dfcd4a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref85dfcd4a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref85dfcd4a.flags, cflags_allocs = (C.VkQueryPoolCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cflags_allocs)

	var cqueryType_allocs *cgoAllocMap
	ref85dfcd4a.queryType, cqueryType_allocs = (C.VkQueryType)(x.QueryType), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cqueryType_allocs)

	var cqueryCount_allocs *cgoAllocMap
	ref85dfcd4a.queryCount, cqueryCount_allocs = (C.uint32_t)(x.QueryCount), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cqueryCount_allocs)

	var cpipelineStatistics_allocs *cgoAllocMap
	ref85dfcd4a.pipelineStatistics, cpipelineStatistics_allocs = (C.VkQueryPipelineStatisticFlags)(x.PipelineStatistics), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cpipelineStatistics_allocs)

	x.ref85dfcd4a = ref85dfcd4a
	x.allocs85dfcd4a = allocs85dfcd4a
	return ref85dfcd4a, allocs85dfcd4a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueryPoolCreateInfo) PassValue() (C.VkQueryPoolCreateInfo, *cgoAllocMap) {
	if x.ref85dfcd4a != nil {
		return *x.ref85dfcd4a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueryPoolCreateInfo) Deref() {
	if x.ref85dfcd4a == nil {
		return
	}
	x.SType = (StructureType)(x.ref85dfcd4a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref85dfcd4a.pNext))
	x.Flags = (QueryPoolCreateFlags)(x.ref85dfcd4a.flags)
	x.QueryType = (QueryType)(x.ref85dfcd4a.queryType)
	x.QueryCount = (uint32)(x.ref85dfcd4a.queryCount)
	x.PipelineStatistics = (QueryPipelineStatisticFlags)(x.ref85dfcd4a.pipelineStatistics)
}

// allocBufferCreateInfoMemory allocates memory for type C.VkBufferCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferCreateInfoValue = unsafe.Sizeof([1]C.VkBufferCreateInfo{})

// copyPUint32_tBytes copies the data from Go slice as *C.uint32_t.
func copyPUint32_tBytes(slice *sliceHeader) (*C.uint32_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint32_tValue) * slice.Len,
		Cap:  int(sizeOfUint32_tValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint32_t)(mem0), allocs
}

// allocUint32_tMemory allocates memory for type C.uint32_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint32_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint32_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint32_tValue = unsafe.Sizeof([1]C.uint32_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferCreateInfo) Ref() *C.VkBufferCreateInfo {
	if x == nil {
		return nil
	}
	return x.reffe19d2cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferCreateInfo) Free() {
	if x != nil && x.allocsfe19d2cd != nil {
		x.allocsfe19d2cd.(*cgoAllocMap).Free()
		x.reffe19d2cd = nil
	}
}

// NewBufferCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferCreateInfoRef(ref unsafe.Pointer) *BufferCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(BufferCreateInfo)
	obj.reffe19d2cd = (*C.VkBufferCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferCreateInfo) PassRef() (*C.VkBufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe19d2cd != nil {
		return x.reffe19d2cd, nil
	}
	memfe19d2cd := allocBufferCreateInfoMemory(1)
	reffe19d2cd := (*C.VkBufferCreateInfo)(memfe19d2cd)
	allocsfe19d2cd := new(cgoAllocMap)
	allocsfe19d2cd.Add(memfe19d2cd)

	var csType_allocs *cgoAllocMap
	reffe19d2cd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffe19d2cd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reffe19d2cd.flags, cflags_allocs = (C.VkBufferCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cflags_allocs)

	var csize_allocs *cgoAllocMap
	reffe19d2cd.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(csize_allocs)

	var cusage_allocs *cgoAllocMap
	reffe19d2cd.usage, cusage_allocs = (C.VkBufferUsageFlags)(x.Usage), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cusage_allocs)

	var csharingMode_allocs *cgoAllocMap
	reffe19d2cd.sharingMode, csharingMode_allocs = (C.VkSharingMode)(x.SharingMode), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(csharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	reffe19d2cd.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	reffe19d2cd.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)))
	allocsfe19d2cd.Borrow(cpQueueFamilyIndices_allocs)

	x.reffe19d2cd = reffe19d2cd
	x.allocsfe19d2cd = allocsfe19d2cd
	return reffe19d2cd, allocsfe19d2cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferCreateInfo) PassValue() (C.VkBufferCreateInfo, *cgoAllocMap) {
	if x.reffe19d2cd != nil {
		return *x.reffe19d2cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferCreateInfo) Deref() {
	if x.reffe19d2cd == nil {
		return
	}
	x.SType = (StructureType)(x.reffe19d2cd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe19d2cd.pNext))
	x.Flags = (BufferCreateFlags)(x.reffe19d2cd.flags)
	x.Size = (DeviceSize)(x.reffe19d2cd.size)
	x.Usage = (BufferUsageFlags)(x.reffe19d2cd.usage)
	x.SharingMode = (SharingMode)(x.reffe19d2cd.sharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.reffe19d2cd.queueFamilyIndexCount)
	hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf2fab0d.Data = unsafe.Pointer(x.reffe19d2cd.pQueueFamilyIndices)
	hxf2fab0d.Cap = 0x7fffffff
	// hxf2fab0d.Len = ?

}

// allocBufferViewCreateInfoMemory allocates memory for type C.VkBufferViewCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferViewCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferViewCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferViewCreateInfoValue = unsafe.Sizeof([1]C.VkBufferViewCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferViewCreateInfo) Ref() *C.VkBufferViewCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref49b97027
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferViewCreateInfo) Free() {
	if x != nil && x.allocs49b97027 != nil {
		x.allocs49b97027.(*cgoAllocMap).Free()
		x.ref49b97027 = nil
	}
}

// NewBufferViewCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferViewCreateInfoRef(ref unsafe.Pointer) *BufferViewCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(BufferViewCreateInfo)
	obj.ref49b97027 = (*C.VkBufferViewCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferViewCreateInfo) PassRef() (*C.VkBufferViewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref49b97027 != nil {
		return x.ref49b97027, nil
	}
	mem49b97027 := allocBufferViewCreateInfoMemory(1)
	ref49b97027 := (*C.VkBufferViewCreateInfo)(mem49b97027)
	allocs49b97027 := new(cgoAllocMap)
	allocs49b97027.Add(mem49b97027)

	var csType_allocs *cgoAllocMap
	ref49b97027.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs49b97027.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref49b97027.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs49b97027.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref49b97027.flags, cflags_allocs = (C.VkBufferViewCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs49b97027.Borrow(cflags_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref49b97027.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs49b97027.Borrow(cbuffer_allocs)

	var cformat_allocs *cgoAllocMap
	ref49b97027.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs49b97027.Borrow(cformat_allocs)

	var coffset_allocs *cgoAllocMap
	ref49b97027.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs49b97027.Borrow(coffset_allocs)

	var c_range_allocs *cgoAllocMap
	ref49b97027._range, c_range_allocs = (C.VkDeviceSize)(x.Range), cgoAllocsUnknown
	allocs49b97027.Borrow(c_range_allocs)

	x.ref49b97027 = ref49b97027
	x.allocs49b97027 = allocs49b97027
	return ref49b97027, allocs49b97027

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferViewCreateInfo) PassValue() (C.VkBufferViewCreateInfo, *cgoAllocMap) {
	if x.ref49b97027 != nil {
		return *x.ref49b97027, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferViewCreateInfo) Deref() {
	if x.ref49b97027 == nil {
		return
	}
	x.SType = (StructureType)(x.ref49b97027.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref49b97027.pNext))
	x.Flags = (BufferViewCreateFlags)(x.ref49b97027.flags)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref49b97027.buffer))
	x.Format = (Format)(x.ref49b97027.format)
	x.Offset = (DeviceSize)(x.ref49b97027.offset)
	x.Range = (DeviceSize)(x.ref49b97027._range)
}

// allocImageCreateInfoMemory allocates memory for type C.VkImageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageCreateInfoValue = unsafe.Sizeof([1]C.VkImageCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageCreateInfo) Ref() *C.VkImageCreateInfo {
	if x == nil {
		return nil
	}
	return x.reffb587ba1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageCreateInfo) Free() {
	if x != nil && x.allocsfb587ba1 != nil {
		x.allocsfb587ba1.(*cgoAllocMap).Free()
		x.reffb587ba1 = nil
	}
}

// NewImageCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageCreateInfoRef(ref unsafe.Pointer) *ImageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageCreateInfo)
	obj.reffb587ba1 = (*C.VkImageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageCreateInfo) PassRef() (*C.VkImageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffb587ba1 != nil {
		return x.reffb587ba1, nil
	}
	memfb587ba1 := allocImageCreateInfoMemory(1)
	reffb587ba1 := (*C.VkImageCreateInfo)(memfb587ba1)
	allocsfb587ba1 := new(cgoAllocMap)
	allocsfb587ba1.Add(memfb587ba1)

	var csType_allocs *cgoAllocMap
	reffb587ba1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfb587ba1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffb587ba1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reffb587ba1.flags, cflags_allocs = (C.VkImageCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cflags_allocs)

	var cimageType_allocs *cgoAllocMap
	reffb587ba1.imageType, cimageType_allocs = (C.VkImageType)(x.ImageType), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cimageType_allocs)

	var cformat_allocs *cgoAllocMap
	reffb587ba1.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cformat_allocs)

	var cextent_allocs *cgoAllocMap
	reffb587ba1.extent, cextent_allocs = x.Extent.PassValue()
	allocsfb587ba1.Borrow(cextent_allocs)

	var cmipLevels_allocs *cgoAllocMap
	reffb587ba1.mipLevels, cmipLevels_allocs = (C.uint32_t)(x.MipLevels), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cmipLevels_allocs)

	var carrayLayers_allocs *cgoAllocMap
	reffb587ba1.arrayLayers, carrayLayers_allocs = (C.uint32_t)(x.ArrayLayers), cgoAllocsUnknown
	allocsfb587ba1.Borrow(carrayLayers_allocs)

	var csamples_allocs *cgoAllocMap
	reffb587ba1.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocsfb587ba1.Borrow(csamples_allocs)

	var ctiling_allocs *cgoAllocMap
	reffb587ba1.tiling, ctiling_allocs = (C.VkImageTiling)(x.Tiling), cgoAllocsUnknown
	allocsfb587ba1.Borrow(ctiling_allocs)

	var cusage_allocs *cgoAllocMap
	reffb587ba1.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cusage_allocs)

	var csharingMode_allocs *cgoAllocMap
	reffb587ba1.sharingMode, csharingMode_allocs = (C.VkSharingMode)(x.SharingMode), cgoAllocsUnknown
	allocsfb587ba1.Borrow(csharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	reffb587ba1.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	reffb587ba1.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)))
	allocsfb587ba1.Borrow(cpQueueFamilyIndices_allocs)

	var cinitialLayout_allocs *cgoAllocMap
	reffb587ba1.initialLayout, cinitialLayout_allocs = (C.VkImageLayout)(x.InitialLayout), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cinitialLayout_allocs)

	x.reffb587ba1 = reffb587ba1
	x.allocsfb587ba1 = allocsfb587ba1
	return reffb587ba1, allocsfb587ba1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageCreateInfo) PassValue() (C.VkImageCreateInfo, *cgoAllocMap) {
	if x.reffb587ba1 != nil {
		return *x.reffb587ba1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageCreateInfo) Deref() {
	if x.reffb587ba1 == nil {
		return
	}
	x.SType = (StructureType)(x.reffb587ba1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffb587ba1.pNext))
	x.Flags = (ImageCreateFlags)(x.reffb587ba1.flags)
	x.ImageType = (ImageType)(x.reffb587ba1.imageType)
	x.Format = (Format)(x.reffb587ba1.format)
	x.Extent = *NewExtent3DRef(unsafe.Pointer(&x.reffb587ba1.extent))
	x.MipLevels = (uint32)(x.reffb587ba1.mipLevels)
	x.ArrayLayers = (uint32)(x.reffb587ba1.arrayLayers)
	x.Samples = (SampleCountFlagBits)(x.reffb587ba1.samples)
	x.Tiling = (ImageTiling)(x.reffb587ba1.tiling)
	x.Usage = (ImageUsageFlags)(x.reffb587ba1.usage)
	x.SharingMode = (SharingMode)(x.reffb587ba1.sharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.reffb587ba1.queueFamilyIndexCount)
	hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf69fe70.Data = unsafe.Pointer(x.reffb587ba1.pQueueFamilyIndices)
	hxf69fe70.Cap = 0x7fffffff
	// hxf69fe70.Len = ?

	x.InitialLayout = (ImageLayout)(x.reffb587ba1.initialLayout)
}

// allocSubresourceLayoutMemory allocates memory for type C.VkSubresourceLayout in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubresourceLayoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubresourceLayoutValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubresourceLayoutValue = unsafe.Sizeof([1]C.VkSubresourceLayout{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubresourceLayout) Ref() *C.VkSubresourceLayout {
	if x == nil {
		return nil
	}
	return x.ref182612ad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubresourceLayout) Free() {
	if x != nil && x.allocs182612ad != nil {
		x.allocs182612ad.(*cgoAllocMap).Free()
		x.ref182612ad = nil
	}
}

// NewSubresourceLayoutRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubresourceLayoutRef(ref unsafe.Pointer) *SubresourceLayout {
	if ref == nil {
		return nil
	}
	obj := new(SubresourceLayout)
	obj.ref182612ad = (*C.VkSubresourceLayout)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubresourceLayout) PassRef() (*C.VkSubresourceLayout, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref182612ad != nil {
		return x.ref182612ad, nil
	}
	mem182612ad := allocSubresourceLayoutMemory(1)
	ref182612ad := (*C.VkSubresourceLayout)(mem182612ad)
	allocs182612ad := new(cgoAllocMap)
	allocs182612ad.Add(mem182612ad)

	var coffset_allocs *cgoAllocMap
	ref182612ad.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs182612ad.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref182612ad.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs182612ad.Borrow(csize_allocs)

	var crowPitch_allocs *cgoAllocMap
	ref182612ad.rowPitch, crowPitch_allocs = (C.VkDeviceSize)(x.RowPitch), cgoAllocsUnknown
	allocs182612ad.Borrow(crowPitch_allocs)

	var carrayPitch_allocs *cgoAllocMap
	ref182612ad.arrayPitch, carrayPitch_allocs = (C.VkDeviceSize)(x.ArrayPitch), cgoAllocsUnknown
	allocs182612ad.Borrow(carrayPitch_allocs)

	var cdepthPitch_allocs *cgoAllocMap
	ref182612ad.depthPitch, cdepthPitch_allocs = (C.VkDeviceSize)(x.DepthPitch), cgoAllocsUnknown
	allocs182612ad.Borrow(cdepthPitch_allocs)

	x.ref182612ad = ref182612ad
	x.allocs182612ad = allocs182612ad
	return ref182612ad, allocs182612ad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubresourceLayout) PassValue() (C.VkSubresourceLayout, *cgoAllocMap) {
	if x.ref182612ad != nil {
		return *x.ref182612ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubresourceLayout) Deref() {
	if x.ref182612ad == nil {
		return
	}
	x.Offset = (DeviceSize)(x.ref182612ad.offset)
	x.Size = (DeviceSize)(x.ref182612ad.size)
	x.RowPitch = (DeviceSize)(x.ref182612ad.rowPitch)
	x.ArrayPitch = (DeviceSize)(x.ref182612ad.arrayPitch)
	x.DepthPitch = (DeviceSize)(x.ref182612ad.depthPitch)
}

// allocComponentMappingMemory allocates memory for type C.VkComponentMapping in C.
// The caller is responsible for freeing the this memory via C.free.
func allocComponentMappingMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfComponentMappingValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfComponentMappingValue = unsafe.Sizeof([1]C.VkComponentMapping{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ComponentMapping) Ref() *C.VkComponentMapping {
	if x == nil {
		return nil
	}
	return x.ref63d3d563
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ComponentMapping) Free() {
	if x != nil && x.allocs63d3d563 != nil {
		x.allocs63d3d563.(*cgoAllocMap).Free()
		x.ref63d3d563 = nil
	}
}

// NewComponentMappingRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewComponentMappingRef(ref unsafe.Pointer) *ComponentMapping {
	if ref == nil {
		return nil
	}
	obj := new(ComponentMapping)
	obj.ref63d3d563 = (*C.VkComponentMapping)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ComponentMapping) PassRef() (*C.VkComponentMapping, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref63d3d563 != nil {
		return x.ref63d3d563, nil
	}
	mem63d3d563 := allocComponentMappingMemory(1)
	ref63d3d563 := (*C.VkComponentMapping)(mem63d3d563)
	allocs63d3d563 := new(cgoAllocMap)
	allocs63d3d563.Add(mem63d3d563)

	var cr_allocs *cgoAllocMap
	ref63d3d563.r, cr_allocs = (C.VkComponentSwizzle)(x.R), cgoAllocsUnknown
	allocs63d3d563.Borrow(cr_allocs)

	var cg_allocs *cgoAllocMap
	ref63d3d563.g, cg_allocs = (C.VkComponentSwizzle)(x.G), cgoAllocsUnknown
	allocs63d3d563.Borrow(cg_allocs)

	var cb_allocs *cgoAllocMap
	ref63d3d563.b, cb_allocs = (C.VkComponentSwizzle)(x.B), cgoAllocsUnknown
	allocs63d3d563.Borrow(cb_allocs)

	var ca_allocs *cgoAllocMap
	ref63d3d563.a, ca_allocs = (C.VkComponentSwizzle)(x.A), cgoAllocsUnknown
	allocs63d3d563.Borrow(ca_allocs)

	x.ref63d3d563 = ref63d3d563
	x.allocs63d3d563 = allocs63d3d563
	return ref63d3d563, allocs63d3d563

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ComponentMapping) PassValue() (C.VkComponentMapping, *cgoAllocMap) {
	if x.ref63d3d563 != nil {
		return *x.ref63d3d563, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ComponentMapping) Deref() {
	if x.ref63d3d563 == nil {
		return
	}
	x.R = (ComponentSwizzle)(x.ref63d3d563.r)
	x.G = (ComponentSwizzle)(x.ref63d3d563.g)
	x.B = (ComponentSwizzle)(x.ref63d3d563.b)
	x.A = (ComponentSwizzle)(x.ref63d3d563.a)
}

// allocImageViewCreateInfoMemory allocates memory for type C.VkImageViewCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageViewCreateInfoValue = unsafe.Sizeof([1]C.VkImageViewCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageViewCreateInfo) Ref() *C.VkImageViewCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref77e8d4b8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageViewCreateInfo) Free() {
	if x != nil && x.allocs77e8d4b8 != nil {
		x.allocs77e8d4b8.(*cgoAllocMap).Free()
		x.ref77e8d4b8 = nil
	}
}

// NewImageViewCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageViewCreateInfoRef(ref unsafe.Pointer) *ImageViewCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageViewCreateInfo)
	obj.ref77e8d4b8 = (*C.VkImageViewCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageViewCreateInfo) PassRef() (*C.VkImageViewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref77e8d4b8 != nil {
		return x.ref77e8d4b8, nil
	}
	mem77e8d4b8 := allocImageViewCreateInfoMemory(1)
	ref77e8d4b8 := (*C.VkImageViewCreateInfo)(mem77e8d4b8)
	allocs77e8d4b8 := new(cgoAllocMap)
	allocs77e8d4b8.Add(mem77e8d4b8)

	var csType_allocs *cgoAllocMap
	ref77e8d4b8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref77e8d4b8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref77e8d4b8.flags, cflags_allocs = (C.VkImageViewCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cflags_allocs)

	var cimage_allocs *cgoAllocMap
	ref77e8d4b8.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cimage_allocs)

	var cviewType_allocs *cgoAllocMap
	ref77e8d4b8.viewType, cviewType_allocs = (C.VkImageViewType)(x.ViewType), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cviewType_allocs)

	var cformat_allocs *cgoAllocMap
	ref77e8d4b8.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cformat_allocs)

	var ccomponents_allocs *cgoAllocMap
	ref77e8d4b8.components, ccomponents_allocs = x.Components.PassValue()
	allocs77e8d4b8.Borrow(ccomponents_allocs)

	var csubresourceRange_allocs *cgoAllocMap
	ref77e8d4b8.subresourceRange, csubresourceRange_allocs = x.SubresourceRange.PassValue()
	allocs77e8d4b8.Borrow(csubresourceRange_allocs)

	x.ref77e8d4b8 = ref77e8d4b8
	x.allocs77e8d4b8 = allocs77e8d4b8
	return ref77e8d4b8, allocs77e8d4b8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageViewCreateInfo) PassValue() (C.VkImageViewCreateInfo, *cgoAllocMap) {
	if x.ref77e8d4b8 != nil {
		return *x.ref77e8d4b8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageViewCreateInfo) Deref() {
	if x.ref77e8d4b8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref77e8d4b8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref77e8d4b8.pNext))
	x.Flags = (ImageViewCreateFlags)(x.ref77e8d4b8.flags)
	x.Image = *(*Image)(unsafe.Pointer(&x.ref77e8d4b8.image))
	x.ViewType = (ImageViewType)(x.ref77e8d4b8.viewType)
	x.Format = (Format)(x.ref77e8d4b8.format)
	x.Components = *NewComponentMappingRef(unsafe.Pointer(&x.ref77e8d4b8.components))
	x.SubresourceRange = *NewImageSubresourceRangeRef(unsafe.Pointer(&x.ref77e8d4b8.subresourceRange))
}

// allocShaderModuleCreateInfoMemory allocates memory for type C.VkShaderModuleCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderModuleCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderModuleCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfShaderModuleCreateInfoValue = unsafe.Sizeof([1]C.VkShaderModuleCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShaderModuleCreateInfo) Ref() *C.VkShaderModuleCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc663d23e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShaderModuleCreateInfo) Free() {
	if x != nil && x.allocsc663d23e != nil {
		x.allocsc663d23e.(*cgoAllocMap).Free()
		x.refc663d23e = nil
	}
}

// NewShaderModuleCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderModuleCreateInfoRef(ref unsafe.Pointer) *ShaderModuleCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ShaderModuleCreateInfo)
	obj.refc663d23e = (*C.VkShaderModuleCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShaderModuleCreateInfo) PassRef() (*C.VkShaderModuleCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc663d23e != nil {
		return x.refc663d23e, nil
	}
	memc663d23e := allocShaderModuleCreateInfoMemory(1)
	refc663d23e := (*C.VkShaderModuleCreateInfo)(memc663d23e)
	allocsc663d23e := new(cgoAllocMap)
	allocsc663d23e.Add(memc663d23e)

	var csType_allocs *cgoAllocMap
	refc663d23e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc663d23e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc663d23e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc663d23e.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc663d23e.flags, cflags_allocs = (C.VkShaderModuleCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsc663d23e.Borrow(cflags_allocs)

	var ccodeSize_allocs *cgoAllocMap
	refc663d23e.codeSize, ccodeSize_allocs = (C.size_t)(x.CodeSize), cgoAllocsUnknown
	allocsc663d23e.Borrow(ccodeSize_allocs)

	var cpCode_allocs *cgoAllocMap
	refc663d23e.pCode, cpCode_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PCode)))
	allocsc663d23e.Borrow(cpCode_allocs)

	x.refc663d23e = refc663d23e
	x.allocsc663d23e = allocsc663d23e
	return refc663d23e, allocsc663d23e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShaderModuleCreateInfo) PassValue() (C.VkShaderModuleCreateInfo, *cgoAllocMap) {
	if x.refc663d23e != nil {
		return *x.refc663d23e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShaderModuleCreateInfo) Deref() {
	if x.refc663d23e == nil {
		return
	}
	x.SType = (StructureType)(x.refc663d23e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc663d23e.pNext))
	x.Flags = (ShaderModuleCreateFlags)(x.refc663d23e.flags)
	x.CodeSize = (uint32)(x.refc663d23e.codeSize)
	hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&x.PCode))
	hxf65bf54.Data = unsafe.Pointer(x.refc663d23e.pCode)
	hxf65bf54.Cap = 0x7fffffff
	// hxf65bf54.Len = ?

}

// allocPipelineCacheCreateInfoMemory allocates memory for type C.VkPipelineCacheCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCacheCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCacheCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineCacheCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineCacheCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineCacheCreateInfo) Ref() *C.VkPipelineCacheCreateInfo {
	if x == nil {
		return nil
	}
	return x.reff11e7dd1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineCacheCreateInfo) Free() {
	if x != nil && x.allocsf11e7dd1 != nil {
		x.allocsf11e7dd1.(*cgoAllocMap).Free()
		x.reff11e7dd1 = nil
	}
}

// NewPipelineCacheCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineCacheCreateInfoRef(ref unsafe.Pointer) *PipelineCacheCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCacheCreateInfo)
	obj.reff11e7dd1 = (*C.VkPipelineCacheCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineCacheCreateInfo) PassRef() (*C.VkPipelineCacheCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff11e7dd1 != nil {
		return x.reff11e7dd1, nil
	}
	memf11e7dd1 := allocPipelineCacheCreateInfoMemory(1)
	reff11e7dd1 := (*C.VkPipelineCacheCreateInfo)(memf11e7dd1)
	allocsf11e7dd1 := new(cgoAllocMap)
	allocsf11e7dd1.Add(memf11e7dd1)

	var csType_allocs *cgoAllocMap
	reff11e7dd1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff11e7dd1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reff11e7dd1.flags, cflags_allocs = (C.VkPipelineCacheCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cflags_allocs)

	var cinitialDataSize_allocs *cgoAllocMap
	reff11e7dd1.initialDataSize, cinitialDataSize_allocs = (C.size_t)(x.InitialDataSize), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cinitialDataSize_allocs)

	var cpInitialData_allocs *cgoAllocMap
	reff11e7dd1.pInitialData, cpInitialData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PInitialData)), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cpInitialData_allocs)

	x.reff11e7dd1 = reff11e7dd1
	x.allocsf11e7dd1 = allocsf11e7dd1
	return reff11e7dd1, allocsf11e7dd1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineCacheCreateInfo) PassValue() (C.VkPipelineCacheCreateInfo, *cgoAllocMap) {
	if x.reff11e7dd1 != nil {
		return *x.reff11e7dd1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineCacheCreateInfo) Deref() {
	if x.reff11e7dd1 == nil {
		return
	}
	x.SType = (StructureType)(x.reff11e7dd1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff11e7dd1.pNext))
	x.Flags = (PipelineCacheCreateFlags)(x.reff11e7dd1.flags)
	x.InitialDataSize = (uint32)(x.reff11e7dd1.initialDataSize)
	x.PInitialData = (unsafe.Pointer)(unsafe.Pointer(x.reff11e7dd1.pInitialData))
}

// allocSpecializationMapEntryMemory allocates memory for type C.VkSpecializationMapEntry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSpecializationMapEntryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSpecializationMapEntryValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSpecializationMapEntryValue = unsafe.Sizeof([1]C.VkSpecializationMapEntry{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SpecializationMapEntry) Ref() *C.VkSpecializationMapEntry {
	if x == nil {
		return nil
	}
	return x.ref2fd815d1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SpecializationMapEntry) Free() {
	if x != nil && x.allocs2fd815d1 != nil {
		x.allocs2fd815d1.(*cgoAllocMap).Free()
		x.ref2fd815d1 = nil
	}
}

// NewSpecializationMapEntryRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSpecializationMapEntryRef(ref unsafe.Pointer) *SpecializationMapEntry {
	if ref == nil {
		return nil
	}
	obj := new(SpecializationMapEntry)
	obj.ref2fd815d1 = (*C.VkSpecializationMapEntry)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SpecializationMapEntry) PassRef() (*C.VkSpecializationMapEntry, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2fd815d1 != nil {
		return x.ref2fd815d1, nil
	}
	mem2fd815d1 := allocSpecializationMapEntryMemory(1)
	ref2fd815d1 := (*C.VkSpecializationMapEntry)(mem2fd815d1)
	allocs2fd815d1 := new(cgoAllocMap)
	allocs2fd815d1.Add(mem2fd815d1)

	var cconstantID_allocs *cgoAllocMap
	ref2fd815d1.constantID, cconstantID_allocs = (C.uint32_t)(x.ConstantID), cgoAllocsUnknown
	allocs2fd815d1.Borrow(cconstantID_allocs)

	var coffset_allocs *cgoAllocMap
	ref2fd815d1.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocs2fd815d1.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref2fd815d1.size, csize_allocs = (C.size_t)(x.Size), cgoAllocsUnknown
	allocs2fd815d1.Borrow(csize_allocs)

	x.ref2fd815d1 = ref2fd815d1
	x.allocs2fd815d1 = allocs2fd815d1
	return ref2fd815d1, allocs2fd815d1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SpecializationMapEntry) PassValue() (C.VkSpecializationMapEntry, *cgoAllocMap) {
	if x.ref2fd815d1 != nil {
		return *x.ref2fd815d1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SpecializationMapEntry) Deref() {
	if x.ref2fd815d1 == nil {
		return
	}
	x.ConstantID = (uint32)(x.ref2fd815d1.constantID)
	x.Offset = (uint32)(x.ref2fd815d1.offset)
	x.Size = (uint32)(x.ref2fd815d1.size)
}

// allocSpecializationInfoMemory allocates memory for type C.VkSpecializationInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSpecializationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSpecializationInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSpecializationInfoValue = unsafe.Sizeof([1]C.VkSpecializationInfo{})

// unpackSSpecializationMapEntry transforms a sliced Go data structure into plain C format.
func unpackSSpecializationMapEntry(x []SpecializationMapEntry) (unpacked *C.VkSpecializationMapEntry, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSpecializationMapEntryMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSpecializationMapEntry)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSpecializationMapEntry)(h.Data)
	return
}

// packSSpecializationMapEntry reads sliced Go data structure out from plain C format.
func packSSpecializationMapEntry(v []SpecializationMapEntry, ptr0 *C.VkSpecializationMapEntry) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSpecializationMapEntryValue]C.VkSpecializationMapEntry)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSpecializationMapEntryRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SpecializationInfo) Ref() *C.VkSpecializationInfo {
	if x == nil {
		return nil
	}
	return x.ref6bc395a3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SpecializationInfo) Free() {
	if x != nil && x.allocs6bc395a3 != nil {
		x.allocs6bc395a3.(*cgoAllocMap).Free()
		x.ref6bc395a3 = nil
	}
}

// NewSpecializationInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSpecializationInfoRef(ref unsafe.Pointer) *SpecializationInfo {
	if ref == nil {
		return nil
	}
	obj := new(SpecializationInfo)
	obj.ref6bc395a3 = (*C.VkSpecializationInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SpecializationInfo) PassRef() (*C.VkSpecializationInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6bc395a3 != nil {
		return x.ref6bc395a3, nil
	}
	mem6bc395a3 := allocSpecializationInfoMemory(1)
	ref6bc395a3 := (*C.VkSpecializationInfo)(mem6bc395a3)
	allocs6bc395a3 := new(cgoAllocMap)
	allocs6bc395a3.Add(mem6bc395a3)

	var cmapEntryCount_allocs *cgoAllocMap
	ref6bc395a3.mapEntryCount, cmapEntryCount_allocs = (C.uint32_t)(x.MapEntryCount), cgoAllocsUnknown
	allocs6bc395a3.Borrow(cmapEntryCount_allocs)

	var cpMapEntries_allocs *cgoAllocMap
	ref6bc395a3.pMapEntries, cpMapEntries_allocs = unpackSSpecializationMapEntry(x.PMapEntries)
	allocs6bc395a3.Borrow(cpMapEntries_allocs)

	var cdataSize_allocs *cgoAllocMap
	ref6bc395a3.dataSize, cdataSize_allocs = (C.size_t)(x.DataSize), cgoAllocsUnknown
	allocs6bc395a3.Borrow(cdataSize_allocs)

	var cpData_allocs *cgoAllocMap
	ref6bc395a3.pData, cpData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocs6bc395a3.Borrow(cpData_allocs)

	x.ref6bc395a3 = ref6bc395a3
	x.allocs6bc395a3 = allocs6bc395a3
	return ref6bc395a3, allocs6bc395a3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SpecializationInfo) PassValue() (C.VkSpecializationInfo, *cgoAllocMap) {
	if x.ref6bc395a3 != nil {
		return *x.ref6bc395a3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SpecializationInfo) Deref() {
	if x.ref6bc395a3 == nil {
		return
	}
	x.MapEntryCount = (uint32)(x.ref6bc395a3.mapEntryCount)
	packSSpecializationMapEntry(x.PMapEntries, x.ref6bc395a3.pMapEntries)
	x.DataSize = (uint32)(x.ref6bc395a3.dataSize)
	x.PData = (unsafe.Pointer)(unsafe.Pointer(x.ref6bc395a3.pData))
}

// allocPipelineShaderStageCreateInfoMemory allocates memory for type C.VkPipelineShaderStageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineShaderStageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineShaderStageCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineShaderStageCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineShaderStageCreateInfo{})

// unpackSSpecializationInfo transforms a sliced Go data structure into plain C format.
func unpackSSpecializationInfo(x []SpecializationInfo) (unpacked *C.VkSpecializationInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSpecializationInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSpecializationInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSpecializationInfo)(h.Data)
	return
}

// packSSpecializationInfo reads sliced Go data structure out from plain C format.
func packSSpecializationInfo(v []SpecializationInfo, ptr0 *C.VkSpecializationInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSpecializationInfoValue]C.VkSpecializationInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSpecializationInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineShaderStageCreateInfo) Ref() *C.VkPipelineShaderStageCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref50ba8b60
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineShaderStageCreateInfo) Free() {
	if x != nil && x.allocs50ba8b60 != nil {
		x.allocs50ba8b60.(*cgoAllocMap).Free()
		x.ref50ba8b60 = nil
	}
}

// NewPipelineShaderStageCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineShaderStageCreateInfoRef(ref unsafe.Pointer) *PipelineShaderStageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineShaderStageCreateInfo)
	obj.ref50ba8b60 = (*C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineShaderStageCreateInfo) PassRef() (*C.VkPipelineShaderStageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref50ba8b60 != nil {
		return x.ref50ba8b60, nil
	}
	mem50ba8b60 := allocPipelineShaderStageCreateInfoMemory(1)
	ref50ba8b60 := (*C.VkPipelineShaderStageCreateInfo)(mem50ba8b60)
	allocs50ba8b60 := new(cgoAllocMap)
	allocs50ba8b60.Add(mem50ba8b60)

	var csType_allocs *cgoAllocMap
	ref50ba8b60.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs50ba8b60.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref50ba8b60.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref50ba8b60.flags, cflags_allocs = (C.VkPipelineShaderStageCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cflags_allocs)

	var cstage_allocs *cgoAllocMap
	ref50ba8b60.stage, cstage_allocs = (C.VkShaderStageFlagBits)(x.Stage), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cstage_allocs)

	var cmodule_allocs *cgoAllocMap
	ref50ba8b60.module, cmodule_allocs = *(*C.VkShaderModule)(unsafe.Pointer(&x.Module)), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cmodule_allocs)

	var cpName_allocs *cgoAllocMap
	ref50ba8b60.pName, cpName_allocs = unpackPCharString(x.PName)
	allocs50ba8b60.Borrow(cpName_allocs)

	var cpSpecializationInfo_allocs *cgoAllocMap
	ref50ba8b60.pSpecializationInfo, cpSpecializationInfo_allocs = unpackSSpecializationInfo(x.PSpecializationInfo)
	allocs50ba8b60.Borrow(cpSpecializationInfo_allocs)

	x.ref50ba8b60 = ref50ba8b60
	x.allocs50ba8b60 = allocs50ba8b60
	return ref50ba8b60, allocs50ba8b60

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineShaderStageCreateInfo) PassValue() (C.VkPipelineShaderStageCreateInfo, *cgoAllocMap) {
	if x.ref50ba8b60 != nil {
		return *x.ref50ba8b60, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineShaderStageCreateInfo) Deref() {
	if x.ref50ba8b60 == nil {
		return
	}
	x.SType = (StructureType)(x.ref50ba8b60.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref50ba8b60.pNext))
	x.Flags = (PipelineShaderStageCreateFlags)(x.ref50ba8b60.flags)
	x.Stage = (ShaderStageFlagBits)(x.ref50ba8b60.stage)
	x.Module = *(*ShaderModule)(unsafe.Pointer(&x.ref50ba8b60.module))
	x.PName = packPCharString(x.ref50ba8b60.pName)
	packSSpecializationInfo(x.PSpecializationInfo, x.ref50ba8b60.pSpecializationInfo)
}

// allocComputePipelineCreateInfoMemory allocates memory for type C.VkComputePipelineCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocComputePipelineCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfComputePipelineCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfComputePipelineCreateInfoValue = unsafe.Sizeof([1]C.VkComputePipelineCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ComputePipelineCreateInfo) Ref() *C.VkComputePipelineCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref77823220
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ComputePipelineCreateInfo) Free() {
	if x != nil && x.allocs77823220 != nil {
		x.allocs77823220.(*cgoAllocMap).Free()
		x.ref77823220 = nil
	}
}

// NewComputePipelineCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewComputePipelineCreateInfoRef(ref unsafe.Pointer) *ComputePipelineCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ComputePipelineCreateInfo)
	obj.ref77823220 = (*C.VkComputePipelineCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ComputePipelineCreateInfo) PassRef() (*C.VkComputePipelineCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref77823220 != nil {
		return x.ref77823220, nil
	}
	mem77823220 := allocComputePipelineCreateInfoMemory(1)
	ref77823220 := (*C.VkComputePipelineCreateInfo)(mem77823220)
	allocs77823220 := new(cgoAllocMap)
	allocs77823220.Add(mem77823220)

	var csType_allocs *cgoAllocMap
	ref77823220.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs77823220.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref77823220.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs77823220.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref77823220.flags, cflags_allocs = (C.VkPipelineCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs77823220.Borrow(cflags_allocs)

	var cstage_allocs *cgoAllocMap
	ref77823220.stage, cstage_allocs = x.Stage.PassValue()
	allocs77823220.Borrow(cstage_allocs)

	var clayout_allocs *cgoAllocMap
	ref77823220.layout, clayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.Layout)), cgoAllocsUnknown
	allocs77823220.Borrow(clayout_allocs)

	var cbasePipelineHandle_allocs *cgoAllocMap
	ref77823220.basePipelineHandle, cbasePipelineHandle_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.BasePipelineHandle)), cgoAllocsUnknown
	allocs77823220.Borrow(cbasePipelineHandle_allocs)

	var cbasePipelineIndex_allocs *cgoAllocMap
	ref77823220.basePipelineIndex, cbasePipelineIndex_allocs = (C.int32_t)(x.BasePipelineIndex), cgoAllocsUnknown
	allocs77823220.Borrow(cbasePipelineIndex_allocs)

	x.ref77823220 = ref77823220
	x.allocs77823220 = allocs77823220
	return ref77823220, allocs77823220

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ComputePipelineCreateInfo) PassValue() (C.VkComputePipelineCreateInfo, *cgoAllocMap) {
	if x.ref77823220 != nil {
		return *x.ref77823220, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ComputePipelineCreateInfo) Deref() {
	if x.ref77823220 == nil {
		return
	}
	x.SType = (StructureType)(x.ref77823220.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref77823220.pNext))
	x.Flags = (PipelineCreateFlags)(x.ref77823220.flags)
	x.Stage = *NewPipelineShaderStageCreateInfoRef(unsafe.Pointer(&x.ref77823220.stage))
	x.Layout = *(*PipelineLayout)(unsafe.Pointer(&x.ref77823220.layout))
	x.BasePipelineHandle = *(*Pipeline)(unsafe.Pointer(&x.ref77823220.basePipelineHandle))
	x.BasePipelineIndex = (int32)(x.ref77823220.basePipelineIndex)
}

// allocVertexInputBindingDescriptionMemory allocates memory for type C.VkVertexInputBindingDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputBindingDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputBindingDescriptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVertexInputBindingDescriptionValue = unsafe.Sizeof([1]C.VkVertexInputBindingDescription{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VertexInputBindingDescription) Ref() *C.VkVertexInputBindingDescription {
	if x == nil {
		return nil
	}
	return x.ref5c9d8c23
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VertexInputBindingDescription) Free() {
	if x != nil && x.allocs5c9d8c23 != nil {
		x.allocs5c9d8c23.(*cgoAllocMap).Free()
		x.ref5c9d8c23 = nil
	}
}

// NewVertexInputBindingDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVertexInputBindingDescriptionRef(ref unsafe.Pointer) *VertexInputBindingDescription {
	if ref == nil {
		return nil
	}
	obj := new(VertexInputBindingDescription)
	obj.ref5c9d8c23 = (*C.VkVertexInputBindingDescription)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VertexInputBindingDescription) PassRef() (*C.VkVertexInputBindingDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5c9d8c23 != nil {
		return x.ref5c9d8c23, nil
	}
	mem5c9d8c23 := allocVertexInputBindingDescriptionMemory(1)
	ref5c9d8c23 := (*C.VkVertexInputBindingDescription)(mem5c9d8c23)
	allocs5c9d8c23 := new(cgoAllocMap)
	allocs5c9d8c23.Add(mem5c9d8c23)

	var cbinding_allocs *cgoAllocMap
	ref5c9d8c23.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocs5c9d8c23.Borrow(cbinding_allocs)

	var cstride_allocs *cgoAllocMap
	ref5c9d8c23.stride, cstride_allocs = (C.uint32_t)(x.Stride), cgoAllocsUnknown
	allocs5c9d8c23.Borrow(cstride_allocs)

	var cinputRate_allocs *cgoAllocMap
	ref5c9d8c23.inputRate, cinputRate_allocs = (C.VkVertexInputRate)(x.InputRate), cgoAllocsUnknown
	allocs5c9d8c23.Borrow(cinputRate_allocs)

	x.ref5c9d8c23 = ref5c9d8c23
	x.allocs5c9d8c23 = allocs5c9d8c23
	return ref5c9d8c23, allocs5c9d8c23

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VertexInputBindingDescription) PassValue() (C.VkVertexInputBindingDescription, *cgoAllocMap) {
	if x.ref5c9d8c23 != nil {
		return *x.ref5c9d8c23, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VertexInputBindingDescription) Deref() {
	if x.ref5c9d8c23 == nil {
		return
	}
	x.Binding = (uint32)(x.ref5c9d8c23.binding)
	x.Stride = (uint32)(x.ref5c9d8c23.stride)
	x.InputRate = (VertexInputRate)(x.ref5c9d8c23.inputRate)
}

// allocVertexInputAttributeDescriptionMemory allocates memory for type C.VkVertexInputAttributeDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputAttributeDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputAttributeDescriptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVertexInputAttributeDescriptionValue = unsafe.Sizeof([1]C.VkVertexInputAttributeDescription{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VertexInputAttributeDescription) Ref() *C.VkVertexInputAttributeDescription {
	if x == nil {
		return nil
	}
	return x.refdc4635ff
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VertexInputAttributeDescription) Free() {
	if x != nil && x.allocsdc4635ff != nil {
		x.allocsdc4635ff.(*cgoAllocMap).Free()
		x.refdc4635ff = nil
	}
}

// NewVertexInputAttributeDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVertexInputAttributeDescriptionRef(ref unsafe.Pointer) *VertexInputAttributeDescription {
	if ref == nil {
		return nil
	}
	obj := new(VertexInputAttributeDescription)
	obj.refdc4635ff = (*C.VkVertexInputAttributeDescription)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VertexInputAttributeDescription) PassRef() (*C.VkVertexInputAttributeDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdc4635ff != nil {
		return x.refdc4635ff, nil
	}
	memdc4635ff := allocVertexInputAttributeDescriptionMemory(1)
	refdc4635ff := (*C.VkVertexInputAttributeDescription)(memdc4635ff)
	allocsdc4635ff := new(cgoAllocMap)
	allocsdc4635ff.Add(memdc4635ff)

	var clocation_allocs *cgoAllocMap
	refdc4635ff.location, clocation_allocs = (C.uint32_t)(x.Location), cgoAllocsUnknown
	allocsdc4635ff.Borrow(clocation_allocs)

	var cbinding_allocs *cgoAllocMap
	refdc4635ff.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocsdc4635ff.Borrow(cbinding_allocs)

	var cformat_allocs *cgoAllocMap
	refdc4635ff.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsdc4635ff.Borrow(cformat_allocs)

	var coffset_allocs *cgoAllocMap
	refdc4635ff.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocsdc4635ff.Borrow(coffset_allocs)

	x.refdc4635ff = refdc4635ff
	x.allocsdc4635ff = allocsdc4635ff
	return refdc4635ff, allocsdc4635ff

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VertexInputAttributeDescription) PassValue() (C.VkVertexInputAttributeDescription, *cgoAllocMap) {
	if x.refdc4635ff != nil {
		return *x.refdc4635ff, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VertexInputAttributeDescription) Deref() {
	if x.refdc4635ff == nil {
		return
	}
	x.Location = (uint32)(x.refdc4635ff.location)
	x.Binding = (uint32)(x.refdc4635ff.binding)
	x.Format = (Format)(x.refdc4635ff.format)
	x.Offset = (uint32)(x.refdc4635ff.offset)
}

// allocPipelineVertexInputStateCreateInfoMemory allocates memory for type C.VkPipelineVertexInputStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineVertexInputStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineVertexInputStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineVertexInputStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineVertexInputStateCreateInfo{})

// unpackSVertexInputBindingDescription transforms a sliced Go data structure into plain C format.
func unpackSVertexInputBindingDescription(x []VertexInputBindingDescription) (unpacked *C.VkVertexInputBindingDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocVertexInputBindingDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkVertexInputBindingDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkVertexInputBindingDescription)(h.Data)
	return
}

// unpackSVertexInputAttributeDescription transforms a sliced Go data structure into plain C format.
func unpackSVertexInputAttributeDescription(x []VertexInputAttributeDescription) (unpacked *C.VkVertexInputAttributeDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocVertexInputAttributeDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkVertexInputAttributeDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkVertexInputAttributeDescription)(h.Data)
	return
}

// packSVertexInputBindingDescription reads sliced Go data structure out from plain C format.
func packSVertexInputBindingDescription(v []VertexInputBindingDescription, ptr0 *C.VkVertexInputBindingDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVertexInputBindingDescriptionValue]C.VkVertexInputBindingDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVertexInputBindingDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// packSVertexInputAttributeDescription reads sliced Go data structure out from plain C format.
func packSVertexInputAttributeDescription(v []VertexInputAttributeDescription, ptr0 *C.VkVertexInputAttributeDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVertexInputAttributeDescriptionValue]C.VkVertexInputAttributeDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVertexInputAttributeDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineVertexInputStateCreateInfo) Ref() *C.VkPipelineVertexInputStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref5fe4aa50
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineVertexInputStateCreateInfo) Free() {
	if x != nil && x.allocs5fe4aa50 != nil {
		x.allocs5fe4aa50.(*cgoAllocMap).Free()
		x.ref5fe4aa50 = nil
	}
}

// NewPipelineVertexInputStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineVertexInputStateCreateInfoRef(ref unsafe.Pointer) *PipelineVertexInputStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineVertexInputStateCreateInfo)
	obj.ref5fe4aa50 = (*C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineVertexInputStateCreateInfo) PassRef() (*C.VkPipelineVertexInputStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5fe4aa50 != nil {
		return x.ref5fe4aa50, nil
	}
	mem5fe4aa50 := allocPipelineVertexInputStateCreateInfoMemory(1)
	ref5fe4aa50 := (*C.VkPipelineVertexInputStateCreateInfo)(mem5fe4aa50)
	allocs5fe4aa50 := new(cgoAllocMap)
	allocs5fe4aa50.Add(mem5fe4aa50)

	var csType_allocs *cgoAllocMap
	ref5fe4aa50.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5fe4aa50.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref5fe4aa50.flags, cflags_allocs = (C.VkPipelineVertexInputStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cflags_allocs)

	var cvertexBindingDescriptionCount_allocs *cgoAllocMap
	ref5fe4aa50.vertexBindingDescriptionCount, cvertexBindingDescriptionCount_allocs = (C.uint32_t)(x.VertexBindingDescriptionCount), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cvertexBindingDescriptionCount_allocs)

	var cpVertexBindingDescriptions_allocs *cgoAllocMap
	ref5fe4aa50.pVertexBindingDescriptions, cpVertexBindingDescriptions_allocs = unpackSVertexInputBindingDescription(x.PVertexBindingDescriptions)
	allocs5fe4aa50.Borrow(cpVertexBindingDescriptions_allocs)

	var cvertexAttributeDescriptionCount_allocs *cgoAllocMap
	ref5fe4aa50.vertexAttributeDescriptionCount, cvertexAttributeDescriptionCount_allocs = (C.uint32_t)(x.VertexAttributeDescriptionCount), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cvertexAttributeDescriptionCount_allocs)

	var cpVertexAttributeDescriptions_allocs *cgoAllocMap
	ref5fe4aa50.pVertexAttributeDescriptions, cpVertexAttributeDescriptions_allocs = unpackSVertexInputAttributeDescription(x.PVertexAttributeDescriptions)
	allocs5fe4aa50.Borrow(cpVertexAttributeDescriptions_allocs)

	x.ref5fe4aa50 = ref5fe4aa50
	x.allocs5fe4aa50 = allocs5fe4aa50
	return ref5fe4aa50, allocs5fe4aa50

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineVertexInputStateCreateInfo) PassValue() (C.VkPipelineVertexInputStateCreateInfo, *cgoAllocMap) {
	if x.ref5fe4aa50 != nil {
		return *x.ref5fe4aa50, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineVertexInputStateCreateInfo) Deref() {
	if x.ref5fe4aa50 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5fe4aa50.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5fe4aa50.pNext))
	x.Flags = (PipelineVertexInputStateCreateFlags)(x.ref5fe4aa50.flags)
	x.VertexBindingDescriptionCount = (uint32)(x.ref5fe4aa50.vertexBindingDescriptionCount)
	packSVertexInputBindingDescription(x.PVertexBindingDescriptions, x.ref5fe4aa50.pVertexBindingDescriptions)
	x.VertexAttributeDescriptionCount = (uint32)(x.ref5fe4aa50.vertexAttributeDescriptionCount)
	packSVertexInputAttributeDescription(x.PVertexAttributeDescriptions, x.ref5fe4aa50.pVertexAttributeDescriptions)
}

// allocPipelineInputAssemblyStateCreateInfoMemory allocates memory for type C.VkPipelineInputAssemblyStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineInputAssemblyStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineInputAssemblyStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineInputAssemblyStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineInputAssemblyStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineInputAssemblyStateCreateInfo) Ref() *C.VkPipelineInputAssemblyStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref22e1691d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineInputAssemblyStateCreateInfo) Free() {
	if x != nil && x.allocs22e1691d != nil {
		x.allocs22e1691d.(*cgoAllocMap).Free()
		x.ref22e1691d = nil
	}
}

// NewPipelineInputAssemblyStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineInputAssemblyStateCreateInfoRef(ref unsafe.Pointer) *PipelineInputAssemblyStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineInputAssemblyStateCreateInfo)
	obj.ref22e1691d = (*C.VkPipelineInputAssemblyStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineInputAssemblyStateCreateInfo) PassRef() (*C.VkPipelineInputAssemblyStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref22e1691d != nil {
		return x.ref22e1691d, nil
	}
	mem22e1691d := allocPipelineInputAssemblyStateCreateInfoMemory(1)
	ref22e1691d := (*C.VkPipelineInputAssemblyStateCreateInfo)(mem22e1691d)
	allocs22e1691d := new(cgoAllocMap)
	allocs22e1691d.Add(mem22e1691d)

	var csType_allocs *cgoAllocMap
	ref22e1691d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs22e1691d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref22e1691d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs22e1691d.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref22e1691d.flags, cflags_allocs = (C.VkPipelineInputAssemblyStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs22e1691d.Borrow(cflags_allocs)

	var ctopology_allocs *cgoAllocMap
	ref22e1691d.topology, ctopology_allocs = (C.VkPrimitiveTopology)(x.Topology), cgoAllocsUnknown
	allocs22e1691d.Borrow(ctopology_allocs)

	var cprimitiveRestartEnable_allocs *cgoAllocMap
	ref22e1691d.primitiveRestartEnable, cprimitiveRestartEnable_allocs = (C.VkBool32)(x.PrimitiveRestartEnable), cgoAllocsUnknown
	allocs22e1691d.Borrow(cprimitiveRestartEnable_allocs)

	x.ref22e1691d = ref22e1691d
	x.allocs22e1691d = allocs22e1691d
	return ref22e1691d, allocs22e1691d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineInputAssemblyStateCreateInfo) PassValue() (C.VkPipelineInputAssemblyStateCreateInfo, *cgoAllocMap) {
	if x.ref22e1691d != nil {
		return *x.ref22e1691d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineInputAssemblyStateCreateInfo) Deref() {
	if x.ref22e1691d == nil {
		return
	}
	x.SType = (StructureType)(x.ref22e1691d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref22e1691d.pNext))
	x.Flags = (PipelineInputAssemblyStateCreateFlags)(x.ref22e1691d.flags)
	x.Topology = (PrimitiveTopology)(x.ref22e1691d.topology)
	x.PrimitiveRestartEnable = (Bool32)(x.ref22e1691d.primitiveRestartEnable)
}

// allocPipelineTessellationStateCreateInfoMemory allocates memory for type C.VkPipelineTessellationStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineTessellationStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineTessellationStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineTessellationStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineTessellationStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineTessellationStateCreateInfo) Ref() *C.VkPipelineTessellationStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref4ef3997a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineTessellationStateCreateInfo) Free() {
	if x != nil && x.allocs4ef3997a != nil {
		x.allocs4ef3997a.(*cgoAllocMap).Free()
		x.ref4ef3997a = nil
	}
}

// NewPipelineTessellationStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineTessellationStateCreateInfoRef(ref unsafe.Pointer) *PipelineTessellationStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineTessellationStateCreateInfo)
	obj.ref4ef3997a = (*C.VkPipelineTessellationStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineTessellationStateCreateInfo) PassRef() (*C.VkPipelineTessellationStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4ef3997a != nil {
		return x.ref4ef3997a, nil
	}
	mem4ef3997a := allocPipelineTessellationStateCreateInfoMemory(1)
	ref4ef3997a := (*C.VkPipelineTessellationStateCreateInfo)(mem4ef3997a)
	allocs4ef3997a := new(cgoAllocMap)
	allocs4ef3997a.Add(mem4ef3997a)

	var csType_allocs *cgoAllocMap
	ref4ef3997a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4ef3997a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4ef3997a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4ef3997a.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref4ef3997a.flags, cflags_allocs = (C.VkPipelineTessellationStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs4ef3997a.Borrow(cflags_allocs)

	var cpatchControlPoints_allocs *cgoAllocMap
	ref4ef3997a.patchControlPoints, cpatchControlPoints_allocs = (C.uint32_t)(x.PatchControlPoints), cgoAllocsUnknown
	allocs4ef3997a.Borrow(cpatchControlPoints_allocs)

	x.ref4ef3997a = ref4ef3997a
	x.allocs4ef3997a = allocs4ef3997a
	return ref4ef3997a, allocs4ef3997a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineTessellationStateCreateInfo) PassValue() (C.VkPipelineTessellationStateCreateInfo, *cgoAllocMap) {
	if x.ref4ef3997a != nil {
		return *x.ref4ef3997a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineTessellationStateCreateInfo) Deref() {
	if x.ref4ef3997a == nil {
		return
	}
	x.SType = (StructureType)(x.ref4ef3997a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4ef3997a.pNext))
	x.Flags = (PipelineTessellationStateCreateFlags)(x.ref4ef3997a.flags)
	x.PatchControlPoints = (uint32)(x.ref4ef3997a.patchControlPoints)
}

// allocViewportMemory allocates memory for type C.VkViewport in C.
// The caller is responsible for freeing the this memory via C.free.
func allocViewportMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfViewportValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfViewportValue = unsafe.Sizeof([1]C.VkViewport{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Viewport) Ref() *C.VkViewport {
	if x == nil {
		return nil
	}
	return x.ref75cf5291
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Viewport) Free() {
	if x != nil && x.allocs75cf5291 != nil {
		x.allocs75cf5291.(*cgoAllocMap).Free()
		x.ref75cf5291 = nil
	}
}

// NewViewportRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewViewportRef(ref unsafe.Pointer) *Viewport {
	if ref == nil {
		return nil
	}
	obj := new(Viewport)
	obj.ref75cf5291 = (*C.VkViewport)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Viewport) PassRef() (*C.VkViewport, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75cf5291 != nil {
		return x.ref75cf5291, nil
	}
	mem75cf5291 := allocViewportMemory(1)
	ref75cf5291 := (*C.VkViewport)(mem75cf5291)
	allocs75cf5291 := new(cgoAllocMap)
	allocs75cf5291.Add(mem75cf5291)

	var cx_allocs *cgoAllocMap
	ref75cf5291.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs75cf5291.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref75cf5291.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs75cf5291.Borrow(cy_allocs)

	var cwidth_allocs *cgoAllocMap
	ref75cf5291.width, cwidth_allocs = (C.float)(x.Width), cgoAllocsUnknown
	allocs75cf5291.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref75cf5291.height, cheight_allocs = (C.float)(x.Height), cgoAllocsUnknown
	allocs75cf5291.Borrow(cheight_allocs)

	var cminDepth_allocs *cgoAllocMap
	ref75cf5291.minDepth, cminDepth_allocs = (C.float)(x.MinDepth), cgoAllocsUnknown
	allocs75cf5291.Borrow(cminDepth_allocs)

	var cmaxDepth_allocs *cgoAllocMap
	ref75cf5291.maxDepth, cmaxDepth_allocs = (C.float)(x.MaxDepth), cgoAllocsUnknown
	allocs75cf5291.Borrow(cmaxDepth_allocs)

	x.ref75cf5291 = ref75cf5291
	x.allocs75cf5291 = allocs75cf5291
	return ref75cf5291, allocs75cf5291

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Viewport) PassValue() (C.VkViewport, *cgoAllocMap) {
	if x.ref75cf5291 != nil {
		return *x.ref75cf5291, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Viewport) Deref() {
	if x.ref75cf5291 == nil {
		return
	}
	x.X = (float32)(x.ref75cf5291.x)
	x.Y = (float32)(x.ref75cf5291.y)
	x.Width = (float32)(x.ref75cf5291.width)
	x.Height = (float32)(x.ref75cf5291.height)
	x.MinDepth = (float32)(x.ref75cf5291.minDepth)
	x.MaxDepth = (float32)(x.ref75cf5291.maxDepth)
}

// allocPipelineViewportStateCreateInfoMemory allocates memory for type C.VkPipelineViewportStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineViewportStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineViewportStateCreateInfo{})

// unpackSViewport transforms a sliced Go data structure into plain C format.
func unpackSViewport(x []Viewport) (unpacked *C.VkViewport, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocViewportMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkViewport)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkViewport)(h.Data)
	return
}

// unpackSRect2D transforms a sliced Go data structure into plain C format.
func unpackSRect2D(x []Rect2D) (unpacked *C.VkRect2D, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRect2DMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRect2D)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRect2D)(h.Data)
	return
}

// packSViewport reads sliced Go data structure out from plain C format.
func packSViewport(v []Viewport, ptr0 *C.VkViewport) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfViewportValue]C.VkViewport)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewViewportRef(unsafe.Pointer(&ptr1))
	}
}

// packSRect2D reads sliced Go data structure out from plain C format.
func packSRect2D(v []Rect2D, ptr0 *C.VkRect2D) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRect2DValue]C.VkRect2D)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRect2DRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportStateCreateInfo) Ref() *C.VkPipelineViewportStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc4705791
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportStateCreateInfo) Free() {
	if x != nil && x.allocsc4705791 != nil {
		x.allocsc4705791.(*cgoAllocMap).Free()
		x.refc4705791 = nil
	}
}

// NewPipelineViewportStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportStateCreateInfoRef(ref unsafe.Pointer) *PipelineViewportStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportStateCreateInfo)
	obj.refc4705791 = (*C.VkPipelineViewportStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportStateCreateInfo) PassRef() (*C.VkPipelineViewportStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc4705791 != nil {
		return x.refc4705791, nil
	}
	memc4705791 := allocPipelineViewportStateCreateInfoMemory(1)
	refc4705791 := (*C.VkPipelineViewportStateCreateInfo)(memc4705791)
	allocsc4705791 := new(cgoAllocMap)
	allocsc4705791.Add(memc4705791)

	var csType_allocs *cgoAllocMap
	refc4705791.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc4705791.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc4705791.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc4705791.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc4705791.flags, cflags_allocs = (C.VkPipelineViewportStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsc4705791.Borrow(cflags_allocs)

	var cviewportCount_allocs *cgoAllocMap
	refc4705791.viewportCount, cviewportCount_allocs = (C.uint32_t)(x.ViewportCount), cgoAllocsUnknown
	allocsc4705791.Borrow(cviewportCount_allocs)

	var cpViewports_allocs *cgoAllocMap
	refc4705791.pViewports, cpViewports_allocs = unpackSViewport(x.PViewports)
	allocsc4705791.Borrow(cpViewports_allocs)

	var cscissorCount_allocs *cgoAllocMap
	refc4705791.scissorCount, cscissorCount_allocs = (C.uint32_t)(x.ScissorCount), cgoAllocsUnknown
	allocsc4705791.Borrow(cscissorCount_allocs)

	var cpScissors_allocs *cgoAllocMap
	refc4705791.pScissors, cpScissors_allocs = unpackSRect2D(x.PScissors)
	allocsc4705791.Borrow(cpScissors_allocs)

	x.refc4705791 = refc4705791
	x.allocsc4705791 = allocsc4705791
	return refc4705791, allocsc4705791

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportStateCreateInfo) PassValue() (C.VkPipelineViewportStateCreateInfo, *cgoAllocMap) {
	if x.refc4705791 != nil {
		return *x.refc4705791, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportStateCreateInfo) Deref() {
	if x.refc4705791 == nil {
		return
	}
	x.SType = (StructureType)(x.refc4705791.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc4705791.pNext))
	x.Flags = (PipelineViewportStateCreateFlags)(x.refc4705791.flags)
	x.ViewportCount = (uint32)(x.refc4705791.viewportCount)
	packSViewport(x.PViewports, x.refc4705791.pViewports)
	x.ScissorCount = (uint32)(x.refc4705791.scissorCount)
	packSRect2D(x.PScissors, x.refc4705791.pScissors)
}

// allocPipelineRasterizationStateCreateInfoMemory allocates memory for type C.VkPipelineRasterizationStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineRasterizationStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineRasterizationStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRasterizationStateCreateInfo) Ref() *C.VkPipelineRasterizationStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref48cb9fad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRasterizationStateCreateInfo) Free() {
	if x != nil && x.allocs48cb9fad != nil {
		x.allocs48cb9fad.(*cgoAllocMap).Free()
		x.ref48cb9fad = nil
	}
}

// NewPipelineRasterizationStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRasterizationStateCreateInfoRef(ref unsafe.Pointer) *PipelineRasterizationStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRasterizationStateCreateInfo)
	obj.ref48cb9fad = (*C.VkPipelineRasterizationStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRasterizationStateCreateInfo) PassRef() (*C.VkPipelineRasterizationStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref48cb9fad != nil {
		return x.ref48cb9fad, nil
	}
	mem48cb9fad := allocPipelineRasterizationStateCreateInfoMemory(1)
	ref48cb9fad := (*C.VkPipelineRasterizationStateCreateInfo)(mem48cb9fad)
	allocs48cb9fad := new(cgoAllocMap)
	allocs48cb9fad.Add(mem48cb9fad)

	var csType_allocs *cgoAllocMap
	ref48cb9fad.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs48cb9fad.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref48cb9fad.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref48cb9fad.flags, cflags_allocs = (C.VkPipelineRasterizationStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cflags_allocs)

	var cdepthClampEnable_allocs *cgoAllocMap
	ref48cb9fad.depthClampEnable, cdepthClampEnable_allocs = (C.VkBool32)(x.DepthClampEnable), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthClampEnable_allocs)

	var crasterizerDiscardEnable_allocs *cgoAllocMap
	ref48cb9fad.rasterizerDiscardEnable, crasterizerDiscardEnable_allocs = (C.VkBool32)(x.RasterizerDiscardEnable), cgoAllocsUnknown
	allocs48cb9fad.Borrow(crasterizerDiscardEnable_allocs)

	var cpolygonMode_allocs *cgoAllocMap
	ref48cb9fad.polygonMode, cpolygonMode_allocs = (C.VkPolygonMode)(x.PolygonMode), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cpolygonMode_allocs)

	var ccullMode_allocs *cgoAllocMap
	ref48cb9fad.cullMode, ccullMode_allocs = (C.VkCullModeFlags)(x.CullMode), cgoAllocsUnknown
	allocs48cb9fad.Borrow(ccullMode_allocs)

	var cfrontFace_allocs *cgoAllocMap
	ref48cb9fad.frontFace, cfrontFace_allocs = (C.VkFrontFace)(x.FrontFace), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cfrontFace_allocs)

	var cdepthBiasEnable_allocs *cgoAllocMap
	ref48cb9fad.depthBiasEnable, cdepthBiasEnable_allocs = (C.VkBool32)(x.DepthBiasEnable), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasEnable_allocs)

	var cdepthBiasConstantFactor_allocs *cgoAllocMap
	ref48cb9fad.depthBiasConstantFactor, cdepthBiasConstantFactor_allocs = (C.float)(x.DepthBiasConstantFactor), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasConstantFactor_allocs)

	var cdepthBiasClamp_allocs *cgoAllocMap
	ref48cb9fad.depthBiasClamp, cdepthBiasClamp_allocs = (C.float)(x.DepthBiasClamp), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasClamp_allocs)

	var cdepthBiasSlopeFactor_allocs *cgoAllocMap
	ref48cb9fad.depthBiasSlopeFactor, cdepthBiasSlopeFactor_allocs = (C.float)(x.DepthBiasSlopeFactor), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasSlopeFactor_allocs)

	var clineWidth_allocs *cgoAllocMap
	ref48cb9fad.lineWidth, clineWidth_allocs = (C.float)(x.LineWidth), cgoAllocsUnknown
	allocs48cb9fad.Borrow(clineWidth_allocs)

	x.ref48cb9fad = ref48cb9fad
	x.allocs48cb9fad = allocs48cb9fad
	return ref48cb9fad, allocs48cb9fad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRasterizationStateCreateInfo) PassValue() (C.VkPipelineRasterizationStateCreateInfo, *cgoAllocMap) {
	if x.ref48cb9fad != nil {
		return *x.ref48cb9fad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRasterizationStateCreateInfo) Deref() {
	if x.ref48cb9fad == nil {
		return
	}
	x.SType = (StructureType)(x.ref48cb9fad.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref48cb9fad.pNext))
	x.Flags = (PipelineRasterizationStateCreateFlags)(x.ref48cb9fad.flags)
	x.DepthClampEnable = (Bool32)(x.ref48cb9fad.depthClampEnable)
	x.RasterizerDiscardEnable = (Bool32)(x.ref48cb9fad.rasterizerDiscardEnable)
	x.PolygonMode = (PolygonMode)(x.ref48cb9fad.polygonMode)
	x.CullMode = (CullModeFlags)(x.ref48cb9fad.cullMode)
	x.FrontFace = (FrontFace)(x.ref48cb9fad.frontFace)
	x.DepthBiasEnable = (Bool32)(x.ref48cb9fad.depthBiasEnable)
	x.DepthBiasConstantFactor = (float32)(x.ref48cb9fad.depthBiasConstantFactor)
	x.DepthBiasClamp = (float32)(x.ref48cb9fad.depthBiasClamp)
	x.DepthBiasSlopeFactor = (float32)(x.ref48cb9fad.depthBiasSlopeFactor)
	x.LineWidth = (float32)(x.ref48cb9fad.lineWidth)
}

// allocPipelineMultisampleStateCreateInfoMemory allocates memory for type C.VkPipelineMultisampleStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineMultisampleStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineMultisampleStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineMultisampleStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineMultisampleStateCreateInfo{})

// copyPSampleMaskBytes copies the data from Go slice as *C.VkSampleMask.
func copyPSampleMaskBytes(slice *sliceHeader) (*C.VkSampleMask, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSampleMaskValue) * slice.Len,
		Cap:  int(sizeOfSampleMaskValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSampleMask)(mem0), allocs
}

// allocSampleMaskMemory allocates memory for type C.VkSampleMask in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSampleMaskMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSampleMaskValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSampleMaskValue = unsafe.Sizeof([1]C.VkSampleMask{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineMultisampleStateCreateInfo) Ref() *C.VkPipelineMultisampleStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb6538bfb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineMultisampleStateCreateInfo) Free() {
	if x != nil && x.allocsb6538bfb != nil {
		x.allocsb6538bfb.(*cgoAllocMap).Free()
		x.refb6538bfb = nil
	}
}

// NewPipelineMultisampleStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineMultisampleStateCreateInfoRef(ref unsafe.Pointer) *PipelineMultisampleStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineMultisampleStateCreateInfo)
	obj.refb6538bfb = (*C.VkPipelineMultisampleStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineMultisampleStateCreateInfo) PassRef() (*C.VkPipelineMultisampleStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb6538bfb != nil {
		return x.refb6538bfb, nil
	}
	memb6538bfb := allocPipelineMultisampleStateCreateInfoMemory(1)
	refb6538bfb := (*C.VkPipelineMultisampleStateCreateInfo)(memb6538bfb)
	allocsb6538bfb := new(cgoAllocMap)
	allocsb6538bfb.Add(memb6538bfb)

	var csType_allocs *cgoAllocMap
	refb6538bfb.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb6538bfb.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb6538bfb.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refb6538bfb.flags, cflags_allocs = (C.VkPipelineMultisampleStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cflags_allocs)

	var crasterizationSamples_allocs *cgoAllocMap
	refb6538bfb.rasterizationSamples, crasterizationSamples_allocs = (C.VkSampleCountFlagBits)(x.RasterizationSamples), cgoAllocsUnknown
	allocsb6538bfb.Borrow(crasterizationSamples_allocs)

	var csampleShadingEnable_allocs *cgoAllocMap
	refb6538bfb.sampleShadingEnable, csampleShadingEnable_allocs = (C.VkBool32)(x.SampleShadingEnable), cgoAllocsUnknown
	allocsb6538bfb.Borrow(csampleShadingEnable_allocs)

	var cminSampleShading_allocs *cgoAllocMap
	refb6538bfb.minSampleShading, cminSampleShading_allocs = (C.float)(x.MinSampleShading), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cminSampleShading_allocs)

	var cpSampleMask_allocs *cgoAllocMap
	refb6538bfb.pSampleMask, cpSampleMask_allocs = copyPSampleMaskBytes((*sliceHeader)(unsafe.Pointer(&x.PSampleMask)))
	allocsb6538bfb.Borrow(cpSampleMask_allocs)

	var calphaToCoverageEnable_allocs *cgoAllocMap
	refb6538bfb.alphaToCoverageEnable, calphaToCoverageEnable_allocs = (C.VkBool32)(x.AlphaToCoverageEnable), cgoAllocsUnknown
	allocsb6538bfb.Borrow(calphaToCoverageEnable_allocs)

	var calphaToOneEnable_allocs *cgoAllocMap
	refb6538bfb.alphaToOneEnable, calphaToOneEnable_allocs = (C.VkBool32)(x.AlphaToOneEnable), cgoAllocsUnknown
	allocsb6538bfb.Borrow(calphaToOneEnable_allocs)

	x.refb6538bfb = refb6538bfb
	x.allocsb6538bfb = allocsb6538bfb
	return refb6538bfb, allocsb6538bfb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineMultisampleStateCreateInfo) PassValue() (C.VkPipelineMultisampleStateCreateInfo, *cgoAllocMap) {
	if x.refb6538bfb != nil {
		return *x.refb6538bfb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineMultisampleStateCreateInfo) Deref() {
	if x.refb6538bfb == nil {
		return
	}
	x.SType = (StructureType)(x.refb6538bfb.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb6538bfb.pNext))
	x.Flags = (PipelineMultisampleStateCreateFlags)(x.refb6538bfb.flags)
	x.RasterizationSamples = (SampleCountFlagBits)(x.refb6538bfb.rasterizationSamples)
	x.SampleShadingEnable = (Bool32)(x.refb6538bfb.sampleShadingEnable)
	x.MinSampleShading = (float32)(x.refb6538bfb.minSampleShading)
	hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&x.PSampleMask))
	hxf3b8dbd.Data = unsafe.Pointer(x.refb6538bfb.pSampleMask)
	hxf3b8dbd.Cap = 0x7fffffff
	// hxf3b8dbd.Len = ?

	x.AlphaToCoverageEnable = (Bool32)(x.refb6538bfb.alphaToCoverageEnable)
	x.AlphaToOneEnable = (Bool32)(x.refb6538bfb.alphaToOneEnable)
}

// allocStencilOpStateMemory allocates memory for type C.VkStencilOpState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStencilOpStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStencilOpStateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStencilOpStateValue = unsafe.Sizeof([1]C.VkStencilOpState{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StencilOpState) Ref() *C.VkStencilOpState {
	if x == nil {
		return nil
	}
	return x.ref28886871
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StencilOpState) Free() {
	if x != nil && x.allocs28886871 != nil {
		x.allocs28886871.(*cgoAllocMap).Free()
		x.ref28886871 = nil
	}
}

// NewStencilOpStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStencilOpStateRef(ref unsafe.Pointer) *StencilOpState {
	if ref == nil {
		return nil
	}
	obj := new(StencilOpState)
	obj.ref28886871 = (*C.VkStencilOpState)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StencilOpState) PassRef() (*C.VkStencilOpState, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref28886871 != nil {
		return x.ref28886871, nil
	}
	mem28886871 := allocStencilOpStateMemory(1)
	ref28886871 := (*C.VkStencilOpState)(mem28886871)
	allocs28886871 := new(cgoAllocMap)
	allocs28886871.Add(mem28886871)

	var cfailOp_allocs *cgoAllocMap
	ref28886871.failOp, cfailOp_allocs = (C.VkStencilOp)(x.FailOp), cgoAllocsUnknown
	allocs28886871.Borrow(cfailOp_allocs)

	var cpassOp_allocs *cgoAllocMap
	ref28886871.passOp, cpassOp_allocs = (C.VkStencilOp)(x.PassOp), cgoAllocsUnknown
	allocs28886871.Borrow(cpassOp_allocs)

	var cdepthFailOp_allocs *cgoAllocMap
	ref28886871.depthFailOp, cdepthFailOp_allocs = (C.VkStencilOp)(x.DepthFailOp), cgoAllocsUnknown
	allocs28886871.Borrow(cdepthFailOp_allocs)

	var ccompareOp_allocs *cgoAllocMap
	ref28886871.compareOp, ccompareOp_allocs = (C.VkCompareOp)(x.CompareOp), cgoAllocsUnknown
	allocs28886871.Borrow(ccompareOp_allocs)

	var ccompareMask_allocs *cgoAllocMap
	ref28886871.compareMask, ccompareMask_allocs = (C.uint32_t)(x.CompareMask), cgoAllocsUnknown
	allocs28886871.Borrow(ccompareMask_allocs)

	var cwriteMask_allocs *cgoAllocMap
	ref28886871.writeMask, cwriteMask_allocs = (C.uint32_t)(x.WriteMask), cgoAllocsUnknown
	allocs28886871.Borrow(cwriteMask_allocs)

	var creference_allocs *cgoAllocMap
	ref28886871.reference, creference_allocs = (C.uint32_t)(x.Reference), cgoAllocsUnknown
	allocs28886871.Borrow(creference_allocs)

	x.ref28886871 = ref28886871
	x.allocs28886871 = allocs28886871
	return ref28886871, allocs28886871

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StencilOpState) PassValue() (C.VkStencilOpState, *cgoAllocMap) {
	if x.ref28886871 != nil {
		return *x.ref28886871, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StencilOpState) Deref() {
	if x.ref28886871 == nil {
		return
	}
	x.FailOp = (StencilOp)(x.ref28886871.failOp)
	x.PassOp = (StencilOp)(x.ref28886871.passOp)
	x.DepthFailOp = (StencilOp)(x.ref28886871.depthFailOp)
	x.CompareOp = (CompareOp)(x.ref28886871.compareOp)
	x.CompareMask = (uint32)(x.ref28886871.compareMask)
	x.WriteMask = (uint32)(x.ref28886871.writeMask)
	x.Reference = (uint32)(x.ref28886871.reference)
}

// allocPipelineDepthStencilStateCreateInfoMemory allocates memory for type C.VkPipelineDepthStencilStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineDepthStencilStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineDepthStencilStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineDepthStencilStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineDepthStencilStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineDepthStencilStateCreateInfo) Ref() *C.VkPipelineDepthStencilStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refeabfcf1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineDepthStencilStateCreateInfo) Free() {
	if x != nil && x.allocseabfcf1 != nil {
		x.allocseabfcf1.(*cgoAllocMap).Free()
		x.refeabfcf1 = nil
	}
}

// NewPipelineDepthStencilStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineDepthStencilStateCreateInfoRef(ref unsafe.Pointer) *PipelineDepthStencilStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineDepthStencilStateCreateInfo)
	obj.refeabfcf1 = (*C.VkPipelineDepthStencilStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineDepthStencilStateCreateInfo) PassRef() (*C.VkPipelineDepthStencilStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeabfcf1 != nil {
		return x.refeabfcf1, nil
	}
	memeabfcf1 := allocPipelineDepthStencilStateCreateInfoMemory(1)
	refeabfcf1 := (*C.VkPipelineDepthStencilStateCreateInfo)(memeabfcf1)
	allocseabfcf1 := new(cgoAllocMap)
	allocseabfcf1.Add(memeabfcf1)

	var csType_allocs *cgoAllocMap
	refeabfcf1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseabfcf1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeabfcf1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseabfcf1.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refeabfcf1.flags, cflags_allocs = (C.VkPipelineDepthStencilStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocseabfcf1.Borrow(cflags_allocs)

	var cdepthTestEnable_allocs *cgoAllocMap
	refeabfcf1.depthTestEnable, cdepthTestEnable_allocs = (C.VkBool32)(x.DepthTestEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthTestEnable_allocs)

	var cdepthWriteEnable_allocs *cgoAllocMap
	refeabfcf1.depthWriteEnable, cdepthWriteEnable_allocs = (C.VkBool32)(x.DepthWriteEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthWriteEnable_allocs)

	var cdepthCompareOp_allocs *cgoAllocMap
	refeabfcf1.depthCompareOp, cdepthCompareOp_allocs = (C.VkCompareOp)(x.DepthCompareOp), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthCompareOp_allocs)

	var cdepthBoundsTestEnable_allocs *cgoAllocMap
	refeabfcf1.depthBoundsTestEnable, cdepthBoundsTestEnable_allocs = (C.VkBool32)(x.DepthBoundsTestEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthBoundsTestEnable_allocs)

	var cstencilTestEnable_allocs *cgoAllocMap
	refeabfcf1.stencilTestEnable, cstencilTestEnable_allocs = (C.VkBool32)(x.StencilTestEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cstencilTestEnable_allocs)

	var cfront_allocs *cgoAllocMap
	refeabfcf1.front, cfront_allocs = x.Front.PassValue()
	allocseabfcf1.Borrow(cfront_allocs)

	var cback_allocs *cgoAllocMap
	refeabfcf1.back, cback_allocs = x.Back.PassValue()
	allocseabfcf1.Borrow(cback_allocs)

	var cminDepthBounds_allocs *cgoAllocMap
	refeabfcf1.minDepthBounds, cminDepthBounds_allocs = (C.float)(x.MinDepthBounds), cgoAllocsUnknown
	allocseabfcf1.Borrow(cminDepthBounds_allocs)

	var cmaxDepthBounds_allocs *cgoAllocMap
	refeabfcf1.maxDepthBounds, cmaxDepthBounds_allocs = (C.float)(x.MaxDepthBounds), cgoAllocsUnknown
	allocseabfcf1.Borrow(cmaxDepthBounds_allocs)

	x.refeabfcf1 = refeabfcf1
	x.allocseabfcf1 = allocseabfcf1
	return refeabfcf1, allocseabfcf1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineDepthStencilStateCreateInfo) PassValue() (C.VkPipelineDepthStencilStateCreateInfo, *cgoAllocMap) {
	if x.refeabfcf1 != nil {
		return *x.refeabfcf1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineDepthStencilStateCreateInfo) Deref() {
	if x.refeabfcf1 == nil {
		return
	}
	x.SType = (StructureType)(x.refeabfcf1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeabfcf1.pNext))
	x.Flags = (PipelineDepthStencilStateCreateFlags)(x.refeabfcf1.flags)
	x.DepthTestEnable = (Bool32)(x.refeabfcf1.depthTestEnable)
	x.DepthWriteEnable = (Bool32)(x.refeabfcf1.depthWriteEnable)
	x.DepthCompareOp = (CompareOp)(x.refeabfcf1.depthCompareOp)
	x.DepthBoundsTestEnable = (Bool32)(x.refeabfcf1.depthBoundsTestEnable)
	x.StencilTestEnable = (Bool32)(x.refeabfcf1.stencilTestEnable)
	x.Front = *NewStencilOpStateRef(unsafe.Pointer(&x.refeabfcf1.front))
	x.Back = *NewStencilOpStateRef(unsafe.Pointer(&x.refeabfcf1.back))
	x.MinDepthBounds = (float32)(x.refeabfcf1.minDepthBounds)
	x.MaxDepthBounds = (float32)(x.refeabfcf1.maxDepthBounds)
}

// allocPipelineColorBlendAttachmentStateMemory allocates memory for type C.VkPipelineColorBlendAttachmentState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineColorBlendAttachmentStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineColorBlendAttachmentStateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineColorBlendAttachmentStateValue = unsafe.Sizeof([1]C.VkPipelineColorBlendAttachmentState{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineColorBlendAttachmentState) Ref() *C.VkPipelineColorBlendAttachmentState {
	if x == nil {
		return nil
	}
	return x.ref9e889477
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineColorBlendAttachmentState) Free() {
	if x != nil && x.allocs9e889477 != nil {
		x.allocs9e889477.(*cgoAllocMap).Free()
		x.ref9e889477 = nil
	}
}

// NewPipelineColorBlendAttachmentStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineColorBlendAttachmentStateRef(ref unsafe.Pointer) *PipelineColorBlendAttachmentState {
	if ref == nil {
		return nil
	}
	obj := new(PipelineColorBlendAttachmentState)
	obj.ref9e889477 = (*C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineColorBlendAttachmentState) PassRef() (*C.VkPipelineColorBlendAttachmentState, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9e889477 != nil {
		return x.ref9e889477, nil
	}
	mem9e889477 := allocPipelineColorBlendAttachmentStateMemory(1)
	ref9e889477 := (*C.VkPipelineColorBlendAttachmentState)(mem9e889477)
	allocs9e889477 := new(cgoAllocMap)
	allocs9e889477.Add(mem9e889477)

	var cblendEnable_allocs *cgoAllocMap
	ref9e889477.blendEnable, cblendEnable_allocs = (C.VkBool32)(x.BlendEnable), cgoAllocsUnknown
	allocs9e889477.Borrow(cblendEnable_allocs)

	var csrcColorBlendFactor_allocs *cgoAllocMap
	ref9e889477.srcColorBlendFactor, csrcColorBlendFactor_allocs = (C.VkBlendFactor)(x.SrcColorBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(csrcColorBlendFactor_allocs)

	var cdstColorBlendFactor_allocs *cgoAllocMap
	ref9e889477.dstColorBlendFactor, cdstColorBlendFactor_allocs = (C.VkBlendFactor)(x.DstColorBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(cdstColorBlendFactor_allocs)

	var ccolorBlendOp_allocs *cgoAllocMap
	ref9e889477.colorBlendOp, ccolorBlendOp_allocs = (C.VkBlendOp)(x.ColorBlendOp), cgoAllocsUnknown
	allocs9e889477.Borrow(ccolorBlendOp_allocs)

	var csrcAlphaBlendFactor_allocs *cgoAllocMap
	ref9e889477.srcAlphaBlendFactor, csrcAlphaBlendFactor_allocs = (C.VkBlendFactor)(x.SrcAlphaBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(csrcAlphaBlendFactor_allocs)

	var cdstAlphaBlendFactor_allocs *cgoAllocMap
	ref9e889477.dstAlphaBlendFactor, cdstAlphaBlendFactor_allocs = (C.VkBlendFactor)(x.DstAlphaBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(cdstAlphaBlendFactor_allocs)

	var calphaBlendOp_allocs *cgoAllocMap
	ref9e889477.alphaBlendOp, calphaBlendOp_allocs = (C.VkBlendOp)(x.AlphaBlendOp), cgoAllocsUnknown
	allocs9e889477.Borrow(calphaBlendOp_allocs)

	var ccolorWriteMask_allocs *cgoAllocMap
	ref9e889477.colorWriteMask, ccolorWriteMask_allocs = (C.VkColorComponentFlags)(x.ColorWriteMask), cgoAllocsUnknown
	allocs9e889477.Borrow(ccolorWriteMask_allocs)

	x.ref9e889477 = ref9e889477
	x.allocs9e889477 = allocs9e889477
	return ref9e889477, allocs9e889477

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineColorBlendAttachmentState) PassValue() (C.VkPipelineColorBlendAttachmentState, *cgoAllocMap) {
	if x.ref9e889477 != nil {
		return *x.ref9e889477, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineColorBlendAttachmentState) Deref() {
	if x.ref9e889477 == nil {
		return
	}
	x.BlendEnable = (Bool32)(x.ref9e889477.blendEnable)
	x.SrcColorBlendFactor = (BlendFactor)(x.ref9e889477.srcColorBlendFactor)
	x.DstColorBlendFactor = (BlendFactor)(x.ref9e889477.dstColorBlendFactor)
	x.ColorBlendOp = (BlendOp)(x.ref9e889477.colorBlendOp)
	x.SrcAlphaBlendFactor = (BlendFactor)(x.ref9e889477.srcAlphaBlendFactor)
	x.DstAlphaBlendFactor = (BlendFactor)(x.ref9e889477.dstAlphaBlendFactor)
	x.AlphaBlendOp = (BlendOp)(x.ref9e889477.alphaBlendOp)
	x.ColorWriteMask = (ColorComponentFlags)(x.ref9e889477.colorWriteMask)
}

// allocPipelineColorBlendStateCreateInfoMemory allocates memory for type C.VkPipelineColorBlendStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineColorBlendStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineColorBlendStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineColorBlendStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineColorBlendStateCreateInfo{})

// unpackSPipelineColorBlendAttachmentState transforms a sliced Go data structure into plain C format.
func unpackSPipelineColorBlendAttachmentState(x []PipelineColorBlendAttachmentState) (unpacked *C.VkPipelineColorBlendAttachmentState, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineColorBlendAttachmentStateMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineColorBlendAttachmentState)(h.Data)
	return
}

// packSPipelineColorBlendAttachmentState reads sliced Go data structure out from plain C format.
func packSPipelineColorBlendAttachmentState(v []PipelineColorBlendAttachmentState, ptr0 *C.VkPipelineColorBlendAttachmentState) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineColorBlendAttachmentStateValue]C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineColorBlendAttachmentStateRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineColorBlendStateCreateInfo) Ref() *C.VkPipelineColorBlendStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref2a9b490b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineColorBlendStateCreateInfo) Free() {
	if x != nil && x.allocs2a9b490b != nil {
		x.allocs2a9b490b.(*cgoAllocMap).Free()
		x.ref2a9b490b = nil
	}
}

// NewPipelineColorBlendStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineColorBlendStateCreateInfoRef(ref unsafe.Pointer) *PipelineColorBlendStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineColorBlendStateCreateInfo)
	obj.ref2a9b490b = (*C.VkPipelineColorBlendStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineColorBlendStateCreateInfo) PassRef() (*C.VkPipelineColorBlendStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2a9b490b != nil {
		return x.ref2a9b490b, nil
	}
	mem2a9b490b := allocPipelineColorBlendStateCreateInfoMemory(1)
	ref2a9b490b := (*C.VkPipelineColorBlendStateCreateInfo)(mem2a9b490b)
	allocs2a9b490b := new(cgoAllocMap)
	allocs2a9b490b.Add(mem2a9b490b)

	var csType_allocs *cgoAllocMap
	ref2a9b490b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2a9b490b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2a9b490b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref2a9b490b.flags, cflags_allocs = (C.VkPipelineColorBlendStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cflags_allocs)

	var clogicOpEnable_allocs *cgoAllocMap
	ref2a9b490b.logicOpEnable, clogicOpEnable_allocs = (C.VkBool32)(x.LogicOpEnable), cgoAllocsUnknown
	allocs2a9b490b.Borrow(clogicOpEnable_allocs)

	var clogicOp_allocs *cgoAllocMap
	ref2a9b490b.logicOp, clogicOp_allocs = (C.VkLogicOp)(x.LogicOp), cgoAllocsUnknown
	allocs2a9b490b.Borrow(clogicOp_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	ref2a9b490b.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	ref2a9b490b.pAttachments, cpAttachments_allocs = unpackSPipelineColorBlendAttachmentState(x.PAttachments)
	allocs2a9b490b.Borrow(cpAttachments_allocs)

	var cblendConstants_allocs *cgoAllocMap
	ref2a9b490b.blendConstants, cblendConstants_allocs = *(*[4]C.float)(unsafe.Pointer(&x.BlendConstants)), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cblendConstants_allocs)

	x.ref2a9b490b = ref2a9b490b
	x.allocs2a9b490b = allocs2a9b490b
	return ref2a9b490b, allocs2a9b490b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineColorBlendStateCreateInfo) PassValue() (C.VkPipelineColorBlendStateCreateInfo, *cgoAllocMap) {
	if x.ref2a9b490b != nil {
		return *x.ref2a9b490b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineColorBlendStateCreateInfo) Deref() {
	if x.ref2a9b490b == nil {
		return
	}
	x.SType = (StructureType)(x.ref2a9b490b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2a9b490b.pNext))
	x.Flags = (PipelineColorBlendStateCreateFlags)(x.ref2a9b490b.flags)
	x.LogicOpEnable = (Bool32)(x.ref2a9b490b.logicOpEnable)
	x.LogicOp = (LogicOp)(x.ref2a9b490b.logicOp)
	x.AttachmentCount = (uint32)(x.ref2a9b490b.attachmentCount)
	packSPipelineColorBlendAttachmentState(x.PAttachments, x.ref2a9b490b.pAttachments)
	x.BlendConstants = *(*[4]float32)(unsafe.Pointer(&x.ref2a9b490b.blendConstants))
}

// allocPipelineDynamicStateCreateInfoMemory allocates memory for type C.VkPipelineDynamicStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineDynamicStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineDynamicStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineDynamicStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineDynamicStateCreateInfo{})

// copyPDynamicStateBytes copies the data from Go slice as *C.VkDynamicState.
func copyPDynamicStateBytes(slice *sliceHeader) (*C.VkDynamicState, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDynamicStateValue) * slice.Len,
		Cap:  int(sizeOfDynamicStateValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDynamicState)(mem0), allocs
}

// allocDynamicStateMemory allocates memory for type C.VkDynamicState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDynamicStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDynamicStateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDynamicStateValue = unsafe.Sizeof([1]C.VkDynamicState{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineDynamicStateCreateInfo) Ref() *C.VkPipelineDynamicStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref246d7bc8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineDynamicStateCreateInfo) Free() {
	if x != nil && x.allocs246d7bc8 != nil {
		x.allocs246d7bc8.(*cgoAllocMap).Free()
		x.ref246d7bc8 = nil
	}
}

// NewPipelineDynamicStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineDynamicStateCreateInfoRef(ref unsafe.Pointer) *PipelineDynamicStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineDynamicStateCreateInfo)
	obj.ref246d7bc8 = (*C.VkPipelineDynamicStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineDynamicStateCreateInfo) PassRef() (*C.VkPipelineDynamicStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref246d7bc8 != nil {
		return x.ref246d7bc8, nil
	}
	mem246d7bc8 := allocPipelineDynamicStateCreateInfoMemory(1)
	ref246d7bc8 := (*C.VkPipelineDynamicStateCreateInfo)(mem246d7bc8)
	allocs246d7bc8 := new(cgoAllocMap)
	allocs246d7bc8.Add(mem246d7bc8)

	var csType_allocs *cgoAllocMap
	ref246d7bc8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs246d7bc8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref246d7bc8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref246d7bc8.flags, cflags_allocs = (C.VkPipelineDynamicStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cflags_allocs)

	var cdynamicStateCount_allocs *cgoAllocMap
	ref246d7bc8.dynamicStateCount, cdynamicStateCount_allocs = (C.uint32_t)(x.DynamicStateCount), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cdynamicStateCount_allocs)

	var cpDynamicStates_allocs *cgoAllocMap
	ref246d7bc8.pDynamicStates, cpDynamicStates_allocs = copyPDynamicStateBytes((*sliceHeader)(unsafe.Pointer(&x.PDynamicStates)))
	allocs246d7bc8.Borrow(cpDynamicStates_allocs)

	x.ref246d7bc8 = ref246d7bc8
	x.allocs246d7bc8 = allocs246d7bc8
	return ref246d7bc8, allocs246d7bc8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineDynamicStateCreateInfo) PassValue() (C.VkPipelineDynamicStateCreateInfo, *cgoAllocMap) {
	if x.ref246d7bc8 != nil {
		return *x.ref246d7bc8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineDynamicStateCreateInfo) Deref() {
	if x.ref246d7bc8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref246d7bc8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref246d7bc8.pNext))
	x.Flags = (PipelineDynamicStateCreateFlags)(x.ref246d7bc8.flags)
	x.DynamicStateCount = (uint32)(x.ref246d7bc8.dynamicStateCount)
	hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&x.PDynamicStates))
	hxf7a6dff.Data = unsafe.Pointer(x.ref246d7bc8.pDynamicStates)
	hxf7a6dff.Cap = 0x7fffffff
	// hxf7a6dff.Len = ?

}

// allocGraphicsPipelineCreateInfoMemory allocates memory for type C.VkGraphicsPipelineCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGraphicsPipelineCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGraphicsPipelineCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGraphicsPipelineCreateInfoValue = unsafe.Sizeof([1]C.VkGraphicsPipelineCreateInfo{})

// unpackSPipelineShaderStageCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineShaderStageCreateInfo(x []PipelineShaderStageCreateInfo) (unpacked *C.VkPipelineShaderStageCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineShaderStageCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineShaderStageCreateInfo)(h.Data)
	return
}

// packSPipelineShaderStageCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineShaderStageCreateInfo(v []PipelineShaderStageCreateInfo, ptr0 *C.VkPipelineShaderStageCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineShaderStageCreateInfoValue]C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineShaderStageCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GraphicsPipelineCreateInfo) Ref() *C.VkGraphicsPipelineCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref178f88b6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GraphicsPipelineCreateInfo) Free() {
	if x != nil && x.allocs178f88b6 != nil {
		x.allocs178f88b6.(*cgoAllocMap).Free()
		x.ref178f88b6 = nil
	}
}

// NewGraphicsPipelineCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGraphicsPipelineCreateInfoRef(ref unsafe.Pointer) *GraphicsPipelineCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(GraphicsPipelineCreateInfo)
	obj.ref178f88b6 = (*C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GraphicsPipelineCreateInfo) PassRef() (*C.VkGraphicsPipelineCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref178f88b6 != nil {
		return x.ref178f88b6, nil
	}
	mem178f88b6 := allocGraphicsPipelineCreateInfoMemory(1)
	ref178f88b6 := (*C.VkGraphicsPipelineCreateInfo)(mem178f88b6)
	allocs178f88b6 := new(cgoAllocMap)
	allocs178f88b6.Add(mem178f88b6)

	var csType_allocs *cgoAllocMap
	ref178f88b6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs178f88b6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref178f88b6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs178f88b6.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref178f88b6.flags, cflags_allocs = (C.VkPipelineCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs178f88b6.Borrow(cflags_allocs)

	var cstageCount_allocs *cgoAllocMap
	ref178f88b6.stageCount, cstageCount_allocs = (C.uint32_t)(x.StageCount), cgoAllocsUnknown
	allocs178f88b6.Borrow(cstageCount_allocs)

	var cpStages_allocs *cgoAllocMap
	ref178f88b6.pStages, cpStages_allocs = unpackSPipelineShaderStageCreateInfo(x.PStages)
	allocs178f88b6.Borrow(cpStages_allocs)

	var cpVertexInputState_allocs *cgoAllocMap
	ref178f88b6.pVertexInputState, cpVertexInputState_allocs = x.PVertexInputState.PassRef()
	allocs178f88b6.Borrow(cpVertexInputState_allocs)

	var cpInputAssemblyState_allocs *cgoAllocMap
	ref178f88b6.pInputAssemblyState, cpInputAssemblyState_allocs = x.PInputAssemblyState.PassRef()
	allocs178f88b6.Borrow(cpInputAssemblyState_allocs)

	var cpTessellationState_allocs *cgoAllocMap
	ref178f88b6.pTessellationState, cpTessellationState_allocs = x.PTessellationState.PassRef()
	allocs178f88b6.Borrow(cpTessellationState_allocs)

	var cpViewportState_allocs *cgoAllocMap
	ref178f88b6.pViewportState, cpViewportState_allocs = x.PViewportState.PassRef()
	allocs178f88b6.Borrow(cpViewportState_allocs)

	var cpRasterizationState_allocs *cgoAllocMap
	ref178f88b6.pRasterizationState, cpRasterizationState_allocs = x.PRasterizationState.PassRef()
	allocs178f88b6.Borrow(cpRasterizationState_allocs)

	var cpMultisampleState_allocs *cgoAllocMap
	ref178f88b6.pMultisampleState, cpMultisampleState_allocs = x.PMultisampleState.PassRef()
	allocs178f88b6.Borrow(cpMultisampleState_allocs)

	var cpDepthStencilState_allocs *cgoAllocMap
	ref178f88b6.pDepthStencilState, cpDepthStencilState_allocs = x.PDepthStencilState.PassRef()
	allocs178f88b6.Borrow(cpDepthStencilState_allocs)

	var cpColorBlendState_allocs *cgoAllocMap
	ref178f88b6.pColorBlendState, cpColorBlendState_allocs = x.PColorBlendState.PassRef()
	allocs178f88b6.Borrow(cpColorBlendState_allocs)

	var cpDynamicState_allocs *cgoAllocMap
	ref178f88b6.pDynamicState, cpDynamicState_allocs = x.PDynamicState.PassRef()
	allocs178f88b6.Borrow(cpDynamicState_allocs)

	var clayout_allocs *cgoAllocMap
	ref178f88b6.layout, clayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.Layout)), cgoAllocsUnknown
	allocs178f88b6.Borrow(clayout_allocs)

	var crenderPass_allocs *cgoAllocMap
	ref178f88b6.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocs178f88b6.Borrow(crenderPass_allocs)

	var csubpass_allocs *cgoAllocMap
	ref178f88b6.subpass, csubpass_allocs = (C.uint32_t)(x.Subpass), cgoAllocsUnknown
	allocs178f88b6.Borrow(csubpass_allocs)

	var cbasePipelineHandle_allocs *cgoAllocMap
	ref178f88b6.basePipelineHandle, cbasePipelineHandle_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.BasePipelineHandle)), cgoAllocsUnknown
	allocs178f88b6.Borrow(cbasePipelineHandle_allocs)

	var cbasePipelineIndex_allocs *cgoAllocMap
	ref178f88b6.basePipelineIndex, cbasePipelineIndex_allocs = (C.int32_t)(x.BasePipelineIndex), cgoAllocsUnknown
	allocs178f88b6.Borrow(cbasePipelineIndex_allocs)

	x.ref178f88b6 = ref178f88b6
	x.allocs178f88b6 = allocs178f88b6
	return ref178f88b6, allocs178f88b6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GraphicsPipelineCreateInfo) PassValue() (C.VkGraphicsPipelineCreateInfo, *cgoAllocMap) {
	if x.ref178f88b6 != nil {
		return *x.ref178f88b6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GraphicsPipelineCreateInfo) Deref() {
	if x.ref178f88b6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref178f88b6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref178f88b6.pNext))
	x.Flags = (PipelineCreateFlags)(x.ref178f88b6.flags)
	x.StageCount = (uint32)(x.ref178f88b6.stageCount)
	packSPipelineShaderStageCreateInfo(x.PStages, x.ref178f88b6.pStages)
	x.PVertexInputState = NewPipelineVertexInputStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pVertexInputState))
	x.PInputAssemblyState = NewPipelineInputAssemblyStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pInputAssemblyState))
	x.PTessellationState = NewPipelineTessellationStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pTessellationState))
	x.PViewportState = NewPipelineViewportStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pViewportState))
	x.PRasterizationState = NewPipelineRasterizationStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pRasterizationState))
	x.PMultisampleState = NewPipelineMultisampleStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pMultisampleState))
	x.PDepthStencilState = NewPipelineDepthStencilStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pDepthStencilState))
	x.PColorBlendState = NewPipelineColorBlendStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pColorBlendState))
	x.PDynamicState = NewPipelineDynamicStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pDynamicState))
	x.Layout = *(*PipelineLayout)(unsafe.Pointer(&x.ref178f88b6.layout))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref178f88b6.renderPass))
	x.Subpass = (uint32)(x.ref178f88b6.subpass)
	x.BasePipelineHandle = *(*Pipeline)(unsafe.Pointer(&x.ref178f88b6.basePipelineHandle))
	x.BasePipelineIndex = (int32)(x.ref178f88b6.basePipelineIndex)
}

// allocPushConstantRangeMemory allocates memory for type C.VkPushConstantRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPushConstantRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPushConstantRangeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPushConstantRangeValue = unsafe.Sizeof([1]C.VkPushConstantRange{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PushConstantRange) Ref() *C.VkPushConstantRange {
	if x == nil {
		return nil
	}
	return x.ref6f025856
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PushConstantRange) Free() {
	if x != nil && x.allocs6f025856 != nil {
		x.allocs6f025856.(*cgoAllocMap).Free()
		x.ref6f025856 = nil
	}
}

// NewPushConstantRangeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPushConstantRangeRef(ref unsafe.Pointer) *PushConstantRange {
	if ref == nil {
		return nil
	}
	obj := new(PushConstantRange)
	obj.ref6f025856 = (*C.VkPushConstantRange)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PushConstantRange) PassRef() (*C.VkPushConstantRange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6f025856 != nil {
		return x.ref6f025856, nil
	}
	mem6f025856 := allocPushConstantRangeMemory(1)
	ref6f025856 := (*C.VkPushConstantRange)(mem6f025856)
	allocs6f025856 := new(cgoAllocMap)
	allocs6f025856.Add(mem6f025856)

	var cstageFlags_allocs *cgoAllocMap
	ref6f025856.stageFlags, cstageFlags_allocs = (C.VkShaderStageFlags)(x.StageFlags), cgoAllocsUnknown
	allocs6f025856.Borrow(cstageFlags_allocs)

	var coffset_allocs *cgoAllocMap
	ref6f025856.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocs6f025856.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref6f025856.size, csize_allocs = (C.uint32_t)(x.Size), cgoAllocsUnknown
	allocs6f025856.Borrow(csize_allocs)

	x.ref6f025856 = ref6f025856
	x.allocs6f025856 = allocs6f025856
	return ref6f025856, allocs6f025856

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PushConstantRange) PassValue() (C.VkPushConstantRange, *cgoAllocMap) {
	if x.ref6f025856 != nil {
		return *x.ref6f025856, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PushConstantRange) Deref() {
	if x.ref6f025856 == nil {
		return
	}
	x.StageFlags = (ShaderStageFlags)(x.ref6f025856.stageFlags)
	x.Offset = (uint32)(x.ref6f025856.offset)
	x.Size = (uint32)(x.ref6f025856.size)
}

// allocPipelineLayoutCreateInfoMemory allocates memory for type C.VkPipelineLayoutCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineLayoutCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineLayoutCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineLayoutCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineLayoutCreateInfo{})

// copyPDescriptorSetLayoutBytes copies the data from Go slice as *C.VkDescriptorSetLayout.
func copyPDescriptorSetLayoutBytes(slice *sliceHeader) (*C.VkDescriptorSetLayout, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDescriptorSetLayoutValue) * slice.Len,
		Cap:  int(sizeOfDescriptorSetLayoutValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDescriptorSetLayout)(mem0), allocs
}

// allocDescriptorSetLayoutMemory allocates memory for type C.VkDescriptorSetLayout in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorSetLayoutValue = unsafe.Sizeof([1]C.VkDescriptorSetLayout{})

// unpackSPushConstantRange transforms a sliced Go data structure into plain C format.
func unpackSPushConstantRange(x []PushConstantRange) (unpacked *C.VkPushConstantRange, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPushConstantRangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPushConstantRange)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPushConstantRange)(h.Data)
	return
}

// packSPushConstantRange reads sliced Go data structure out from plain C format.
func packSPushConstantRange(v []PushConstantRange, ptr0 *C.VkPushConstantRange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPushConstantRangeValue]C.VkPushConstantRange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPushConstantRangeRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineLayoutCreateInfo) Ref() *C.VkPipelineLayoutCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref64cc4eed
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineLayoutCreateInfo) Free() {
	if x != nil && x.allocs64cc4eed != nil {
		x.allocs64cc4eed.(*cgoAllocMap).Free()
		x.ref64cc4eed = nil
	}
}

// NewPipelineLayoutCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineLayoutCreateInfoRef(ref unsafe.Pointer) *PipelineLayoutCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineLayoutCreateInfo)
	obj.ref64cc4eed = (*C.VkPipelineLayoutCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineLayoutCreateInfo) PassRef() (*C.VkPipelineLayoutCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref64cc4eed != nil {
		return x.ref64cc4eed, nil
	}
	mem64cc4eed := allocPipelineLayoutCreateInfoMemory(1)
	ref64cc4eed := (*C.VkPipelineLayoutCreateInfo)(mem64cc4eed)
	allocs64cc4eed := new(cgoAllocMap)
	allocs64cc4eed.Add(mem64cc4eed)

	var csType_allocs *cgoAllocMap
	ref64cc4eed.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs64cc4eed.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref64cc4eed.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref64cc4eed.flags, cflags_allocs = (C.VkPipelineLayoutCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cflags_allocs)

	var csetLayoutCount_allocs *cgoAllocMap
	ref64cc4eed.setLayoutCount, csetLayoutCount_allocs = (C.uint32_t)(x.SetLayoutCount), cgoAllocsUnknown
	allocs64cc4eed.Borrow(csetLayoutCount_allocs)

	var cpSetLayouts_allocs *cgoAllocMap
	ref64cc4eed.pSetLayouts, cpSetLayouts_allocs = copyPDescriptorSetLayoutBytes((*sliceHeader)(unsafe.Pointer(&x.PSetLayouts)))
	allocs64cc4eed.Borrow(cpSetLayouts_allocs)

	var cpushConstantRangeCount_allocs *cgoAllocMap
	ref64cc4eed.pushConstantRangeCount, cpushConstantRangeCount_allocs = (C.uint32_t)(x.PushConstantRangeCount), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cpushConstantRangeCount_allocs)

	var cpPushConstantRanges_allocs *cgoAllocMap
	ref64cc4eed.pPushConstantRanges, cpPushConstantRanges_allocs = unpackSPushConstantRange(x.PPushConstantRanges)
	allocs64cc4eed.Borrow(cpPushConstantRanges_allocs)

	x.ref64cc4eed = ref64cc4eed
	x.allocs64cc4eed = allocs64cc4eed
	return ref64cc4eed, allocs64cc4eed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineLayoutCreateInfo) PassValue() (C.VkPipelineLayoutCreateInfo, *cgoAllocMap) {
	if x.ref64cc4eed != nil {
		return *x.ref64cc4eed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineLayoutCreateInfo) Deref() {
	if x.ref64cc4eed == nil {
		return
	}
	x.SType = (StructureType)(x.ref64cc4eed.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref64cc4eed.pNext))
	x.Flags = (PipelineLayoutCreateFlags)(x.ref64cc4eed.flags)
	x.SetLayoutCount = (uint32)(x.ref64cc4eed.setLayoutCount)
	hxfe48d67 := (*sliceHeader)(unsafe.Pointer(&x.PSetLayouts))
	hxfe48d67.Data = unsafe.Pointer(x.ref64cc4eed.pSetLayouts)
	hxfe48d67.Cap = 0x7fffffff
	// hxfe48d67.Len = ?

	x.PushConstantRangeCount = (uint32)(x.ref64cc4eed.pushConstantRangeCount)
	packSPushConstantRange(x.PPushConstantRanges, x.ref64cc4eed.pPushConstantRanges)
}

// allocSamplerCreateInfoMemory allocates memory for type C.VkSamplerCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSamplerCreateInfoValue = unsafe.Sizeof([1]C.VkSamplerCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerCreateInfo) Ref() *C.VkSamplerCreateInfo {
	if x == nil {
		return nil
	}
	return x.refce034abf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerCreateInfo) Free() {
	if x != nil && x.allocsce034abf != nil {
		x.allocsce034abf.(*cgoAllocMap).Free()
		x.refce034abf = nil
	}
}

// NewSamplerCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerCreateInfoRef(ref unsafe.Pointer) *SamplerCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SamplerCreateInfo)
	obj.refce034abf = (*C.VkSamplerCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerCreateInfo) PassRef() (*C.VkSamplerCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refce034abf != nil {
		return x.refce034abf, nil
	}
	memce034abf := allocSamplerCreateInfoMemory(1)
	refce034abf := (*C.VkSamplerCreateInfo)(memce034abf)
	allocsce034abf := new(cgoAllocMap)
	allocsce034abf.Add(memce034abf)

	var csType_allocs *cgoAllocMap
	refce034abf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsce034abf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refce034abf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsce034abf.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refce034abf.flags, cflags_allocs = (C.VkSamplerCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsce034abf.Borrow(cflags_allocs)

	var cmagFilter_allocs *cgoAllocMap
	refce034abf.magFilter, cmagFilter_allocs = (C.VkFilter)(x.MagFilter), cgoAllocsUnknown
	allocsce034abf.Borrow(cmagFilter_allocs)

	var cminFilter_allocs *cgoAllocMap
	refce034abf.minFilter, cminFilter_allocs = (C.VkFilter)(x.MinFilter), cgoAllocsUnknown
	allocsce034abf.Borrow(cminFilter_allocs)

	var cmipmapMode_allocs *cgoAllocMap
	refce034abf.mipmapMode, cmipmapMode_allocs = (C.VkSamplerMipmapMode)(x.MipmapMode), cgoAllocsUnknown
	allocsce034abf.Borrow(cmipmapMode_allocs)

	var caddressModeU_allocs *cgoAllocMap
	refce034abf.addressModeU, caddressModeU_allocs = (C.VkSamplerAddressMode)(x.AddressModeU), cgoAllocsUnknown
	allocsce034abf.Borrow(caddressModeU_allocs)

	var caddressModeV_allocs *cgoAllocMap
	refce034abf.addressModeV, caddressModeV_allocs = (C.VkSamplerAddressMode)(x.AddressModeV), cgoAllocsUnknown
	allocsce034abf.Borrow(caddressModeV_allocs)

	var caddressModeW_allocs *cgoAllocMap
	refce034abf.addressModeW, caddressModeW_allocs = (C.VkSamplerAddressMode)(x.AddressModeW), cgoAllocsUnknown
	allocsce034abf.Borrow(caddressModeW_allocs)

	var cmipLodBias_allocs *cgoAllocMap
	refce034abf.mipLodBias, cmipLodBias_allocs = (C.float)(x.MipLodBias), cgoAllocsUnknown
	allocsce034abf.Borrow(cmipLodBias_allocs)

	var canisotropyEnable_allocs *cgoAllocMap
	refce034abf.anisotropyEnable, canisotropyEnable_allocs = (C.VkBool32)(x.AnisotropyEnable), cgoAllocsUnknown
	allocsce034abf.Borrow(canisotropyEnable_allocs)

	var cmaxAnisotropy_allocs *cgoAllocMap
	refce034abf.maxAnisotropy, cmaxAnisotropy_allocs = (C.float)(x.MaxAnisotropy), cgoAllocsUnknown
	allocsce034abf.Borrow(cmaxAnisotropy_allocs)

	var ccompareEnable_allocs *cgoAllocMap
	refce034abf.compareEnable, ccompareEnable_allocs = (C.VkBool32)(x.CompareEnable), cgoAllocsUnknown
	allocsce034abf.Borrow(ccompareEnable_allocs)

	var ccompareOp_allocs *cgoAllocMap
	refce034abf.compareOp, ccompareOp_allocs = (C.VkCompareOp)(x.CompareOp), cgoAllocsUnknown
	allocsce034abf.Borrow(ccompareOp_allocs)

	var cminLod_allocs *cgoAllocMap
	refce034abf.minLod, cminLod_allocs = (C.float)(x.MinLod), cgoAllocsUnknown
	allocsce034abf.Borrow(cminLod_allocs)

	var cmaxLod_allocs *cgoAllocMap
	refce034abf.maxLod, cmaxLod_allocs = (C.float)(x.MaxLod), cgoAllocsUnknown
	allocsce034abf.Borrow(cmaxLod_allocs)

	var cborderColor_allocs *cgoAllocMap
	refce034abf.borderColor, cborderColor_allocs = (C.VkBorderColor)(x.BorderColor), cgoAllocsUnknown
	allocsce034abf.Borrow(cborderColor_allocs)

	var cunnormalizedCoordinates_allocs *cgoAllocMap
	refce034abf.unnormalizedCoordinates, cunnormalizedCoordinates_allocs = (C.VkBool32)(x.UnnormalizedCoordinates), cgoAllocsUnknown
	allocsce034abf.Borrow(cunnormalizedCoordinates_allocs)

	x.refce034abf = refce034abf
	x.allocsce034abf = allocsce034abf
	return refce034abf, allocsce034abf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerCreateInfo) PassValue() (C.VkSamplerCreateInfo, *cgoAllocMap) {
	if x.refce034abf != nil {
		return *x.refce034abf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerCreateInfo) Deref() {
	if x.refce034abf == nil {
		return
	}
	x.SType = (StructureType)(x.refce034abf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refce034abf.pNext))
	x.Flags = (SamplerCreateFlags)(x.refce034abf.flags)
	x.MagFilter = (Filter)(x.refce034abf.magFilter)
	x.MinFilter = (Filter)(x.refce034abf.minFilter)
	x.MipmapMode = (SamplerMipmapMode)(x.refce034abf.mipmapMode)
	x.AddressModeU = (SamplerAddressMode)(x.refce034abf.addressModeU)
	x.AddressModeV = (SamplerAddressMode)(x.refce034abf.addressModeV)
	x.AddressModeW = (SamplerAddressMode)(x.refce034abf.addressModeW)
	x.MipLodBias = (float32)(x.refce034abf.mipLodBias)
	x.AnisotropyEnable = (Bool32)(x.refce034abf.anisotropyEnable)
	x.MaxAnisotropy = (float32)(x.refce034abf.maxAnisotropy)
	x.CompareEnable = (Bool32)(x.refce034abf.compareEnable)
	x.CompareOp = (CompareOp)(x.refce034abf.compareOp)
	x.MinLod = (float32)(x.refce034abf.minLod)
	x.MaxLod = (float32)(x.refce034abf.maxLod)
	x.BorderColor = (BorderColor)(x.refce034abf.borderColor)
	x.UnnormalizedCoordinates = (Bool32)(x.refce034abf.unnormalizedCoordinates)
}

// allocCopyDescriptorSetMemory allocates memory for type C.VkCopyDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyDescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyDescriptorSetValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCopyDescriptorSetValue = unsafe.Sizeof([1]C.VkCopyDescriptorSet{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CopyDescriptorSet) Ref() *C.VkCopyDescriptorSet {
	if x == nil {
		return nil
	}
	return x.reffe237a3a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CopyDescriptorSet) Free() {
	if x != nil && x.allocsfe237a3a != nil {
		x.allocsfe237a3a.(*cgoAllocMap).Free()
		x.reffe237a3a = nil
	}
}

// NewCopyDescriptorSetRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCopyDescriptorSetRef(ref unsafe.Pointer) *CopyDescriptorSet {
	if ref == nil {
		return nil
	}
	obj := new(CopyDescriptorSet)
	obj.reffe237a3a = (*C.VkCopyDescriptorSet)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CopyDescriptorSet) PassRef() (*C.VkCopyDescriptorSet, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe237a3a != nil {
		return x.reffe237a3a, nil
	}
	memfe237a3a := allocCopyDescriptorSetMemory(1)
	reffe237a3a := (*C.VkCopyDescriptorSet)(memfe237a3a)
	allocsfe237a3a := new(cgoAllocMap)
	allocsfe237a3a.Add(memfe237a3a)

	var csType_allocs *cgoAllocMap
	reffe237a3a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffe237a3a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cpNext_allocs)

	var csrcSet_allocs *cgoAllocMap
	reffe237a3a.srcSet, csrcSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.SrcSet)), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csrcSet_allocs)

	var csrcBinding_allocs *cgoAllocMap
	reffe237a3a.srcBinding, csrcBinding_allocs = (C.uint32_t)(x.SrcBinding), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csrcBinding_allocs)

	var csrcArrayElement_allocs *cgoAllocMap
	reffe237a3a.srcArrayElement, csrcArrayElement_allocs = (C.uint32_t)(x.SrcArrayElement), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csrcArrayElement_allocs)

	var cdstSet_allocs *cgoAllocMap
	reffe237a3a.dstSet, cdstSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.DstSet)), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdstSet_allocs)

	var cdstBinding_allocs *cgoAllocMap
	reffe237a3a.dstBinding, cdstBinding_allocs = (C.uint32_t)(x.DstBinding), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdstBinding_allocs)

	var cdstArrayElement_allocs *cgoAllocMap
	reffe237a3a.dstArrayElement, cdstArrayElement_allocs = (C.uint32_t)(x.DstArrayElement), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdstArrayElement_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	reffe237a3a.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdescriptorCount_allocs)

	x.reffe237a3a = reffe237a3a
	x.allocsfe237a3a = allocsfe237a3a
	return reffe237a3a, allocsfe237a3a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CopyDescriptorSet) PassValue() (C.VkCopyDescriptorSet, *cgoAllocMap) {
	if x.reffe237a3a != nil {
		return *x.reffe237a3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CopyDescriptorSet) Deref() {
	if x.reffe237a3a == nil {
		return
	}
	x.SType = (StructureType)(x.reffe237a3a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe237a3a.pNext))
	x.SrcSet = *(*DescriptorSet)(unsafe.Pointer(&x.reffe237a3a.srcSet))
	x.SrcBinding = (uint32)(x.reffe237a3a.srcBinding)
	x.SrcArrayElement = (uint32)(x.reffe237a3a.srcArrayElement)
	x.DstSet = *(*DescriptorSet)(unsafe.Pointer(&x.reffe237a3a.dstSet))
	x.DstBinding = (uint32)(x.reffe237a3a.dstBinding)
	x.DstArrayElement = (uint32)(x.reffe237a3a.dstArrayElement)
	x.DescriptorCount = (uint32)(x.reffe237a3a.descriptorCount)
}

// allocDescriptorBufferInfoMemory allocates memory for type C.VkDescriptorBufferInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorBufferInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorBufferInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorBufferInfoValue = unsafe.Sizeof([1]C.VkDescriptorBufferInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorBufferInfo) Ref() *C.VkDescriptorBufferInfo {
	if x == nil {
		return nil
	}
	return x.refe64bec0e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorBufferInfo) Free() {
	if x != nil && x.allocse64bec0e != nil {
		x.allocse64bec0e.(*cgoAllocMap).Free()
		x.refe64bec0e = nil
	}
}

// NewDescriptorBufferInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorBufferInfoRef(ref unsafe.Pointer) *DescriptorBufferInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorBufferInfo)
	obj.refe64bec0e = (*C.VkDescriptorBufferInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorBufferInfo) PassRef() (*C.VkDescriptorBufferInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe64bec0e != nil {
		return x.refe64bec0e, nil
	}
	meme64bec0e := allocDescriptorBufferInfoMemory(1)
	refe64bec0e := (*C.VkDescriptorBufferInfo)(meme64bec0e)
	allocse64bec0e := new(cgoAllocMap)
	allocse64bec0e.Add(meme64bec0e)

	var cbuffer_allocs *cgoAllocMap
	refe64bec0e.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocse64bec0e.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	refe64bec0e.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocse64bec0e.Borrow(coffset_allocs)

	var c_range_allocs *cgoAllocMap
	refe64bec0e._range, c_range_allocs = (C.VkDeviceSize)(x.Range), cgoAllocsUnknown
	allocse64bec0e.Borrow(c_range_allocs)

	x.refe64bec0e = refe64bec0e
	x.allocse64bec0e = allocse64bec0e
	return refe64bec0e, allocse64bec0e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorBufferInfo) PassValue() (C.VkDescriptorBufferInfo, *cgoAllocMap) {
	if x.refe64bec0e != nil {
		return *x.refe64bec0e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorBufferInfo) Deref() {
	if x.refe64bec0e == nil {
		return
	}
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refe64bec0e.buffer))
	x.Offset = (DeviceSize)(x.refe64bec0e.offset)
	x.Range = (DeviceSize)(x.refe64bec0e._range)
}

// allocDescriptorImageInfoMemory allocates memory for type C.VkDescriptorImageInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorImageInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorImageInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorImageInfoValue = unsafe.Sizeof([1]C.VkDescriptorImageInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorImageInfo) Ref() *C.VkDescriptorImageInfo {
	if x == nil {
		return nil
	}
	return x.refaf073b07
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorImageInfo) Free() {
	if x != nil && x.allocsaf073b07 != nil {
		x.allocsaf073b07.(*cgoAllocMap).Free()
		x.refaf073b07 = nil
	}
}

// NewDescriptorImageInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorImageInfoRef(ref unsafe.Pointer) *DescriptorImageInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorImageInfo)
	obj.refaf073b07 = (*C.VkDescriptorImageInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorImageInfo) PassRef() (*C.VkDescriptorImageInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaf073b07 != nil {
		return x.refaf073b07, nil
	}
	memaf073b07 := allocDescriptorImageInfoMemory(1)
	refaf073b07 := (*C.VkDescriptorImageInfo)(memaf073b07)
	allocsaf073b07 := new(cgoAllocMap)
	allocsaf073b07.Add(memaf073b07)

	var csampler_allocs *cgoAllocMap
	refaf073b07.sampler, csampler_allocs = *(*C.VkSampler)(unsafe.Pointer(&x.Sampler)), cgoAllocsUnknown
	allocsaf073b07.Borrow(csampler_allocs)

	var cimageView_allocs *cgoAllocMap
	refaf073b07.imageView, cimageView_allocs = *(*C.VkImageView)(unsafe.Pointer(&x.ImageView)), cgoAllocsUnknown
	allocsaf073b07.Borrow(cimageView_allocs)

	var cimageLayout_allocs *cgoAllocMap
	refaf073b07.imageLayout, cimageLayout_allocs = (C.VkImageLayout)(x.ImageLayout), cgoAllocsUnknown
	allocsaf073b07.Borrow(cimageLayout_allocs)

	x.refaf073b07 = refaf073b07
	x.allocsaf073b07 = allocsaf073b07
	return refaf073b07, allocsaf073b07

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorImageInfo) PassValue() (C.VkDescriptorImageInfo, *cgoAllocMap) {
	if x.refaf073b07 != nil {
		return *x.refaf073b07, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorImageInfo) Deref() {
	if x.refaf073b07 == nil {
		return
	}
	x.Sampler = *(*Sampler)(unsafe.Pointer(&x.refaf073b07.sampler))
	x.ImageView = *(*ImageView)(unsafe.Pointer(&x.refaf073b07.imageView))
	x.ImageLayout = (ImageLayout)(x.refaf073b07.imageLayout)
}

// allocDescriptorPoolSizeMemory allocates memory for type C.VkDescriptorPoolSize in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorPoolSizeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorPoolSizeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorPoolSizeValue = unsafe.Sizeof([1]C.VkDescriptorPoolSize{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorPoolSize) Ref() *C.VkDescriptorPoolSize {
	if x == nil {
		return nil
	}
	return x.refe15137da
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorPoolSize) Free() {
	if x != nil && x.allocse15137da != nil {
		x.allocse15137da.(*cgoAllocMap).Free()
		x.refe15137da = nil
	}
}

// NewDescriptorPoolSizeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorPoolSizeRef(ref unsafe.Pointer) *DescriptorPoolSize {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorPoolSize)
	obj.refe15137da = (*C.VkDescriptorPoolSize)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorPoolSize) PassRef() (*C.VkDescriptorPoolSize, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe15137da != nil {
		return x.refe15137da, nil
	}
	meme15137da := allocDescriptorPoolSizeMemory(1)
	refe15137da := (*C.VkDescriptorPoolSize)(meme15137da)
	allocse15137da := new(cgoAllocMap)
	allocse15137da.Add(meme15137da)

	var c_type_allocs *cgoAllocMap
	refe15137da._type, c_type_allocs = (C.VkDescriptorType)(x.Type), cgoAllocsUnknown
	allocse15137da.Borrow(c_type_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	refe15137da.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocse15137da.Borrow(cdescriptorCount_allocs)

	x.refe15137da = refe15137da
	x.allocse15137da = allocse15137da
	return refe15137da, allocse15137da

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorPoolSize) PassValue() (C.VkDescriptorPoolSize, *cgoAllocMap) {
	if x.refe15137da != nil {
		return *x.refe15137da, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorPoolSize) Deref() {
	if x.refe15137da == nil {
		return
	}
	x.Type = (DescriptorType)(x.refe15137da._type)
	x.DescriptorCount = (uint32)(x.refe15137da.descriptorCount)
}

// allocDescriptorPoolCreateInfoMemory allocates memory for type C.VkDescriptorPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorPoolCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorPoolCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorPoolCreateInfo{})

// unpackSDescriptorPoolSize transforms a sliced Go data structure into plain C format.
func unpackSDescriptorPoolSize(x []DescriptorPoolSize) (unpacked *C.VkDescriptorPoolSize, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorPoolSizeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorPoolSize)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorPoolSize)(h.Data)
	return
}

// packSDescriptorPoolSize reads sliced Go data structure out from plain C format.
func packSDescriptorPoolSize(v []DescriptorPoolSize, ptr0 *C.VkDescriptorPoolSize) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorPoolSizeValue]C.VkDescriptorPoolSize)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorPoolSizeRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorPoolCreateInfo) Ref() *C.VkDescriptorPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref19868463
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorPoolCreateInfo) Free() {
	if x != nil && x.allocs19868463 != nil {
		x.allocs19868463.(*cgoAllocMap).Free()
		x.ref19868463 = nil
	}
}

// NewDescriptorPoolCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorPoolCreateInfoRef(ref unsafe.Pointer) *DescriptorPoolCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorPoolCreateInfo)
	obj.ref19868463 = (*C.VkDescriptorPoolCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorPoolCreateInfo) PassRef() (*C.VkDescriptorPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref19868463 != nil {
		return x.ref19868463, nil
	}
	mem19868463 := allocDescriptorPoolCreateInfoMemory(1)
	ref19868463 := (*C.VkDescriptorPoolCreateInfo)(mem19868463)
	allocs19868463 := new(cgoAllocMap)
	allocs19868463.Add(mem19868463)

	var csType_allocs *cgoAllocMap
	ref19868463.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs19868463.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref19868463.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs19868463.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref19868463.flags, cflags_allocs = (C.VkDescriptorPoolCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs19868463.Borrow(cflags_allocs)

	var cmaxSets_allocs *cgoAllocMap
	ref19868463.maxSets, cmaxSets_allocs = (C.uint32_t)(x.MaxSets), cgoAllocsUnknown
	allocs19868463.Borrow(cmaxSets_allocs)

	var cpoolSizeCount_allocs *cgoAllocMap
	ref19868463.poolSizeCount, cpoolSizeCount_allocs = (C.uint32_t)(x.PoolSizeCount), cgoAllocsUnknown
	allocs19868463.Borrow(cpoolSizeCount_allocs)

	var cpPoolSizes_allocs *cgoAllocMap
	ref19868463.pPoolSizes, cpPoolSizes_allocs = unpackSDescriptorPoolSize(x.PPoolSizes)
	allocs19868463.Borrow(cpPoolSizes_allocs)

	x.ref19868463 = ref19868463
	x.allocs19868463 = allocs19868463
	return ref19868463, allocs19868463

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorPoolCreateInfo) PassValue() (C.VkDescriptorPoolCreateInfo, *cgoAllocMap) {
	if x.ref19868463 != nil {
		return *x.ref19868463, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorPoolCreateInfo) Deref() {
	if x.ref19868463 == nil {
		return
	}
	x.SType = (StructureType)(x.ref19868463.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref19868463.pNext))
	x.Flags = (DescriptorPoolCreateFlags)(x.ref19868463.flags)
	x.MaxSets = (uint32)(x.ref19868463.maxSets)
	x.PoolSizeCount = (uint32)(x.ref19868463.poolSizeCount)
	packSDescriptorPoolSize(x.PPoolSizes, x.ref19868463.pPoolSizes)
}

// allocDescriptorSetAllocateInfoMemory allocates memory for type C.VkDescriptorSetAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetAllocateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorSetAllocateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetAllocateInfo) Ref() *C.VkDescriptorSetAllocateInfo {
	if x == nil {
		return nil
	}
	return x.ref2dd6cc22
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetAllocateInfo) Free() {
	if x != nil && x.allocs2dd6cc22 != nil {
		x.allocs2dd6cc22.(*cgoAllocMap).Free()
		x.ref2dd6cc22 = nil
	}
}

// NewDescriptorSetAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetAllocateInfoRef(ref unsafe.Pointer) *DescriptorSetAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetAllocateInfo)
	obj.ref2dd6cc22 = (*C.VkDescriptorSetAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetAllocateInfo) PassRef() (*C.VkDescriptorSetAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2dd6cc22 != nil {
		return x.ref2dd6cc22, nil
	}
	mem2dd6cc22 := allocDescriptorSetAllocateInfoMemory(1)
	ref2dd6cc22 := (*C.VkDescriptorSetAllocateInfo)(mem2dd6cc22)
	allocs2dd6cc22 := new(cgoAllocMap)
	allocs2dd6cc22.Add(mem2dd6cc22)

	var csType_allocs *cgoAllocMap
	ref2dd6cc22.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2dd6cc22.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cpNext_allocs)

	var cdescriptorPool_allocs *cgoAllocMap
	ref2dd6cc22.descriptorPool, cdescriptorPool_allocs = *(*C.VkDescriptorPool)(unsafe.Pointer(&x.DescriptorPool)), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cdescriptorPool_allocs)

	var cdescriptorSetCount_allocs *cgoAllocMap
	ref2dd6cc22.descriptorSetCount, cdescriptorSetCount_allocs = (C.uint32_t)(x.DescriptorSetCount), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cdescriptorSetCount_allocs)

	var cpSetLayouts_allocs *cgoAllocMap
	ref2dd6cc22.pSetLayouts, cpSetLayouts_allocs = copyPDescriptorSetLayoutBytes((*sliceHeader)(unsafe.Pointer(&x.PSetLayouts)))
	allocs2dd6cc22.Borrow(cpSetLayouts_allocs)

	x.ref2dd6cc22 = ref2dd6cc22
	x.allocs2dd6cc22 = allocs2dd6cc22
	return ref2dd6cc22, allocs2dd6cc22

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetAllocateInfo) PassValue() (C.VkDescriptorSetAllocateInfo, *cgoAllocMap) {
	if x.ref2dd6cc22 != nil {
		return *x.ref2dd6cc22, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetAllocateInfo) Deref() {
	if x.ref2dd6cc22 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2dd6cc22.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2dd6cc22.pNext))
	x.DescriptorPool = *(*DescriptorPool)(unsafe.Pointer(&x.ref2dd6cc22.descriptorPool))
	x.DescriptorSetCount = (uint32)(x.ref2dd6cc22.descriptorSetCount)
	hxf4171bf := (*sliceHeader)(unsafe.Pointer(&x.PSetLayouts))
	hxf4171bf.Data = unsafe.Pointer(x.ref2dd6cc22.pSetLayouts)
	hxf4171bf.Cap = 0x7fffffff
	// hxf4171bf.Len = ?

}

// allocDescriptorSetLayoutBindingMemory allocates memory for type C.VkDescriptorSetLayoutBinding in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutBindingMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutBindingValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorSetLayoutBindingValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutBinding{})

// copyPSamplerBytes copies the data from Go slice as *C.VkSampler.
func copyPSamplerBytes(slice *sliceHeader) (*C.VkSampler, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSamplerValue) * slice.Len,
		Cap:  int(sizeOfSamplerValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSampler)(mem0), allocs
}

// allocSamplerMemory allocates memory for type C.VkSampler in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSamplerValue = unsafe.Sizeof([1]C.VkSampler{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetLayoutBinding) Ref() *C.VkDescriptorSetLayoutBinding {
	if x == nil {
		return nil
	}
	return x.ref8b50b4ec
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetLayoutBinding) Free() {
	if x != nil && x.allocs8b50b4ec != nil {
		x.allocs8b50b4ec.(*cgoAllocMap).Free()
		x.ref8b50b4ec = nil
	}
}

// NewDescriptorSetLayoutBindingRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetLayoutBindingRef(ref unsafe.Pointer) *DescriptorSetLayoutBinding {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutBinding)
	obj.ref8b50b4ec = (*C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetLayoutBinding) PassRef() (*C.VkDescriptorSetLayoutBinding, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8b50b4ec != nil {
		return x.ref8b50b4ec, nil
	}
	mem8b50b4ec := allocDescriptorSetLayoutBindingMemory(1)
	ref8b50b4ec := (*C.VkDescriptorSetLayoutBinding)(mem8b50b4ec)
	allocs8b50b4ec := new(cgoAllocMap)
	allocs8b50b4ec.Add(mem8b50b4ec)

	var cbinding_allocs *cgoAllocMap
	ref8b50b4ec.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cbinding_allocs)

	var cdescriptorType_allocs *cgoAllocMap
	ref8b50b4ec.descriptorType, cdescriptorType_allocs = (C.VkDescriptorType)(x.DescriptorType), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cdescriptorType_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	ref8b50b4ec.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cdescriptorCount_allocs)

	var cstageFlags_allocs *cgoAllocMap
	ref8b50b4ec.stageFlags, cstageFlags_allocs = (C.VkShaderStageFlags)(x.StageFlags), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cstageFlags_allocs)

	var cpImmutableSamplers_allocs *cgoAllocMap
	ref8b50b4ec.pImmutableSamplers, cpImmutableSamplers_allocs = copyPSamplerBytes((*sliceHeader)(unsafe.Pointer(&x.PImmutableSamplers)))
	allocs8b50b4ec.Borrow(cpImmutableSamplers_allocs)

	x.ref8b50b4ec = ref8b50b4ec
	x.allocs8b50b4ec = allocs8b50b4ec
	return ref8b50b4ec, allocs8b50b4ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetLayoutBinding) PassValue() (C.VkDescriptorSetLayoutBinding, *cgoAllocMap) {
	if x.ref8b50b4ec != nil {
		return *x.ref8b50b4ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetLayoutBinding) Deref() {
	if x.ref8b50b4ec == nil {
		return
	}
	x.Binding = (uint32)(x.ref8b50b4ec.binding)
	x.DescriptorType = (DescriptorType)(x.ref8b50b4ec.descriptorType)
	x.DescriptorCount = (uint32)(x.ref8b50b4ec.descriptorCount)
	x.StageFlags = (ShaderStageFlags)(x.ref8b50b4ec.stageFlags)
	hxf058b18 := (*sliceHeader)(unsafe.Pointer(&x.PImmutableSamplers))
	hxf058b18.Data = unsafe.Pointer(x.ref8b50b4ec.pImmutableSamplers)
	hxf058b18.Cap = 0x7fffffff
	// hxf058b18.Len = ?

}

// allocDescriptorSetLayoutCreateInfoMemory allocates memory for type C.VkDescriptorSetLayoutCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorSetLayoutCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutCreateInfo{})

// unpackSDescriptorSetLayoutBinding transforms a sliced Go data structure into plain C format.
func unpackSDescriptorSetLayoutBinding(x []DescriptorSetLayoutBinding) (unpacked *C.VkDescriptorSetLayoutBinding, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorSetLayoutBindingMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorSetLayoutBinding)(h.Data)
	return
}

// packSDescriptorSetLayoutBinding reads sliced Go data structure out from plain C format.
func packSDescriptorSetLayoutBinding(v []DescriptorSetLayoutBinding, ptr0 *C.VkDescriptorSetLayoutBinding) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorSetLayoutBindingValue]C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorSetLayoutBindingRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetLayoutCreateInfo) Ref() *C.VkDescriptorSetLayoutCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref5ee8e0ed
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetLayoutCreateInfo) Free() {
	if x != nil && x.allocs5ee8e0ed != nil {
		x.allocs5ee8e0ed.(*cgoAllocMap).Free()
		x.ref5ee8e0ed = nil
	}
}

// NewDescriptorSetLayoutCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetLayoutCreateInfoRef(ref unsafe.Pointer) *DescriptorSetLayoutCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutCreateInfo)
	obj.ref5ee8e0ed = (*C.VkDescriptorSetLayoutCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetLayoutCreateInfo) PassRef() (*C.VkDescriptorSetLayoutCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ee8e0ed != nil {
		return x.ref5ee8e0ed, nil
	}
	mem5ee8e0ed := allocDescriptorSetLayoutCreateInfoMemory(1)
	ref5ee8e0ed := (*C.VkDescriptorSetLayoutCreateInfo)(mem5ee8e0ed)
	allocs5ee8e0ed := new(cgoAllocMap)
	allocs5ee8e0ed.Add(mem5ee8e0ed)

	var csType_allocs *cgoAllocMap
	ref5ee8e0ed.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5ee8e0ed.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref5ee8e0ed.flags, cflags_allocs = (C.VkDescriptorSetLayoutCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(cflags_allocs)

	var cbindingCount_allocs *cgoAllocMap
	ref5ee8e0ed.bindingCount, cbindingCount_allocs = (C.uint32_t)(x.BindingCount), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(cbindingCount_allocs)

	var cpBindings_allocs *cgoAllocMap
	ref5ee8e0ed.pBindings, cpBindings_allocs = unpackSDescriptorSetLayoutBinding(x.PBindings)
	allocs5ee8e0ed.Borrow(cpBindings_allocs)

	x.ref5ee8e0ed = ref5ee8e0ed
	x.allocs5ee8e0ed = allocs5ee8e0ed
	return ref5ee8e0ed, allocs5ee8e0ed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetLayoutCreateInfo) PassValue() (C.VkDescriptorSetLayoutCreateInfo, *cgoAllocMap) {
	if x.ref5ee8e0ed != nil {
		return *x.ref5ee8e0ed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetLayoutCreateInfo) Deref() {
	if x.ref5ee8e0ed == nil {
		return
	}
	x.SType = (StructureType)(x.ref5ee8e0ed.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5ee8e0ed.pNext))
	x.Flags = (DescriptorSetLayoutCreateFlags)(x.ref5ee8e0ed.flags)
	x.BindingCount = (uint32)(x.ref5ee8e0ed.bindingCount)
	packSDescriptorSetLayoutBinding(x.PBindings, x.ref5ee8e0ed.pBindings)
}

// allocWriteDescriptorSetMemory allocates memory for type C.VkWriteDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWriteDescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWriteDescriptorSetValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfWriteDescriptorSetValue = unsafe.Sizeof([1]C.VkWriteDescriptorSet{})

// unpackSDescriptorImageInfo transforms a sliced Go data structure into plain C format.
func unpackSDescriptorImageInfo(x []DescriptorImageInfo) (unpacked *C.VkDescriptorImageInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorImageInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorImageInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorImageInfo)(h.Data)
	return
}

// unpackSDescriptorBufferInfo transforms a sliced Go data structure into plain C format.
func unpackSDescriptorBufferInfo(x []DescriptorBufferInfo) (unpacked *C.VkDescriptorBufferInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorBufferInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorBufferInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorBufferInfo)(h.Data)
	return
}

// copyPBufferViewBytes copies the data from Go slice as *C.VkBufferView.
func copyPBufferViewBytes(slice *sliceHeader) (*C.VkBufferView, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfBufferViewValue) * slice.Len,
		Cap:  int(sizeOfBufferViewValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkBufferView)(mem0), allocs
}

// allocBufferViewMemory allocates memory for type C.VkBufferView in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferViewMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferViewValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferViewValue = unsafe.Sizeof([1]C.VkBufferView{})

// packSDescriptorImageInfo reads sliced Go data structure out from plain C format.
func packSDescriptorImageInfo(v []DescriptorImageInfo, ptr0 *C.VkDescriptorImageInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorImageInfoValue]C.VkDescriptorImageInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorImageInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSDescriptorBufferInfo reads sliced Go data structure out from plain C format.
func packSDescriptorBufferInfo(v []DescriptorBufferInfo, ptr0 *C.VkDescriptorBufferInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorBufferInfoValue]C.VkDescriptorBufferInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorBufferInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *WriteDescriptorSet) Ref() *C.VkWriteDescriptorSet {
	if x == nil {
		return nil
	}
	return x.ref3cec3f3f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *WriteDescriptorSet) Free() {
	if x != nil && x.allocs3cec3f3f != nil {
		x.allocs3cec3f3f.(*cgoAllocMap).Free()
		x.ref3cec3f3f = nil
	}
}

// NewWriteDescriptorSetRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWriteDescriptorSetRef(ref unsafe.Pointer) *WriteDescriptorSet {
	if ref == nil {
		return nil
	}
	obj := new(WriteDescriptorSet)
	obj.ref3cec3f3f = (*C.VkWriteDescriptorSet)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *WriteDescriptorSet) PassRef() (*C.VkWriteDescriptorSet, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3cec3f3f != nil {
		return x.ref3cec3f3f, nil
	}
	mem3cec3f3f := allocWriteDescriptorSetMemory(1)
	ref3cec3f3f := (*C.VkWriteDescriptorSet)(mem3cec3f3f)
	allocs3cec3f3f := new(cgoAllocMap)
	allocs3cec3f3f.Add(mem3cec3f3f)

	var csType_allocs *cgoAllocMap
	ref3cec3f3f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3cec3f3f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cpNext_allocs)

	var cdstSet_allocs *cgoAllocMap
	ref3cec3f3f.dstSet, cdstSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.DstSet)), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdstSet_allocs)

	var cdstBinding_allocs *cgoAllocMap
	ref3cec3f3f.dstBinding, cdstBinding_allocs = (C.uint32_t)(x.DstBinding), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdstBinding_allocs)

	var cdstArrayElement_allocs *cgoAllocMap
	ref3cec3f3f.dstArrayElement, cdstArrayElement_allocs = (C.uint32_t)(x.DstArrayElement), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdstArrayElement_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	ref3cec3f3f.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdescriptorCount_allocs)

	var cdescriptorType_allocs *cgoAllocMap
	ref3cec3f3f.descriptorType, cdescriptorType_allocs = (C.VkDescriptorType)(x.DescriptorType), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdescriptorType_allocs)

	var cpImageInfo_allocs *cgoAllocMap
	ref3cec3f3f.pImageInfo, cpImageInfo_allocs = unpackSDescriptorImageInfo(x.PImageInfo)
	allocs3cec3f3f.Borrow(cpImageInfo_allocs)

	var cpBufferInfo_allocs *cgoAllocMap
	ref3cec3f3f.pBufferInfo, cpBufferInfo_allocs = unpackSDescriptorBufferInfo(x.PBufferInfo)
	allocs3cec3f3f.Borrow(cpBufferInfo_allocs)

	var cpTexelBufferView_allocs *cgoAllocMap
	ref3cec3f3f.pTexelBufferView, cpTexelBufferView_allocs = copyPBufferViewBytes((*sliceHeader)(unsafe.Pointer(&x.PTexelBufferView)))
	allocs3cec3f3f.Borrow(cpTexelBufferView_allocs)

	x.ref3cec3f3f = ref3cec3f3f
	x.allocs3cec3f3f = allocs3cec3f3f
	return ref3cec3f3f, allocs3cec3f3f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x WriteDescriptorSet) PassValue() (C.VkWriteDescriptorSet, *cgoAllocMap) {
	if x.ref3cec3f3f != nil {
		return *x.ref3cec3f3f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *WriteDescriptorSet) Deref() {
	if x.ref3cec3f3f == nil {
		return
	}
	x.SType = (StructureType)(x.ref3cec3f3f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3cec3f3f.pNext))
	x.DstSet = *(*DescriptorSet)(unsafe.Pointer(&x.ref3cec3f3f.dstSet))
	x.DstBinding = (uint32)(x.ref3cec3f3f.dstBinding)
	x.DstArrayElement = (uint32)(x.ref3cec3f3f.dstArrayElement)
	x.DescriptorCount = (uint32)(x.ref3cec3f3f.descriptorCount)
	x.DescriptorType = (DescriptorType)(x.ref3cec3f3f.descriptorType)
	packSDescriptorImageInfo(x.PImageInfo, x.ref3cec3f3f.pImageInfo)
	packSDescriptorBufferInfo(x.PBufferInfo, x.ref3cec3f3f.pBufferInfo)
	hxff6bc57 := (*sliceHeader)(unsafe.Pointer(&x.PTexelBufferView))
	hxff6bc57.Data = unsafe.Pointer(x.ref3cec3f3f.pTexelBufferView)
	hxff6bc57.Cap = 0x7fffffff
	// hxff6bc57.Len = ?

}

// allocAttachmentDescriptionMemory allocates memory for type C.VkAttachmentDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentDescriptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAttachmentDescriptionValue = unsafe.Sizeof([1]C.VkAttachmentDescription{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentDescription) Ref() *C.VkAttachmentDescription {
	if x == nil {
		return nil
	}
	return x.refa5d685fc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentDescription) Free() {
	if x != nil && x.allocsa5d685fc != nil {
		x.allocsa5d685fc.(*cgoAllocMap).Free()
		x.refa5d685fc = nil
	}
}

// NewAttachmentDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentDescriptionRef(ref unsafe.Pointer) *AttachmentDescription {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentDescription)
	obj.refa5d685fc = (*C.VkAttachmentDescription)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentDescription) PassRef() (*C.VkAttachmentDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa5d685fc != nil {
		return x.refa5d685fc, nil
	}
	mema5d685fc := allocAttachmentDescriptionMemory(1)
	refa5d685fc := (*C.VkAttachmentDescription)(mema5d685fc)
	allocsa5d685fc := new(cgoAllocMap)
	allocsa5d685fc.Add(mema5d685fc)

	var cflags_allocs *cgoAllocMap
	refa5d685fc.flags, cflags_allocs = (C.VkAttachmentDescriptionFlags)(x.Flags), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cflags_allocs)

	var cformat_allocs *cgoAllocMap
	refa5d685fc.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cformat_allocs)

	var csamples_allocs *cgoAllocMap
	refa5d685fc.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocsa5d685fc.Borrow(csamples_allocs)

	var cloadOp_allocs *cgoAllocMap
	refa5d685fc.loadOp, cloadOp_allocs = (C.VkAttachmentLoadOp)(x.LoadOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cloadOp_allocs)

	var cstoreOp_allocs *cgoAllocMap
	refa5d685fc.storeOp, cstoreOp_allocs = (C.VkAttachmentStoreOp)(x.StoreOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cstoreOp_allocs)

	var cstencilLoadOp_allocs *cgoAllocMap
	refa5d685fc.stencilLoadOp, cstencilLoadOp_allocs = (C.VkAttachmentLoadOp)(x.StencilLoadOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cstencilLoadOp_allocs)

	var cstencilStoreOp_allocs *cgoAllocMap
	refa5d685fc.stencilStoreOp, cstencilStoreOp_allocs = (C.VkAttachmentStoreOp)(x.StencilStoreOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cstencilStoreOp_allocs)

	var cinitialLayout_allocs *cgoAllocMap
	refa5d685fc.initialLayout, cinitialLayout_allocs = (C.VkImageLayout)(x.InitialLayout), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cinitialLayout_allocs)

	var cfinalLayout_allocs *cgoAllocMap
	refa5d685fc.finalLayout, cfinalLayout_allocs = (C.VkImageLayout)(x.FinalLayout), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cfinalLayout_allocs)

	x.refa5d685fc = refa5d685fc
	x.allocsa5d685fc = allocsa5d685fc
	return refa5d685fc, allocsa5d685fc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentDescription) PassValue() (C.VkAttachmentDescription, *cgoAllocMap) {
	if x.refa5d685fc != nil {
		return *x.refa5d685fc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentDescription) Deref() {
	if x.refa5d685fc == nil {
		return
	}
	x.Flags = (AttachmentDescriptionFlags)(x.refa5d685fc.flags)
	x.Format = (Format)(x.refa5d685fc.format)
	x.Samples = (SampleCountFlagBits)(x.refa5d685fc.samples)
	x.LoadOp = (AttachmentLoadOp)(x.refa5d685fc.loadOp)
	x.StoreOp = (AttachmentStoreOp)(x.refa5d685fc.storeOp)
	x.StencilLoadOp = (AttachmentLoadOp)(x.refa5d685fc.stencilLoadOp)
	x.StencilStoreOp = (AttachmentStoreOp)(x.refa5d685fc.stencilStoreOp)
	x.InitialLayout = (ImageLayout)(x.refa5d685fc.initialLayout)
	x.FinalLayout = (ImageLayout)(x.refa5d685fc.finalLayout)
}

// allocAttachmentReferenceMemory allocates memory for type C.VkAttachmentReference in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentReferenceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentReferenceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAttachmentReferenceValue = unsafe.Sizeof([1]C.VkAttachmentReference{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentReference) Ref() *C.VkAttachmentReference {
	if x == nil {
		return nil
	}
	return x.refef4776de
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentReference) Free() {
	if x != nil && x.allocsef4776de != nil {
		x.allocsef4776de.(*cgoAllocMap).Free()
		x.refef4776de = nil
	}
}

// NewAttachmentReferenceRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentReferenceRef(ref unsafe.Pointer) *AttachmentReference {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentReference)
	obj.refef4776de = (*C.VkAttachmentReference)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentReference) PassRef() (*C.VkAttachmentReference, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refef4776de != nil {
		return x.refef4776de, nil
	}
	memef4776de := allocAttachmentReferenceMemory(1)
	refef4776de := (*C.VkAttachmentReference)(memef4776de)
	allocsef4776de := new(cgoAllocMap)
	allocsef4776de.Add(memef4776de)

	var cattachment_allocs *cgoAllocMap
	refef4776de.attachment, cattachment_allocs = (C.uint32_t)(x.Attachment), cgoAllocsUnknown
	allocsef4776de.Borrow(cattachment_allocs)

	var clayout_allocs *cgoAllocMap
	refef4776de.layout, clayout_allocs = (C.VkImageLayout)(x.Layout), cgoAllocsUnknown
	allocsef4776de.Borrow(clayout_allocs)

	x.refef4776de = refef4776de
	x.allocsef4776de = allocsef4776de
	return refef4776de, allocsef4776de

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentReference) PassValue() (C.VkAttachmentReference, *cgoAllocMap) {
	if x.refef4776de != nil {
		return *x.refef4776de, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentReference) Deref() {
	if x.refef4776de == nil {
		return
	}
	x.Attachment = (uint32)(x.refef4776de.attachment)
	x.Layout = (ImageLayout)(x.refef4776de.layout)
}

// allocFramebufferCreateInfoMemory allocates memory for type C.VkFramebufferCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFramebufferCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFramebufferCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFramebufferCreateInfoValue = unsafe.Sizeof([1]C.VkFramebufferCreateInfo{})

// copyPImageViewBytes copies the data from Go slice as *C.VkImageView.
func copyPImageViewBytes(slice *sliceHeader) (*C.VkImageView, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfImageViewValue) * slice.Len,
		Cap:  int(sizeOfImageViewValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkImageView)(mem0), allocs
}

// allocImageViewMemory allocates memory for type C.VkImageView in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageViewValue = unsafe.Sizeof([1]C.VkImageView{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FramebufferCreateInfo) Ref() *C.VkFramebufferCreateInfo {
	if x == nil {
		return nil
	}
	return x.refa3ad85cc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FramebufferCreateInfo) Free() {
	if x != nil && x.allocsa3ad85cc != nil {
		x.allocsa3ad85cc.(*cgoAllocMap).Free()
		x.refa3ad85cc = nil
	}
}

// NewFramebufferCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFramebufferCreateInfoRef(ref unsafe.Pointer) *FramebufferCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(FramebufferCreateInfo)
	obj.refa3ad85cc = (*C.VkFramebufferCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FramebufferCreateInfo) PassRef() (*C.VkFramebufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa3ad85cc != nil {
		return x.refa3ad85cc, nil
	}
	mema3ad85cc := allocFramebufferCreateInfoMemory(1)
	refa3ad85cc := (*C.VkFramebufferCreateInfo)(mema3ad85cc)
	allocsa3ad85cc := new(cgoAllocMap)
	allocsa3ad85cc.Add(mema3ad85cc)

	var csType_allocs *cgoAllocMap
	refa3ad85cc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa3ad85cc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refa3ad85cc.flags, cflags_allocs = (C.VkFramebufferCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cflags_allocs)

	var crenderPass_allocs *cgoAllocMap
	refa3ad85cc.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(crenderPass_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	refa3ad85cc.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	refa3ad85cc.pAttachments, cpAttachments_allocs = copyPImageViewBytes((*sliceHeader)(unsafe.Pointer(&x.PAttachments)))
	allocsa3ad85cc.Borrow(cpAttachments_allocs)

	var cwidth_allocs *cgoAllocMap
	refa3ad85cc.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refa3ad85cc.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cheight_allocs)

	var clayers_allocs *cgoAllocMap
	refa3ad85cc.layers, clayers_allocs = (C.uint32_t)(x.Layers), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(clayers_allocs)

	x.refa3ad85cc = refa3ad85cc
	x.allocsa3ad85cc = allocsa3ad85cc
	return refa3ad85cc, allocsa3ad85cc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FramebufferCreateInfo) PassValue() (C.VkFramebufferCreateInfo, *cgoAllocMap) {
	if x.refa3ad85cc != nil {
		return *x.refa3ad85cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FramebufferCreateInfo) Deref() {
	if x.refa3ad85cc == nil {
		return
	}
	x.SType = (StructureType)(x.refa3ad85cc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa3ad85cc.pNext))
	x.Flags = (FramebufferCreateFlags)(x.refa3ad85cc.flags)
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.refa3ad85cc.renderPass))
	x.AttachmentCount = (uint32)(x.refa3ad85cc.attachmentCount)
	hxf5fa529 := (*sliceHeader)(unsafe.Pointer(&x.PAttachments))
	hxf5fa529.Data = unsafe.Pointer(x.refa3ad85cc.pAttachments)
	hxf5fa529.Cap = 0x7fffffff
	// hxf5fa529.Len = ?

	x.Width = (uint32)(x.refa3ad85cc.width)
	x.Height = (uint32)(x.refa3ad85cc.height)
	x.Layers = (uint32)(x.refa3ad85cc.layers)
}

// allocSubpassDescriptionMemory allocates memory for type C.VkSubpassDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDescriptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubpassDescriptionValue = unsafe.Sizeof([1]C.VkSubpassDescription{})

// unpackSAttachmentReference transforms a sliced Go data structure into plain C format.
func unpackSAttachmentReference(x []AttachmentReference) (unpacked *C.VkAttachmentReference, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentReferenceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentReference)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentReference)(h.Data)
	return
}

// packSAttachmentReference reads sliced Go data structure out from plain C format.
func packSAttachmentReference(v []AttachmentReference, ptr0 *C.VkAttachmentReference) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentReferenceValue]C.VkAttachmentReference)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentReferenceRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassDescription) Ref() *C.VkSubpassDescription {
	if x == nil {
		return nil
	}
	return x.refc7bfeda
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassDescription) Free() {
	if x != nil && x.allocsc7bfeda != nil {
		x.allocsc7bfeda.(*cgoAllocMap).Free()
		x.refc7bfeda = nil
	}
}

// NewSubpassDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassDescriptionRef(ref unsafe.Pointer) *SubpassDescription {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDescription)
	obj.refc7bfeda = (*C.VkSubpassDescription)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassDescription) PassRef() (*C.VkSubpassDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc7bfeda != nil {
		return x.refc7bfeda, nil
	}
	memc7bfeda := allocSubpassDescriptionMemory(1)
	refc7bfeda := (*C.VkSubpassDescription)(memc7bfeda)
	allocsc7bfeda := new(cgoAllocMap)
	allocsc7bfeda.Add(memc7bfeda)

	var cflags_allocs *cgoAllocMap
	refc7bfeda.flags, cflags_allocs = (C.VkSubpassDescriptionFlags)(x.Flags), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cflags_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	refc7bfeda.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cpipelineBindPoint_allocs)

	var cinputAttachmentCount_allocs *cgoAllocMap
	refc7bfeda.inputAttachmentCount, cinputAttachmentCount_allocs = (C.uint32_t)(x.InputAttachmentCount), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cinputAttachmentCount_allocs)

	var cpInputAttachments_allocs *cgoAllocMap
	refc7bfeda.pInputAttachments, cpInputAttachments_allocs = unpackSAttachmentReference(x.PInputAttachments)
	allocsc7bfeda.Borrow(cpInputAttachments_allocs)

	var ccolorAttachmentCount_allocs *cgoAllocMap
	refc7bfeda.colorAttachmentCount, ccolorAttachmentCount_allocs = (C.uint32_t)(x.ColorAttachmentCount), cgoAllocsUnknown
	allocsc7bfeda.Borrow(ccolorAttachmentCount_allocs)

	var cpColorAttachments_allocs *cgoAllocMap
	refc7bfeda.pColorAttachments, cpColorAttachments_allocs = unpackSAttachmentReference(x.PColorAttachments)
	allocsc7bfeda.Borrow(cpColorAttachments_allocs)

	var cpResolveAttachments_allocs *cgoAllocMap
	refc7bfeda.pResolveAttachments, cpResolveAttachments_allocs = unpackSAttachmentReference(x.PResolveAttachments)
	allocsc7bfeda.Borrow(cpResolveAttachments_allocs)

	var cpDepthStencilAttachment_allocs *cgoAllocMap
	refc7bfeda.pDepthStencilAttachment, cpDepthStencilAttachment_allocs = x.PDepthStencilAttachment.PassRef()
	allocsc7bfeda.Borrow(cpDepthStencilAttachment_allocs)

	var cpreserveAttachmentCount_allocs *cgoAllocMap
	refc7bfeda.preserveAttachmentCount, cpreserveAttachmentCount_allocs = (C.uint32_t)(x.PreserveAttachmentCount), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cpreserveAttachmentCount_allocs)

	var cpPreserveAttachments_allocs *cgoAllocMap
	refc7bfeda.pPreserveAttachments, cpPreserveAttachments_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments)))
	allocsc7bfeda.Borrow(cpPreserveAttachments_allocs)

	x.refc7bfeda = refc7bfeda
	x.allocsc7bfeda = allocsc7bfeda
	return refc7bfeda, allocsc7bfeda

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassDescription) PassValue() (C.VkSubpassDescription, *cgoAllocMap) {
	if x.refc7bfeda != nil {
		return *x.refc7bfeda, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassDescription) Deref() {
	if x.refc7bfeda == nil {
		return
	}
	x.Flags = (SubpassDescriptionFlags)(x.refc7bfeda.flags)
	x.PipelineBindPoint = (PipelineBindPoint)(x.refc7bfeda.pipelineBindPoint)
	x.InputAttachmentCount = (uint32)(x.refc7bfeda.inputAttachmentCount)
	packSAttachmentReference(x.PInputAttachments, x.refc7bfeda.pInputAttachments)
	x.ColorAttachmentCount = (uint32)(x.refc7bfeda.colorAttachmentCount)
	packSAttachmentReference(x.PColorAttachments, x.refc7bfeda.pColorAttachments)
	packSAttachmentReference(x.PResolveAttachments, x.refc7bfeda.pResolveAttachments)
	x.PDepthStencilAttachment = NewAttachmentReferenceRef(unsafe.Pointer(x.refc7bfeda.pDepthStencilAttachment))
	x.PreserveAttachmentCount = (uint32)(x.refc7bfeda.preserveAttachmentCount)
	hxf21690b := (*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments))
	hxf21690b.Data = unsafe.Pointer(x.refc7bfeda.pPreserveAttachments)
	hxf21690b.Cap = 0x7fffffff
	// hxf21690b.Len = ?

}

// allocSubpassDependencyMemory allocates memory for type C.VkSubpassDependency in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDependencyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDependencyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubpassDependencyValue = unsafe.Sizeof([1]C.VkSubpassDependency{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassDependency) Ref() *C.VkSubpassDependency {
	if x == nil {
		return nil
	}
	return x.refdb197adb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassDependency) Free() {
	if x != nil && x.allocsdb197adb != nil {
		x.allocsdb197adb.(*cgoAllocMap).Free()
		x.refdb197adb = nil
	}
}

// NewSubpassDependencyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassDependencyRef(ref unsafe.Pointer) *SubpassDependency {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDependency)
	obj.refdb197adb = (*C.VkSubpassDependency)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassDependency) PassRef() (*C.VkSubpassDependency, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdb197adb != nil {
		return x.refdb197adb, nil
	}
	memdb197adb := allocSubpassDependencyMemory(1)
	refdb197adb := (*C.VkSubpassDependency)(memdb197adb)
	allocsdb197adb := new(cgoAllocMap)
	allocsdb197adb.Add(memdb197adb)

	var csrcSubpass_allocs *cgoAllocMap
	refdb197adb.srcSubpass, csrcSubpass_allocs = (C.uint32_t)(x.SrcSubpass), cgoAllocsUnknown
	allocsdb197adb.Borrow(csrcSubpass_allocs)

	var cdstSubpass_allocs *cgoAllocMap
	refdb197adb.dstSubpass, cdstSubpass_allocs = (C.uint32_t)(x.DstSubpass), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdstSubpass_allocs)

	var csrcStageMask_allocs *cgoAllocMap
	refdb197adb.srcStageMask, csrcStageMask_allocs = (C.VkPipelineStageFlags)(x.SrcStageMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(csrcStageMask_allocs)

	var cdstStageMask_allocs *cgoAllocMap
	refdb197adb.dstStageMask, cdstStageMask_allocs = (C.VkPipelineStageFlags)(x.DstStageMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdstStageMask_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refdb197adb.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refdb197adb.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdstAccessMask_allocs)

	var cdependencyFlags_allocs *cgoAllocMap
	refdb197adb.dependencyFlags, cdependencyFlags_allocs = (C.VkDependencyFlags)(x.DependencyFlags), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdependencyFlags_allocs)

	x.refdb197adb = refdb197adb
	x.allocsdb197adb = allocsdb197adb
	return refdb197adb, allocsdb197adb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassDependency) PassValue() (C.VkSubpassDependency, *cgoAllocMap) {
	if x.refdb197adb != nil {
		return *x.refdb197adb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassDependency) Deref() {
	if x.refdb197adb == nil {
		return
	}
	x.SrcSubpass = (uint32)(x.refdb197adb.srcSubpass)
	x.DstSubpass = (uint32)(x.refdb197adb.dstSubpass)
	x.SrcStageMask = (PipelineStageFlags)(x.refdb197adb.srcStageMask)
	x.DstStageMask = (PipelineStageFlags)(x.refdb197adb.dstStageMask)
	x.SrcAccessMask = (AccessFlags)(x.refdb197adb.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refdb197adb.dstAccessMask)
	x.DependencyFlags = (DependencyFlags)(x.refdb197adb.dependencyFlags)
}

// allocRenderPassCreateInfoMemory allocates memory for type C.VkRenderPassCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderPassCreateInfoValue = unsafe.Sizeof([1]C.VkRenderPassCreateInfo{})

// unpackSAttachmentDescription transforms a sliced Go data structure into plain C format.
func unpackSAttachmentDescription(x []AttachmentDescription) (unpacked *C.VkAttachmentDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentDescription)(h.Data)
	return
}

// unpackSSubpassDescription transforms a sliced Go data structure into plain C format.
func unpackSSubpassDescription(x []SubpassDescription) (unpacked *C.VkSubpassDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDescription)(h.Data)
	return
}

// unpackSSubpassDependency transforms a sliced Go data structure into plain C format.
func unpackSSubpassDependency(x []SubpassDependency) (unpacked *C.VkSubpassDependency, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDependencyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDependency)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDependency)(h.Data)
	return
}

// packSAttachmentDescription reads sliced Go data structure out from plain C format.
func packSAttachmentDescription(v []AttachmentDescription, ptr0 *C.VkAttachmentDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentDescriptionValue]C.VkAttachmentDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassDescription reads sliced Go data structure out from plain C format.
func packSSubpassDescription(v []SubpassDescription, ptr0 *C.VkSubpassDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDescriptionValue]C.VkSubpassDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassDependency reads sliced Go data structure out from plain C format.
func packSSubpassDependency(v []SubpassDependency, ptr0 *C.VkSubpassDependency) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDependencyValue]C.VkSubpassDependency)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDependencyRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassCreateInfo) Ref() *C.VkRenderPassCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref886d7d86
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassCreateInfo) Free() {
	if x != nil && x.allocs886d7d86 != nil {
		x.allocs886d7d86.(*cgoAllocMap).Free()
		x.ref886d7d86 = nil
	}
}

// NewRenderPassCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassCreateInfoRef(ref unsafe.Pointer) *RenderPassCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassCreateInfo)
	obj.ref886d7d86 = (*C.VkRenderPassCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassCreateInfo) PassRef() (*C.VkRenderPassCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref886d7d86 != nil {
		return x.ref886d7d86, nil
	}
	mem886d7d86 := allocRenderPassCreateInfoMemory(1)
	ref886d7d86 := (*C.VkRenderPassCreateInfo)(mem886d7d86)
	allocs886d7d86 := new(cgoAllocMap)
	allocs886d7d86.Add(mem886d7d86)

	var csType_allocs *cgoAllocMap
	ref886d7d86.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs886d7d86.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref886d7d86.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs886d7d86.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref886d7d86.flags, cflags_allocs = (C.VkRenderPassCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs886d7d86.Borrow(cflags_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	ref886d7d86.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocs886d7d86.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	ref886d7d86.pAttachments, cpAttachments_allocs = unpackSAttachmentDescription(x.PAttachments)
	allocs886d7d86.Borrow(cpAttachments_allocs)

	var csubpassCount_allocs *cgoAllocMap
	ref886d7d86.subpassCount, csubpassCount_allocs = (C.uint32_t)(x.SubpassCount), cgoAllocsUnknown
	allocs886d7d86.Borrow(csubpassCount_allocs)

	var cpSubpasses_allocs *cgoAllocMap
	ref886d7d86.pSubpasses, cpSubpasses_allocs = unpackSSubpassDescription(x.PSubpasses)
	allocs886d7d86.Borrow(cpSubpasses_allocs)

	var cdependencyCount_allocs *cgoAllocMap
	ref886d7d86.dependencyCount, cdependencyCount_allocs = (C.uint32_t)(x.DependencyCount), cgoAllocsUnknown
	allocs886d7d86.Borrow(cdependencyCount_allocs)

	var cpDependencies_allocs *cgoAllocMap
	ref886d7d86.pDependencies, cpDependencies_allocs = unpackSSubpassDependency(x.PDependencies)
	allocs886d7d86.Borrow(cpDependencies_allocs)

	x.ref886d7d86 = ref886d7d86
	x.allocs886d7d86 = allocs886d7d86
	return ref886d7d86, allocs886d7d86

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassCreateInfo) PassValue() (C.VkRenderPassCreateInfo, *cgoAllocMap) {
	if x.ref886d7d86 != nil {
		return *x.ref886d7d86, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassCreateInfo) Deref() {
	if x.ref886d7d86 == nil {
		return
	}
	x.SType = (StructureType)(x.ref886d7d86.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref886d7d86.pNext))
	x.Flags = (RenderPassCreateFlags)(x.ref886d7d86.flags)
	x.AttachmentCount = (uint32)(x.ref886d7d86.attachmentCount)
	packSAttachmentDescription(x.PAttachments, x.ref886d7d86.pAttachments)
	x.SubpassCount = (uint32)(x.ref886d7d86.subpassCount)
	packSSubpassDescription(x.PSubpasses, x.ref886d7d86.pSubpasses)
	x.DependencyCount = (uint32)(x.ref886d7d86.dependencyCount)
	packSSubpassDependency(x.PDependencies, x.ref886d7d86.pDependencies)
}

// allocCommandPoolCreateInfoMemory allocates memory for type C.VkCommandPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandPoolCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCommandPoolCreateInfoValue = unsafe.Sizeof([1]C.VkCommandPoolCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandPoolCreateInfo) Ref() *C.VkCommandPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref73550de0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandPoolCreateInfo) Free() {
	if x != nil && x.allocs73550de0 != nil {
		x.allocs73550de0.(*cgoAllocMap).Free()
		x.ref73550de0 = nil
	}
}

// NewCommandPoolCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandPoolCreateInfoRef(ref unsafe.Pointer) *CommandPoolCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandPoolCreateInfo)
	obj.ref73550de0 = (*C.VkCommandPoolCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandPoolCreateInfo) PassRef() (*C.VkCommandPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref73550de0 != nil {
		return x.ref73550de0, nil
	}
	mem73550de0 := allocCommandPoolCreateInfoMemory(1)
	ref73550de0 := (*C.VkCommandPoolCreateInfo)(mem73550de0)
	allocs73550de0 := new(cgoAllocMap)
	allocs73550de0.Add(mem73550de0)

	var csType_allocs *cgoAllocMap
	ref73550de0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs73550de0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref73550de0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs73550de0.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref73550de0.flags, cflags_allocs = (C.VkCommandPoolCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs73550de0.Borrow(cflags_allocs)

	var cqueueFamilyIndex_allocs *cgoAllocMap
	ref73550de0.queueFamilyIndex, cqueueFamilyIndex_allocs = (C.uint32_t)(x.QueueFamilyIndex), cgoAllocsUnknown
	allocs73550de0.Borrow(cqueueFamilyIndex_allocs)

	x.ref73550de0 = ref73550de0
	x.allocs73550de0 = allocs73550de0
	return ref73550de0, allocs73550de0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandPoolCreateInfo) PassValue() (C.VkCommandPoolCreateInfo, *cgoAllocMap) {
	if x.ref73550de0 != nil {
		return *x.ref73550de0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandPoolCreateInfo) Deref() {
	if x.ref73550de0 == nil {
		return
	}
	x.SType = (StructureType)(x.ref73550de0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref73550de0.pNext))
	x.Flags = (CommandPoolCreateFlags)(x.ref73550de0.flags)
	x.QueueFamilyIndex = (uint32)(x.ref73550de0.queueFamilyIndex)
}

// allocCommandBufferAllocateInfoMemory allocates memory for type C.VkCommandBufferAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferAllocateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCommandBufferAllocateInfoValue = unsafe.Sizeof([1]C.VkCommandBufferAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferAllocateInfo) Ref() *C.VkCommandBufferAllocateInfo {
	if x == nil {
		return nil
	}
	return x.refd1a0a7c8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferAllocateInfo) Free() {
	if x != nil && x.allocsd1a0a7c8 != nil {
		x.allocsd1a0a7c8.(*cgoAllocMap).Free()
		x.refd1a0a7c8 = nil
	}
}

// NewCommandBufferAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferAllocateInfoRef(ref unsafe.Pointer) *CommandBufferAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferAllocateInfo)
	obj.refd1a0a7c8 = (*C.VkCommandBufferAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferAllocateInfo) PassRef() (*C.VkCommandBufferAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd1a0a7c8 != nil {
		return x.refd1a0a7c8, nil
	}
	memd1a0a7c8 := allocCommandBufferAllocateInfoMemory(1)
	refd1a0a7c8 := (*C.VkCommandBufferAllocateInfo)(memd1a0a7c8)
	allocsd1a0a7c8 := new(cgoAllocMap)
	allocsd1a0a7c8.Add(memd1a0a7c8)

	var csType_allocs *cgoAllocMap
	refd1a0a7c8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd1a0a7c8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(cpNext_allocs)

	var ccommandPool_allocs *cgoAllocMap
	refd1a0a7c8.commandPool, ccommandPool_allocs = *(*C.VkCommandPool)(unsafe.Pointer(&x.CommandPool)), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(ccommandPool_allocs)

	var clevel_allocs *cgoAllocMap
	refd1a0a7c8.level, clevel_allocs = (C.VkCommandBufferLevel)(x.Level), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(clevel_allocs)

	var ccommandBufferCount_allocs *cgoAllocMap
	refd1a0a7c8.commandBufferCount, ccommandBufferCount_allocs = (C.uint32_t)(x.CommandBufferCount), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(ccommandBufferCount_allocs)

	x.refd1a0a7c8 = refd1a0a7c8
	x.allocsd1a0a7c8 = allocsd1a0a7c8
	return refd1a0a7c8, allocsd1a0a7c8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferAllocateInfo) PassValue() (C.VkCommandBufferAllocateInfo, *cgoAllocMap) {
	if x.refd1a0a7c8 != nil {
		return *x.refd1a0a7c8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferAllocateInfo) Deref() {
	if x.refd1a0a7c8 == nil {
		return
	}
	x.SType = (StructureType)(x.refd1a0a7c8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd1a0a7c8.pNext))
	x.CommandPool = *(*CommandPool)(unsafe.Pointer(&x.refd1a0a7c8.commandPool))
	x.Level = (CommandBufferLevel)(x.refd1a0a7c8.level)
	x.CommandBufferCount = (uint32)(x.refd1a0a7c8.commandBufferCount)
}

// allocCommandBufferInheritanceInfoMemory allocates memory for type C.VkCommandBufferInheritanceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferInheritanceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferInheritanceInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCommandBufferInheritanceInfoValue = unsafe.Sizeof([1]C.VkCommandBufferInheritanceInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferInheritanceInfo) Ref() *C.VkCommandBufferInheritanceInfo {
	if x == nil {
		return nil
	}
	return x.ref737f8019
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferInheritanceInfo) Free() {
	if x != nil && x.allocs737f8019 != nil {
		x.allocs737f8019.(*cgoAllocMap).Free()
		x.ref737f8019 = nil
	}
}

// NewCommandBufferInheritanceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferInheritanceInfoRef(ref unsafe.Pointer) *CommandBufferInheritanceInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferInheritanceInfo)
	obj.ref737f8019 = (*C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferInheritanceInfo) PassRef() (*C.VkCommandBufferInheritanceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref737f8019 != nil {
		return x.ref737f8019, nil
	}
	mem737f8019 := allocCommandBufferInheritanceInfoMemory(1)
	ref737f8019 := (*C.VkCommandBufferInheritanceInfo)(mem737f8019)
	allocs737f8019 := new(cgoAllocMap)
	allocs737f8019.Add(mem737f8019)

	var csType_allocs *cgoAllocMap
	ref737f8019.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs737f8019.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref737f8019.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs737f8019.Borrow(cpNext_allocs)

	var crenderPass_allocs *cgoAllocMap
	ref737f8019.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocs737f8019.Borrow(crenderPass_allocs)

	var csubpass_allocs *cgoAllocMap
	ref737f8019.subpass, csubpass_allocs = (C.uint32_t)(x.Subpass), cgoAllocsUnknown
	allocs737f8019.Borrow(csubpass_allocs)

	var cframebuffer_allocs *cgoAllocMap
	ref737f8019.framebuffer, cframebuffer_allocs = *(*C.VkFramebuffer)(unsafe.Pointer(&x.Framebuffer)), cgoAllocsUnknown
	allocs737f8019.Borrow(cframebuffer_allocs)

	var cocclusionQueryEnable_allocs *cgoAllocMap
	ref737f8019.occlusionQueryEnable, cocclusionQueryEnable_allocs = (C.VkBool32)(x.OcclusionQueryEnable), cgoAllocsUnknown
	allocs737f8019.Borrow(cocclusionQueryEnable_allocs)

	var cqueryFlags_allocs *cgoAllocMap
	ref737f8019.queryFlags, cqueryFlags_allocs = (C.VkQueryControlFlags)(x.QueryFlags), cgoAllocsUnknown
	allocs737f8019.Borrow(cqueryFlags_allocs)

	var cpipelineStatistics_allocs *cgoAllocMap
	ref737f8019.pipelineStatistics, cpipelineStatistics_allocs = (C.VkQueryPipelineStatisticFlags)(x.PipelineStatistics), cgoAllocsUnknown
	allocs737f8019.Borrow(cpipelineStatistics_allocs)

	x.ref737f8019 = ref737f8019
	x.allocs737f8019 = allocs737f8019
	return ref737f8019, allocs737f8019

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferInheritanceInfo) PassValue() (C.VkCommandBufferInheritanceInfo, *cgoAllocMap) {
	if x.ref737f8019 != nil {
		return *x.ref737f8019, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferInheritanceInfo) Deref() {
	if x.ref737f8019 == nil {
		return
	}
	x.SType = (StructureType)(x.ref737f8019.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref737f8019.pNext))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref737f8019.renderPass))
	x.Subpass = (uint32)(x.ref737f8019.subpass)
	x.Framebuffer = *(*Framebuffer)(unsafe.Pointer(&x.ref737f8019.framebuffer))
	x.OcclusionQueryEnable = (Bool32)(x.ref737f8019.occlusionQueryEnable)
	x.QueryFlags = (QueryControlFlags)(x.ref737f8019.queryFlags)
	x.PipelineStatistics = (QueryPipelineStatisticFlags)(x.ref737f8019.pipelineStatistics)
}

// allocCommandBufferBeginInfoMemory allocates memory for type C.VkCommandBufferBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferBeginInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCommandBufferBeginInfoValue = unsafe.Sizeof([1]C.VkCommandBufferBeginInfo{})

// unpackSCommandBufferInheritanceInfo transforms a sliced Go data structure into plain C format.
func unpackSCommandBufferInheritanceInfo(x []CommandBufferInheritanceInfo) (unpacked *C.VkCommandBufferInheritanceInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCommandBufferInheritanceInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCommandBufferInheritanceInfo)(h.Data)
	return
}

// packSCommandBufferInheritanceInfo reads sliced Go data structure out from plain C format.
func packSCommandBufferInheritanceInfo(v []CommandBufferInheritanceInfo, ptr0 *C.VkCommandBufferInheritanceInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCommandBufferInheritanceInfoValue]C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCommandBufferInheritanceInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferBeginInfo) Ref() *C.VkCommandBufferBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref266762df
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferBeginInfo) Free() {
	if x != nil && x.allocs266762df != nil {
		x.allocs266762df.(*cgoAllocMap).Free()
		x.ref266762df = nil
	}
}

// NewCommandBufferBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferBeginInfoRef(ref unsafe.Pointer) *CommandBufferBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferBeginInfo)
	obj.ref266762df = (*C.VkCommandBufferBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferBeginInfo) PassRef() (*C.VkCommandBufferBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref266762df != nil {
		return x.ref266762df, nil
	}
	mem266762df := allocCommandBufferBeginInfoMemory(1)
	ref266762df := (*C.VkCommandBufferBeginInfo)(mem266762df)
	allocs266762df := new(cgoAllocMap)
	allocs266762df.Add(mem266762df)

	var csType_allocs *cgoAllocMap
	ref266762df.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs266762df.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref266762df.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs266762df.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref266762df.flags, cflags_allocs = (C.VkCommandBufferUsageFlags)(x.Flags), cgoAllocsUnknown
	allocs266762df.Borrow(cflags_allocs)

	var cpInheritanceInfo_allocs *cgoAllocMap
	ref266762df.pInheritanceInfo, cpInheritanceInfo_allocs = unpackSCommandBufferInheritanceInfo(x.PInheritanceInfo)
	allocs266762df.Borrow(cpInheritanceInfo_allocs)

	x.ref266762df = ref266762df
	x.allocs266762df = allocs266762df
	return ref266762df, allocs266762df

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferBeginInfo) PassValue() (C.VkCommandBufferBeginInfo, *cgoAllocMap) {
	if x.ref266762df != nil {
		return *x.ref266762df, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferBeginInfo) Deref() {
	if x.ref266762df == nil {
		return
	}
	x.SType = (StructureType)(x.ref266762df.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref266762df.pNext))
	x.Flags = (CommandBufferUsageFlags)(x.ref266762df.flags)
	packSCommandBufferInheritanceInfo(x.PInheritanceInfo, x.ref266762df.pInheritanceInfo)
}

// allocBufferCopyMemory allocates memory for type C.VkBufferCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferCopyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferCopyValue = unsafe.Sizeof([1]C.VkBufferCopy{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferCopy) Ref() *C.VkBufferCopy {
	if x == nil {
		return nil
	}
	return x.ref12184ffd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferCopy) Free() {
	if x != nil && x.allocs12184ffd != nil {
		x.allocs12184ffd.(*cgoAllocMap).Free()
		x.ref12184ffd = nil
	}
}

// NewBufferCopyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferCopyRef(ref unsafe.Pointer) *BufferCopy {
	if ref == nil {
		return nil
	}
	obj := new(BufferCopy)
	obj.ref12184ffd = (*C.VkBufferCopy)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferCopy) PassRef() (*C.VkBufferCopy, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref12184ffd != nil {
		return x.ref12184ffd, nil
	}
	mem12184ffd := allocBufferCopyMemory(1)
	ref12184ffd := (*C.VkBufferCopy)(mem12184ffd)
	allocs12184ffd := new(cgoAllocMap)
	allocs12184ffd.Add(mem12184ffd)

	var csrcOffset_allocs *cgoAllocMap
	ref12184ffd.srcOffset, csrcOffset_allocs = (C.VkDeviceSize)(x.SrcOffset), cgoAllocsUnknown
	allocs12184ffd.Borrow(csrcOffset_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref12184ffd.dstOffset, cdstOffset_allocs = (C.VkDeviceSize)(x.DstOffset), cgoAllocsUnknown
	allocs12184ffd.Borrow(cdstOffset_allocs)

	var csize_allocs *cgoAllocMap
	ref12184ffd.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs12184ffd.Borrow(csize_allocs)

	x.ref12184ffd = ref12184ffd
	x.allocs12184ffd = allocs12184ffd
	return ref12184ffd, allocs12184ffd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferCopy) PassValue() (C.VkBufferCopy, *cgoAllocMap) {
	if x.ref12184ffd != nil {
		return *x.ref12184ffd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferCopy) Deref() {
	if x.ref12184ffd == nil {
		return
	}
	x.SrcOffset = (DeviceSize)(x.ref12184ffd.srcOffset)
	x.DstOffset = (DeviceSize)(x.ref12184ffd.dstOffset)
	x.Size = (DeviceSize)(x.ref12184ffd.size)
}

// allocImageSubresourceLayersMemory allocates memory for type C.VkImageSubresourceLayers in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSubresourceLayersMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSubresourceLayersValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageSubresourceLayersValue = unsafe.Sizeof([1]C.VkImageSubresourceLayers{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSubresourceLayers) Ref() *C.VkImageSubresourceLayers {
	if x == nil {
		return nil
	}
	return x.ref3b13bcd2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSubresourceLayers) Free() {
	if x != nil && x.allocs3b13bcd2 != nil {
		x.allocs3b13bcd2.(*cgoAllocMap).Free()
		x.ref3b13bcd2 = nil
	}
}

// NewImageSubresourceLayersRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSubresourceLayersRef(ref unsafe.Pointer) *ImageSubresourceLayers {
	if ref == nil {
		return nil
	}
	obj := new(ImageSubresourceLayers)
	obj.ref3b13bcd2 = (*C.VkImageSubresourceLayers)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSubresourceLayers) PassRef() (*C.VkImageSubresourceLayers, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3b13bcd2 != nil {
		return x.ref3b13bcd2, nil
	}
	mem3b13bcd2 := allocImageSubresourceLayersMemory(1)
	ref3b13bcd2 := (*C.VkImageSubresourceLayers)(mem3b13bcd2)
	allocs3b13bcd2 := new(cgoAllocMap)
	allocs3b13bcd2.Add(mem3b13bcd2)

	var caspectMask_allocs *cgoAllocMap
	ref3b13bcd2.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(caspectMask_allocs)

	var cmipLevel_allocs *cgoAllocMap
	ref3b13bcd2.mipLevel, cmipLevel_allocs = (C.uint32_t)(x.MipLevel), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(cmipLevel_allocs)

	var cbaseArrayLayer_allocs *cgoAllocMap
	ref3b13bcd2.baseArrayLayer, cbaseArrayLayer_allocs = (C.uint32_t)(x.BaseArrayLayer), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(cbaseArrayLayer_allocs)

	var clayerCount_allocs *cgoAllocMap
	ref3b13bcd2.layerCount, clayerCount_allocs = (C.uint32_t)(x.LayerCount), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(clayerCount_allocs)

	x.ref3b13bcd2 = ref3b13bcd2
	x.allocs3b13bcd2 = allocs3b13bcd2
	return ref3b13bcd2, allocs3b13bcd2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSubresourceLayers) PassValue() (C.VkImageSubresourceLayers, *cgoAllocMap) {
	if x.ref3b13bcd2 != nil {
		return *x.ref3b13bcd2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSubresourceLayers) Deref() {
	if x.ref3b13bcd2 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.ref3b13bcd2.aspectMask)
	x.MipLevel = (uint32)(x.ref3b13bcd2.mipLevel)
	x.BaseArrayLayer = (uint32)(x.ref3b13bcd2.baseArrayLayer)
	x.LayerCount = (uint32)(x.ref3b13bcd2.layerCount)
}

// allocBufferImageCopyMemory allocates memory for type C.VkBufferImageCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferImageCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferImageCopyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferImageCopyValue = unsafe.Sizeof([1]C.VkBufferImageCopy{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferImageCopy) Ref() *C.VkBufferImageCopy {
	if x == nil {
		return nil
	}
	return x.ref6d50e36e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferImageCopy) Free() {
	if x != nil && x.allocs6d50e36e != nil {
		x.allocs6d50e36e.(*cgoAllocMap).Free()
		x.ref6d50e36e = nil
	}
}

// NewBufferImageCopyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferImageCopyRef(ref unsafe.Pointer) *BufferImageCopy {
	if ref == nil {
		return nil
	}
	obj := new(BufferImageCopy)
	obj.ref6d50e36e = (*C.VkBufferImageCopy)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferImageCopy) PassRef() (*C.VkBufferImageCopy, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6d50e36e != nil {
		return x.ref6d50e36e, nil
	}
	mem6d50e36e := allocBufferImageCopyMemory(1)
	ref6d50e36e := (*C.VkBufferImageCopy)(mem6d50e36e)
	allocs6d50e36e := new(cgoAllocMap)
	allocs6d50e36e.Add(mem6d50e36e)

	var cbufferOffset_allocs *cgoAllocMap
	ref6d50e36e.bufferOffset, cbufferOffset_allocs = (C.VkDeviceSize)(x.BufferOffset), cgoAllocsUnknown
	allocs6d50e36e.Borrow(cbufferOffset_allocs)

	var cbufferRowLength_allocs *cgoAllocMap
	ref6d50e36e.bufferRowLength, cbufferRowLength_allocs = (C.uint32_t)(x.BufferRowLength), cgoAllocsUnknown
	allocs6d50e36e.Borrow(cbufferRowLength_allocs)

	var cbufferImageHeight_allocs *cgoAllocMap
	ref6d50e36e.bufferImageHeight, cbufferImageHeight_allocs = (C.uint32_t)(x.BufferImageHeight), cgoAllocsUnknown
	allocs6d50e36e.Borrow(cbufferImageHeight_allocs)

	var cimageSubresource_allocs *cgoAllocMap
	ref6d50e36e.imageSubresource, cimageSubresource_allocs = x.ImageSubresource.PassValue()
	allocs6d50e36e.Borrow(cimageSubresource_allocs)

	var cimageOffset_allocs *cgoAllocMap
	ref6d50e36e.imageOffset, cimageOffset_allocs = x.ImageOffset.PassValue()
	allocs6d50e36e.Borrow(cimageOffset_allocs)

	var cimageExtent_allocs *cgoAllocMap
	ref6d50e36e.imageExtent, cimageExtent_allocs = x.ImageExtent.PassValue()
	allocs6d50e36e.Borrow(cimageExtent_allocs)

	x.ref6d50e36e = ref6d50e36e
	x.allocs6d50e36e = allocs6d50e36e
	return ref6d50e36e, allocs6d50e36e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferImageCopy) PassValue() (C.VkBufferImageCopy, *cgoAllocMap) {
	if x.ref6d50e36e != nil {
		return *x.ref6d50e36e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferImageCopy) Deref() {
	if x.ref6d50e36e == nil {
		return
	}
	x.BufferOffset = (DeviceSize)(x.ref6d50e36e.bufferOffset)
	x.BufferRowLength = (uint32)(x.ref6d50e36e.bufferRowLength)
	x.BufferImageHeight = (uint32)(x.ref6d50e36e.bufferImageHeight)
	x.ImageSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref6d50e36e.imageSubresource))
	x.ImageOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref6d50e36e.imageOffset))
	x.ImageExtent = *NewExtent3DRef(unsafe.Pointer(&x.ref6d50e36e.imageExtent))
}

// allocClearDepthStencilValueMemory allocates memory for type C.VkClearDepthStencilValue in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearDepthStencilValueMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearDepthStencilValueValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfClearDepthStencilValueValue = unsafe.Sizeof([1]C.VkClearDepthStencilValue{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ClearDepthStencilValue) Ref() *C.VkClearDepthStencilValue {
	if x == nil {
		return nil
	}
	return x.refa7d07c03
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ClearDepthStencilValue) Free() {
	if x != nil && x.allocsa7d07c03 != nil {
		x.allocsa7d07c03.(*cgoAllocMap).Free()
		x.refa7d07c03 = nil
	}
}

// NewClearDepthStencilValueRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewClearDepthStencilValueRef(ref unsafe.Pointer) *ClearDepthStencilValue {
	if ref == nil {
		return nil
	}
	obj := new(ClearDepthStencilValue)
	obj.refa7d07c03 = (*C.VkClearDepthStencilValue)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ClearDepthStencilValue) PassRef() (*C.VkClearDepthStencilValue, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa7d07c03 != nil {
		return x.refa7d07c03, nil
	}
	mema7d07c03 := allocClearDepthStencilValueMemory(1)
	refa7d07c03 := (*C.VkClearDepthStencilValue)(mema7d07c03)
	allocsa7d07c03 := new(cgoAllocMap)
	allocsa7d07c03.Add(mema7d07c03)

	var cdepth_allocs *cgoAllocMap
	refa7d07c03.depth, cdepth_allocs = (C.float)(x.Depth), cgoAllocsUnknown
	allocsa7d07c03.Borrow(cdepth_allocs)

	var cstencil_allocs *cgoAllocMap
	refa7d07c03.stencil, cstencil_allocs = (C.uint32_t)(x.Stencil), cgoAllocsUnknown
	allocsa7d07c03.Borrow(cstencil_allocs)

	x.refa7d07c03 = refa7d07c03
	x.allocsa7d07c03 = allocsa7d07c03
	return refa7d07c03, allocsa7d07c03

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ClearDepthStencilValue) PassValue() (C.VkClearDepthStencilValue, *cgoAllocMap) {
	if x.refa7d07c03 != nil {
		return *x.refa7d07c03, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ClearDepthStencilValue) Deref() {
	if x.refa7d07c03 == nil {
		return
	}
	x.Depth = (float32)(x.refa7d07c03.depth)
	x.Stencil = (uint32)(x.refa7d07c03.stencil)
}

// allocClearAttachmentMemory allocates memory for type C.VkClearAttachment in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearAttachmentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearAttachmentValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfClearAttachmentValue = unsafe.Sizeof([1]C.VkClearAttachment{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ClearAttachment) Ref() *C.VkClearAttachment {
	if x == nil {
		return nil
	}
	return x.refe9150303
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ClearAttachment) Free() {
	if x != nil && x.allocse9150303 != nil {
		x.allocse9150303.(*cgoAllocMap).Free()
		x.refe9150303 = nil
	}
}

// NewClearAttachmentRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewClearAttachmentRef(ref unsafe.Pointer) *ClearAttachment {
	if ref == nil {
		return nil
	}
	obj := new(ClearAttachment)
	obj.refe9150303 = (*C.VkClearAttachment)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ClearAttachment) PassRef() (*C.VkClearAttachment, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe9150303 != nil {
		return x.refe9150303, nil
	}
	meme9150303 := allocClearAttachmentMemory(1)
	refe9150303 := (*C.VkClearAttachment)(meme9150303)
	allocse9150303 := new(cgoAllocMap)
	allocse9150303.Add(meme9150303)

	var caspectMask_allocs *cgoAllocMap
	refe9150303.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocse9150303.Borrow(caspectMask_allocs)

	var ccolorAttachment_allocs *cgoAllocMap
	refe9150303.colorAttachment, ccolorAttachment_allocs = (C.uint32_t)(x.ColorAttachment), cgoAllocsUnknown
	allocse9150303.Borrow(ccolorAttachment_allocs)

	var cclearValue_allocs *cgoAllocMap
	refe9150303.clearValue, cclearValue_allocs = *(*C.VkClearValue)(unsafe.Pointer(&x.ClearValue)), cgoAllocsUnknown
	allocse9150303.Borrow(cclearValue_allocs)

	x.refe9150303 = refe9150303
	x.allocse9150303 = allocse9150303
	return refe9150303, allocse9150303

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ClearAttachment) PassValue() (C.VkClearAttachment, *cgoAllocMap) {
	if x.refe9150303 != nil {
		return *x.refe9150303, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ClearAttachment) Deref() {
	if x.refe9150303 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.refe9150303.aspectMask)
	x.ColorAttachment = (uint32)(x.refe9150303.colorAttachment)
	x.ClearValue = *(*ClearValue)(unsafe.Pointer(&x.refe9150303.clearValue))
}

// allocClearRectMemory allocates memory for type C.VkClearRect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearRectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfClearRectValue = unsafe.Sizeof([1]C.VkClearRect{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ClearRect) Ref() *C.VkClearRect {
	if x == nil {
		return nil
	}
	return x.ref1d449c8b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ClearRect) Free() {
	if x != nil && x.allocs1d449c8b != nil {
		x.allocs1d449c8b.(*cgoAllocMap).Free()
		x.ref1d449c8b = nil
	}
}

// NewClearRectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewClearRectRef(ref unsafe.Pointer) *ClearRect {
	if ref == nil {
		return nil
	}
	obj := new(ClearRect)
	obj.ref1d449c8b = (*C.VkClearRect)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ClearRect) PassRef() (*C.VkClearRect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d449c8b != nil {
		return x.ref1d449c8b, nil
	}
	mem1d449c8b := allocClearRectMemory(1)
	ref1d449c8b := (*C.VkClearRect)(mem1d449c8b)
	allocs1d449c8b := new(cgoAllocMap)
	allocs1d449c8b.Add(mem1d449c8b)

	var crect_allocs *cgoAllocMap
	ref1d449c8b.rect, crect_allocs = x.Rect.PassValue()
	allocs1d449c8b.Borrow(crect_allocs)

	var cbaseArrayLayer_allocs *cgoAllocMap
	ref1d449c8b.baseArrayLayer, cbaseArrayLayer_allocs = (C.uint32_t)(x.BaseArrayLayer), cgoAllocsUnknown
	allocs1d449c8b.Borrow(cbaseArrayLayer_allocs)

	var clayerCount_allocs *cgoAllocMap
	ref1d449c8b.layerCount, clayerCount_allocs = (C.uint32_t)(x.LayerCount), cgoAllocsUnknown
	allocs1d449c8b.Borrow(clayerCount_allocs)

	x.ref1d449c8b = ref1d449c8b
	x.allocs1d449c8b = allocs1d449c8b
	return ref1d449c8b, allocs1d449c8b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ClearRect) PassValue() (C.VkClearRect, *cgoAllocMap) {
	if x.ref1d449c8b != nil {
		return *x.ref1d449c8b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ClearRect) Deref() {
	if x.ref1d449c8b == nil {
		return
	}
	x.Rect = *NewRect2DRef(unsafe.Pointer(&x.ref1d449c8b.rect))
	x.BaseArrayLayer = (uint32)(x.ref1d449c8b.baseArrayLayer)
	x.LayerCount = (uint32)(x.ref1d449c8b.layerCount)
}

// allocImageBlitMemory allocates memory for type C.VkImageBlit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageBlitMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageBlitValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageBlitValue = unsafe.Sizeof([1]C.VkImageBlit{})

// allocA2Offset3DMemory allocates memory for type [2]C.VkOffset3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA2Offset3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA2Offset3DValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA2Offset3DValue = unsafe.Sizeof([1][2]C.VkOffset3D{})

// unpackA2Offset3D transforms a sliced Go data structure into plain C format.
func unpackA2Offset3D(x [2]Offset3D) (unpacked [2]C.VkOffset3D, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA2Offset3DMemory(1)
	allocs.Add(mem0)
	v0 := (*[2]C.VkOffset3D)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[2]C.VkOffset3D)(mem0)
	return
}

// packA2Offset3D reads sliced Go data structure out from plain C format.
func packA2Offset3D(v *[2]Offset3D, ptr0 *[2]C.VkOffset3D) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewOffset3DRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageBlit) Ref() *C.VkImageBlit {
	if x == nil {
		return nil
	}
	return x.ref11311e8d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageBlit) Free() {
	if x != nil && x.allocs11311e8d != nil {
		x.allocs11311e8d.(*cgoAllocMap).Free()
		x.ref11311e8d = nil
	}
}

// NewImageBlitRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageBlitRef(ref unsafe.Pointer) *ImageBlit {
	if ref == nil {
		return nil
	}
	obj := new(ImageBlit)
	obj.ref11311e8d = (*C.VkImageBlit)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageBlit) PassRef() (*C.VkImageBlit, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11311e8d != nil {
		return x.ref11311e8d, nil
	}
	mem11311e8d := allocImageBlitMemory(1)
	ref11311e8d := (*C.VkImageBlit)(mem11311e8d)
	allocs11311e8d := new(cgoAllocMap)
	allocs11311e8d.Add(mem11311e8d)

	var csrcSubresource_allocs *cgoAllocMap
	ref11311e8d.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs11311e8d.Borrow(csrcSubresource_allocs)

	var csrcOffsets_allocs *cgoAllocMap
	ref11311e8d.srcOffsets, csrcOffsets_allocs = unpackA2Offset3D(x.SrcOffsets)
	allocs11311e8d.Borrow(csrcOffsets_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref11311e8d.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs11311e8d.Borrow(cdstSubresource_allocs)

	var cdstOffsets_allocs *cgoAllocMap
	ref11311e8d.dstOffsets, cdstOffsets_allocs = unpackA2Offset3D(x.DstOffsets)
	allocs11311e8d.Borrow(cdstOffsets_allocs)

	x.ref11311e8d = ref11311e8d
	x.allocs11311e8d = allocs11311e8d
	return ref11311e8d, allocs11311e8d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageBlit) PassValue() (C.VkImageBlit, *cgoAllocMap) {
	if x.ref11311e8d != nil {
		return *x.ref11311e8d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageBlit) Deref() {
	if x.ref11311e8d == nil {
		return
	}
	x.SrcSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref11311e8d.srcSubresource))
	packA2Offset3D(&x.SrcOffsets, (*[2]C.VkOffset3D)(unsafe.Pointer(&x.ref11311e8d.srcOffsets)))
	x.DstSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref11311e8d.dstSubresource))
	packA2Offset3D(&x.DstOffsets, (*[2]C.VkOffset3D)(unsafe.Pointer(&x.ref11311e8d.dstOffsets)))
}

// allocImageCopyMemory allocates memory for type C.VkImageCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCopyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageCopyValue = unsafe.Sizeof([1]C.VkImageCopy{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageCopy) Ref() *C.VkImageCopy {
	if x == nil {
		return nil
	}
	return x.ref4e7a1214
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageCopy) Free() {
	if x != nil && x.allocs4e7a1214 != nil {
		x.allocs4e7a1214.(*cgoAllocMap).Free()
		x.ref4e7a1214 = nil
	}
}

// NewImageCopyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageCopyRef(ref unsafe.Pointer) *ImageCopy {
	if ref == nil {
		return nil
	}
	obj := new(ImageCopy)
	obj.ref4e7a1214 = (*C.VkImageCopy)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageCopy) PassRef() (*C.VkImageCopy, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4e7a1214 != nil {
		return x.ref4e7a1214, nil
	}
	mem4e7a1214 := allocImageCopyMemory(1)
	ref4e7a1214 := (*C.VkImageCopy)(mem4e7a1214)
	allocs4e7a1214 := new(cgoAllocMap)
	allocs4e7a1214.Add(mem4e7a1214)

	var csrcSubresource_allocs *cgoAllocMap
	ref4e7a1214.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs4e7a1214.Borrow(csrcSubresource_allocs)

	var csrcOffset_allocs *cgoAllocMap
	ref4e7a1214.srcOffset, csrcOffset_allocs = x.SrcOffset.PassValue()
	allocs4e7a1214.Borrow(csrcOffset_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref4e7a1214.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs4e7a1214.Borrow(cdstSubresource_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref4e7a1214.dstOffset, cdstOffset_allocs = x.DstOffset.PassValue()
	allocs4e7a1214.Borrow(cdstOffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref4e7a1214.extent, cextent_allocs = x.Extent.PassValue()
	allocs4e7a1214.Borrow(cextent_allocs)

	x.ref4e7a1214 = ref4e7a1214
	x.allocs4e7a1214 = allocs4e7a1214
	return ref4e7a1214, allocs4e7a1214

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageCopy) PassValue() (C.VkImageCopy, *cgoAllocMap) {
	if x.ref4e7a1214 != nil {
		return *x.ref4e7a1214, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageCopy) Deref() {
	if x.ref4e7a1214 == nil {
		return
	}
	x.SrcSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref4e7a1214.srcSubresource))
	x.SrcOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref4e7a1214.srcOffset))
	x.DstSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref4e7a1214.dstSubresource))
	x.DstOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref4e7a1214.dstOffset))
	x.Extent = *NewExtent3DRef(unsafe.Pointer(&x.ref4e7a1214.extent))
}

// allocImageResolveMemory allocates memory for type C.VkImageResolve in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageResolveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageResolveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageResolveValue = unsafe.Sizeof([1]C.VkImageResolve{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageResolve) Ref() *C.VkImageResolve {
	if x == nil {
		return nil
	}
	return x.ref7bda856d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageResolve) Free() {
	if x != nil && x.allocs7bda856d != nil {
		x.allocs7bda856d.(*cgoAllocMap).Free()
		x.ref7bda856d = nil
	}
}

// NewImageResolveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageResolveRef(ref unsafe.Pointer) *ImageResolve {
	if ref == nil {
		return nil
	}
	obj := new(ImageResolve)
	obj.ref7bda856d = (*C.VkImageResolve)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageResolve) PassRef() (*C.VkImageResolve, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7bda856d != nil {
		return x.ref7bda856d, nil
	}
	mem7bda856d := allocImageResolveMemory(1)
	ref7bda856d := (*C.VkImageResolve)(mem7bda856d)
	allocs7bda856d := new(cgoAllocMap)
	allocs7bda856d.Add(mem7bda856d)

	var csrcSubresource_allocs *cgoAllocMap
	ref7bda856d.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs7bda856d.Borrow(csrcSubresource_allocs)

	var csrcOffset_allocs *cgoAllocMap
	ref7bda856d.srcOffset, csrcOffset_allocs = x.SrcOffset.PassValue()
	allocs7bda856d.Borrow(csrcOffset_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref7bda856d.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs7bda856d.Borrow(cdstSubresource_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref7bda856d.dstOffset, cdstOffset_allocs = x.DstOffset.PassValue()
	allocs7bda856d.Borrow(cdstOffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref7bda856d.extent, cextent_allocs = x.Extent.PassValue()
	allocs7bda856d.Borrow(cextent_allocs)

	x.ref7bda856d = ref7bda856d
	x.allocs7bda856d = allocs7bda856d
	return ref7bda856d, allocs7bda856d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageResolve) PassValue() (C.VkImageResolve, *cgoAllocMap) {
	if x.ref7bda856d != nil {
		return *x.ref7bda856d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageResolve) Deref() {
	if x.ref7bda856d == nil {
		return
	}
	x.SrcSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref7bda856d.srcSubresource))
	x.SrcOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref7bda856d.srcOffset))
	x.DstSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref7bda856d.dstSubresource))
	x.DstOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref7bda856d.dstOffset))
	x.Extent = *NewExtent3DRef(unsafe.Pointer(&x.ref7bda856d.extent))
}

// allocRenderPassBeginInfoMemory allocates memory for type C.VkRenderPassBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassBeginInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderPassBeginInfoValue = unsafe.Sizeof([1]C.VkRenderPassBeginInfo{})

// copyPClearValueBytes copies the data from Go slice as *C.VkClearValue.
func copyPClearValueBytes(slice *sliceHeader) (*C.VkClearValue, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfClearValueValue) * slice.Len,
		Cap:  int(sizeOfClearValueValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkClearValue)(mem0), allocs
}

// allocClearValueMemory allocates memory for type C.VkClearValue in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearValueMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearValueValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfClearValueValue = unsafe.Sizeof([1]C.VkClearValue{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassBeginInfo) Ref() *C.VkRenderPassBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref3c3752c8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassBeginInfo) Free() {
	if x != nil && x.allocs3c3752c8 != nil {
		x.allocs3c3752c8.(*cgoAllocMap).Free()
		x.ref3c3752c8 = nil
	}
}

// NewRenderPassBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassBeginInfoRef(ref unsafe.Pointer) *RenderPassBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassBeginInfo)
	obj.ref3c3752c8 = (*C.VkRenderPassBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassBeginInfo) PassRef() (*C.VkRenderPassBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c3752c8 != nil {
		return x.ref3c3752c8, nil
	}
	mem3c3752c8 := allocRenderPassBeginInfoMemory(1)
	ref3c3752c8 := (*C.VkRenderPassBeginInfo)(mem3c3752c8)
	allocs3c3752c8 := new(cgoAllocMap)
	allocs3c3752c8.Add(mem3c3752c8)

	var csType_allocs *cgoAllocMap
	ref3c3752c8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3c3752c8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3c3752c8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cpNext_allocs)

	var crenderPass_allocs *cgoAllocMap
	ref3c3752c8.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(crenderPass_allocs)

	var cframebuffer_allocs *cgoAllocMap
	ref3c3752c8.framebuffer, cframebuffer_allocs = *(*C.VkFramebuffer)(unsafe.Pointer(&x.Framebuffer)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cframebuffer_allocs)

	var crenderArea_allocs *cgoAllocMap
	ref3c3752c8.renderArea, crenderArea_allocs = x.RenderArea.PassValue()
	allocs3c3752c8.Borrow(crenderArea_allocs)

	var cclearValueCount_allocs *cgoAllocMap
	ref3c3752c8.clearValueCount, cclearValueCount_allocs = (C.uint32_t)(x.ClearValueCount), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cclearValueCount_allocs)

	var cpClearValues_allocs *cgoAllocMap
	ref3c3752c8.pClearValues, cpClearValues_allocs = copyPClearValueBytes((*sliceHeader)(unsafe.Pointer(&x.PClearValues)))
	allocs3c3752c8.Borrow(cpClearValues_allocs)

	x.ref3c3752c8 = ref3c3752c8
	x.allocs3c3752c8 = allocs3c3752c8
	return ref3c3752c8, allocs3c3752c8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassBeginInfo) PassValue() (C.VkRenderPassBeginInfo, *cgoAllocMap) {
	if x.ref3c3752c8 != nil {
		return *x.ref3c3752c8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassBeginInfo) Deref() {
	if x.ref3c3752c8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3c3752c8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3c3752c8.pNext))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref3c3752c8.renderPass))
	x.Framebuffer = *(*Framebuffer)(unsafe.Pointer(&x.ref3c3752c8.framebuffer))
	x.RenderArea = *NewRect2DRef(unsafe.Pointer(&x.ref3c3752c8.renderArea))
	x.ClearValueCount = (uint32)(x.ref3c3752c8.clearValueCount)
	hxf1231c9 := (*sliceHeader)(unsafe.Pointer(&x.PClearValues))
	hxf1231c9.Data = unsafe.Pointer(x.ref3c3752c8.pClearValues)
	hxf1231c9.Cap = 0x7fffffff
	// hxf1231c9.Len = ?

}

// allocPhysicalDeviceSubgroupPropertiesMemory allocates memory for type C.VkPhysicalDeviceSubgroupProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSubgroupPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSubgroupPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceSubgroupPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSubgroupProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSubgroupProperties) Ref() *C.VkPhysicalDeviceSubgroupProperties {
	if x == nil {
		return nil
	}
	return x.refb019c29f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSubgroupProperties) Free() {
	if x != nil && x.allocsb019c29f != nil {
		x.allocsb019c29f.(*cgoAllocMap).Free()
		x.refb019c29f = nil
	}
}

// NewPhysicalDeviceSubgroupPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSubgroupPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceSubgroupProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSubgroupProperties)
	obj.refb019c29f = (*C.VkPhysicalDeviceSubgroupProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSubgroupProperties) PassRef() (*C.VkPhysicalDeviceSubgroupProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb019c29f != nil {
		return x.refb019c29f, nil
	}
	memb019c29f := allocPhysicalDeviceSubgroupPropertiesMemory(1)
	refb019c29f := (*C.VkPhysicalDeviceSubgroupProperties)(memb019c29f)
	allocsb019c29f := new(cgoAllocMap)
	allocsb019c29f.Add(memb019c29f)

	var csType_allocs *cgoAllocMap
	refb019c29f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb019c29f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb019c29f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb019c29f.Borrow(cpNext_allocs)

	var csubgroupSize_allocs *cgoAllocMap
	refb019c29f.subgroupSize, csubgroupSize_allocs = (C.uint32_t)(x.SubgroupSize), cgoAllocsUnknown
	allocsb019c29f.Borrow(csubgroupSize_allocs)

	var csupportedStages_allocs *cgoAllocMap
	refb019c29f.supportedStages, csupportedStages_allocs = (C.VkShaderStageFlags)(x.SupportedStages), cgoAllocsUnknown
	allocsb019c29f.Borrow(csupportedStages_allocs)

	var csupportedOperations_allocs *cgoAllocMap
	refb019c29f.supportedOperations, csupportedOperations_allocs = (C.VkSubgroupFeatureFlags)(x.SupportedOperations), cgoAllocsUnknown
	allocsb019c29f.Borrow(csupportedOperations_allocs)

	var cquadOperationsInAllStages_allocs *cgoAllocMap
	refb019c29f.quadOperationsInAllStages, cquadOperationsInAllStages_allocs = (C.VkBool32)(x.QuadOperationsInAllStages), cgoAllocsUnknown
	allocsb019c29f.Borrow(cquadOperationsInAllStages_allocs)

	x.refb019c29f = refb019c29f
	x.allocsb019c29f = allocsb019c29f
	return refb019c29f, allocsb019c29f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSubgroupProperties) PassValue() (C.VkPhysicalDeviceSubgroupProperties, *cgoAllocMap) {
	if x.refb019c29f != nil {
		return *x.refb019c29f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSubgroupProperties) Deref() {
	if x.refb019c29f == nil {
		return
	}
	x.SType = (StructureType)(x.refb019c29f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb019c29f.pNext))
	x.SubgroupSize = (uint32)(x.refb019c29f.subgroupSize)
	x.SupportedStages = (ShaderStageFlags)(x.refb019c29f.supportedStages)
	x.SupportedOperations = (SubgroupFeatureFlags)(x.refb019c29f.supportedOperations)
	x.QuadOperationsInAllStages = (Bool32)(x.refb019c29f.quadOperationsInAllStages)
}

// allocBindBufferMemoryInfoMemory allocates memory for type C.VkBindBufferMemoryInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindBufferMemoryInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindBufferMemoryInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindBufferMemoryInfoValue = unsafe.Sizeof([1]C.VkBindBufferMemoryInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindBufferMemoryInfo) Ref() *C.VkBindBufferMemoryInfo {
	if x == nil {
		return nil
	}
	return x.refd392322d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindBufferMemoryInfo) Free() {
	if x != nil && x.allocsd392322d != nil {
		x.allocsd392322d.(*cgoAllocMap).Free()
		x.refd392322d = nil
	}
}

// NewBindBufferMemoryInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindBufferMemoryInfoRef(ref unsafe.Pointer) *BindBufferMemoryInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindBufferMemoryInfo)
	obj.refd392322d = (*C.VkBindBufferMemoryInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindBufferMemoryInfo) PassRef() (*C.VkBindBufferMemoryInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd392322d != nil {
		return x.refd392322d, nil
	}
	memd392322d := allocBindBufferMemoryInfoMemory(1)
	refd392322d := (*C.VkBindBufferMemoryInfo)(memd392322d)
	allocsd392322d := new(cgoAllocMap)
	allocsd392322d.Add(memd392322d)

	var csType_allocs *cgoAllocMap
	refd392322d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd392322d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd392322d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd392322d.Borrow(cpNext_allocs)

	var cbuffer_allocs *cgoAllocMap
	refd392322d.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsd392322d.Borrow(cbuffer_allocs)

	var cmemory_allocs *cgoAllocMap
	refd392322d.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocsd392322d.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	refd392322d.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocsd392322d.Borrow(cmemoryOffset_allocs)

	x.refd392322d = refd392322d
	x.allocsd392322d = allocsd392322d
	return refd392322d, allocsd392322d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindBufferMemoryInfo) PassValue() (C.VkBindBufferMemoryInfo, *cgoAllocMap) {
	if x.refd392322d != nil {
		return *x.refd392322d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindBufferMemoryInfo) Deref() {
	if x.refd392322d == nil {
		return
	}
	x.SType = (StructureType)(x.refd392322d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd392322d.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refd392322d.buffer))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.refd392322d.memory))
	x.MemoryOffset = (DeviceSize)(x.refd392322d.memoryOffset)
}

// allocBindImageMemoryInfoMemory allocates memory for type C.VkBindImageMemoryInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindImageMemoryInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindImageMemoryInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindImageMemoryInfoValue = unsafe.Sizeof([1]C.VkBindImageMemoryInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImageMemoryInfo) Ref() *C.VkBindImageMemoryInfo {
	if x == nil {
		return nil
	}
	return x.ref767a2113
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImageMemoryInfo) Free() {
	if x != nil && x.allocs767a2113 != nil {
		x.allocs767a2113.(*cgoAllocMap).Free()
		x.ref767a2113 = nil
	}
}

// NewBindImageMemoryInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImageMemoryInfoRef(ref unsafe.Pointer) *BindImageMemoryInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindImageMemoryInfo)
	obj.ref767a2113 = (*C.VkBindImageMemoryInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImageMemoryInfo) PassRef() (*C.VkBindImageMemoryInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref767a2113 != nil {
		return x.ref767a2113, nil
	}
	mem767a2113 := allocBindImageMemoryInfoMemory(1)
	ref767a2113 := (*C.VkBindImageMemoryInfo)(mem767a2113)
	allocs767a2113 := new(cgoAllocMap)
	allocs767a2113.Add(mem767a2113)

	var csType_allocs *cgoAllocMap
	ref767a2113.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs767a2113.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref767a2113.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs767a2113.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	ref767a2113.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs767a2113.Borrow(cimage_allocs)

	var cmemory_allocs *cgoAllocMap
	ref767a2113.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs767a2113.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	ref767a2113.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocs767a2113.Borrow(cmemoryOffset_allocs)

	x.ref767a2113 = ref767a2113
	x.allocs767a2113 = allocs767a2113
	return ref767a2113, allocs767a2113

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImageMemoryInfo) PassValue() (C.VkBindImageMemoryInfo, *cgoAllocMap) {
	if x.ref767a2113 != nil {
		return *x.ref767a2113, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImageMemoryInfo) Deref() {
	if x.ref767a2113 == nil {
		return
	}
	x.SType = (StructureType)(x.ref767a2113.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref767a2113.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref767a2113.image))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref767a2113.memory))
	x.MemoryOffset = (DeviceSize)(x.ref767a2113.memoryOffset)
}

// allocPhysicalDevice16BitStorageFeaturesMemory allocates memory for type C.VkPhysicalDevice16BitStorageFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevice16BitStorageFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevice16BitStorageFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDevice16BitStorageFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDevice16BitStorageFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevice16BitStorageFeatures) Ref() *C.VkPhysicalDevice16BitStorageFeatures {
	if x == nil {
		return nil
	}
	return x.refa90fed14
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevice16BitStorageFeatures) Free() {
	if x != nil && x.allocsa90fed14 != nil {
		x.allocsa90fed14.(*cgoAllocMap).Free()
		x.refa90fed14 = nil
	}
}

// NewPhysicalDevice16BitStorageFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevice16BitStorageFeaturesRef(ref unsafe.Pointer) *PhysicalDevice16BitStorageFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevice16BitStorageFeatures)
	obj.refa90fed14 = (*C.VkPhysicalDevice16BitStorageFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevice16BitStorageFeatures) PassRef() (*C.VkPhysicalDevice16BitStorageFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa90fed14 != nil {
		return x.refa90fed14, nil
	}
	mema90fed14 := allocPhysicalDevice16BitStorageFeaturesMemory(1)
	refa90fed14 := (*C.VkPhysicalDevice16BitStorageFeatures)(mema90fed14)
	allocsa90fed14 := new(cgoAllocMap)
	allocsa90fed14.Add(mema90fed14)

	var csType_allocs *cgoAllocMap
	refa90fed14.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa90fed14.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa90fed14.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa90fed14.Borrow(cpNext_allocs)

	var cstorageBuffer16BitAccess_allocs *cgoAllocMap
	refa90fed14.storageBuffer16BitAccess, cstorageBuffer16BitAccess_allocs = (C.VkBool32)(x.StorageBuffer16BitAccess), cgoAllocsUnknown
	allocsa90fed14.Borrow(cstorageBuffer16BitAccess_allocs)

	var cuniformAndStorageBuffer16BitAccess_allocs *cgoAllocMap
	refa90fed14.uniformAndStorageBuffer16BitAccess, cuniformAndStorageBuffer16BitAccess_allocs = (C.VkBool32)(x.UniformAndStorageBuffer16BitAccess), cgoAllocsUnknown
	allocsa90fed14.Borrow(cuniformAndStorageBuffer16BitAccess_allocs)

	var cstoragePushConstant16_allocs *cgoAllocMap
	refa90fed14.storagePushConstant16, cstoragePushConstant16_allocs = (C.VkBool32)(x.StoragePushConstant16), cgoAllocsUnknown
	allocsa90fed14.Borrow(cstoragePushConstant16_allocs)

	var cstorageInputOutput16_allocs *cgoAllocMap
	refa90fed14.storageInputOutput16, cstorageInputOutput16_allocs = (C.VkBool32)(x.StorageInputOutput16), cgoAllocsUnknown
	allocsa90fed14.Borrow(cstorageInputOutput16_allocs)

	x.refa90fed14 = refa90fed14
	x.allocsa90fed14 = allocsa90fed14
	return refa90fed14, allocsa90fed14

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevice16BitStorageFeatures) PassValue() (C.VkPhysicalDevice16BitStorageFeatures, *cgoAllocMap) {
	if x.refa90fed14 != nil {
		return *x.refa90fed14, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevice16BitStorageFeatures) Deref() {
	if x.refa90fed14 == nil {
		return
	}
	x.SType = (StructureType)(x.refa90fed14.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa90fed14.pNext))
	x.StorageBuffer16BitAccess = (Bool32)(x.refa90fed14.storageBuffer16BitAccess)
	x.UniformAndStorageBuffer16BitAccess = (Bool32)(x.refa90fed14.uniformAndStorageBuffer16BitAccess)
	x.StoragePushConstant16 = (Bool32)(x.refa90fed14.storagePushConstant16)
	x.StorageInputOutput16 = (Bool32)(x.refa90fed14.storageInputOutput16)
}

// allocMemoryDedicatedRequirementsMemory allocates memory for type C.VkMemoryDedicatedRequirements in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryDedicatedRequirementsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryDedicatedRequirementsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryDedicatedRequirementsValue = unsafe.Sizeof([1]C.VkMemoryDedicatedRequirements{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryDedicatedRequirements) Ref() *C.VkMemoryDedicatedRequirements {
	if x == nil {
		return nil
	}
	return x.refaa924122
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryDedicatedRequirements) Free() {
	if x != nil && x.allocsaa924122 != nil {
		x.allocsaa924122.(*cgoAllocMap).Free()
		x.refaa924122 = nil
	}
}

// NewMemoryDedicatedRequirementsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryDedicatedRequirementsRef(ref unsafe.Pointer) *MemoryDedicatedRequirements {
	if ref == nil {
		return nil
	}
	obj := new(MemoryDedicatedRequirements)
	obj.refaa924122 = (*C.VkMemoryDedicatedRequirements)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryDedicatedRequirements) PassRef() (*C.VkMemoryDedicatedRequirements, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaa924122 != nil {
		return x.refaa924122, nil
	}
	memaa924122 := allocMemoryDedicatedRequirementsMemory(1)
	refaa924122 := (*C.VkMemoryDedicatedRequirements)(memaa924122)
	allocsaa924122 := new(cgoAllocMap)
	allocsaa924122.Add(memaa924122)

	var csType_allocs *cgoAllocMap
	refaa924122.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsaa924122.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refaa924122.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsaa924122.Borrow(cpNext_allocs)

	var cprefersDedicatedAllocation_allocs *cgoAllocMap
	refaa924122.prefersDedicatedAllocation, cprefersDedicatedAllocation_allocs = (C.VkBool32)(x.PrefersDedicatedAllocation), cgoAllocsUnknown
	allocsaa924122.Borrow(cprefersDedicatedAllocation_allocs)

	var crequiresDedicatedAllocation_allocs *cgoAllocMap
	refaa924122.requiresDedicatedAllocation, crequiresDedicatedAllocation_allocs = (C.VkBool32)(x.RequiresDedicatedAllocation), cgoAllocsUnknown
	allocsaa924122.Borrow(crequiresDedicatedAllocation_allocs)

	x.refaa924122 = refaa924122
	x.allocsaa924122 = allocsaa924122
	return refaa924122, allocsaa924122

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryDedicatedRequirements) PassValue() (C.VkMemoryDedicatedRequirements, *cgoAllocMap) {
	if x.refaa924122 != nil {
		return *x.refaa924122, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryDedicatedRequirements) Deref() {
	if x.refaa924122 == nil {
		return
	}
	x.SType = (StructureType)(x.refaa924122.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refaa924122.pNext))
	x.PrefersDedicatedAllocation = (Bool32)(x.refaa924122.prefersDedicatedAllocation)
	x.RequiresDedicatedAllocation = (Bool32)(x.refaa924122.requiresDedicatedAllocation)
}

// allocMemoryDedicatedAllocateInfoMemory allocates memory for type C.VkMemoryDedicatedAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryDedicatedAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryDedicatedAllocateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryDedicatedAllocateInfoValue = unsafe.Sizeof([1]C.VkMemoryDedicatedAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryDedicatedAllocateInfo) Ref() *C.VkMemoryDedicatedAllocateInfo {
	if x == nil {
		return nil
	}
	return x.reff8fabe62
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryDedicatedAllocateInfo) Free() {
	if x != nil && x.allocsf8fabe62 != nil {
		x.allocsf8fabe62.(*cgoAllocMap).Free()
		x.reff8fabe62 = nil
	}
}

// NewMemoryDedicatedAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryDedicatedAllocateInfoRef(ref unsafe.Pointer) *MemoryDedicatedAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(MemoryDedicatedAllocateInfo)
	obj.reff8fabe62 = (*C.VkMemoryDedicatedAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryDedicatedAllocateInfo) PassRef() (*C.VkMemoryDedicatedAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff8fabe62 != nil {
		return x.reff8fabe62, nil
	}
	memf8fabe62 := allocMemoryDedicatedAllocateInfoMemory(1)
	reff8fabe62 := (*C.VkMemoryDedicatedAllocateInfo)(memf8fabe62)
	allocsf8fabe62 := new(cgoAllocMap)
	allocsf8fabe62.Add(memf8fabe62)

	var csType_allocs *cgoAllocMap
	reff8fabe62.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf8fabe62.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff8fabe62.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf8fabe62.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	reff8fabe62.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocsf8fabe62.Borrow(cimage_allocs)

	var cbuffer_allocs *cgoAllocMap
	reff8fabe62.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsf8fabe62.Borrow(cbuffer_allocs)

	x.reff8fabe62 = reff8fabe62
	x.allocsf8fabe62 = allocsf8fabe62
	return reff8fabe62, allocsf8fabe62

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryDedicatedAllocateInfo) PassValue() (C.VkMemoryDedicatedAllocateInfo, *cgoAllocMap) {
	if x.reff8fabe62 != nil {
		return *x.reff8fabe62, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryDedicatedAllocateInfo) Deref() {
	if x.reff8fabe62 == nil {
		return
	}
	x.SType = (StructureType)(x.reff8fabe62.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff8fabe62.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.reff8fabe62.image))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.reff8fabe62.buffer))
}

// allocMemoryAllocateFlagsInfoMemory allocates memory for type C.VkMemoryAllocateFlagsInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryAllocateFlagsInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryAllocateFlagsInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryAllocateFlagsInfoValue = unsafe.Sizeof([1]C.VkMemoryAllocateFlagsInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryAllocateFlagsInfo) Ref() *C.VkMemoryAllocateFlagsInfo {
	if x == nil {
		return nil
	}
	return x.ref7ca6664
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryAllocateFlagsInfo) Free() {
	if x != nil && x.allocs7ca6664 != nil {
		x.allocs7ca6664.(*cgoAllocMap).Free()
		x.ref7ca6664 = nil
	}
}

// NewMemoryAllocateFlagsInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryAllocateFlagsInfoRef(ref unsafe.Pointer) *MemoryAllocateFlagsInfo {
	if ref == nil {
		return nil
	}
	obj := new(MemoryAllocateFlagsInfo)
	obj.ref7ca6664 = (*C.VkMemoryAllocateFlagsInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryAllocateFlagsInfo) PassRef() (*C.VkMemoryAllocateFlagsInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7ca6664 != nil {
		return x.ref7ca6664, nil
	}
	mem7ca6664 := allocMemoryAllocateFlagsInfoMemory(1)
	ref7ca6664 := (*C.VkMemoryAllocateFlagsInfo)(mem7ca6664)
	allocs7ca6664 := new(cgoAllocMap)
	allocs7ca6664.Add(mem7ca6664)

	var csType_allocs *cgoAllocMap
	ref7ca6664.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7ca6664.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7ca6664.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7ca6664.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref7ca6664.flags, cflags_allocs = (C.VkMemoryAllocateFlags)(x.Flags), cgoAllocsUnknown
	allocs7ca6664.Borrow(cflags_allocs)

	var cdeviceMask_allocs *cgoAllocMap
	ref7ca6664.deviceMask, cdeviceMask_allocs = (C.uint32_t)(x.DeviceMask), cgoAllocsUnknown
	allocs7ca6664.Borrow(cdeviceMask_allocs)

	x.ref7ca6664 = ref7ca6664
	x.allocs7ca6664 = allocs7ca6664
	return ref7ca6664, allocs7ca6664

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryAllocateFlagsInfo) PassValue() (C.VkMemoryAllocateFlagsInfo, *cgoAllocMap) {
	if x.ref7ca6664 != nil {
		return *x.ref7ca6664, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryAllocateFlagsInfo) Deref() {
	if x.ref7ca6664 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7ca6664.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7ca6664.pNext))
	x.Flags = (MemoryAllocateFlags)(x.ref7ca6664.flags)
	x.DeviceMask = (uint32)(x.ref7ca6664.deviceMask)
}

// allocDeviceGroupRenderPassBeginInfoMemory allocates memory for type C.VkDeviceGroupRenderPassBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupRenderPassBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupRenderPassBeginInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceGroupRenderPassBeginInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupRenderPassBeginInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupRenderPassBeginInfo) Ref() *C.VkDeviceGroupRenderPassBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref139f3599
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupRenderPassBeginInfo) Free() {
	if x != nil && x.allocs139f3599 != nil {
		x.allocs139f3599.(*cgoAllocMap).Free()
		x.ref139f3599 = nil
	}
}

// NewDeviceGroupRenderPassBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupRenderPassBeginInfoRef(ref unsafe.Pointer) *DeviceGroupRenderPassBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupRenderPassBeginInfo)
	obj.ref139f3599 = (*C.VkDeviceGroupRenderPassBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupRenderPassBeginInfo) PassRef() (*C.VkDeviceGroupRenderPassBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref139f3599 != nil {
		return x.ref139f3599, nil
	}
	mem139f3599 := allocDeviceGroupRenderPassBeginInfoMemory(1)
	ref139f3599 := (*C.VkDeviceGroupRenderPassBeginInfo)(mem139f3599)
	allocs139f3599 := new(cgoAllocMap)
	allocs139f3599.Add(mem139f3599)

	var csType_allocs *cgoAllocMap
	ref139f3599.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs139f3599.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref139f3599.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs139f3599.Borrow(cpNext_allocs)

	var cdeviceMask_allocs *cgoAllocMap
	ref139f3599.deviceMask, cdeviceMask_allocs = (C.uint32_t)(x.DeviceMask), cgoAllocsUnknown
	allocs139f3599.Borrow(cdeviceMask_allocs)

	var cdeviceRenderAreaCount_allocs *cgoAllocMap
	ref139f3599.deviceRenderAreaCount, cdeviceRenderAreaCount_allocs = (C.uint32_t)(x.DeviceRenderAreaCount), cgoAllocsUnknown
	allocs139f3599.Borrow(cdeviceRenderAreaCount_allocs)

	var cpDeviceRenderAreas_allocs *cgoAllocMap
	ref139f3599.pDeviceRenderAreas, cpDeviceRenderAreas_allocs = unpackSRect2D(x.PDeviceRenderAreas)
	allocs139f3599.Borrow(cpDeviceRenderAreas_allocs)

	x.ref139f3599 = ref139f3599
	x.allocs139f3599 = allocs139f3599
	return ref139f3599, allocs139f3599

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupRenderPassBeginInfo) PassValue() (C.VkDeviceGroupRenderPassBeginInfo, *cgoAllocMap) {
	if x.ref139f3599 != nil {
		return *x.ref139f3599, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupRenderPassBeginInfo) Deref() {
	if x.ref139f3599 == nil {
		return
	}
	x.SType = (StructureType)(x.ref139f3599.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref139f3599.pNext))
	x.DeviceMask = (uint32)(x.ref139f3599.deviceMask)
	x.DeviceRenderAreaCount = (uint32)(x.ref139f3599.deviceRenderAreaCount)
	packSRect2D(x.PDeviceRenderAreas, x.ref139f3599.pDeviceRenderAreas)
}

// allocDeviceGroupCommandBufferBeginInfoMemory allocates memory for type C.VkDeviceGroupCommandBufferBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupCommandBufferBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupCommandBufferBeginInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceGroupCommandBufferBeginInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupCommandBufferBeginInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupCommandBufferBeginInfo) Ref() *C.VkDeviceGroupCommandBufferBeginInfo {
	if x == nil {
		return nil
	}
	return x.refb9a8f0cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupCommandBufferBeginInfo) Free() {
	if x != nil && x.allocsb9a8f0cd != nil {
		x.allocsb9a8f0cd.(*cgoAllocMap).Free()
		x.refb9a8f0cd = nil
	}
}

// NewDeviceGroupCommandBufferBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupCommandBufferBeginInfoRef(ref unsafe.Pointer) *DeviceGroupCommandBufferBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupCommandBufferBeginInfo)
	obj.refb9a8f0cd = (*C.VkDeviceGroupCommandBufferBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupCommandBufferBeginInfo) PassRef() (*C.VkDeviceGroupCommandBufferBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb9a8f0cd != nil {
		return x.refb9a8f0cd, nil
	}
	memb9a8f0cd := allocDeviceGroupCommandBufferBeginInfoMemory(1)
	refb9a8f0cd := (*C.VkDeviceGroupCommandBufferBeginInfo)(memb9a8f0cd)
	allocsb9a8f0cd := new(cgoAllocMap)
	allocsb9a8f0cd.Add(memb9a8f0cd)

	var csType_allocs *cgoAllocMap
	refb9a8f0cd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb9a8f0cd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb9a8f0cd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb9a8f0cd.Borrow(cpNext_allocs)

	var cdeviceMask_allocs *cgoAllocMap
	refb9a8f0cd.deviceMask, cdeviceMask_allocs = (C.uint32_t)(x.DeviceMask), cgoAllocsUnknown
	allocsb9a8f0cd.Borrow(cdeviceMask_allocs)

	x.refb9a8f0cd = refb9a8f0cd
	x.allocsb9a8f0cd = allocsb9a8f0cd
	return refb9a8f0cd, allocsb9a8f0cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupCommandBufferBeginInfo) PassValue() (C.VkDeviceGroupCommandBufferBeginInfo, *cgoAllocMap) {
	if x.refb9a8f0cd != nil {
		return *x.refb9a8f0cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupCommandBufferBeginInfo) Deref() {
	if x.refb9a8f0cd == nil {
		return
	}
	x.SType = (StructureType)(x.refb9a8f0cd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb9a8f0cd.pNext))
	x.DeviceMask = (uint32)(x.refb9a8f0cd.deviceMask)
}

// allocDeviceGroupSubmitInfoMemory allocates memory for type C.VkDeviceGroupSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupSubmitInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceGroupSubmitInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupSubmitInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupSubmitInfo) Ref() *C.VkDeviceGroupSubmitInfo {
	if x == nil {
		return nil
	}
	return x.refea4e7ce4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupSubmitInfo) Free() {
	if x != nil && x.allocsea4e7ce4 != nil {
		x.allocsea4e7ce4.(*cgoAllocMap).Free()
		x.refea4e7ce4 = nil
	}
}

// NewDeviceGroupSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupSubmitInfoRef(ref unsafe.Pointer) *DeviceGroupSubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupSubmitInfo)
	obj.refea4e7ce4 = (*C.VkDeviceGroupSubmitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupSubmitInfo) PassRef() (*C.VkDeviceGroupSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refea4e7ce4 != nil {
		return x.refea4e7ce4, nil
	}
	memea4e7ce4 := allocDeviceGroupSubmitInfoMemory(1)
	refea4e7ce4 := (*C.VkDeviceGroupSubmitInfo)(memea4e7ce4)
	allocsea4e7ce4 := new(cgoAllocMap)
	allocsea4e7ce4.Add(memea4e7ce4)

	var csType_allocs *cgoAllocMap
	refea4e7ce4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refea4e7ce4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	refea4e7ce4.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphoreDeviceIndices_allocs *cgoAllocMap
	refea4e7ce4.pWaitSemaphoreDeviceIndices, cpWaitSemaphoreDeviceIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphoreDeviceIndices)))
	allocsea4e7ce4.Borrow(cpWaitSemaphoreDeviceIndices_allocs)

	var ccommandBufferCount_allocs *cgoAllocMap
	refea4e7ce4.commandBufferCount, ccommandBufferCount_allocs = (C.uint32_t)(x.CommandBufferCount), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(ccommandBufferCount_allocs)

	var cpCommandBufferDeviceMasks_allocs *cgoAllocMap
	refea4e7ce4.pCommandBufferDeviceMasks, cpCommandBufferDeviceMasks_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PCommandBufferDeviceMasks)))
	allocsea4e7ce4.Borrow(cpCommandBufferDeviceMasks_allocs)

	var csignalSemaphoreCount_allocs *cgoAllocMap
	refea4e7ce4.signalSemaphoreCount, csignalSemaphoreCount_allocs = (C.uint32_t)(x.SignalSemaphoreCount), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(csignalSemaphoreCount_allocs)

	var cpSignalSemaphoreDeviceIndices_allocs *cgoAllocMap
	refea4e7ce4.pSignalSemaphoreDeviceIndices, cpSignalSemaphoreDeviceIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphoreDeviceIndices)))
	allocsea4e7ce4.Borrow(cpSignalSemaphoreDeviceIndices_allocs)

	x.refea4e7ce4 = refea4e7ce4
	x.allocsea4e7ce4 = allocsea4e7ce4
	return refea4e7ce4, allocsea4e7ce4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupSubmitInfo) PassValue() (C.VkDeviceGroupSubmitInfo, *cgoAllocMap) {
	if x.refea4e7ce4 != nil {
		return *x.refea4e7ce4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupSubmitInfo) Deref() {
	if x.refea4e7ce4 == nil {
		return
	}
	x.SType = (StructureType)(x.refea4e7ce4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refea4e7ce4.pNext))
	x.WaitSemaphoreCount = (uint32)(x.refea4e7ce4.waitSemaphoreCount)
	hxf04b15b := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphoreDeviceIndices))
	hxf04b15b.Data = unsafe.Pointer(x.refea4e7ce4.pWaitSemaphoreDeviceIndices)
	hxf04b15b.Cap = 0x7fffffff
	// hxf04b15b.Len = ?

	x.CommandBufferCount = (uint32)(x.refea4e7ce4.commandBufferCount)
	hxf2f888b := (*sliceHeader)(unsafe.Pointer(&x.PCommandBufferDeviceMasks))
	hxf2f888b.Data = unsafe.Pointer(x.refea4e7ce4.pCommandBufferDeviceMasks)
	hxf2f888b.Cap = 0x7fffffff
	// hxf2f888b.Len = ?

	x.SignalSemaphoreCount = (uint32)(x.refea4e7ce4.signalSemaphoreCount)
	hxf5d1de2 := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphoreDeviceIndices))
	hxf5d1de2.Data = unsafe.Pointer(x.refea4e7ce4.pSignalSemaphoreDeviceIndices)
	hxf5d1de2.Cap = 0x7fffffff
	// hxf5d1de2.Len = ?

}

// allocDeviceGroupBindSparseInfoMemory allocates memory for type C.VkDeviceGroupBindSparseInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupBindSparseInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupBindSparseInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceGroupBindSparseInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupBindSparseInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupBindSparseInfo) Ref() *C.VkDeviceGroupBindSparseInfo {
	if x == nil {
		return nil
	}
	return x.ref5b5446cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupBindSparseInfo) Free() {
	if x != nil && x.allocs5b5446cd != nil {
		x.allocs5b5446cd.(*cgoAllocMap).Free()
		x.ref5b5446cd = nil
	}
}

// NewDeviceGroupBindSparseInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupBindSparseInfoRef(ref unsafe.Pointer) *DeviceGroupBindSparseInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupBindSparseInfo)
	obj.ref5b5446cd = (*C.VkDeviceGroupBindSparseInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupBindSparseInfo) PassRef() (*C.VkDeviceGroupBindSparseInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5b5446cd != nil {
		return x.ref5b5446cd, nil
	}
	mem5b5446cd := allocDeviceGroupBindSparseInfoMemory(1)
	ref5b5446cd := (*C.VkDeviceGroupBindSparseInfo)(mem5b5446cd)
	allocs5b5446cd := new(cgoAllocMap)
	allocs5b5446cd.Add(mem5b5446cd)

	var csType_allocs *cgoAllocMap
	ref5b5446cd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5b5446cd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5b5446cd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5b5446cd.Borrow(cpNext_allocs)

	var cresourceDeviceIndex_allocs *cgoAllocMap
	ref5b5446cd.resourceDeviceIndex, cresourceDeviceIndex_allocs = (C.uint32_t)(x.ResourceDeviceIndex), cgoAllocsUnknown
	allocs5b5446cd.Borrow(cresourceDeviceIndex_allocs)

	var cmemoryDeviceIndex_allocs *cgoAllocMap
	ref5b5446cd.memoryDeviceIndex, cmemoryDeviceIndex_allocs = (C.uint32_t)(x.MemoryDeviceIndex), cgoAllocsUnknown
	allocs5b5446cd.Borrow(cmemoryDeviceIndex_allocs)

	x.ref5b5446cd = ref5b5446cd
	x.allocs5b5446cd = allocs5b5446cd
	return ref5b5446cd, allocs5b5446cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupBindSparseInfo) PassValue() (C.VkDeviceGroupBindSparseInfo, *cgoAllocMap) {
	if x.ref5b5446cd != nil {
		return *x.ref5b5446cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupBindSparseInfo) Deref() {
	if x.ref5b5446cd == nil {
		return
	}
	x.SType = (StructureType)(x.ref5b5446cd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5b5446cd.pNext))
	x.ResourceDeviceIndex = (uint32)(x.ref5b5446cd.resourceDeviceIndex)
	x.MemoryDeviceIndex = (uint32)(x.ref5b5446cd.memoryDeviceIndex)
}

// allocBindBufferMemoryDeviceGroupInfoMemory allocates memory for type C.VkBindBufferMemoryDeviceGroupInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindBufferMemoryDeviceGroupInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindBufferMemoryDeviceGroupInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindBufferMemoryDeviceGroupInfoValue = unsafe.Sizeof([1]C.VkBindBufferMemoryDeviceGroupInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindBufferMemoryDeviceGroupInfo) Ref() *C.VkBindBufferMemoryDeviceGroupInfo {
	if x == nil {
		return nil
	}
	return x.reff136b64f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindBufferMemoryDeviceGroupInfo) Free() {
	if x != nil && x.allocsf136b64f != nil {
		x.allocsf136b64f.(*cgoAllocMap).Free()
		x.reff136b64f = nil
	}
}

// NewBindBufferMemoryDeviceGroupInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindBufferMemoryDeviceGroupInfoRef(ref unsafe.Pointer) *BindBufferMemoryDeviceGroupInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindBufferMemoryDeviceGroupInfo)
	obj.reff136b64f = (*C.VkBindBufferMemoryDeviceGroupInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindBufferMemoryDeviceGroupInfo) PassRef() (*C.VkBindBufferMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff136b64f != nil {
		return x.reff136b64f, nil
	}
	memf136b64f := allocBindBufferMemoryDeviceGroupInfoMemory(1)
	reff136b64f := (*C.VkBindBufferMemoryDeviceGroupInfo)(memf136b64f)
	allocsf136b64f := new(cgoAllocMap)
	allocsf136b64f.Add(memf136b64f)

	var csType_allocs *cgoAllocMap
	reff136b64f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf136b64f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff136b64f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf136b64f.Borrow(cpNext_allocs)

	var cdeviceIndexCount_allocs *cgoAllocMap
	reff136b64f.deviceIndexCount, cdeviceIndexCount_allocs = (C.uint32_t)(x.DeviceIndexCount), cgoAllocsUnknown
	allocsf136b64f.Borrow(cdeviceIndexCount_allocs)

	var cpDeviceIndices_allocs *cgoAllocMap
	reff136b64f.pDeviceIndices, cpDeviceIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices)))
	allocsf136b64f.Borrow(cpDeviceIndices_allocs)

	x.reff136b64f = reff136b64f
	x.allocsf136b64f = allocsf136b64f
	return reff136b64f, allocsf136b64f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindBufferMemoryDeviceGroupInfo) PassValue() (C.VkBindBufferMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x.reff136b64f != nil {
		return *x.reff136b64f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindBufferMemoryDeviceGroupInfo) Deref() {
	if x.reff136b64f == nil {
		return
	}
	x.SType = (StructureType)(x.reff136b64f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff136b64f.pNext))
	x.DeviceIndexCount = (uint32)(x.reff136b64f.deviceIndexCount)
	hxfe53d34 := (*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices))
	hxfe53d34.Data = unsafe.Pointer(x.reff136b64f.pDeviceIndices)
	hxfe53d34.Cap = 0x7fffffff
	// hxfe53d34.Len = ?

}

// allocBindImageMemoryDeviceGroupInfoMemory allocates memory for type C.VkBindImageMemoryDeviceGroupInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindImageMemoryDeviceGroupInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindImageMemoryDeviceGroupInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindImageMemoryDeviceGroupInfoValue = unsafe.Sizeof([1]C.VkBindImageMemoryDeviceGroupInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImageMemoryDeviceGroupInfo) Ref() *C.VkBindImageMemoryDeviceGroupInfo {
	if x == nil {
		return nil
	}
	return x.ref24f026a5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImageMemoryDeviceGroupInfo) Free() {
	if x != nil && x.allocs24f026a5 != nil {
		x.allocs24f026a5.(*cgoAllocMap).Free()
		x.ref24f026a5 = nil
	}
}

// NewBindImageMemoryDeviceGroupInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImageMemoryDeviceGroupInfoRef(ref unsafe.Pointer) *BindImageMemoryDeviceGroupInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindImageMemoryDeviceGroupInfo)
	obj.ref24f026a5 = (*C.VkBindImageMemoryDeviceGroupInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImageMemoryDeviceGroupInfo) PassRef() (*C.VkBindImageMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref24f026a5 != nil {
		return x.ref24f026a5, nil
	}
	mem24f026a5 := allocBindImageMemoryDeviceGroupInfoMemory(1)
	ref24f026a5 := (*C.VkBindImageMemoryDeviceGroupInfo)(mem24f026a5)
	allocs24f026a5 := new(cgoAllocMap)
	allocs24f026a5.Add(mem24f026a5)

	var csType_allocs *cgoAllocMap
	ref24f026a5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs24f026a5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref24f026a5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs24f026a5.Borrow(cpNext_allocs)

	var cdeviceIndexCount_allocs *cgoAllocMap
	ref24f026a5.deviceIndexCount, cdeviceIndexCount_allocs = (C.uint32_t)(x.DeviceIndexCount), cgoAllocsUnknown
	allocs24f026a5.Borrow(cdeviceIndexCount_allocs)

	var cpDeviceIndices_allocs *cgoAllocMap
	ref24f026a5.pDeviceIndices, cpDeviceIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices)))
	allocs24f026a5.Borrow(cpDeviceIndices_allocs)

	var csplitInstanceBindRegionCount_allocs *cgoAllocMap
	ref24f026a5.splitInstanceBindRegionCount, csplitInstanceBindRegionCount_allocs = (C.uint32_t)(x.SplitInstanceBindRegionCount), cgoAllocsUnknown
	allocs24f026a5.Borrow(csplitInstanceBindRegionCount_allocs)

	var cpSplitInstanceBindRegions_allocs *cgoAllocMap
	ref24f026a5.pSplitInstanceBindRegions, cpSplitInstanceBindRegions_allocs = unpackSRect2D(x.PSplitInstanceBindRegions)
	allocs24f026a5.Borrow(cpSplitInstanceBindRegions_allocs)

	x.ref24f026a5 = ref24f026a5
	x.allocs24f026a5 = allocs24f026a5
	return ref24f026a5, allocs24f026a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImageMemoryDeviceGroupInfo) PassValue() (C.VkBindImageMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x.ref24f026a5 != nil {
		return *x.ref24f026a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImageMemoryDeviceGroupInfo) Deref() {
	if x.ref24f026a5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref24f026a5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref24f026a5.pNext))
	x.DeviceIndexCount = (uint32)(x.ref24f026a5.deviceIndexCount)
	hxf547023 := (*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices))
	hxf547023.Data = unsafe.Pointer(x.ref24f026a5.pDeviceIndices)
	hxf547023.Cap = 0x7fffffff
	// hxf547023.Len = ?

	x.SplitInstanceBindRegionCount = (uint32)(x.ref24f026a5.splitInstanceBindRegionCount)
	packSRect2D(x.PSplitInstanceBindRegions, x.ref24f026a5.pSplitInstanceBindRegions)
}

// allocPhysicalDeviceGroupPropertiesMemory allocates memory for type C.VkPhysicalDeviceGroupProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceGroupPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceGroupPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceGroupPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceGroupProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceGroupProperties) Ref() *C.VkPhysicalDeviceGroupProperties {
	if x == nil {
		return nil
	}
	return x.ref2aa9a663
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceGroupProperties) Free() {
	if x != nil && x.allocs2aa9a663 != nil {
		x.allocs2aa9a663.(*cgoAllocMap).Free()
		x.ref2aa9a663 = nil
	}
}

// NewPhysicalDeviceGroupPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceGroupPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceGroupProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceGroupProperties)
	obj.ref2aa9a663 = (*C.VkPhysicalDeviceGroupProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceGroupProperties) PassRef() (*C.VkPhysicalDeviceGroupProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2aa9a663 != nil {
		return x.ref2aa9a663, nil
	}
	mem2aa9a663 := allocPhysicalDeviceGroupPropertiesMemory(1)
	ref2aa9a663 := (*C.VkPhysicalDeviceGroupProperties)(mem2aa9a663)
	allocs2aa9a663 := new(cgoAllocMap)
	allocs2aa9a663.Add(mem2aa9a663)

	var csType_allocs *cgoAllocMap
	ref2aa9a663.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2aa9a663.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2aa9a663.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2aa9a663.Borrow(cpNext_allocs)

	var cphysicalDeviceCount_allocs *cgoAllocMap
	ref2aa9a663.physicalDeviceCount, cphysicalDeviceCount_allocs = (C.uint32_t)(x.PhysicalDeviceCount), cgoAllocsUnknown
	allocs2aa9a663.Borrow(cphysicalDeviceCount_allocs)

	var cphysicalDevices_allocs *cgoAllocMap
	ref2aa9a663.physicalDevices, cphysicalDevices_allocs = *(*[32]C.VkPhysicalDevice)(unsafe.Pointer(&x.PhysicalDevices)), cgoAllocsUnknown
	allocs2aa9a663.Borrow(cphysicalDevices_allocs)

	var csubsetAllocation_allocs *cgoAllocMap
	ref2aa9a663.subsetAllocation, csubsetAllocation_allocs = (C.VkBool32)(x.SubsetAllocation), cgoAllocsUnknown
	allocs2aa9a663.Borrow(csubsetAllocation_allocs)

	x.ref2aa9a663 = ref2aa9a663
	x.allocs2aa9a663 = allocs2aa9a663
	return ref2aa9a663, allocs2aa9a663

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceGroupProperties) PassValue() (C.VkPhysicalDeviceGroupProperties, *cgoAllocMap) {
	if x.ref2aa9a663 != nil {
		return *x.ref2aa9a663, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceGroupProperties) Deref() {
	if x.ref2aa9a663 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2aa9a663.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2aa9a663.pNext))
	x.PhysicalDeviceCount = (uint32)(x.ref2aa9a663.physicalDeviceCount)
	x.PhysicalDevices = *(*[32]PhysicalDevice)(unsafe.Pointer(&x.ref2aa9a663.physicalDevices))
	x.SubsetAllocation = (Bool32)(x.ref2aa9a663.subsetAllocation)
}

// allocDeviceGroupDeviceCreateInfoMemory allocates memory for type C.VkDeviceGroupDeviceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupDeviceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupDeviceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceGroupDeviceCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupDeviceCreateInfo{})

// copyPPhysicalDeviceBytes copies the data from Go slice as *C.VkPhysicalDevice.
func copyPPhysicalDeviceBytes(slice *sliceHeader) (*C.VkPhysicalDevice, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPhysicalDeviceValue) * slice.Len,
		Cap:  int(sizeOfPhysicalDeviceValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkPhysicalDevice)(mem0), allocs
}

// allocPhysicalDeviceMemory allocates memory for type C.VkPhysicalDevice in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceValue = unsafe.Sizeof([1]C.VkPhysicalDevice{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupDeviceCreateInfo) Ref() *C.VkDeviceGroupDeviceCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb2275723
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupDeviceCreateInfo) Free() {
	if x != nil && x.allocsb2275723 != nil {
		x.allocsb2275723.(*cgoAllocMap).Free()
		x.refb2275723 = nil
	}
}

// NewDeviceGroupDeviceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupDeviceCreateInfoRef(ref unsafe.Pointer) *DeviceGroupDeviceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupDeviceCreateInfo)
	obj.refb2275723 = (*C.VkDeviceGroupDeviceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupDeviceCreateInfo) PassRef() (*C.VkDeviceGroupDeviceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb2275723 != nil {
		return x.refb2275723, nil
	}
	memb2275723 := allocDeviceGroupDeviceCreateInfoMemory(1)
	refb2275723 := (*C.VkDeviceGroupDeviceCreateInfo)(memb2275723)
	allocsb2275723 := new(cgoAllocMap)
	allocsb2275723.Add(memb2275723)

	var csType_allocs *cgoAllocMap
	refb2275723.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb2275723.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb2275723.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb2275723.Borrow(cpNext_allocs)

	var cphysicalDeviceCount_allocs *cgoAllocMap
	refb2275723.physicalDeviceCount, cphysicalDeviceCount_allocs = (C.uint32_t)(x.PhysicalDeviceCount), cgoAllocsUnknown
	allocsb2275723.Borrow(cphysicalDeviceCount_allocs)

	var cpPhysicalDevices_allocs *cgoAllocMap
	refb2275723.pPhysicalDevices, cpPhysicalDevices_allocs = copyPPhysicalDeviceBytes((*sliceHeader)(unsafe.Pointer(&x.PPhysicalDevices)))
	allocsb2275723.Borrow(cpPhysicalDevices_allocs)

	x.refb2275723 = refb2275723
	x.allocsb2275723 = allocsb2275723
	return refb2275723, allocsb2275723

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupDeviceCreateInfo) PassValue() (C.VkDeviceGroupDeviceCreateInfo, *cgoAllocMap) {
	if x.refb2275723 != nil {
		return *x.refb2275723, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupDeviceCreateInfo) Deref() {
	if x.refb2275723 == nil {
		return
	}
	x.SType = (StructureType)(x.refb2275723.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb2275723.pNext))
	x.PhysicalDeviceCount = (uint32)(x.refb2275723.physicalDeviceCount)
	hxf5ebb88 := (*sliceHeader)(unsafe.Pointer(&x.PPhysicalDevices))
	hxf5ebb88.Data = unsafe.Pointer(x.refb2275723.pPhysicalDevices)
	hxf5ebb88.Cap = 0x7fffffff
	// hxf5ebb88.Len = ?

}

// allocBufferMemoryRequirementsInfo2Memory allocates memory for type C.VkBufferMemoryRequirementsInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferMemoryRequirementsInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferMemoryRequirementsInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferMemoryRequirementsInfo2Value = unsafe.Sizeof([1]C.VkBufferMemoryRequirementsInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferMemoryRequirementsInfo2) Ref() *C.VkBufferMemoryRequirementsInfo2 {
	if x == nil {
		return nil
	}
	return x.reff54a2a42
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferMemoryRequirementsInfo2) Free() {
	if x != nil && x.allocsf54a2a42 != nil {
		x.allocsf54a2a42.(*cgoAllocMap).Free()
		x.reff54a2a42 = nil
	}
}

// NewBufferMemoryRequirementsInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferMemoryRequirementsInfo2Ref(ref unsafe.Pointer) *BufferMemoryRequirementsInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(BufferMemoryRequirementsInfo2)
	obj.reff54a2a42 = (*C.VkBufferMemoryRequirementsInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferMemoryRequirementsInfo2) PassRef() (*C.VkBufferMemoryRequirementsInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff54a2a42 != nil {
		return x.reff54a2a42, nil
	}
	memf54a2a42 := allocBufferMemoryRequirementsInfo2Memory(1)
	reff54a2a42 := (*C.VkBufferMemoryRequirementsInfo2)(memf54a2a42)
	allocsf54a2a42 := new(cgoAllocMap)
	allocsf54a2a42.Add(memf54a2a42)

	var csType_allocs *cgoAllocMap
	reff54a2a42.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf54a2a42.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff54a2a42.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf54a2a42.Borrow(cpNext_allocs)

	var cbuffer_allocs *cgoAllocMap
	reff54a2a42.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsf54a2a42.Borrow(cbuffer_allocs)

	x.reff54a2a42 = reff54a2a42
	x.allocsf54a2a42 = allocsf54a2a42
	return reff54a2a42, allocsf54a2a42

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferMemoryRequirementsInfo2) PassValue() (C.VkBufferMemoryRequirementsInfo2, *cgoAllocMap) {
	if x.reff54a2a42 != nil {
		return *x.reff54a2a42, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferMemoryRequirementsInfo2) Deref() {
	if x.reff54a2a42 == nil {
		return
	}
	x.SType = (StructureType)(x.reff54a2a42.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff54a2a42.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.reff54a2a42.buffer))
}

// allocImageMemoryRequirementsInfo2Memory allocates memory for type C.VkImageMemoryRequirementsInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemoryRequirementsInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageMemoryRequirementsInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageMemoryRequirementsInfo2Value = unsafe.Sizeof([1]C.VkImageMemoryRequirementsInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageMemoryRequirementsInfo2) Ref() *C.VkImageMemoryRequirementsInfo2 {
	if x == nil {
		return nil
	}
	return x.ref75b3ca05
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageMemoryRequirementsInfo2) Free() {
	if x != nil && x.allocs75b3ca05 != nil {
		x.allocs75b3ca05.(*cgoAllocMap).Free()
		x.ref75b3ca05 = nil
	}
}

// NewImageMemoryRequirementsInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageMemoryRequirementsInfo2Ref(ref unsafe.Pointer) *ImageMemoryRequirementsInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(ImageMemoryRequirementsInfo2)
	obj.ref75b3ca05 = (*C.VkImageMemoryRequirementsInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageMemoryRequirementsInfo2) PassRef() (*C.VkImageMemoryRequirementsInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75b3ca05 != nil {
		return x.ref75b3ca05, nil
	}
	mem75b3ca05 := allocImageMemoryRequirementsInfo2Memory(1)
	ref75b3ca05 := (*C.VkImageMemoryRequirementsInfo2)(mem75b3ca05)
	allocs75b3ca05 := new(cgoAllocMap)
	allocs75b3ca05.Add(mem75b3ca05)

	var csType_allocs *cgoAllocMap
	ref75b3ca05.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs75b3ca05.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref75b3ca05.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs75b3ca05.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	ref75b3ca05.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs75b3ca05.Borrow(cimage_allocs)

	x.ref75b3ca05 = ref75b3ca05
	x.allocs75b3ca05 = allocs75b3ca05
	return ref75b3ca05, allocs75b3ca05

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageMemoryRequirementsInfo2) PassValue() (C.VkImageMemoryRequirementsInfo2, *cgoAllocMap) {
	if x.ref75b3ca05 != nil {
		return *x.ref75b3ca05, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageMemoryRequirementsInfo2) Deref() {
	if x.ref75b3ca05 == nil {
		return
	}
	x.SType = (StructureType)(x.ref75b3ca05.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref75b3ca05.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref75b3ca05.image))
}

// allocImageSparseMemoryRequirementsInfo2Memory allocates memory for type C.VkImageSparseMemoryRequirementsInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSparseMemoryRequirementsInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSparseMemoryRequirementsInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageSparseMemoryRequirementsInfo2Value = unsafe.Sizeof([1]C.VkImageSparseMemoryRequirementsInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSparseMemoryRequirementsInfo2) Ref() *C.VkImageSparseMemoryRequirementsInfo2 {
	if x == nil {
		return nil
	}
	return x.ref878956f7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSparseMemoryRequirementsInfo2) Free() {
	if x != nil && x.allocs878956f7 != nil {
		x.allocs878956f7.(*cgoAllocMap).Free()
		x.ref878956f7 = nil
	}
}

// NewImageSparseMemoryRequirementsInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSparseMemoryRequirementsInfo2Ref(ref unsafe.Pointer) *ImageSparseMemoryRequirementsInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(ImageSparseMemoryRequirementsInfo2)
	obj.ref878956f7 = (*C.VkImageSparseMemoryRequirementsInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSparseMemoryRequirementsInfo2) PassRef() (*C.VkImageSparseMemoryRequirementsInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref878956f7 != nil {
		return x.ref878956f7, nil
	}
	mem878956f7 := allocImageSparseMemoryRequirementsInfo2Memory(1)
	ref878956f7 := (*C.VkImageSparseMemoryRequirementsInfo2)(mem878956f7)
	allocs878956f7 := new(cgoAllocMap)
	allocs878956f7.Add(mem878956f7)

	var csType_allocs *cgoAllocMap
	ref878956f7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs878956f7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref878956f7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs878956f7.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	ref878956f7.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs878956f7.Borrow(cimage_allocs)

	x.ref878956f7 = ref878956f7
	x.allocs878956f7 = allocs878956f7
	return ref878956f7, allocs878956f7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSparseMemoryRequirementsInfo2) PassValue() (C.VkImageSparseMemoryRequirementsInfo2, *cgoAllocMap) {
	if x.ref878956f7 != nil {
		return *x.ref878956f7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSparseMemoryRequirementsInfo2) Deref() {
	if x.ref878956f7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref878956f7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref878956f7.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref878956f7.image))
}

// allocMemoryRequirements2Memory allocates memory for type C.VkMemoryRequirements2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryRequirements2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryRequirements2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryRequirements2Value = unsafe.Sizeof([1]C.VkMemoryRequirements2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryRequirements2) Ref() *C.VkMemoryRequirements2 {
	if x == nil {
		return nil
	}
	return x.refc0e75f21
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryRequirements2) Free() {
	if x != nil && x.allocsc0e75f21 != nil {
		x.allocsc0e75f21.(*cgoAllocMap).Free()
		x.refc0e75f21 = nil
	}
}

// NewMemoryRequirements2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryRequirements2Ref(ref unsafe.Pointer) *MemoryRequirements2 {
	if ref == nil {
		return nil
	}
	obj := new(MemoryRequirements2)
	obj.refc0e75f21 = (*C.VkMemoryRequirements2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryRequirements2) PassRef() (*C.VkMemoryRequirements2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0e75f21 != nil {
		return x.refc0e75f21, nil
	}
	memc0e75f21 := allocMemoryRequirements2Memory(1)
	refc0e75f21 := (*C.VkMemoryRequirements2)(memc0e75f21)
	allocsc0e75f21 := new(cgoAllocMap)
	allocsc0e75f21.Add(memc0e75f21)

	var csType_allocs *cgoAllocMap
	refc0e75f21.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc0e75f21.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc0e75f21.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc0e75f21.Borrow(cpNext_allocs)

	var cmemoryRequirements_allocs *cgoAllocMap
	refc0e75f21.memoryRequirements, cmemoryRequirements_allocs = x.MemoryRequirements.PassValue()
	allocsc0e75f21.Borrow(cmemoryRequirements_allocs)

	x.refc0e75f21 = refc0e75f21
	x.allocsc0e75f21 = allocsc0e75f21
	return refc0e75f21, allocsc0e75f21

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryRequirements2) PassValue() (C.VkMemoryRequirements2, *cgoAllocMap) {
	if x.refc0e75f21 != nil {
		return *x.refc0e75f21, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryRequirements2) Deref() {
	if x.refc0e75f21 == nil {
		return
	}
	x.SType = (StructureType)(x.refc0e75f21.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc0e75f21.pNext))
	x.MemoryRequirements = *NewMemoryRequirementsRef(unsafe.Pointer(&x.refc0e75f21.memoryRequirements))
}

// allocSparseImageMemoryRequirements2Memory allocates memory for type C.VkSparseImageMemoryRequirements2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryRequirements2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryRequirements2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSparseImageMemoryRequirements2Value = unsafe.Sizeof([1]C.VkSparseImageMemoryRequirements2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageMemoryRequirements2) Ref() *C.VkSparseImageMemoryRequirements2 {
	if x == nil {
		return nil
	}
	return x.refb8da955c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageMemoryRequirements2) Free() {
	if x != nil && x.allocsb8da955c != nil {
		x.allocsb8da955c.(*cgoAllocMap).Free()
		x.refb8da955c = nil
	}
}

// NewSparseImageMemoryRequirements2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageMemoryRequirements2Ref(ref unsafe.Pointer) *SparseImageMemoryRequirements2 {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryRequirements2)
	obj.refb8da955c = (*C.VkSparseImageMemoryRequirements2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageMemoryRequirements2) PassRef() (*C.VkSparseImageMemoryRequirements2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8da955c != nil {
		return x.refb8da955c, nil
	}
	memb8da955c := allocSparseImageMemoryRequirements2Memory(1)
	refb8da955c := (*C.VkSparseImageMemoryRequirements2)(memb8da955c)
	allocsb8da955c := new(cgoAllocMap)
	allocsb8da955c.Add(memb8da955c)

	var csType_allocs *cgoAllocMap
	refb8da955c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb8da955c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb8da955c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb8da955c.Borrow(cpNext_allocs)

	var cmemoryRequirements_allocs *cgoAllocMap
	refb8da955c.memoryRequirements, cmemoryRequirements_allocs = x.MemoryRequirements.PassValue()
	allocsb8da955c.Borrow(cmemoryRequirements_allocs)

	x.refb8da955c = refb8da955c
	x.allocsb8da955c = allocsb8da955c
	return refb8da955c, allocsb8da955c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageMemoryRequirements2) PassValue() (C.VkSparseImageMemoryRequirements2, *cgoAllocMap) {
	if x.refb8da955c != nil {
		return *x.refb8da955c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageMemoryRequirements2) Deref() {
	if x.refb8da955c == nil {
		return
	}
	x.SType = (StructureType)(x.refb8da955c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb8da955c.pNext))
	x.MemoryRequirements = *NewSparseImageMemoryRequirementsRef(unsafe.Pointer(&x.refb8da955c.memoryRequirements))
}

// allocPhysicalDeviceFeatures2Memory allocates memory for type C.VkPhysicalDeviceFeatures2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFeatures2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFeatures2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceFeatures2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceFeatures2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFeatures2) Ref() *C.VkPhysicalDeviceFeatures2 {
	if x == nil {
		return nil
	}
	return x.refff6ed04
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFeatures2) Free() {
	if x != nil && x.allocsff6ed04 != nil {
		x.allocsff6ed04.(*cgoAllocMap).Free()
		x.refff6ed04 = nil
	}
}

// NewPhysicalDeviceFeatures2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFeatures2Ref(ref unsafe.Pointer) *PhysicalDeviceFeatures2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFeatures2)
	obj.refff6ed04 = (*C.VkPhysicalDeviceFeatures2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFeatures2) PassRef() (*C.VkPhysicalDeviceFeatures2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff6ed04 != nil {
		return x.refff6ed04, nil
	}
	memff6ed04 := allocPhysicalDeviceFeatures2Memory(1)
	refff6ed04 := (*C.VkPhysicalDeviceFeatures2)(memff6ed04)
	allocsff6ed04 := new(cgoAllocMap)
	allocsff6ed04.Add(memff6ed04)

	var csType_allocs *cgoAllocMap
	refff6ed04.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsff6ed04.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refff6ed04.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsff6ed04.Borrow(cpNext_allocs)

	var cfeatures_allocs *cgoAllocMap
	refff6ed04.features, cfeatures_allocs = x.Features.PassValue()
	allocsff6ed04.Borrow(cfeatures_allocs)

	x.refff6ed04 = refff6ed04
	x.allocsff6ed04 = allocsff6ed04
	return refff6ed04, allocsff6ed04

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFeatures2) PassValue() (C.VkPhysicalDeviceFeatures2, *cgoAllocMap) {
	if x.refff6ed04 != nil {
		return *x.refff6ed04, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFeatures2) Deref() {
	if x.refff6ed04 == nil {
		return
	}
	x.SType = (StructureType)(x.refff6ed04.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refff6ed04.pNext))
	x.Features = *NewPhysicalDeviceFeaturesRef(unsafe.Pointer(&x.refff6ed04.features))
}

// allocPhysicalDeviceProperties2Memory allocates memory for type C.VkPhysicalDeviceProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceProperties2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceProperties2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProperties2) Ref() *C.VkPhysicalDeviceProperties2 {
	if x == nil {
		return nil
	}
	return x.ref947bd13e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProperties2) Free() {
	if x != nil && x.allocs947bd13e != nil {
		x.allocs947bd13e.(*cgoAllocMap).Free()
		x.ref947bd13e = nil
	}
}

// NewPhysicalDeviceProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceProperties2Ref(ref unsafe.Pointer) *PhysicalDeviceProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProperties2)
	obj.ref947bd13e = (*C.VkPhysicalDeviceProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProperties2) PassRef() (*C.VkPhysicalDeviceProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref947bd13e != nil {
		return x.ref947bd13e, nil
	}
	mem947bd13e := allocPhysicalDeviceProperties2Memory(1)
	ref947bd13e := (*C.VkPhysicalDeviceProperties2)(mem947bd13e)
	allocs947bd13e := new(cgoAllocMap)
	allocs947bd13e.Add(mem947bd13e)

	var csType_allocs *cgoAllocMap
	ref947bd13e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs947bd13e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref947bd13e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs947bd13e.Borrow(cpNext_allocs)

	var cproperties_allocs *cgoAllocMap
	ref947bd13e.properties, cproperties_allocs = x.Properties.PassValue()
	allocs947bd13e.Borrow(cproperties_allocs)

	x.ref947bd13e = ref947bd13e
	x.allocs947bd13e = allocs947bd13e
	return ref947bd13e, allocs947bd13e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProperties2) PassValue() (C.VkPhysicalDeviceProperties2, *cgoAllocMap) {
	if x.ref947bd13e != nil {
		return *x.ref947bd13e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProperties2) Deref() {
	if x.ref947bd13e == nil {
		return
	}
	x.SType = (StructureType)(x.ref947bd13e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref947bd13e.pNext))
	x.Properties = *NewPhysicalDevicePropertiesRef(unsafe.Pointer(&x.ref947bd13e.properties))
}

// allocFormatProperties2Memory allocates memory for type C.VkFormatProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFormatProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFormatProperties2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFormatProperties2Value = unsafe.Sizeof([1]C.VkFormatProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FormatProperties2) Ref() *C.VkFormatProperties2 {
	if x == nil {
		return nil
	}
	return x.refddc6af2a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FormatProperties2) Free() {
	if x != nil && x.allocsddc6af2a != nil {
		x.allocsddc6af2a.(*cgoAllocMap).Free()
		x.refddc6af2a = nil
	}
}

// NewFormatProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFormatProperties2Ref(ref unsafe.Pointer) *FormatProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(FormatProperties2)
	obj.refddc6af2a = (*C.VkFormatProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FormatProperties2) PassRef() (*C.VkFormatProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refddc6af2a != nil {
		return x.refddc6af2a, nil
	}
	memddc6af2a := allocFormatProperties2Memory(1)
	refddc6af2a := (*C.VkFormatProperties2)(memddc6af2a)
	allocsddc6af2a := new(cgoAllocMap)
	allocsddc6af2a.Add(memddc6af2a)

	var csType_allocs *cgoAllocMap
	refddc6af2a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsddc6af2a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refddc6af2a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsddc6af2a.Borrow(cpNext_allocs)

	var cformatProperties_allocs *cgoAllocMap
	refddc6af2a.formatProperties, cformatProperties_allocs = x.FormatProperties.PassValue()
	allocsddc6af2a.Borrow(cformatProperties_allocs)

	x.refddc6af2a = refddc6af2a
	x.allocsddc6af2a = allocsddc6af2a
	return refddc6af2a, allocsddc6af2a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FormatProperties2) PassValue() (C.VkFormatProperties2, *cgoAllocMap) {
	if x.refddc6af2a != nil {
		return *x.refddc6af2a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FormatProperties2) Deref() {
	if x.refddc6af2a == nil {
		return
	}
	x.SType = (StructureType)(x.refddc6af2a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refddc6af2a.pNext))
	x.FormatProperties = *NewFormatPropertiesRef(unsafe.Pointer(&x.refddc6af2a.formatProperties))
}

// allocImageFormatProperties2Memory allocates memory for type C.VkImageFormatProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageFormatProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageFormatProperties2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageFormatProperties2Value = unsafe.Sizeof([1]C.VkImageFormatProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageFormatProperties2) Ref() *C.VkImageFormatProperties2 {
	if x == nil {
		return nil
	}
	return x.ref224187e7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageFormatProperties2) Free() {
	if x != nil && x.allocs224187e7 != nil {
		x.allocs224187e7.(*cgoAllocMap).Free()
		x.ref224187e7 = nil
	}
}

// NewImageFormatProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageFormatProperties2Ref(ref unsafe.Pointer) *ImageFormatProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(ImageFormatProperties2)
	obj.ref224187e7 = (*C.VkImageFormatProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageFormatProperties2) PassRef() (*C.VkImageFormatProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref224187e7 != nil {
		return x.ref224187e7, nil
	}
	mem224187e7 := allocImageFormatProperties2Memory(1)
	ref224187e7 := (*C.VkImageFormatProperties2)(mem224187e7)
	allocs224187e7 := new(cgoAllocMap)
	allocs224187e7.Add(mem224187e7)

	var csType_allocs *cgoAllocMap
	ref224187e7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs224187e7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref224187e7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs224187e7.Borrow(cpNext_allocs)

	var cimageFormatProperties_allocs *cgoAllocMap
	ref224187e7.imageFormatProperties, cimageFormatProperties_allocs = x.ImageFormatProperties.PassValue()
	allocs224187e7.Borrow(cimageFormatProperties_allocs)

	x.ref224187e7 = ref224187e7
	x.allocs224187e7 = allocs224187e7
	return ref224187e7, allocs224187e7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageFormatProperties2) PassValue() (C.VkImageFormatProperties2, *cgoAllocMap) {
	if x.ref224187e7 != nil {
		return *x.ref224187e7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageFormatProperties2) Deref() {
	if x.ref224187e7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref224187e7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref224187e7.pNext))
	x.ImageFormatProperties = *NewImageFormatPropertiesRef(unsafe.Pointer(&x.ref224187e7.imageFormatProperties))
}

// allocPhysicalDeviceImageFormatInfo2Memory allocates memory for type C.VkPhysicalDeviceImageFormatInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceImageFormatInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceImageFormatInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceImageFormatInfo2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceImageFormatInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceImageFormatInfo2) Ref() *C.VkPhysicalDeviceImageFormatInfo2 {
	if x == nil {
		return nil
	}
	return x.ref5934b445
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceImageFormatInfo2) Free() {
	if x != nil && x.allocs5934b445 != nil {
		x.allocs5934b445.(*cgoAllocMap).Free()
		x.ref5934b445 = nil
	}
}

// NewPhysicalDeviceImageFormatInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceImageFormatInfo2Ref(ref unsafe.Pointer) *PhysicalDeviceImageFormatInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceImageFormatInfo2)
	obj.ref5934b445 = (*C.VkPhysicalDeviceImageFormatInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceImageFormatInfo2) PassRef() (*C.VkPhysicalDeviceImageFormatInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5934b445 != nil {
		return x.ref5934b445, nil
	}
	mem5934b445 := allocPhysicalDeviceImageFormatInfo2Memory(1)
	ref5934b445 := (*C.VkPhysicalDeviceImageFormatInfo2)(mem5934b445)
	allocs5934b445 := new(cgoAllocMap)
	allocs5934b445.Add(mem5934b445)

	var csType_allocs *cgoAllocMap
	ref5934b445.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5934b445.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5934b445.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5934b445.Borrow(cpNext_allocs)

	var cformat_allocs *cgoAllocMap
	ref5934b445.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs5934b445.Borrow(cformat_allocs)

	var c_type_allocs *cgoAllocMap
	ref5934b445._type, c_type_allocs = (C.VkImageType)(x.Type), cgoAllocsUnknown
	allocs5934b445.Borrow(c_type_allocs)

	var ctiling_allocs *cgoAllocMap
	ref5934b445.tiling, ctiling_allocs = (C.VkImageTiling)(x.Tiling), cgoAllocsUnknown
	allocs5934b445.Borrow(ctiling_allocs)

	var cusage_allocs *cgoAllocMap
	ref5934b445.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocs5934b445.Borrow(cusage_allocs)

	var cflags_allocs *cgoAllocMap
	ref5934b445.flags, cflags_allocs = (C.VkImageCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs5934b445.Borrow(cflags_allocs)

	x.ref5934b445 = ref5934b445
	x.allocs5934b445 = allocs5934b445
	return ref5934b445, allocs5934b445

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceImageFormatInfo2) PassValue() (C.VkPhysicalDeviceImageFormatInfo2, *cgoAllocMap) {
	if x.ref5934b445 != nil {
		return *x.ref5934b445, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceImageFormatInfo2) Deref() {
	if x.ref5934b445 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5934b445.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5934b445.pNext))
	x.Format = (Format)(x.ref5934b445.format)
	x.Type = (ImageType)(x.ref5934b445._type)
	x.Tiling = (ImageTiling)(x.ref5934b445.tiling)
	x.Usage = (ImageUsageFlags)(x.ref5934b445.usage)
	x.Flags = (ImageCreateFlags)(x.ref5934b445.flags)
}

// allocQueueFamilyProperties2Memory allocates memory for type C.VkQueueFamilyProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueueFamilyProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueueFamilyProperties2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfQueueFamilyProperties2Value = unsafe.Sizeof([1]C.VkQueueFamilyProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueueFamilyProperties2) Ref() *C.VkQueueFamilyProperties2 {
	if x == nil {
		return nil
	}
	return x.ref85bf626c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueueFamilyProperties2) Free() {
	if x != nil && x.allocs85bf626c != nil {
		x.allocs85bf626c.(*cgoAllocMap).Free()
		x.ref85bf626c = nil
	}
}

// NewQueueFamilyProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueueFamilyProperties2Ref(ref unsafe.Pointer) *QueueFamilyProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(QueueFamilyProperties2)
	obj.ref85bf626c = (*C.VkQueueFamilyProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueueFamilyProperties2) PassRef() (*C.VkQueueFamilyProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85bf626c != nil {
		return x.ref85bf626c, nil
	}
	mem85bf626c := allocQueueFamilyProperties2Memory(1)
	ref85bf626c := (*C.VkQueueFamilyProperties2)(mem85bf626c)
	allocs85bf626c := new(cgoAllocMap)
	allocs85bf626c.Add(mem85bf626c)

	var csType_allocs *cgoAllocMap
	ref85bf626c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs85bf626c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref85bf626c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs85bf626c.Borrow(cpNext_allocs)

	var cqueueFamilyProperties_allocs *cgoAllocMap
	ref85bf626c.queueFamilyProperties, cqueueFamilyProperties_allocs = x.QueueFamilyProperties.PassValue()
	allocs85bf626c.Borrow(cqueueFamilyProperties_allocs)

	x.ref85bf626c = ref85bf626c
	x.allocs85bf626c = allocs85bf626c
	return ref85bf626c, allocs85bf626c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueueFamilyProperties2) PassValue() (C.VkQueueFamilyProperties2, *cgoAllocMap) {
	if x.ref85bf626c != nil {
		return *x.ref85bf626c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueueFamilyProperties2) Deref() {
	if x.ref85bf626c == nil {
		return
	}
	x.SType = (StructureType)(x.ref85bf626c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref85bf626c.pNext))
	x.QueueFamilyProperties = *NewQueueFamilyPropertiesRef(unsafe.Pointer(&x.ref85bf626c.queueFamilyProperties))
}

// allocPhysicalDeviceMemoryProperties2Memory allocates memory for type C.VkPhysicalDeviceMemoryProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMemoryProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMemoryProperties2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceMemoryProperties2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceMemoryProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMemoryProperties2) Ref() *C.VkPhysicalDeviceMemoryProperties2 {
	if x == nil {
		return nil
	}
	return x.refd9e39b19
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMemoryProperties2) Free() {
	if x != nil && x.allocsd9e39b19 != nil {
		x.allocsd9e39b19.(*cgoAllocMap).Free()
		x.refd9e39b19 = nil
	}
}

// NewPhysicalDeviceMemoryProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMemoryProperties2Ref(ref unsafe.Pointer) *PhysicalDeviceMemoryProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMemoryProperties2)
	obj.refd9e39b19 = (*C.VkPhysicalDeviceMemoryProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMemoryProperties2) PassRef() (*C.VkPhysicalDeviceMemoryProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9e39b19 != nil {
		return x.refd9e39b19, nil
	}
	memd9e39b19 := allocPhysicalDeviceMemoryProperties2Memory(1)
	refd9e39b19 := (*C.VkPhysicalDeviceMemoryProperties2)(memd9e39b19)
	allocsd9e39b19 := new(cgoAllocMap)
	allocsd9e39b19.Add(memd9e39b19)

	var csType_allocs *cgoAllocMap
	refd9e39b19.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd9e39b19.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd9e39b19.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd9e39b19.Borrow(cpNext_allocs)

	var cmemoryProperties_allocs *cgoAllocMap
	refd9e39b19.memoryProperties, cmemoryProperties_allocs = x.MemoryProperties.PassValue()
	allocsd9e39b19.Borrow(cmemoryProperties_allocs)

	x.refd9e39b19 = refd9e39b19
	x.allocsd9e39b19 = allocsd9e39b19
	return refd9e39b19, allocsd9e39b19

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMemoryProperties2) PassValue() (C.VkPhysicalDeviceMemoryProperties2, *cgoAllocMap) {
	if x.refd9e39b19 != nil {
		return *x.refd9e39b19, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMemoryProperties2) Deref() {
	if x.refd9e39b19 == nil {
		return
	}
	x.SType = (StructureType)(x.refd9e39b19.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd9e39b19.pNext))
	x.MemoryProperties = *NewPhysicalDeviceMemoryPropertiesRef(unsafe.Pointer(&x.refd9e39b19.memoryProperties))
}

// allocSparseImageFormatProperties2Memory allocates memory for type C.VkSparseImageFormatProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageFormatProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageFormatProperties2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSparseImageFormatProperties2Value = unsafe.Sizeof([1]C.VkSparseImageFormatProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageFormatProperties2) Ref() *C.VkSparseImageFormatProperties2 {
	if x == nil {
		return nil
	}
	return x.ref6b48294b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageFormatProperties2) Free() {
	if x != nil && x.allocs6b48294b != nil {
		x.allocs6b48294b.(*cgoAllocMap).Free()
		x.ref6b48294b = nil
	}
}

// NewSparseImageFormatProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageFormatProperties2Ref(ref unsafe.Pointer) *SparseImageFormatProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageFormatProperties2)
	obj.ref6b48294b = (*C.VkSparseImageFormatProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageFormatProperties2) PassRef() (*C.VkSparseImageFormatProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6b48294b != nil {
		return x.ref6b48294b, nil
	}
	mem6b48294b := allocSparseImageFormatProperties2Memory(1)
	ref6b48294b := (*C.VkSparseImageFormatProperties2)(mem6b48294b)
	allocs6b48294b := new(cgoAllocMap)
	allocs6b48294b.Add(mem6b48294b)

	var csType_allocs *cgoAllocMap
	ref6b48294b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6b48294b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6b48294b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6b48294b.Borrow(cpNext_allocs)

	var cproperties_allocs *cgoAllocMap
	ref6b48294b.properties, cproperties_allocs = x.Properties.PassValue()
	allocs6b48294b.Borrow(cproperties_allocs)

	x.ref6b48294b = ref6b48294b
	x.allocs6b48294b = allocs6b48294b
	return ref6b48294b, allocs6b48294b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageFormatProperties2) PassValue() (C.VkSparseImageFormatProperties2, *cgoAllocMap) {
	if x.ref6b48294b != nil {
		return *x.ref6b48294b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageFormatProperties2) Deref() {
	if x.ref6b48294b == nil {
		return
	}
	x.SType = (StructureType)(x.ref6b48294b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6b48294b.pNext))
	x.Properties = *NewSparseImageFormatPropertiesRef(unsafe.Pointer(&x.ref6b48294b.properties))
}

// allocPhysicalDeviceSparseImageFormatInfo2Memory allocates memory for type C.VkPhysicalDeviceSparseImageFormatInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSparseImageFormatInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSparseImageFormatInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceSparseImageFormatInfo2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceSparseImageFormatInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSparseImageFormatInfo2) Ref() *C.VkPhysicalDeviceSparseImageFormatInfo2 {
	if x == nil {
		return nil
	}
	return x.ref566d5513
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSparseImageFormatInfo2) Free() {
	if x != nil && x.allocs566d5513 != nil {
		x.allocs566d5513.(*cgoAllocMap).Free()
		x.ref566d5513 = nil
	}
}

// NewPhysicalDeviceSparseImageFormatInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSparseImageFormatInfo2Ref(ref unsafe.Pointer) *PhysicalDeviceSparseImageFormatInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSparseImageFormatInfo2)
	obj.ref566d5513 = (*C.VkPhysicalDeviceSparseImageFormatInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSparseImageFormatInfo2) PassRef() (*C.VkPhysicalDeviceSparseImageFormatInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref566d5513 != nil {
		return x.ref566d5513, nil
	}
	mem566d5513 := allocPhysicalDeviceSparseImageFormatInfo2Memory(1)
	ref566d5513 := (*C.VkPhysicalDeviceSparseImageFormatInfo2)(mem566d5513)
	allocs566d5513 := new(cgoAllocMap)
	allocs566d5513.Add(mem566d5513)

	var csType_allocs *cgoAllocMap
	ref566d5513.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs566d5513.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref566d5513.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs566d5513.Borrow(cpNext_allocs)

	var cformat_allocs *cgoAllocMap
	ref566d5513.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs566d5513.Borrow(cformat_allocs)

	var c_type_allocs *cgoAllocMap
	ref566d5513._type, c_type_allocs = (C.VkImageType)(x.Type), cgoAllocsUnknown
	allocs566d5513.Borrow(c_type_allocs)

	var csamples_allocs *cgoAllocMap
	ref566d5513.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocs566d5513.Borrow(csamples_allocs)

	var cusage_allocs *cgoAllocMap
	ref566d5513.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocs566d5513.Borrow(cusage_allocs)

	var ctiling_allocs *cgoAllocMap
	ref566d5513.tiling, ctiling_allocs = (C.VkImageTiling)(x.Tiling), cgoAllocsUnknown
	allocs566d5513.Borrow(ctiling_allocs)

	x.ref566d5513 = ref566d5513
	x.allocs566d5513 = allocs566d5513
	return ref566d5513, allocs566d5513

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSparseImageFormatInfo2) PassValue() (C.VkPhysicalDeviceSparseImageFormatInfo2, *cgoAllocMap) {
	if x.ref566d5513 != nil {
		return *x.ref566d5513, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSparseImageFormatInfo2) Deref() {
	if x.ref566d5513 == nil {
		return
	}
	x.SType = (StructureType)(x.ref566d5513.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref566d5513.pNext))
	x.Format = (Format)(x.ref566d5513.format)
	x.Type = (ImageType)(x.ref566d5513._type)
	x.Samples = (SampleCountFlagBits)(x.ref566d5513.samples)
	x.Usage = (ImageUsageFlags)(x.ref566d5513.usage)
	x.Tiling = (ImageTiling)(x.ref566d5513.tiling)
}

// allocPhysicalDevicePointClippingPropertiesMemory allocates memory for type C.VkPhysicalDevicePointClippingProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePointClippingPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePointClippingPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDevicePointClippingPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDevicePointClippingProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevicePointClippingProperties) Ref() *C.VkPhysicalDevicePointClippingProperties {
	if x == nil {
		return nil
	}
	return x.ref5afbd22f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevicePointClippingProperties) Free() {
	if x != nil && x.allocs5afbd22f != nil {
		x.allocs5afbd22f.(*cgoAllocMap).Free()
		x.ref5afbd22f = nil
	}
}

// NewPhysicalDevicePointClippingPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePointClippingPropertiesRef(ref unsafe.Pointer) *PhysicalDevicePointClippingProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevicePointClippingProperties)
	obj.ref5afbd22f = (*C.VkPhysicalDevicePointClippingProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevicePointClippingProperties) PassRef() (*C.VkPhysicalDevicePointClippingProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5afbd22f != nil {
		return x.ref5afbd22f, nil
	}
	mem5afbd22f := allocPhysicalDevicePointClippingPropertiesMemory(1)
	ref5afbd22f := (*C.VkPhysicalDevicePointClippingProperties)(mem5afbd22f)
	allocs5afbd22f := new(cgoAllocMap)
	allocs5afbd22f.Add(mem5afbd22f)

	var csType_allocs *cgoAllocMap
	ref5afbd22f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5afbd22f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5afbd22f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5afbd22f.Borrow(cpNext_allocs)

	var cpointClippingBehavior_allocs *cgoAllocMap
	ref5afbd22f.pointClippingBehavior, cpointClippingBehavior_allocs = (C.VkPointClippingBehavior)(x.PointClippingBehavior), cgoAllocsUnknown
	allocs5afbd22f.Borrow(cpointClippingBehavior_allocs)

	x.ref5afbd22f = ref5afbd22f
	x.allocs5afbd22f = allocs5afbd22f
	return ref5afbd22f, allocs5afbd22f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevicePointClippingProperties) PassValue() (C.VkPhysicalDevicePointClippingProperties, *cgoAllocMap) {
	if x.ref5afbd22f != nil {
		return *x.ref5afbd22f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevicePointClippingProperties) Deref() {
	if x.ref5afbd22f == nil {
		return
	}
	x.SType = (StructureType)(x.ref5afbd22f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5afbd22f.pNext))
	x.PointClippingBehavior = (PointClippingBehavior)(x.ref5afbd22f.pointClippingBehavior)
}

// allocInputAttachmentAspectReferenceMemory allocates memory for type C.VkInputAttachmentAspectReference in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInputAttachmentAspectReferenceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInputAttachmentAspectReferenceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInputAttachmentAspectReferenceValue = unsafe.Sizeof([1]C.VkInputAttachmentAspectReference{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *InputAttachmentAspectReference) Ref() *C.VkInputAttachmentAspectReference {
	if x == nil {
		return nil
	}
	return x.ref4f7194e6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *InputAttachmentAspectReference) Free() {
	if x != nil && x.allocs4f7194e6 != nil {
		x.allocs4f7194e6.(*cgoAllocMap).Free()
		x.ref4f7194e6 = nil
	}
}

// NewInputAttachmentAspectReferenceRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewInputAttachmentAspectReferenceRef(ref unsafe.Pointer) *InputAttachmentAspectReference {
	if ref == nil {
		return nil
	}
	obj := new(InputAttachmentAspectReference)
	obj.ref4f7194e6 = (*C.VkInputAttachmentAspectReference)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *InputAttachmentAspectReference) PassRef() (*C.VkInputAttachmentAspectReference, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4f7194e6 != nil {
		return x.ref4f7194e6, nil
	}
	mem4f7194e6 := allocInputAttachmentAspectReferenceMemory(1)
	ref4f7194e6 := (*C.VkInputAttachmentAspectReference)(mem4f7194e6)
	allocs4f7194e6 := new(cgoAllocMap)
	allocs4f7194e6.Add(mem4f7194e6)

	var csubpass_allocs *cgoAllocMap
	ref4f7194e6.subpass, csubpass_allocs = (C.uint32_t)(x.Subpass), cgoAllocsUnknown
	allocs4f7194e6.Borrow(csubpass_allocs)

	var cinputAttachmentIndex_allocs *cgoAllocMap
	ref4f7194e6.inputAttachmentIndex, cinputAttachmentIndex_allocs = (C.uint32_t)(x.InputAttachmentIndex), cgoAllocsUnknown
	allocs4f7194e6.Borrow(cinputAttachmentIndex_allocs)

	var caspectMask_allocs *cgoAllocMap
	ref4f7194e6.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs4f7194e6.Borrow(caspectMask_allocs)

	x.ref4f7194e6 = ref4f7194e6
	x.allocs4f7194e6 = allocs4f7194e6
	return ref4f7194e6, allocs4f7194e6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x InputAttachmentAspectReference) PassValue() (C.VkInputAttachmentAspectReference, *cgoAllocMap) {
	if x.ref4f7194e6 != nil {
		return *x.ref4f7194e6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *InputAttachmentAspectReference) Deref() {
	if x.ref4f7194e6 == nil {
		return
	}
	x.Subpass = (uint32)(x.ref4f7194e6.subpass)
	x.InputAttachmentIndex = (uint32)(x.ref4f7194e6.inputAttachmentIndex)
	x.AspectMask = (ImageAspectFlags)(x.ref4f7194e6.aspectMask)
}

// allocRenderPassInputAttachmentAspectCreateInfoMemory allocates memory for type C.VkRenderPassInputAttachmentAspectCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassInputAttachmentAspectCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassInputAttachmentAspectCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderPassInputAttachmentAspectCreateInfoValue = unsafe.Sizeof([1]C.VkRenderPassInputAttachmentAspectCreateInfo{})

// unpackSInputAttachmentAspectReference transforms a sliced Go data structure into plain C format.
func unpackSInputAttachmentAspectReference(x []InputAttachmentAspectReference) (unpacked *C.VkInputAttachmentAspectReference, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocInputAttachmentAspectReferenceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkInputAttachmentAspectReference)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkInputAttachmentAspectReference)(h.Data)
	return
}

// packSInputAttachmentAspectReference reads sliced Go data structure out from plain C format.
func packSInputAttachmentAspectReference(v []InputAttachmentAspectReference, ptr0 *C.VkInputAttachmentAspectReference) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfInputAttachmentAspectReferenceValue]C.VkInputAttachmentAspectReference)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewInputAttachmentAspectReferenceRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassInputAttachmentAspectCreateInfo) Ref() *C.VkRenderPassInputAttachmentAspectCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref34eaa5c7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassInputAttachmentAspectCreateInfo) Free() {
	if x != nil && x.allocs34eaa5c7 != nil {
		x.allocs34eaa5c7.(*cgoAllocMap).Free()
		x.ref34eaa5c7 = nil
	}
}

// NewRenderPassInputAttachmentAspectCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassInputAttachmentAspectCreateInfoRef(ref unsafe.Pointer) *RenderPassInputAttachmentAspectCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassInputAttachmentAspectCreateInfo)
	obj.ref34eaa5c7 = (*C.VkRenderPassInputAttachmentAspectCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassInputAttachmentAspectCreateInfo) PassRef() (*C.VkRenderPassInputAttachmentAspectCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref34eaa5c7 != nil {
		return x.ref34eaa5c7, nil
	}
	mem34eaa5c7 := allocRenderPassInputAttachmentAspectCreateInfoMemory(1)
	ref34eaa5c7 := (*C.VkRenderPassInputAttachmentAspectCreateInfo)(mem34eaa5c7)
	allocs34eaa5c7 := new(cgoAllocMap)
	allocs34eaa5c7.Add(mem34eaa5c7)

	var csType_allocs *cgoAllocMap
	ref34eaa5c7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs34eaa5c7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref34eaa5c7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs34eaa5c7.Borrow(cpNext_allocs)

	var caspectReferenceCount_allocs *cgoAllocMap
	ref34eaa5c7.aspectReferenceCount, caspectReferenceCount_allocs = (C.uint32_t)(x.AspectReferenceCount), cgoAllocsUnknown
	allocs34eaa5c7.Borrow(caspectReferenceCount_allocs)

	var cpAspectReferences_allocs *cgoAllocMap
	ref34eaa5c7.pAspectReferences, cpAspectReferences_allocs = unpackSInputAttachmentAspectReference(x.PAspectReferences)
	allocs34eaa5c7.Borrow(cpAspectReferences_allocs)

	x.ref34eaa5c7 = ref34eaa5c7
	x.allocs34eaa5c7 = allocs34eaa5c7
	return ref34eaa5c7, allocs34eaa5c7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassInputAttachmentAspectCreateInfo) PassValue() (C.VkRenderPassInputAttachmentAspectCreateInfo, *cgoAllocMap) {
	if x.ref34eaa5c7 != nil {
		return *x.ref34eaa5c7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassInputAttachmentAspectCreateInfo) Deref() {
	if x.ref34eaa5c7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref34eaa5c7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref34eaa5c7.pNext))
	x.AspectReferenceCount = (uint32)(x.ref34eaa5c7.aspectReferenceCount)
	packSInputAttachmentAspectReference(x.PAspectReferences, x.ref34eaa5c7.pAspectReferences)
}

// allocImageViewUsageCreateInfoMemory allocates memory for type C.VkImageViewUsageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewUsageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewUsageCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageViewUsageCreateInfoValue = unsafe.Sizeof([1]C.VkImageViewUsageCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageViewUsageCreateInfo) Ref() *C.VkImageViewUsageCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref3791cec9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageViewUsageCreateInfo) Free() {
	if x != nil && x.allocs3791cec9 != nil {
		x.allocs3791cec9.(*cgoAllocMap).Free()
		x.ref3791cec9 = nil
	}
}

// NewImageViewUsageCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageViewUsageCreateInfoRef(ref unsafe.Pointer) *ImageViewUsageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageViewUsageCreateInfo)
	obj.ref3791cec9 = (*C.VkImageViewUsageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageViewUsageCreateInfo) PassRef() (*C.VkImageViewUsageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3791cec9 != nil {
		return x.ref3791cec9, nil
	}
	mem3791cec9 := allocImageViewUsageCreateInfoMemory(1)
	ref3791cec9 := (*C.VkImageViewUsageCreateInfo)(mem3791cec9)
	allocs3791cec9 := new(cgoAllocMap)
	allocs3791cec9.Add(mem3791cec9)

	var csType_allocs *cgoAllocMap
	ref3791cec9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3791cec9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3791cec9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3791cec9.Borrow(cpNext_allocs)

	var cusage_allocs *cgoAllocMap
	ref3791cec9.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocs3791cec9.Borrow(cusage_allocs)

	x.ref3791cec9 = ref3791cec9
	x.allocs3791cec9 = allocs3791cec9
	return ref3791cec9, allocs3791cec9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageViewUsageCreateInfo) PassValue() (C.VkImageViewUsageCreateInfo, *cgoAllocMap) {
	if x.ref3791cec9 != nil {
		return *x.ref3791cec9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageViewUsageCreateInfo) Deref() {
	if x.ref3791cec9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3791cec9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3791cec9.pNext))
	x.Usage = (ImageUsageFlags)(x.ref3791cec9.usage)
}

// allocPipelineTessellationDomainOriginStateCreateInfoMemory allocates memory for type C.VkPipelineTessellationDomainOriginStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineTessellationDomainOriginStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineTessellationDomainOriginStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineTessellationDomainOriginStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineTessellationDomainOriginStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineTessellationDomainOriginStateCreateInfo) Ref() *C.VkPipelineTessellationDomainOriginStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref58ef29bf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineTessellationDomainOriginStateCreateInfo) Free() {
	if x != nil && x.allocs58ef29bf != nil {
		x.allocs58ef29bf.(*cgoAllocMap).Free()
		x.ref58ef29bf = nil
	}
}

// NewPipelineTessellationDomainOriginStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineTessellationDomainOriginStateCreateInfoRef(ref unsafe.Pointer) *PipelineTessellationDomainOriginStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineTessellationDomainOriginStateCreateInfo)
	obj.ref58ef29bf = (*C.VkPipelineTessellationDomainOriginStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineTessellationDomainOriginStateCreateInfo) PassRef() (*C.VkPipelineTessellationDomainOriginStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref58ef29bf != nil {
		return x.ref58ef29bf, nil
	}
	mem58ef29bf := allocPipelineTessellationDomainOriginStateCreateInfoMemory(1)
	ref58ef29bf := (*C.VkPipelineTessellationDomainOriginStateCreateInfo)(mem58ef29bf)
	allocs58ef29bf := new(cgoAllocMap)
	allocs58ef29bf.Add(mem58ef29bf)

	var csType_allocs *cgoAllocMap
	ref58ef29bf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs58ef29bf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref58ef29bf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs58ef29bf.Borrow(cpNext_allocs)

	var cdomainOrigin_allocs *cgoAllocMap
	ref58ef29bf.domainOrigin, cdomainOrigin_allocs = (C.VkTessellationDomainOrigin)(x.DomainOrigin), cgoAllocsUnknown
	allocs58ef29bf.Borrow(cdomainOrigin_allocs)

	x.ref58ef29bf = ref58ef29bf
	x.allocs58ef29bf = allocs58ef29bf
	return ref58ef29bf, allocs58ef29bf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineTessellationDomainOriginStateCreateInfo) PassValue() (C.VkPipelineTessellationDomainOriginStateCreateInfo, *cgoAllocMap) {
	if x.ref58ef29bf != nil {
		return *x.ref58ef29bf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineTessellationDomainOriginStateCreateInfo) Deref() {
	if x.ref58ef29bf == nil {
		return
	}
	x.SType = (StructureType)(x.ref58ef29bf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref58ef29bf.pNext))
	x.DomainOrigin = (TessellationDomainOrigin)(x.ref58ef29bf.domainOrigin)
}

// allocRenderPassMultiviewCreateInfoMemory allocates memory for type C.VkRenderPassMultiviewCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassMultiviewCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassMultiviewCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderPassMultiviewCreateInfoValue = unsafe.Sizeof([1]C.VkRenderPassMultiviewCreateInfo{})

// copyPInt32_tBytes copies the data from Go slice as *C.int32_t.
func copyPInt32_tBytes(slice *sliceHeader) (*C.int32_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfInt32_tValue) * slice.Len,
		Cap:  int(sizeOfInt32_tValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.int32_t)(mem0), allocs
}

// allocInt32_tMemory allocates memory for type C.int32_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInt32_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInt32_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInt32_tValue = unsafe.Sizeof([1]C.int32_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassMultiviewCreateInfo) Ref() *C.VkRenderPassMultiviewCreateInfo {
	if x == nil {
		return nil
	}
	return x.refee413e05
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassMultiviewCreateInfo) Free() {
	if x != nil && x.allocsee413e05 != nil {
		x.allocsee413e05.(*cgoAllocMap).Free()
		x.refee413e05 = nil
	}
}

// NewRenderPassMultiviewCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassMultiviewCreateInfoRef(ref unsafe.Pointer) *RenderPassMultiviewCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassMultiviewCreateInfo)
	obj.refee413e05 = (*C.VkRenderPassMultiviewCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassMultiviewCreateInfo) PassRef() (*C.VkRenderPassMultiviewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refee413e05 != nil {
		return x.refee413e05, nil
	}
	memee413e05 := allocRenderPassMultiviewCreateInfoMemory(1)
	refee413e05 := (*C.VkRenderPassMultiviewCreateInfo)(memee413e05)
	allocsee413e05 := new(cgoAllocMap)
	allocsee413e05.Add(memee413e05)

	var csType_allocs *cgoAllocMap
	refee413e05.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsee413e05.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refee413e05.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsee413e05.Borrow(cpNext_allocs)

	var csubpassCount_allocs *cgoAllocMap
	refee413e05.subpassCount, csubpassCount_allocs = (C.uint32_t)(x.SubpassCount), cgoAllocsUnknown
	allocsee413e05.Borrow(csubpassCount_allocs)

	var cpViewMasks_allocs *cgoAllocMap
	refee413e05.pViewMasks, cpViewMasks_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PViewMasks)))
	allocsee413e05.Borrow(cpViewMasks_allocs)

	var cdependencyCount_allocs *cgoAllocMap
	refee413e05.dependencyCount, cdependencyCount_allocs = (C.uint32_t)(x.DependencyCount), cgoAllocsUnknown
	allocsee413e05.Borrow(cdependencyCount_allocs)

	var cpViewOffsets_allocs *cgoAllocMap
	refee413e05.pViewOffsets, cpViewOffsets_allocs = copyPInt32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PViewOffsets)))
	allocsee413e05.Borrow(cpViewOffsets_allocs)

	var ccorrelationMaskCount_allocs *cgoAllocMap
	refee413e05.correlationMaskCount, ccorrelationMaskCount_allocs = (C.uint32_t)(x.CorrelationMaskCount), cgoAllocsUnknown
	allocsee413e05.Borrow(ccorrelationMaskCount_allocs)

	var cpCorrelationMasks_allocs *cgoAllocMap
	refee413e05.pCorrelationMasks, cpCorrelationMasks_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PCorrelationMasks)))
	allocsee413e05.Borrow(cpCorrelationMasks_allocs)

	x.refee413e05 = refee413e05
	x.allocsee413e05 = allocsee413e05
	return refee413e05, allocsee413e05

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassMultiviewCreateInfo) PassValue() (C.VkRenderPassMultiviewCreateInfo, *cgoAllocMap) {
	if x.refee413e05 != nil {
		return *x.refee413e05, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassMultiviewCreateInfo) Deref() {
	if x.refee413e05 == nil {
		return
	}
	x.SType = (StructureType)(x.refee413e05.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refee413e05.pNext))
	x.SubpassCount = (uint32)(x.refee413e05.subpassCount)
	hxff20e84 := (*sliceHeader)(unsafe.Pointer(&x.PViewMasks))
	hxff20e84.Data = unsafe.Pointer(x.refee413e05.pViewMasks)
	hxff20e84.Cap = 0x7fffffff
	// hxff20e84.Len = ?

	x.DependencyCount = (uint32)(x.refee413e05.dependencyCount)
	hxfa26a4d := (*sliceHeader)(unsafe.Pointer(&x.PViewOffsets))
	hxfa26a4d.Data = unsafe.Pointer(x.refee413e05.pViewOffsets)
	hxfa26a4d.Cap = 0x7fffffff
	// hxfa26a4d.Len = ?

	x.CorrelationMaskCount = (uint32)(x.refee413e05.correlationMaskCount)
	hxfe48098 := (*sliceHeader)(unsafe.Pointer(&x.PCorrelationMasks))
	hxfe48098.Data = unsafe.Pointer(x.refee413e05.pCorrelationMasks)
	hxfe48098.Cap = 0x7fffffff
	// hxfe48098.Len = ?

}

// allocPhysicalDeviceMultiviewFeaturesMemory allocates memory for type C.VkPhysicalDeviceMultiviewFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMultiviewFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMultiviewFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceMultiviewFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMultiviewFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMultiviewFeatures) Ref() *C.VkPhysicalDeviceMultiviewFeatures {
	if x == nil {
		return nil
	}
	return x.refd7a7434b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMultiviewFeatures) Free() {
	if x != nil && x.allocsd7a7434b != nil {
		x.allocsd7a7434b.(*cgoAllocMap).Free()
		x.refd7a7434b = nil
	}
}

// NewPhysicalDeviceMultiviewFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMultiviewFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceMultiviewFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMultiviewFeatures)
	obj.refd7a7434b = (*C.VkPhysicalDeviceMultiviewFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMultiviewFeatures) PassRef() (*C.VkPhysicalDeviceMultiviewFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd7a7434b != nil {
		return x.refd7a7434b, nil
	}
	memd7a7434b := allocPhysicalDeviceMultiviewFeaturesMemory(1)
	refd7a7434b := (*C.VkPhysicalDeviceMultiviewFeatures)(memd7a7434b)
	allocsd7a7434b := new(cgoAllocMap)
	allocsd7a7434b.Add(memd7a7434b)

	var csType_allocs *cgoAllocMap
	refd7a7434b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd7a7434b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd7a7434b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd7a7434b.Borrow(cpNext_allocs)

	var cmultiview_allocs *cgoAllocMap
	refd7a7434b.multiview, cmultiview_allocs = (C.VkBool32)(x.Multiview), cgoAllocsUnknown
	allocsd7a7434b.Borrow(cmultiview_allocs)

	var cmultiviewGeometryShader_allocs *cgoAllocMap
	refd7a7434b.multiviewGeometryShader, cmultiviewGeometryShader_allocs = (C.VkBool32)(x.MultiviewGeometryShader), cgoAllocsUnknown
	allocsd7a7434b.Borrow(cmultiviewGeometryShader_allocs)

	var cmultiviewTessellationShader_allocs *cgoAllocMap
	refd7a7434b.multiviewTessellationShader, cmultiviewTessellationShader_allocs = (C.VkBool32)(x.MultiviewTessellationShader), cgoAllocsUnknown
	allocsd7a7434b.Borrow(cmultiviewTessellationShader_allocs)

	x.refd7a7434b = refd7a7434b
	x.allocsd7a7434b = allocsd7a7434b
	return refd7a7434b, allocsd7a7434b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMultiviewFeatures) PassValue() (C.VkPhysicalDeviceMultiviewFeatures, *cgoAllocMap) {
	if x.refd7a7434b != nil {
		return *x.refd7a7434b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMultiviewFeatures) Deref() {
	if x.refd7a7434b == nil {
		return
	}
	x.SType = (StructureType)(x.refd7a7434b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd7a7434b.pNext))
	x.Multiview = (Bool32)(x.refd7a7434b.multiview)
	x.MultiviewGeometryShader = (Bool32)(x.refd7a7434b.multiviewGeometryShader)
	x.MultiviewTessellationShader = (Bool32)(x.refd7a7434b.multiviewTessellationShader)
}

// allocPhysicalDeviceMultiviewPropertiesMemory allocates memory for type C.VkPhysicalDeviceMultiviewProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMultiviewPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMultiviewPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceMultiviewPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMultiviewProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMultiviewProperties) Ref() *C.VkPhysicalDeviceMultiviewProperties {
	if x == nil {
		return nil
	}
	return x.ref95110029
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMultiviewProperties) Free() {
	if x != nil && x.allocs95110029 != nil {
		x.allocs95110029.(*cgoAllocMap).Free()
		x.ref95110029 = nil
	}
}

// NewPhysicalDeviceMultiviewPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMultiviewPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceMultiviewProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMultiviewProperties)
	obj.ref95110029 = (*C.VkPhysicalDeviceMultiviewProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMultiviewProperties) PassRef() (*C.VkPhysicalDeviceMultiviewProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref95110029 != nil {
		return x.ref95110029, nil
	}
	mem95110029 := allocPhysicalDeviceMultiviewPropertiesMemory(1)
	ref95110029 := (*C.VkPhysicalDeviceMultiviewProperties)(mem95110029)
	allocs95110029 := new(cgoAllocMap)
	allocs95110029.Add(mem95110029)

	var csType_allocs *cgoAllocMap
	ref95110029.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs95110029.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref95110029.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs95110029.Borrow(cpNext_allocs)

	var cmaxMultiviewViewCount_allocs *cgoAllocMap
	ref95110029.maxMultiviewViewCount, cmaxMultiviewViewCount_allocs = (C.uint32_t)(x.MaxMultiviewViewCount), cgoAllocsUnknown
	allocs95110029.Borrow(cmaxMultiviewViewCount_allocs)

	var cmaxMultiviewInstanceIndex_allocs *cgoAllocMap
	ref95110029.maxMultiviewInstanceIndex, cmaxMultiviewInstanceIndex_allocs = (C.uint32_t)(x.MaxMultiviewInstanceIndex), cgoAllocsUnknown
	allocs95110029.Borrow(cmaxMultiviewInstanceIndex_allocs)

	x.ref95110029 = ref95110029
	x.allocs95110029 = allocs95110029
	return ref95110029, allocs95110029

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMultiviewProperties) PassValue() (C.VkPhysicalDeviceMultiviewProperties, *cgoAllocMap) {
	if x.ref95110029 != nil {
		return *x.ref95110029, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMultiviewProperties) Deref() {
	if x.ref95110029 == nil {
		return
	}
	x.SType = (StructureType)(x.ref95110029.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref95110029.pNext))
	x.MaxMultiviewViewCount = (uint32)(x.ref95110029.maxMultiviewViewCount)
	x.MaxMultiviewInstanceIndex = (uint32)(x.ref95110029.maxMultiviewInstanceIndex)
}

// allocPhysicalDeviceVariablePointersFeaturesMemory allocates memory for type C.VkPhysicalDeviceVariablePointersFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVariablePointersFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVariablePointersFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceVariablePointersFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVariablePointersFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVariablePointersFeatures) Ref() *C.VkPhysicalDeviceVariablePointersFeatures {
	if x == nil {
		return nil
	}
	return x.refb49644a0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVariablePointersFeatures) Free() {
	if x != nil && x.allocsb49644a0 != nil {
		x.allocsb49644a0.(*cgoAllocMap).Free()
		x.refb49644a0 = nil
	}
}

// NewPhysicalDeviceVariablePointersFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVariablePointersFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceVariablePointersFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVariablePointersFeatures)
	obj.refb49644a0 = (*C.VkPhysicalDeviceVariablePointersFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVariablePointersFeatures) PassRef() (*C.VkPhysicalDeviceVariablePointersFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb49644a0 != nil {
		return x.refb49644a0, nil
	}
	memb49644a0 := allocPhysicalDeviceVariablePointersFeaturesMemory(1)
	refb49644a0 := (*C.VkPhysicalDeviceVariablePointersFeatures)(memb49644a0)
	allocsb49644a0 := new(cgoAllocMap)
	allocsb49644a0.Add(memb49644a0)

	var csType_allocs *cgoAllocMap
	refb49644a0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb49644a0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb49644a0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb49644a0.Borrow(cpNext_allocs)

	var cvariablePointersStorageBuffer_allocs *cgoAllocMap
	refb49644a0.variablePointersStorageBuffer, cvariablePointersStorageBuffer_allocs = (C.VkBool32)(x.VariablePointersStorageBuffer), cgoAllocsUnknown
	allocsb49644a0.Borrow(cvariablePointersStorageBuffer_allocs)

	var cvariablePointers_allocs *cgoAllocMap
	refb49644a0.variablePointers, cvariablePointers_allocs = (C.VkBool32)(x.VariablePointers), cgoAllocsUnknown
	allocsb49644a0.Borrow(cvariablePointers_allocs)

	x.refb49644a0 = refb49644a0
	x.allocsb49644a0 = allocsb49644a0
	return refb49644a0, allocsb49644a0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVariablePointersFeatures) PassValue() (C.VkPhysicalDeviceVariablePointersFeatures, *cgoAllocMap) {
	if x.refb49644a0 != nil {
		return *x.refb49644a0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVariablePointersFeatures) Deref() {
	if x.refb49644a0 == nil {
		return
	}
	x.SType = (StructureType)(x.refb49644a0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb49644a0.pNext))
	x.VariablePointersStorageBuffer = (Bool32)(x.refb49644a0.variablePointersStorageBuffer)
	x.VariablePointers = (Bool32)(x.refb49644a0.variablePointers)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVariablePointerFeatures) Ref() *C.VkPhysicalDeviceVariablePointersFeatures {
	if x == nil {
		return nil
	}
	return x.refb49644a0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVariablePointerFeatures) Free() {
	if x != nil && x.allocsb49644a0 != nil {
		x.allocsb49644a0.(*cgoAllocMap).Free()
		x.refb49644a0 = nil
	}
}

// NewPhysicalDeviceVariablePointerFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVariablePointerFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceVariablePointerFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVariablePointerFeatures)
	obj.refb49644a0 = (*C.VkPhysicalDeviceVariablePointersFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVariablePointerFeatures) PassRef() (*C.VkPhysicalDeviceVariablePointersFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb49644a0 != nil {
		return x.refb49644a0, nil
	}
	memb49644a0 := allocPhysicalDeviceVariablePointersFeaturesMemory(1)
	refb49644a0 := (*C.VkPhysicalDeviceVariablePointersFeatures)(memb49644a0)
	allocsb49644a0 := new(cgoAllocMap)
	allocsb49644a0.Add(memb49644a0)

	var csType_allocs *cgoAllocMap
	refb49644a0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb49644a0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb49644a0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb49644a0.Borrow(cpNext_allocs)

	var cvariablePointersStorageBuffer_allocs *cgoAllocMap
	refb49644a0.variablePointersStorageBuffer, cvariablePointersStorageBuffer_allocs = (C.VkBool32)(x.VariablePointersStorageBuffer), cgoAllocsUnknown
	allocsb49644a0.Borrow(cvariablePointersStorageBuffer_allocs)

	var cvariablePointers_allocs *cgoAllocMap
	refb49644a0.variablePointers, cvariablePointers_allocs = (C.VkBool32)(x.VariablePointers), cgoAllocsUnknown
	allocsb49644a0.Borrow(cvariablePointers_allocs)

	x.refb49644a0 = refb49644a0
	x.allocsb49644a0 = allocsb49644a0
	return refb49644a0, allocsb49644a0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVariablePointerFeatures) PassValue() (C.VkPhysicalDeviceVariablePointersFeatures, *cgoAllocMap) {
	if x.refb49644a0 != nil {
		return *x.refb49644a0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVariablePointerFeatures) Deref() {
	if x.refb49644a0 == nil {
		return
	}
	x.SType = (StructureType)(x.refb49644a0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb49644a0.pNext))
	x.VariablePointersStorageBuffer = (Bool32)(x.refb49644a0.variablePointersStorageBuffer)
	x.VariablePointers = (Bool32)(x.refb49644a0.variablePointers)
}

// allocPhysicalDeviceProtectedMemoryFeaturesMemory allocates memory for type C.VkPhysicalDeviceProtectedMemoryFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceProtectedMemoryFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceProtectedMemoryFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceProtectedMemoryFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceProtectedMemoryFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProtectedMemoryFeatures) Ref() *C.VkPhysicalDeviceProtectedMemoryFeatures {
	if x == nil {
		return nil
	}
	return x.refac441ed1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProtectedMemoryFeatures) Free() {
	if x != nil && x.allocsac441ed1 != nil {
		x.allocsac441ed1.(*cgoAllocMap).Free()
		x.refac441ed1 = nil
	}
}

// NewPhysicalDeviceProtectedMemoryFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceProtectedMemoryFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceProtectedMemoryFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProtectedMemoryFeatures)
	obj.refac441ed1 = (*C.VkPhysicalDeviceProtectedMemoryFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProtectedMemoryFeatures) PassRef() (*C.VkPhysicalDeviceProtectedMemoryFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refac441ed1 != nil {
		return x.refac441ed1, nil
	}
	memac441ed1 := allocPhysicalDeviceProtectedMemoryFeaturesMemory(1)
	refac441ed1 := (*C.VkPhysicalDeviceProtectedMemoryFeatures)(memac441ed1)
	allocsac441ed1 := new(cgoAllocMap)
	allocsac441ed1.Add(memac441ed1)

	var csType_allocs *cgoAllocMap
	refac441ed1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsac441ed1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refac441ed1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsac441ed1.Borrow(cpNext_allocs)

	var cprotectedMemory_allocs *cgoAllocMap
	refac441ed1.protectedMemory, cprotectedMemory_allocs = (C.VkBool32)(x.ProtectedMemory), cgoAllocsUnknown
	allocsac441ed1.Borrow(cprotectedMemory_allocs)

	x.refac441ed1 = refac441ed1
	x.allocsac441ed1 = allocsac441ed1
	return refac441ed1, allocsac441ed1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProtectedMemoryFeatures) PassValue() (C.VkPhysicalDeviceProtectedMemoryFeatures, *cgoAllocMap) {
	if x.refac441ed1 != nil {
		return *x.refac441ed1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProtectedMemoryFeatures) Deref() {
	if x.refac441ed1 == nil {
		return
	}
	x.SType = (StructureType)(x.refac441ed1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refac441ed1.pNext))
	x.ProtectedMemory = (Bool32)(x.refac441ed1.protectedMemory)
}

// allocPhysicalDeviceProtectedMemoryPropertiesMemory allocates memory for type C.VkPhysicalDeviceProtectedMemoryProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceProtectedMemoryPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceProtectedMemoryPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceProtectedMemoryPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceProtectedMemoryProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProtectedMemoryProperties) Ref() *C.VkPhysicalDeviceProtectedMemoryProperties {
	if x == nil {
		return nil
	}
	return x.refb653413
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProtectedMemoryProperties) Free() {
	if x != nil && x.allocsb653413 != nil {
		x.allocsb653413.(*cgoAllocMap).Free()
		x.refb653413 = nil
	}
}

// NewPhysicalDeviceProtectedMemoryPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceProtectedMemoryPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceProtectedMemoryProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProtectedMemoryProperties)
	obj.refb653413 = (*C.VkPhysicalDeviceProtectedMemoryProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProtectedMemoryProperties) PassRef() (*C.VkPhysicalDeviceProtectedMemoryProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb653413 != nil {
		return x.refb653413, nil
	}
	memb653413 := allocPhysicalDeviceProtectedMemoryPropertiesMemory(1)
	refb653413 := (*C.VkPhysicalDeviceProtectedMemoryProperties)(memb653413)
	allocsb653413 := new(cgoAllocMap)
	allocsb653413.Add(memb653413)

	var csType_allocs *cgoAllocMap
	refb653413.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb653413.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb653413.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb653413.Borrow(cpNext_allocs)

	var cprotectedNoFault_allocs *cgoAllocMap
	refb653413.protectedNoFault, cprotectedNoFault_allocs = (C.VkBool32)(x.ProtectedNoFault), cgoAllocsUnknown
	allocsb653413.Borrow(cprotectedNoFault_allocs)

	x.refb653413 = refb653413
	x.allocsb653413 = allocsb653413
	return refb653413, allocsb653413

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProtectedMemoryProperties) PassValue() (C.VkPhysicalDeviceProtectedMemoryProperties, *cgoAllocMap) {
	if x.refb653413 != nil {
		return *x.refb653413, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProtectedMemoryProperties) Deref() {
	if x.refb653413 == nil {
		return
	}
	x.SType = (StructureType)(x.refb653413.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb653413.pNext))
	x.ProtectedNoFault = (Bool32)(x.refb653413.protectedNoFault)
}

// allocDeviceQueueInfo2Memory allocates memory for type C.VkDeviceQueueInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceQueueInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceQueueInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceQueueInfo2Value = unsafe.Sizeof([1]C.VkDeviceQueueInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceQueueInfo2) Ref() *C.VkDeviceQueueInfo2 {
	if x == nil {
		return nil
	}
	return x.ref2f267e52
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceQueueInfo2) Free() {
	if x != nil && x.allocs2f267e52 != nil {
		x.allocs2f267e52.(*cgoAllocMap).Free()
		x.ref2f267e52 = nil
	}
}

// NewDeviceQueueInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceQueueInfo2Ref(ref unsafe.Pointer) *DeviceQueueInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(DeviceQueueInfo2)
	obj.ref2f267e52 = (*C.VkDeviceQueueInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceQueueInfo2) PassRef() (*C.VkDeviceQueueInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f267e52 != nil {
		return x.ref2f267e52, nil
	}
	mem2f267e52 := allocDeviceQueueInfo2Memory(1)
	ref2f267e52 := (*C.VkDeviceQueueInfo2)(mem2f267e52)
	allocs2f267e52 := new(cgoAllocMap)
	allocs2f267e52.Add(mem2f267e52)

	var csType_allocs *cgoAllocMap
	ref2f267e52.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2f267e52.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2f267e52.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2f267e52.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref2f267e52.flags, cflags_allocs = (C.VkDeviceQueueCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs2f267e52.Borrow(cflags_allocs)

	var cqueueFamilyIndex_allocs *cgoAllocMap
	ref2f267e52.queueFamilyIndex, cqueueFamilyIndex_allocs = (C.uint32_t)(x.QueueFamilyIndex), cgoAllocsUnknown
	allocs2f267e52.Borrow(cqueueFamilyIndex_allocs)

	var cqueueIndex_allocs *cgoAllocMap
	ref2f267e52.queueIndex, cqueueIndex_allocs = (C.uint32_t)(x.QueueIndex), cgoAllocsUnknown
	allocs2f267e52.Borrow(cqueueIndex_allocs)

	x.ref2f267e52 = ref2f267e52
	x.allocs2f267e52 = allocs2f267e52
	return ref2f267e52, allocs2f267e52

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceQueueInfo2) PassValue() (C.VkDeviceQueueInfo2, *cgoAllocMap) {
	if x.ref2f267e52 != nil {
		return *x.ref2f267e52, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceQueueInfo2) Deref() {
	if x.ref2f267e52 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2f267e52.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2f267e52.pNext))
	x.Flags = (DeviceQueueCreateFlags)(x.ref2f267e52.flags)
	x.QueueFamilyIndex = (uint32)(x.ref2f267e52.queueFamilyIndex)
	x.QueueIndex = (uint32)(x.ref2f267e52.queueIndex)
}

// allocProtectedSubmitInfoMemory allocates memory for type C.VkProtectedSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocProtectedSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfProtectedSubmitInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfProtectedSubmitInfoValue = unsafe.Sizeof([1]C.VkProtectedSubmitInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ProtectedSubmitInfo) Ref() *C.VkProtectedSubmitInfo {
	if x == nil {
		return nil
	}
	return x.ref6bd69669
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ProtectedSubmitInfo) Free() {
	if x != nil && x.allocs6bd69669 != nil {
		x.allocs6bd69669.(*cgoAllocMap).Free()
		x.ref6bd69669 = nil
	}
}

// NewProtectedSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewProtectedSubmitInfoRef(ref unsafe.Pointer) *ProtectedSubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(ProtectedSubmitInfo)
	obj.ref6bd69669 = (*C.VkProtectedSubmitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ProtectedSubmitInfo) PassRef() (*C.VkProtectedSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6bd69669 != nil {
		return x.ref6bd69669, nil
	}
	mem6bd69669 := allocProtectedSubmitInfoMemory(1)
	ref6bd69669 := (*C.VkProtectedSubmitInfo)(mem6bd69669)
	allocs6bd69669 := new(cgoAllocMap)
	allocs6bd69669.Add(mem6bd69669)

	var csType_allocs *cgoAllocMap
	ref6bd69669.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6bd69669.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6bd69669.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6bd69669.Borrow(cpNext_allocs)

	var cprotectedSubmit_allocs *cgoAllocMap
	ref6bd69669.protectedSubmit, cprotectedSubmit_allocs = (C.VkBool32)(x.ProtectedSubmit), cgoAllocsUnknown
	allocs6bd69669.Borrow(cprotectedSubmit_allocs)

	x.ref6bd69669 = ref6bd69669
	x.allocs6bd69669 = allocs6bd69669
	return ref6bd69669, allocs6bd69669

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ProtectedSubmitInfo) PassValue() (C.VkProtectedSubmitInfo, *cgoAllocMap) {
	if x.ref6bd69669 != nil {
		return *x.ref6bd69669, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ProtectedSubmitInfo) Deref() {
	if x.ref6bd69669 == nil {
		return
	}
	x.SType = (StructureType)(x.ref6bd69669.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6bd69669.pNext))
	x.ProtectedSubmit = (Bool32)(x.ref6bd69669.protectedSubmit)
}

// allocSamplerYcbcrConversionCreateInfoMemory allocates memory for type C.VkSamplerYcbcrConversionCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerYcbcrConversionCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerYcbcrConversionCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSamplerYcbcrConversionCreateInfoValue = unsafe.Sizeof([1]C.VkSamplerYcbcrConversionCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerYcbcrConversionCreateInfo) Ref() *C.VkSamplerYcbcrConversionCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref9875bff7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerYcbcrConversionCreateInfo) Free() {
	if x != nil && x.allocs9875bff7 != nil {
		x.allocs9875bff7.(*cgoAllocMap).Free()
		x.ref9875bff7 = nil
	}
}

// NewSamplerYcbcrConversionCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerYcbcrConversionCreateInfoRef(ref unsafe.Pointer) *SamplerYcbcrConversionCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SamplerYcbcrConversionCreateInfo)
	obj.ref9875bff7 = (*C.VkSamplerYcbcrConversionCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerYcbcrConversionCreateInfo) PassRef() (*C.VkSamplerYcbcrConversionCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9875bff7 != nil {
		return x.ref9875bff7, nil
	}
	mem9875bff7 := allocSamplerYcbcrConversionCreateInfoMemory(1)
	ref9875bff7 := (*C.VkSamplerYcbcrConversionCreateInfo)(mem9875bff7)
	allocs9875bff7 := new(cgoAllocMap)
	allocs9875bff7.Add(mem9875bff7)

	var csType_allocs *cgoAllocMap
	ref9875bff7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9875bff7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9875bff7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9875bff7.Borrow(cpNext_allocs)

	var cformat_allocs *cgoAllocMap
	ref9875bff7.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs9875bff7.Borrow(cformat_allocs)

	var cycbcrModel_allocs *cgoAllocMap
	ref9875bff7.ycbcrModel, cycbcrModel_allocs = (C.VkSamplerYcbcrModelConversion)(x.YcbcrModel), cgoAllocsUnknown
	allocs9875bff7.Borrow(cycbcrModel_allocs)

	var cycbcrRange_allocs *cgoAllocMap
	ref9875bff7.ycbcrRange, cycbcrRange_allocs = (C.VkSamplerYcbcrRange)(x.YcbcrRange), cgoAllocsUnknown
	allocs9875bff7.Borrow(cycbcrRange_allocs)

	var ccomponents_allocs *cgoAllocMap
	ref9875bff7.components, ccomponents_allocs = x.Components.PassValue()
	allocs9875bff7.Borrow(ccomponents_allocs)

	var cxChromaOffset_allocs *cgoAllocMap
	ref9875bff7.xChromaOffset, cxChromaOffset_allocs = (C.VkChromaLocation)(x.XChromaOffset), cgoAllocsUnknown
	allocs9875bff7.Borrow(cxChromaOffset_allocs)

	var cyChromaOffset_allocs *cgoAllocMap
	ref9875bff7.yChromaOffset, cyChromaOffset_allocs = (C.VkChromaLocation)(x.YChromaOffset), cgoAllocsUnknown
	allocs9875bff7.Borrow(cyChromaOffset_allocs)

	var cchromaFilter_allocs *cgoAllocMap
	ref9875bff7.chromaFilter, cchromaFilter_allocs = (C.VkFilter)(x.ChromaFilter), cgoAllocsUnknown
	allocs9875bff7.Borrow(cchromaFilter_allocs)

	var cforceExplicitReconstruction_allocs *cgoAllocMap
	ref9875bff7.forceExplicitReconstruction, cforceExplicitReconstruction_allocs = (C.VkBool32)(x.ForceExplicitReconstruction), cgoAllocsUnknown
	allocs9875bff7.Borrow(cforceExplicitReconstruction_allocs)

	x.ref9875bff7 = ref9875bff7
	x.allocs9875bff7 = allocs9875bff7
	return ref9875bff7, allocs9875bff7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerYcbcrConversionCreateInfo) PassValue() (C.VkSamplerYcbcrConversionCreateInfo, *cgoAllocMap) {
	if x.ref9875bff7 != nil {
		return *x.ref9875bff7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerYcbcrConversionCreateInfo) Deref() {
	if x.ref9875bff7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9875bff7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9875bff7.pNext))
	x.Format = (Format)(x.ref9875bff7.format)
	x.YcbcrModel = (SamplerYcbcrModelConversion)(x.ref9875bff7.ycbcrModel)
	x.YcbcrRange = (SamplerYcbcrRange)(x.ref9875bff7.ycbcrRange)
	x.Components = *NewComponentMappingRef(unsafe.Pointer(&x.ref9875bff7.components))
	x.XChromaOffset = (ChromaLocation)(x.ref9875bff7.xChromaOffset)
	x.YChromaOffset = (ChromaLocation)(x.ref9875bff7.yChromaOffset)
	x.ChromaFilter = (Filter)(x.ref9875bff7.chromaFilter)
	x.ForceExplicitReconstruction = (Bool32)(x.ref9875bff7.forceExplicitReconstruction)
}

// allocSamplerYcbcrConversionInfoMemory allocates memory for type C.VkSamplerYcbcrConversionInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerYcbcrConversionInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerYcbcrConversionInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSamplerYcbcrConversionInfoValue = unsafe.Sizeof([1]C.VkSamplerYcbcrConversionInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerYcbcrConversionInfo) Ref() *C.VkSamplerYcbcrConversionInfo {
	if x == nil {
		return nil
	}
	return x.ref11ff5547
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerYcbcrConversionInfo) Free() {
	if x != nil && x.allocs11ff5547 != nil {
		x.allocs11ff5547.(*cgoAllocMap).Free()
		x.ref11ff5547 = nil
	}
}

// NewSamplerYcbcrConversionInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerYcbcrConversionInfoRef(ref unsafe.Pointer) *SamplerYcbcrConversionInfo {
	if ref == nil {
		return nil
	}
	obj := new(SamplerYcbcrConversionInfo)
	obj.ref11ff5547 = (*C.VkSamplerYcbcrConversionInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerYcbcrConversionInfo) PassRef() (*C.VkSamplerYcbcrConversionInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11ff5547 != nil {
		return x.ref11ff5547, nil
	}
	mem11ff5547 := allocSamplerYcbcrConversionInfoMemory(1)
	ref11ff5547 := (*C.VkSamplerYcbcrConversionInfo)(mem11ff5547)
	allocs11ff5547 := new(cgoAllocMap)
	allocs11ff5547.Add(mem11ff5547)

	var csType_allocs *cgoAllocMap
	ref11ff5547.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs11ff5547.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref11ff5547.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs11ff5547.Borrow(cpNext_allocs)

	var cconversion_allocs *cgoAllocMap
	ref11ff5547.conversion, cconversion_allocs = *(*C.VkSamplerYcbcrConversion)(unsafe.Pointer(&x.Conversion)), cgoAllocsUnknown
	allocs11ff5547.Borrow(cconversion_allocs)

	x.ref11ff5547 = ref11ff5547
	x.allocs11ff5547 = allocs11ff5547
	return ref11ff5547, allocs11ff5547

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerYcbcrConversionInfo) PassValue() (C.VkSamplerYcbcrConversionInfo, *cgoAllocMap) {
	if x.ref11ff5547 != nil {
		return *x.ref11ff5547, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerYcbcrConversionInfo) Deref() {
	if x.ref11ff5547 == nil {
		return
	}
	x.SType = (StructureType)(x.ref11ff5547.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref11ff5547.pNext))
	x.Conversion = *(*SamplerYcbcrConversion)(unsafe.Pointer(&x.ref11ff5547.conversion))
}

// allocBindImagePlaneMemoryInfoMemory allocates memory for type C.VkBindImagePlaneMemoryInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindImagePlaneMemoryInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindImagePlaneMemoryInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindImagePlaneMemoryInfoValue = unsafe.Sizeof([1]C.VkBindImagePlaneMemoryInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImagePlaneMemoryInfo) Ref() *C.VkBindImagePlaneMemoryInfo {
	if x == nil {
		return nil
	}
	return x.ref56b81476
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImagePlaneMemoryInfo) Free() {
	if x != nil && x.allocs56b81476 != nil {
		x.allocs56b81476.(*cgoAllocMap).Free()
		x.ref56b81476 = nil
	}
}

// NewBindImagePlaneMemoryInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImagePlaneMemoryInfoRef(ref unsafe.Pointer) *BindImagePlaneMemoryInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindImagePlaneMemoryInfo)
	obj.ref56b81476 = (*C.VkBindImagePlaneMemoryInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImagePlaneMemoryInfo) PassRef() (*C.VkBindImagePlaneMemoryInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref56b81476 != nil {
		return x.ref56b81476, nil
	}
	mem56b81476 := allocBindImagePlaneMemoryInfoMemory(1)
	ref56b81476 := (*C.VkBindImagePlaneMemoryInfo)(mem56b81476)
	allocs56b81476 := new(cgoAllocMap)
	allocs56b81476.Add(mem56b81476)

	var csType_allocs *cgoAllocMap
	ref56b81476.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs56b81476.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref56b81476.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs56b81476.Borrow(cpNext_allocs)

	var cplaneAspect_allocs *cgoAllocMap
	ref56b81476.planeAspect, cplaneAspect_allocs = (C.VkImageAspectFlagBits)(x.PlaneAspect), cgoAllocsUnknown
	allocs56b81476.Borrow(cplaneAspect_allocs)

	x.ref56b81476 = ref56b81476
	x.allocs56b81476 = allocs56b81476
	return ref56b81476, allocs56b81476

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImagePlaneMemoryInfo) PassValue() (C.VkBindImagePlaneMemoryInfo, *cgoAllocMap) {
	if x.ref56b81476 != nil {
		return *x.ref56b81476, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImagePlaneMemoryInfo) Deref() {
	if x.ref56b81476 == nil {
		return
	}
	x.SType = (StructureType)(x.ref56b81476.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref56b81476.pNext))
	x.PlaneAspect = (ImageAspectFlagBits)(x.ref56b81476.planeAspect)
}

// allocImagePlaneMemoryRequirementsInfoMemory allocates memory for type C.VkImagePlaneMemoryRequirementsInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImagePlaneMemoryRequirementsInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImagePlaneMemoryRequirementsInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImagePlaneMemoryRequirementsInfoValue = unsafe.Sizeof([1]C.VkImagePlaneMemoryRequirementsInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImagePlaneMemoryRequirementsInfo) Ref() *C.VkImagePlaneMemoryRequirementsInfo {
	if x == nil {
		return nil
	}
	return x.refefec131f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImagePlaneMemoryRequirementsInfo) Free() {
	if x != nil && x.allocsefec131f != nil {
		x.allocsefec131f.(*cgoAllocMap).Free()
		x.refefec131f = nil
	}
}

// NewImagePlaneMemoryRequirementsInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImagePlaneMemoryRequirementsInfoRef(ref unsafe.Pointer) *ImagePlaneMemoryRequirementsInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImagePlaneMemoryRequirementsInfo)
	obj.refefec131f = (*C.VkImagePlaneMemoryRequirementsInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImagePlaneMemoryRequirementsInfo) PassRef() (*C.VkImagePlaneMemoryRequirementsInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refefec131f != nil {
		return x.refefec131f, nil
	}
	memefec131f := allocImagePlaneMemoryRequirementsInfoMemory(1)
	refefec131f := (*C.VkImagePlaneMemoryRequirementsInfo)(memefec131f)
	allocsefec131f := new(cgoAllocMap)
	allocsefec131f.Add(memefec131f)

	var csType_allocs *cgoAllocMap
	refefec131f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsefec131f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refefec131f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsefec131f.Borrow(cpNext_allocs)

	var cplaneAspect_allocs *cgoAllocMap
	refefec131f.planeAspect, cplaneAspect_allocs = (C.VkImageAspectFlagBits)(x.PlaneAspect), cgoAllocsUnknown
	allocsefec131f.Borrow(cplaneAspect_allocs)

	x.refefec131f = refefec131f
	x.allocsefec131f = allocsefec131f
	return refefec131f, allocsefec131f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImagePlaneMemoryRequirementsInfo) PassValue() (C.VkImagePlaneMemoryRequirementsInfo, *cgoAllocMap) {
	if x.refefec131f != nil {
		return *x.refefec131f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImagePlaneMemoryRequirementsInfo) Deref() {
	if x.refefec131f == nil {
		return
	}
	x.SType = (StructureType)(x.refefec131f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refefec131f.pNext))
	x.PlaneAspect = (ImageAspectFlagBits)(x.refefec131f.planeAspect)
}

// allocPhysicalDeviceSamplerYcbcrConversionFeaturesMemory allocates memory for type C.VkPhysicalDeviceSamplerYcbcrConversionFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSamplerYcbcrConversionFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSamplerYcbcrConversionFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceSamplerYcbcrConversionFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSamplerYcbcrConversionFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) Ref() *C.VkPhysicalDeviceSamplerYcbcrConversionFeatures {
	if x == nil {
		return nil
	}
	return x.ref1d054d67
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) Free() {
	if x != nil && x.allocs1d054d67 != nil {
		x.allocs1d054d67.(*cgoAllocMap).Free()
		x.ref1d054d67 = nil
	}
}

// NewPhysicalDeviceSamplerYcbcrConversionFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSamplerYcbcrConversionFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceSamplerYcbcrConversionFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSamplerYcbcrConversionFeatures)
	obj.ref1d054d67 = (*C.VkPhysicalDeviceSamplerYcbcrConversionFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) PassRef() (*C.VkPhysicalDeviceSamplerYcbcrConversionFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d054d67 != nil {
		return x.ref1d054d67, nil
	}
	mem1d054d67 := allocPhysicalDeviceSamplerYcbcrConversionFeaturesMemory(1)
	ref1d054d67 := (*C.VkPhysicalDeviceSamplerYcbcrConversionFeatures)(mem1d054d67)
	allocs1d054d67 := new(cgoAllocMap)
	allocs1d054d67.Add(mem1d054d67)

	var csType_allocs *cgoAllocMap
	ref1d054d67.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1d054d67.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1d054d67.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1d054d67.Borrow(cpNext_allocs)

	var csamplerYcbcrConversion_allocs *cgoAllocMap
	ref1d054d67.samplerYcbcrConversion, csamplerYcbcrConversion_allocs = (C.VkBool32)(x.SamplerYcbcrConversion), cgoAllocsUnknown
	allocs1d054d67.Borrow(csamplerYcbcrConversion_allocs)

	x.ref1d054d67 = ref1d054d67
	x.allocs1d054d67 = allocs1d054d67
	return ref1d054d67, allocs1d054d67

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) PassValue() (C.VkPhysicalDeviceSamplerYcbcrConversionFeatures, *cgoAllocMap) {
	if x.ref1d054d67 != nil {
		return *x.ref1d054d67, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) Deref() {
	if x.ref1d054d67 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1d054d67.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1d054d67.pNext))
	x.SamplerYcbcrConversion = (Bool32)(x.ref1d054d67.samplerYcbcrConversion)
}

// allocSamplerYcbcrConversionImageFormatPropertiesMemory allocates memory for type C.VkSamplerYcbcrConversionImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerYcbcrConversionImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerYcbcrConversionImageFormatPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSamplerYcbcrConversionImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkSamplerYcbcrConversionImageFormatProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerYcbcrConversionImageFormatProperties) Ref() *C.VkSamplerYcbcrConversionImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.ref6bc79530
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerYcbcrConversionImageFormatProperties) Free() {
	if x != nil && x.allocs6bc79530 != nil {
		x.allocs6bc79530.(*cgoAllocMap).Free()
		x.ref6bc79530 = nil
	}
}

// NewSamplerYcbcrConversionImageFormatPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerYcbcrConversionImageFormatPropertiesRef(ref unsafe.Pointer) *SamplerYcbcrConversionImageFormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(SamplerYcbcrConversionImageFormatProperties)
	obj.ref6bc79530 = (*C.VkSamplerYcbcrConversionImageFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerYcbcrConversionImageFormatProperties) PassRef() (*C.VkSamplerYcbcrConversionImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6bc79530 != nil {
		return x.ref6bc79530, nil
	}
	mem6bc79530 := allocSamplerYcbcrConversionImageFormatPropertiesMemory(1)
	ref6bc79530 := (*C.VkSamplerYcbcrConversionImageFormatProperties)(mem6bc79530)
	allocs6bc79530 := new(cgoAllocMap)
	allocs6bc79530.Add(mem6bc79530)

	var csType_allocs *cgoAllocMap
	ref6bc79530.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6bc79530.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6bc79530.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6bc79530.Borrow(cpNext_allocs)

	var ccombinedImageSamplerDescriptorCount_allocs *cgoAllocMap
	ref6bc79530.combinedImageSamplerDescriptorCount, ccombinedImageSamplerDescriptorCount_allocs = (C.uint32_t)(x.CombinedImageSamplerDescriptorCount), cgoAllocsUnknown
	allocs6bc79530.Borrow(ccombinedImageSamplerDescriptorCount_allocs)

	x.ref6bc79530 = ref6bc79530
	x.allocs6bc79530 = allocs6bc79530
	return ref6bc79530, allocs6bc79530

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerYcbcrConversionImageFormatProperties) PassValue() (C.VkSamplerYcbcrConversionImageFormatProperties, *cgoAllocMap) {
	if x.ref6bc79530 != nil {
		return *x.ref6bc79530, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerYcbcrConversionImageFormatProperties) Deref() {
	if x.ref6bc79530 == nil {
		return
	}
	x.SType = (StructureType)(x.ref6bc79530.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6bc79530.pNext))
	x.CombinedImageSamplerDescriptorCount = (uint32)(x.ref6bc79530.combinedImageSamplerDescriptorCount)
}

// allocDescriptorUpdateTemplateEntryMemory allocates memory for type C.VkDescriptorUpdateTemplateEntry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorUpdateTemplateEntryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorUpdateTemplateEntryValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorUpdateTemplateEntryValue = unsafe.Sizeof([1]C.VkDescriptorUpdateTemplateEntry{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorUpdateTemplateEntry) Ref() *C.VkDescriptorUpdateTemplateEntry {
	if x == nil {
		return nil
	}
	return x.refabf78fb7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorUpdateTemplateEntry) Free() {
	if x != nil && x.allocsabf78fb7 != nil {
		x.allocsabf78fb7.(*cgoAllocMap).Free()
		x.refabf78fb7 = nil
	}
}

// NewDescriptorUpdateTemplateEntryRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorUpdateTemplateEntryRef(ref unsafe.Pointer) *DescriptorUpdateTemplateEntry {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorUpdateTemplateEntry)
	obj.refabf78fb7 = (*C.VkDescriptorUpdateTemplateEntry)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorUpdateTemplateEntry) PassRef() (*C.VkDescriptorUpdateTemplateEntry, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refabf78fb7 != nil {
		return x.refabf78fb7, nil
	}
	memabf78fb7 := allocDescriptorUpdateTemplateEntryMemory(1)
	refabf78fb7 := (*C.VkDescriptorUpdateTemplateEntry)(memabf78fb7)
	allocsabf78fb7 := new(cgoAllocMap)
	allocsabf78fb7.Add(memabf78fb7)

	var cdstBinding_allocs *cgoAllocMap
	refabf78fb7.dstBinding, cdstBinding_allocs = (C.uint32_t)(x.DstBinding), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cdstBinding_allocs)

	var cdstArrayElement_allocs *cgoAllocMap
	refabf78fb7.dstArrayElement, cdstArrayElement_allocs = (C.uint32_t)(x.DstArrayElement), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cdstArrayElement_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	refabf78fb7.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cdescriptorCount_allocs)

	var cdescriptorType_allocs *cgoAllocMap
	refabf78fb7.descriptorType, cdescriptorType_allocs = (C.VkDescriptorType)(x.DescriptorType), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cdescriptorType_allocs)

	var coffset_allocs *cgoAllocMap
	refabf78fb7.offset, coffset_allocs = (C.size_t)(x.Offset), cgoAllocsUnknown
	allocsabf78fb7.Borrow(coffset_allocs)

	var cstride_allocs *cgoAllocMap
	refabf78fb7.stride, cstride_allocs = (C.size_t)(x.Stride), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cstride_allocs)

	x.refabf78fb7 = refabf78fb7
	x.allocsabf78fb7 = allocsabf78fb7
	return refabf78fb7, allocsabf78fb7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorUpdateTemplateEntry) PassValue() (C.VkDescriptorUpdateTemplateEntry, *cgoAllocMap) {
	if x.refabf78fb7 != nil {
		return *x.refabf78fb7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorUpdateTemplateEntry) Deref() {
	if x.refabf78fb7 == nil {
		return
	}
	x.DstBinding = (uint32)(x.refabf78fb7.dstBinding)
	x.DstArrayElement = (uint32)(x.refabf78fb7.dstArrayElement)
	x.DescriptorCount = (uint32)(x.refabf78fb7.descriptorCount)
	x.DescriptorType = (DescriptorType)(x.refabf78fb7.descriptorType)
	x.Offset = (uint32)(x.refabf78fb7.offset)
	x.Stride = (uint32)(x.refabf78fb7.stride)
}

// allocDescriptorUpdateTemplateCreateInfoMemory allocates memory for type C.VkDescriptorUpdateTemplateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorUpdateTemplateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorUpdateTemplateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorUpdateTemplateCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorUpdateTemplateCreateInfo{})

// unpackSDescriptorUpdateTemplateEntry transforms a sliced Go data structure into plain C format.
func unpackSDescriptorUpdateTemplateEntry(x []DescriptorUpdateTemplateEntry) (unpacked *C.VkDescriptorUpdateTemplateEntry, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorUpdateTemplateEntryMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorUpdateTemplateEntry)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorUpdateTemplateEntry)(h.Data)
	return
}

// packSDescriptorUpdateTemplateEntry reads sliced Go data structure out from plain C format.
func packSDescriptorUpdateTemplateEntry(v []DescriptorUpdateTemplateEntry, ptr0 *C.VkDescriptorUpdateTemplateEntry) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorUpdateTemplateEntryValue]C.VkDescriptorUpdateTemplateEntry)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorUpdateTemplateEntryRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorUpdateTemplateCreateInfo) Ref() *C.VkDescriptorUpdateTemplateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref2af95951
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorUpdateTemplateCreateInfo) Free() {
	if x != nil && x.allocs2af95951 != nil {
		x.allocs2af95951.(*cgoAllocMap).Free()
		x.ref2af95951 = nil
	}
}

// NewDescriptorUpdateTemplateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorUpdateTemplateCreateInfoRef(ref unsafe.Pointer) *DescriptorUpdateTemplateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorUpdateTemplateCreateInfo)
	obj.ref2af95951 = (*C.VkDescriptorUpdateTemplateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorUpdateTemplateCreateInfo) PassRef() (*C.VkDescriptorUpdateTemplateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2af95951 != nil {
		return x.ref2af95951, nil
	}
	mem2af95951 := allocDescriptorUpdateTemplateCreateInfoMemory(1)
	ref2af95951 := (*C.VkDescriptorUpdateTemplateCreateInfo)(mem2af95951)
	allocs2af95951 := new(cgoAllocMap)
	allocs2af95951.Add(mem2af95951)

	var csType_allocs *cgoAllocMap
	ref2af95951.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2af95951.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2af95951.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2af95951.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref2af95951.flags, cflags_allocs = (C.VkDescriptorUpdateTemplateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs2af95951.Borrow(cflags_allocs)

	var cdescriptorUpdateEntryCount_allocs *cgoAllocMap
	ref2af95951.descriptorUpdateEntryCount, cdescriptorUpdateEntryCount_allocs = (C.uint32_t)(x.DescriptorUpdateEntryCount), cgoAllocsUnknown
	allocs2af95951.Borrow(cdescriptorUpdateEntryCount_allocs)

	var cpDescriptorUpdateEntries_allocs *cgoAllocMap
	ref2af95951.pDescriptorUpdateEntries, cpDescriptorUpdateEntries_allocs = unpackSDescriptorUpdateTemplateEntry(x.PDescriptorUpdateEntries)
	allocs2af95951.Borrow(cpDescriptorUpdateEntries_allocs)

	var ctemplateType_allocs *cgoAllocMap
	ref2af95951.templateType, ctemplateType_allocs = (C.VkDescriptorUpdateTemplateType)(x.TemplateType), cgoAllocsUnknown
	allocs2af95951.Borrow(ctemplateType_allocs)

	var cdescriptorSetLayout_allocs *cgoAllocMap
	ref2af95951.descriptorSetLayout, cdescriptorSetLayout_allocs = *(*C.VkDescriptorSetLayout)(unsafe.Pointer(&x.DescriptorSetLayout)), cgoAllocsUnknown
	allocs2af95951.Borrow(cdescriptorSetLayout_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	ref2af95951.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocs2af95951.Borrow(cpipelineBindPoint_allocs)

	var cpipelineLayout_allocs *cgoAllocMap
	ref2af95951.pipelineLayout, cpipelineLayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.PipelineLayout)), cgoAllocsUnknown
	allocs2af95951.Borrow(cpipelineLayout_allocs)

	var cset_allocs *cgoAllocMap
	ref2af95951.set, cset_allocs = (C.uint32_t)(x.Set), cgoAllocsUnknown
	allocs2af95951.Borrow(cset_allocs)

	x.ref2af95951 = ref2af95951
	x.allocs2af95951 = allocs2af95951
	return ref2af95951, allocs2af95951

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorUpdateTemplateCreateInfo) PassValue() (C.VkDescriptorUpdateTemplateCreateInfo, *cgoAllocMap) {
	if x.ref2af95951 != nil {
		return *x.ref2af95951, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorUpdateTemplateCreateInfo) Deref() {
	if x.ref2af95951 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2af95951.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2af95951.pNext))
	x.Flags = (DescriptorUpdateTemplateCreateFlags)(x.ref2af95951.flags)
	x.DescriptorUpdateEntryCount = (uint32)(x.ref2af95951.descriptorUpdateEntryCount)
	packSDescriptorUpdateTemplateEntry(x.PDescriptorUpdateEntries, x.ref2af95951.pDescriptorUpdateEntries)
	x.TemplateType = (DescriptorUpdateTemplateType)(x.ref2af95951.templateType)
	x.DescriptorSetLayout = *(*DescriptorSetLayout)(unsafe.Pointer(&x.ref2af95951.descriptorSetLayout))
	x.PipelineBindPoint = (PipelineBindPoint)(x.ref2af95951.pipelineBindPoint)
	x.PipelineLayout = *(*PipelineLayout)(unsafe.Pointer(&x.ref2af95951.pipelineLayout))
	x.Set = (uint32)(x.ref2af95951.set)
}

// allocExternalMemoryPropertiesMemory allocates memory for type C.VkExternalMemoryProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalMemoryPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalMemoryPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExternalMemoryPropertiesValue = unsafe.Sizeof([1]C.VkExternalMemoryProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalMemoryProperties) Ref() *C.VkExternalMemoryProperties {
	if x == nil {
		return nil
	}
	return x.ref4b738f01
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalMemoryProperties) Free() {
	if x != nil && x.allocs4b738f01 != nil {
		x.allocs4b738f01.(*cgoAllocMap).Free()
		x.ref4b738f01 = nil
	}
}

// NewExternalMemoryPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalMemoryPropertiesRef(ref unsafe.Pointer) *ExternalMemoryProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExternalMemoryProperties)
	obj.ref4b738f01 = (*C.VkExternalMemoryProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalMemoryProperties) PassRef() (*C.VkExternalMemoryProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b738f01 != nil {
		return x.ref4b738f01, nil
	}
	mem4b738f01 := allocExternalMemoryPropertiesMemory(1)
	ref4b738f01 := (*C.VkExternalMemoryProperties)(mem4b738f01)
	allocs4b738f01 := new(cgoAllocMap)
	allocs4b738f01.Add(mem4b738f01)

	var cexternalMemoryFeatures_allocs *cgoAllocMap
	ref4b738f01.externalMemoryFeatures, cexternalMemoryFeatures_allocs = (C.VkExternalMemoryFeatureFlags)(x.ExternalMemoryFeatures), cgoAllocsUnknown
	allocs4b738f01.Borrow(cexternalMemoryFeatures_allocs)

	var cexportFromImportedHandleTypes_allocs *cgoAllocMap
	ref4b738f01.exportFromImportedHandleTypes, cexportFromImportedHandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.ExportFromImportedHandleTypes), cgoAllocsUnknown
	allocs4b738f01.Borrow(cexportFromImportedHandleTypes_allocs)

	var ccompatibleHandleTypes_allocs *cgoAllocMap
	ref4b738f01.compatibleHandleTypes, ccompatibleHandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.CompatibleHandleTypes), cgoAllocsUnknown
	allocs4b738f01.Borrow(ccompatibleHandleTypes_allocs)

	x.ref4b738f01 = ref4b738f01
	x.allocs4b738f01 = allocs4b738f01
	return ref4b738f01, allocs4b738f01

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalMemoryProperties) PassValue() (C.VkExternalMemoryProperties, *cgoAllocMap) {
	if x.ref4b738f01 != nil {
		return *x.ref4b738f01, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalMemoryProperties) Deref() {
	if x.ref4b738f01 == nil {
		return
	}
	x.ExternalMemoryFeatures = (ExternalMemoryFeatureFlags)(x.ref4b738f01.externalMemoryFeatures)
	x.ExportFromImportedHandleTypes = (ExternalMemoryHandleTypeFlags)(x.ref4b738f01.exportFromImportedHandleTypes)
	x.CompatibleHandleTypes = (ExternalMemoryHandleTypeFlags)(x.ref4b738f01.compatibleHandleTypes)
}

// allocPhysicalDeviceExternalImageFormatInfoMemory allocates memory for type C.VkPhysicalDeviceExternalImageFormatInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExternalImageFormatInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExternalImageFormatInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceExternalImageFormatInfoValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExternalImageFormatInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalImageFormatInfo) Ref() *C.VkPhysicalDeviceExternalImageFormatInfo {
	if x == nil {
		return nil
	}
	return x.refc839c724
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalImageFormatInfo) Free() {
	if x != nil && x.allocsc839c724 != nil {
		x.allocsc839c724.(*cgoAllocMap).Free()
		x.refc839c724 = nil
	}
}

// NewPhysicalDeviceExternalImageFormatInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalImageFormatInfoRef(ref unsafe.Pointer) *PhysicalDeviceExternalImageFormatInfo {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalImageFormatInfo)
	obj.refc839c724 = (*C.VkPhysicalDeviceExternalImageFormatInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalImageFormatInfo) PassRef() (*C.VkPhysicalDeviceExternalImageFormatInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc839c724 != nil {
		return x.refc839c724, nil
	}
	memc839c724 := allocPhysicalDeviceExternalImageFormatInfoMemory(1)
	refc839c724 := (*C.VkPhysicalDeviceExternalImageFormatInfo)(memc839c724)
	allocsc839c724 := new(cgoAllocMap)
	allocsc839c724.Add(memc839c724)

	var csType_allocs *cgoAllocMap
	refc839c724.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc839c724.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc839c724.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc839c724.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	refc839c724.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocsc839c724.Borrow(chandleType_allocs)

	x.refc839c724 = refc839c724
	x.allocsc839c724 = allocsc839c724
	return refc839c724, allocsc839c724

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalImageFormatInfo) PassValue() (C.VkPhysicalDeviceExternalImageFormatInfo, *cgoAllocMap) {
	if x.refc839c724 != nil {
		return *x.refc839c724, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalImageFormatInfo) Deref() {
	if x.refc839c724 == nil {
		return
	}
	x.SType = (StructureType)(x.refc839c724.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc839c724.pNext))
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.refc839c724.handleType)
}

// allocExternalImageFormatPropertiesMemory allocates memory for type C.VkExternalImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalImageFormatPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExternalImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkExternalImageFormatProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalImageFormatProperties) Ref() *C.VkExternalImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.refd404c4b5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalImageFormatProperties) Free() {
	if x != nil && x.allocsd404c4b5 != nil {
		x.allocsd404c4b5.(*cgoAllocMap).Free()
		x.refd404c4b5 = nil
	}
}

// NewExternalImageFormatPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalImageFormatPropertiesRef(ref unsafe.Pointer) *ExternalImageFormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExternalImageFormatProperties)
	obj.refd404c4b5 = (*C.VkExternalImageFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalImageFormatProperties) PassRef() (*C.VkExternalImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd404c4b5 != nil {
		return x.refd404c4b5, nil
	}
	memd404c4b5 := allocExternalImageFormatPropertiesMemory(1)
	refd404c4b5 := (*C.VkExternalImageFormatProperties)(memd404c4b5)
	allocsd404c4b5 := new(cgoAllocMap)
	allocsd404c4b5.Add(memd404c4b5)

	var csType_allocs *cgoAllocMap
	refd404c4b5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd404c4b5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd404c4b5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd404c4b5.Borrow(cpNext_allocs)

	var cexternalMemoryProperties_allocs *cgoAllocMap
	refd404c4b5.externalMemoryProperties, cexternalMemoryProperties_allocs = x.ExternalMemoryProperties.PassValue()
	allocsd404c4b5.Borrow(cexternalMemoryProperties_allocs)

	x.refd404c4b5 = refd404c4b5
	x.allocsd404c4b5 = allocsd404c4b5
	return refd404c4b5, allocsd404c4b5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalImageFormatProperties) PassValue() (C.VkExternalImageFormatProperties, *cgoAllocMap) {
	if x.refd404c4b5 != nil {
		return *x.refd404c4b5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalImageFormatProperties) Deref() {
	if x.refd404c4b5 == nil {
		return
	}
	x.SType = (StructureType)(x.refd404c4b5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd404c4b5.pNext))
	x.ExternalMemoryProperties = *NewExternalMemoryPropertiesRef(unsafe.Pointer(&x.refd404c4b5.externalMemoryProperties))
}

// allocPhysicalDeviceExternalBufferInfoMemory allocates memory for type C.VkPhysicalDeviceExternalBufferInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExternalBufferInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExternalBufferInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceExternalBufferInfoValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExternalBufferInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalBufferInfo) Ref() *C.VkPhysicalDeviceExternalBufferInfo {
	if x == nil {
		return nil
	}
	return x.ref8d758947
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalBufferInfo) Free() {
	if x != nil && x.allocs8d758947 != nil {
		x.allocs8d758947.(*cgoAllocMap).Free()
		x.ref8d758947 = nil
	}
}

// NewPhysicalDeviceExternalBufferInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalBufferInfoRef(ref unsafe.Pointer) *PhysicalDeviceExternalBufferInfo {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalBufferInfo)
	obj.ref8d758947 = (*C.VkPhysicalDeviceExternalBufferInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalBufferInfo) PassRef() (*C.VkPhysicalDeviceExternalBufferInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8d758947 != nil {
		return x.ref8d758947, nil
	}
	mem8d758947 := allocPhysicalDeviceExternalBufferInfoMemory(1)
	ref8d758947 := (*C.VkPhysicalDeviceExternalBufferInfo)(mem8d758947)
	allocs8d758947 := new(cgoAllocMap)
	allocs8d758947.Add(mem8d758947)

	var csType_allocs *cgoAllocMap
	ref8d758947.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8d758947.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8d758947.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8d758947.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref8d758947.flags, cflags_allocs = (C.VkBufferCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs8d758947.Borrow(cflags_allocs)

	var cusage_allocs *cgoAllocMap
	ref8d758947.usage, cusage_allocs = (C.VkBufferUsageFlags)(x.Usage), cgoAllocsUnknown
	allocs8d758947.Borrow(cusage_allocs)

	var chandleType_allocs *cgoAllocMap
	ref8d758947.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs8d758947.Borrow(chandleType_allocs)

	x.ref8d758947 = ref8d758947
	x.allocs8d758947 = allocs8d758947
	return ref8d758947, allocs8d758947

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalBufferInfo) PassValue() (C.VkPhysicalDeviceExternalBufferInfo, *cgoAllocMap) {
	if x.ref8d758947 != nil {
		return *x.ref8d758947, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalBufferInfo) Deref() {
	if x.ref8d758947 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8d758947.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8d758947.pNext))
	x.Flags = (BufferCreateFlags)(x.ref8d758947.flags)
	x.Usage = (BufferUsageFlags)(x.ref8d758947.usage)
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.ref8d758947.handleType)
}

// allocExternalBufferPropertiesMemory allocates memory for type C.VkExternalBufferProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalBufferPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalBufferPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExternalBufferPropertiesValue = unsafe.Sizeof([1]C.VkExternalBufferProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalBufferProperties) Ref() *C.VkExternalBufferProperties {
	if x == nil {
		return nil
	}
	return x.ref12f7c546
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalBufferProperties) Free() {
	if x != nil && x.allocs12f7c546 != nil {
		x.allocs12f7c546.(*cgoAllocMap).Free()
		x.ref12f7c546 = nil
	}
}

// NewExternalBufferPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalBufferPropertiesRef(ref unsafe.Pointer) *ExternalBufferProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExternalBufferProperties)
	obj.ref12f7c546 = (*C.VkExternalBufferProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalBufferProperties) PassRef() (*C.VkExternalBufferProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref12f7c546 != nil {
		return x.ref12f7c546, nil
	}
	mem12f7c546 := allocExternalBufferPropertiesMemory(1)
	ref12f7c546 := (*C.VkExternalBufferProperties)(mem12f7c546)
	allocs12f7c546 := new(cgoAllocMap)
	allocs12f7c546.Add(mem12f7c546)

	var csType_allocs *cgoAllocMap
	ref12f7c546.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs12f7c546.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref12f7c546.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs12f7c546.Borrow(cpNext_allocs)

	var cexternalMemoryProperties_allocs *cgoAllocMap
	ref12f7c546.externalMemoryProperties, cexternalMemoryProperties_allocs = x.ExternalMemoryProperties.PassValue()
	allocs12f7c546.Borrow(cexternalMemoryProperties_allocs)

	x.ref12f7c546 = ref12f7c546
	x.allocs12f7c546 = allocs12f7c546
	return ref12f7c546, allocs12f7c546

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalBufferProperties) PassValue() (C.VkExternalBufferProperties, *cgoAllocMap) {
	if x.ref12f7c546 != nil {
		return *x.ref12f7c546, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalBufferProperties) Deref() {
	if x.ref12f7c546 == nil {
		return
	}
	x.SType = (StructureType)(x.ref12f7c546.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref12f7c546.pNext))
	x.ExternalMemoryProperties = *NewExternalMemoryPropertiesRef(unsafe.Pointer(&x.ref12f7c546.externalMemoryProperties))
}

// allocPhysicalDeviceIDPropertiesMemory allocates memory for type C.VkPhysicalDeviceIDProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceIDPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceIDPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceIDPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceIDProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceIDProperties) Ref() *C.VkPhysicalDeviceIDProperties {
	if x == nil {
		return nil
	}
	return x.refe990a9f3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceIDProperties) Free() {
	if x != nil && x.allocse990a9f3 != nil {
		x.allocse990a9f3.(*cgoAllocMap).Free()
		x.refe990a9f3 = nil
	}
}

// NewPhysicalDeviceIDPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceIDPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceIDProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceIDProperties)
	obj.refe990a9f3 = (*C.VkPhysicalDeviceIDProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceIDProperties) PassRef() (*C.VkPhysicalDeviceIDProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe990a9f3 != nil {
		return x.refe990a9f3, nil
	}
	meme990a9f3 := allocPhysicalDeviceIDPropertiesMemory(1)
	refe990a9f3 := (*C.VkPhysicalDeviceIDProperties)(meme990a9f3)
	allocse990a9f3 := new(cgoAllocMap)
	allocse990a9f3.Add(meme990a9f3)

	var csType_allocs *cgoAllocMap
	refe990a9f3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse990a9f3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe990a9f3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse990a9f3.Borrow(cpNext_allocs)

	var cdeviceUUID_allocs *cgoAllocMap
	refe990a9f3.deviceUUID, cdeviceUUID_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.DeviceUUID)), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdeviceUUID_allocs)

	var cdriverUUID_allocs *cgoAllocMap
	refe990a9f3.driverUUID, cdriverUUID_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.DriverUUID)), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdriverUUID_allocs)

	var cdeviceLUID_allocs *cgoAllocMap
	refe990a9f3.deviceLUID, cdeviceLUID_allocs = *(*[8]C.uint8_t)(unsafe.Pointer(&x.DeviceLUID)), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdeviceLUID_allocs)

	var cdeviceNodeMask_allocs *cgoAllocMap
	refe990a9f3.deviceNodeMask, cdeviceNodeMask_allocs = (C.uint32_t)(x.DeviceNodeMask), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdeviceNodeMask_allocs)

	var cdeviceLUIDValid_allocs *cgoAllocMap
	refe990a9f3.deviceLUIDValid, cdeviceLUIDValid_allocs = (C.VkBool32)(x.DeviceLUIDValid), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdeviceLUIDValid_allocs)

	x.refe990a9f3 = refe990a9f3
	x.allocse990a9f3 = allocse990a9f3
	return refe990a9f3, allocse990a9f3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceIDProperties) PassValue() (C.VkPhysicalDeviceIDProperties, *cgoAllocMap) {
	if x.refe990a9f3 != nil {
		return *x.refe990a9f3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceIDProperties) Deref() {
	if x.refe990a9f3 == nil {
		return
	}
	x.SType = (StructureType)(x.refe990a9f3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe990a9f3.pNext))
	x.DeviceUUID = *(*[16]byte)(unsafe.Pointer(&x.refe990a9f3.deviceUUID))
	x.DriverUUID = *(*[16]byte)(unsafe.Pointer(&x.refe990a9f3.driverUUID))
	x.DeviceLUID = *(*[8]byte)(unsafe.Pointer(&x.refe990a9f3.deviceLUID))
	x.DeviceNodeMask = (uint32)(x.refe990a9f3.deviceNodeMask)
	x.DeviceLUIDValid = (Bool32)(x.refe990a9f3.deviceLUIDValid)
}

// allocExternalMemoryImageCreateInfoMemory allocates memory for type C.VkExternalMemoryImageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalMemoryImageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalMemoryImageCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExternalMemoryImageCreateInfoValue = unsafe.Sizeof([1]C.VkExternalMemoryImageCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalMemoryImageCreateInfo) Ref() *C.VkExternalMemoryImageCreateInfo {
	if x == nil {
		return nil
	}
	return x.refdaf1185e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalMemoryImageCreateInfo) Free() {
	if x != nil && x.allocsdaf1185e != nil {
		x.allocsdaf1185e.(*cgoAllocMap).Free()
		x.refdaf1185e = nil
	}
}

// NewExternalMemoryImageCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalMemoryImageCreateInfoRef(ref unsafe.Pointer) *ExternalMemoryImageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ExternalMemoryImageCreateInfo)
	obj.refdaf1185e = (*C.VkExternalMemoryImageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalMemoryImageCreateInfo) PassRef() (*C.VkExternalMemoryImageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdaf1185e != nil {
		return x.refdaf1185e, nil
	}
	memdaf1185e := allocExternalMemoryImageCreateInfoMemory(1)
	refdaf1185e := (*C.VkExternalMemoryImageCreateInfo)(memdaf1185e)
	allocsdaf1185e := new(cgoAllocMap)
	allocsdaf1185e.Add(memdaf1185e)

	var csType_allocs *cgoAllocMap
	refdaf1185e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdaf1185e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdaf1185e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdaf1185e.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	refdaf1185e.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocsdaf1185e.Borrow(chandleTypes_allocs)

	x.refdaf1185e = refdaf1185e
	x.allocsdaf1185e = allocsdaf1185e
	return refdaf1185e, allocsdaf1185e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalMemoryImageCreateInfo) PassValue() (C.VkExternalMemoryImageCreateInfo, *cgoAllocMap) {
	if x.refdaf1185e != nil {
		return *x.refdaf1185e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalMemoryImageCreateInfo) Deref() {
	if x.refdaf1185e == nil {
		return
	}
	x.SType = (StructureType)(x.refdaf1185e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdaf1185e.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlags)(x.refdaf1185e.handleTypes)
}

// allocExternalMemoryBufferCreateInfoMemory allocates memory for type C.VkExternalMemoryBufferCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalMemoryBufferCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalMemoryBufferCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExternalMemoryBufferCreateInfoValue = unsafe.Sizeof([1]C.VkExternalMemoryBufferCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalMemoryBufferCreateInfo) Ref() *C.VkExternalMemoryBufferCreateInfo {
	if x == nil {
		return nil
	}
	return x.refd33a9423
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalMemoryBufferCreateInfo) Free() {
	if x != nil && x.allocsd33a9423 != nil {
		x.allocsd33a9423.(*cgoAllocMap).Free()
		x.refd33a9423 = nil
	}
}

// NewExternalMemoryBufferCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalMemoryBufferCreateInfoRef(ref unsafe.Pointer) *ExternalMemoryBufferCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ExternalMemoryBufferCreateInfo)
	obj.refd33a9423 = (*C.VkExternalMemoryBufferCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalMemoryBufferCreateInfo) PassRef() (*C.VkExternalMemoryBufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd33a9423 != nil {
		return x.refd33a9423, nil
	}
	memd33a9423 := allocExternalMemoryBufferCreateInfoMemory(1)
	refd33a9423 := (*C.VkExternalMemoryBufferCreateInfo)(memd33a9423)
	allocsd33a9423 := new(cgoAllocMap)
	allocsd33a9423.Add(memd33a9423)

	var csType_allocs *cgoAllocMap
	refd33a9423.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd33a9423.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd33a9423.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd33a9423.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	refd33a9423.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocsd33a9423.Borrow(chandleTypes_allocs)

	x.refd33a9423 = refd33a9423
	x.allocsd33a9423 = allocsd33a9423
	return refd33a9423, allocsd33a9423

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalMemoryBufferCreateInfo) PassValue() (C.VkExternalMemoryBufferCreateInfo, *cgoAllocMap) {
	if x.refd33a9423 != nil {
		return *x.refd33a9423, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalMemoryBufferCreateInfo) Deref() {
	if x.refd33a9423 == nil {
		return
	}
	x.SType = (StructureType)(x.refd33a9423.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd33a9423.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlags)(x.refd33a9423.handleTypes)
}

// allocExportMemoryAllocateInfoMemory allocates memory for type C.VkExportMemoryAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExportMemoryAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExportMemoryAllocateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExportMemoryAllocateInfoValue = unsafe.Sizeof([1]C.VkExportMemoryAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExportMemoryAllocateInfo) Ref() *C.VkExportMemoryAllocateInfo {
	if x == nil {
		return nil
	}
	return x.refeb76ec64
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExportMemoryAllocateInfo) Free() {
	if x != nil && x.allocseb76ec64 != nil {
		x.allocseb76ec64.(*cgoAllocMap).Free()
		x.refeb76ec64 = nil
	}
}

// NewExportMemoryAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExportMemoryAllocateInfoRef(ref unsafe.Pointer) *ExportMemoryAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ExportMemoryAllocateInfo)
	obj.refeb76ec64 = (*C.VkExportMemoryAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExportMemoryAllocateInfo) PassRef() (*C.VkExportMemoryAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeb76ec64 != nil {
		return x.refeb76ec64, nil
	}
	memeb76ec64 := allocExportMemoryAllocateInfoMemory(1)
	refeb76ec64 := (*C.VkExportMemoryAllocateInfo)(memeb76ec64)
	allocseb76ec64 := new(cgoAllocMap)
	allocseb76ec64.Add(memeb76ec64)

	var csType_allocs *cgoAllocMap
	refeb76ec64.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseb76ec64.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeb76ec64.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseb76ec64.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	refeb76ec64.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocseb76ec64.Borrow(chandleTypes_allocs)

	x.refeb76ec64 = refeb76ec64
	x.allocseb76ec64 = allocseb76ec64
	return refeb76ec64, allocseb76ec64

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExportMemoryAllocateInfo) PassValue() (C.VkExportMemoryAllocateInfo, *cgoAllocMap) {
	if x.refeb76ec64 != nil {
		return *x.refeb76ec64, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExportMemoryAllocateInfo) Deref() {
	if x.refeb76ec64 == nil {
		return
	}
	x.SType = (StructureType)(x.refeb76ec64.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeb76ec64.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlags)(x.refeb76ec64.handleTypes)
}

// allocPhysicalDeviceExternalFenceInfoMemory allocates memory for type C.VkPhysicalDeviceExternalFenceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExternalFenceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExternalFenceInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceExternalFenceInfoValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExternalFenceInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalFenceInfo) Ref() *C.VkPhysicalDeviceExternalFenceInfo {
	if x == nil {
		return nil
	}
	return x.ref9bb660cc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalFenceInfo) Free() {
	if x != nil && x.allocs9bb660cc != nil {
		x.allocs9bb660cc.(*cgoAllocMap).Free()
		x.ref9bb660cc = nil
	}
}

// NewPhysicalDeviceExternalFenceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalFenceInfoRef(ref unsafe.Pointer) *PhysicalDeviceExternalFenceInfo {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalFenceInfo)
	obj.ref9bb660cc = (*C.VkPhysicalDeviceExternalFenceInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalFenceInfo) PassRef() (*C.VkPhysicalDeviceExternalFenceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9bb660cc != nil {
		return x.ref9bb660cc, nil
	}
	mem9bb660cc := allocPhysicalDeviceExternalFenceInfoMemory(1)
	ref9bb660cc := (*C.VkPhysicalDeviceExternalFenceInfo)(mem9bb660cc)
	allocs9bb660cc := new(cgoAllocMap)
	allocs9bb660cc.Add(mem9bb660cc)

	var csType_allocs *cgoAllocMap
	ref9bb660cc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9bb660cc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9bb660cc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9bb660cc.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	ref9bb660cc.handleType, chandleType_allocs = (C.VkExternalFenceHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs9bb660cc.Borrow(chandleType_allocs)

	x.ref9bb660cc = ref9bb660cc
	x.allocs9bb660cc = allocs9bb660cc
	return ref9bb660cc, allocs9bb660cc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalFenceInfo) PassValue() (C.VkPhysicalDeviceExternalFenceInfo, *cgoAllocMap) {
	if x.ref9bb660cc != nil {
		return *x.ref9bb660cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalFenceInfo) Deref() {
	if x.ref9bb660cc == nil {
		return
	}
	x.SType = (StructureType)(x.ref9bb660cc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9bb660cc.pNext))
	x.HandleType = (ExternalFenceHandleTypeFlagBits)(x.ref9bb660cc.handleType)
}

// allocExternalFencePropertiesMemory allocates memory for type C.VkExternalFenceProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalFencePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalFencePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExternalFencePropertiesValue = unsafe.Sizeof([1]C.VkExternalFenceProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalFenceProperties) Ref() *C.VkExternalFenceProperties {
	if x == nil {
		return nil
	}
	return x.ref18806773
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalFenceProperties) Free() {
	if x != nil && x.allocs18806773 != nil {
		x.allocs18806773.(*cgoAllocMap).Free()
		x.ref18806773 = nil
	}
}

// NewExternalFencePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalFencePropertiesRef(ref unsafe.Pointer) *ExternalFenceProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExternalFenceProperties)
	obj.ref18806773 = (*C.VkExternalFenceProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalFenceProperties) PassRef() (*C.VkExternalFenceProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref18806773 != nil {
		return x.ref18806773, nil
	}
	mem18806773 := allocExternalFencePropertiesMemory(1)
	ref18806773 := (*C.VkExternalFenceProperties)(mem18806773)
	allocs18806773 := new(cgoAllocMap)
	allocs18806773.Add(mem18806773)

	var csType_allocs *cgoAllocMap
	ref18806773.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs18806773.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref18806773.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs18806773.Borrow(cpNext_allocs)

	var cexportFromImportedHandleTypes_allocs *cgoAllocMap
	ref18806773.exportFromImportedHandleTypes, cexportFromImportedHandleTypes_allocs = (C.VkExternalFenceHandleTypeFlags)(x.ExportFromImportedHandleTypes), cgoAllocsUnknown
	allocs18806773.Borrow(cexportFromImportedHandleTypes_allocs)

	var ccompatibleHandleTypes_allocs *cgoAllocMap
	ref18806773.compatibleHandleTypes, ccompatibleHandleTypes_allocs = (C.VkExternalFenceHandleTypeFlags)(x.CompatibleHandleTypes), cgoAllocsUnknown
	allocs18806773.Borrow(ccompatibleHandleTypes_allocs)

	var cexternalFenceFeatures_allocs *cgoAllocMap
	ref18806773.externalFenceFeatures, cexternalFenceFeatures_allocs = (C.VkExternalFenceFeatureFlags)(x.ExternalFenceFeatures), cgoAllocsUnknown
	allocs18806773.Borrow(cexternalFenceFeatures_allocs)

	x.ref18806773 = ref18806773
	x.allocs18806773 = allocs18806773
	return ref18806773, allocs18806773

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalFenceProperties) PassValue() (C.VkExternalFenceProperties, *cgoAllocMap) {
	if x.ref18806773 != nil {
		return *x.ref18806773, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalFenceProperties) Deref() {
	if x.ref18806773 == nil {
		return
	}
	x.SType = (StructureType)(x.ref18806773.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref18806773.pNext))
	x.ExportFromImportedHandleTypes = (ExternalFenceHandleTypeFlags)(x.ref18806773.exportFromImportedHandleTypes)
	x.CompatibleHandleTypes = (ExternalFenceHandleTypeFlags)(x.ref18806773.compatibleHandleTypes)
	x.ExternalFenceFeatures = (ExternalFenceFeatureFlags)(x.ref18806773.externalFenceFeatures)
}

// allocExportFenceCreateInfoMemory allocates memory for type C.VkExportFenceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExportFenceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExportFenceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExportFenceCreateInfoValue = unsafe.Sizeof([1]C.VkExportFenceCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExportFenceCreateInfo) Ref() *C.VkExportFenceCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref5fef8c3a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExportFenceCreateInfo) Free() {
	if x != nil && x.allocs5fef8c3a != nil {
		x.allocs5fef8c3a.(*cgoAllocMap).Free()
		x.ref5fef8c3a = nil
	}
}

// NewExportFenceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExportFenceCreateInfoRef(ref unsafe.Pointer) *ExportFenceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ExportFenceCreateInfo)
	obj.ref5fef8c3a = (*C.VkExportFenceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExportFenceCreateInfo) PassRef() (*C.VkExportFenceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5fef8c3a != nil {
		return x.ref5fef8c3a, nil
	}
	mem5fef8c3a := allocExportFenceCreateInfoMemory(1)
	ref5fef8c3a := (*C.VkExportFenceCreateInfo)(mem5fef8c3a)
	allocs5fef8c3a := new(cgoAllocMap)
	allocs5fef8c3a.Add(mem5fef8c3a)

	var csType_allocs *cgoAllocMap
	ref5fef8c3a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5fef8c3a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5fef8c3a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5fef8c3a.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	ref5fef8c3a.handleTypes, chandleTypes_allocs = (C.VkExternalFenceHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocs5fef8c3a.Borrow(chandleTypes_allocs)

	x.ref5fef8c3a = ref5fef8c3a
	x.allocs5fef8c3a = allocs5fef8c3a
	return ref5fef8c3a, allocs5fef8c3a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExportFenceCreateInfo) PassValue() (C.VkExportFenceCreateInfo, *cgoAllocMap) {
	if x.ref5fef8c3a != nil {
		return *x.ref5fef8c3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExportFenceCreateInfo) Deref() {
	if x.ref5fef8c3a == nil {
		return
	}
	x.SType = (StructureType)(x.ref5fef8c3a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5fef8c3a.pNext))
	x.HandleTypes = (ExternalFenceHandleTypeFlags)(x.ref5fef8c3a.handleTypes)
}

// allocExportSemaphoreCreateInfoMemory allocates memory for type C.VkExportSemaphoreCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExportSemaphoreCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExportSemaphoreCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExportSemaphoreCreateInfoValue = unsafe.Sizeof([1]C.VkExportSemaphoreCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExportSemaphoreCreateInfo) Ref() *C.VkExportSemaphoreCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref17b8d6c5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExportSemaphoreCreateInfo) Free() {
	if x != nil && x.allocs17b8d6c5 != nil {
		x.allocs17b8d6c5.(*cgoAllocMap).Free()
		x.ref17b8d6c5 = nil
	}
}

// NewExportSemaphoreCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExportSemaphoreCreateInfoRef(ref unsafe.Pointer) *ExportSemaphoreCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ExportSemaphoreCreateInfo)
	obj.ref17b8d6c5 = (*C.VkExportSemaphoreCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExportSemaphoreCreateInfo) PassRef() (*C.VkExportSemaphoreCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref17b8d6c5 != nil {
		return x.ref17b8d6c5, nil
	}
	mem17b8d6c5 := allocExportSemaphoreCreateInfoMemory(1)
	ref17b8d6c5 := (*C.VkExportSemaphoreCreateInfo)(mem17b8d6c5)
	allocs17b8d6c5 := new(cgoAllocMap)
	allocs17b8d6c5.Add(mem17b8d6c5)

	var csType_allocs *cgoAllocMap
	ref17b8d6c5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs17b8d6c5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref17b8d6c5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs17b8d6c5.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	ref17b8d6c5.handleTypes, chandleTypes_allocs = (C.VkExternalSemaphoreHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocs17b8d6c5.Borrow(chandleTypes_allocs)

	x.ref17b8d6c5 = ref17b8d6c5
	x.allocs17b8d6c5 = allocs17b8d6c5
	return ref17b8d6c5, allocs17b8d6c5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExportSemaphoreCreateInfo) PassValue() (C.VkExportSemaphoreCreateInfo, *cgoAllocMap) {
	if x.ref17b8d6c5 != nil {
		return *x.ref17b8d6c5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExportSemaphoreCreateInfo) Deref() {
	if x.ref17b8d6c5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref17b8d6c5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref17b8d6c5.pNext))
	x.HandleTypes = (ExternalSemaphoreHandleTypeFlags)(x.ref17b8d6c5.handleTypes)
}

// allocPhysicalDeviceExternalSemaphoreInfoMemory allocates memory for type C.VkPhysicalDeviceExternalSemaphoreInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExternalSemaphoreInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExternalSemaphoreInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceExternalSemaphoreInfoValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExternalSemaphoreInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalSemaphoreInfo) Ref() *C.VkPhysicalDeviceExternalSemaphoreInfo {
	if x == nil {
		return nil
	}
	return x.ref5981d29e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalSemaphoreInfo) Free() {
	if x != nil && x.allocs5981d29e != nil {
		x.allocs5981d29e.(*cgoAllocMap).Free()
		x.ref5981d29e = nil
	}
}

// NewPhysicalDeviceExternalSemaphoreInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalSemaphoreInfoRef(ref unsafe.Pointer) *PhysicalDeviceExternalSemaphoreInfo {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalSemaphoreInfo)
	obj.ref5981d29e = (*C.VkPhysicalDeviceExternalSemaphoreInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalSemaphoreInfo) PassRef() (*C.VkPhysicalDeviceExternalSemaphoreInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5981d29e != nil {
		return x.ref5981d29e, nil
	}
	mem5981d29e := allocPhysicalDeviceExternalSemaphoreInfoMemory(1)
	ref5981d29e := (*C.VkPhysicalDeviceExternalSemaphoreInfo)(mem5981d29e)
	allocs5981d29e := new(cgoAllocMap)
	allocs5981d29e.Add(mem5981d29e)

	var csType_allocs *cgoAllocMap
	ref5981d29e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5981d29e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5981d29e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5981d29e.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	ref5981d29e.handleType, chandleType_allocs = (C.VkExternalSemaphoreHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs5981d29e.Borrow(chandleType_allocs)

	x.ref5981d29e = ref5981d29e
	x.allocs5981d29e = allocs5981d29e
	return ref5981d29e, allocs5981d29e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalSemaphoreInfo) PassValue() (C.VkPhysicalDeviceExternalSemaphoreInfo, *cgoAllocMap) {
	if x.ref5981d29e != nil {
		return *x.ref5981d29e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalSemaphoreInfo) Deref() {
	if x.ref5981d29e == nil {
		return
	}
	x.SType = (StructureType)(x.ref5981d29e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5981d29e.pNext))
	x.HandleType = (ExternalSemaphoreHandleTypeFlagBits)(x.ref5981d29e.handleType)
}

// allocExternalSemaphorePropertiesMemory allocates memory for type C.VkExternalSemaphoreProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalSemaphorePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalSemaphorePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExternalSemaphorePropertiesValue = unsafe.Sizeof([1]C.VkExternalSemaphoreProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalSemaphoreProperties) Ref() *C.VkExternalSemaphoreProperties {
	if x == nil {
		return nil
	}
	return x.ref87ec1054
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalSemaphoreProperties) Free() {
	if x != nil && x.allocs87ec1054 != nil {
		x.allocs87ec1054.(*cgoAllocMap).Free()
		x.ref87ec1054 = nil
	}
}

// NewExternalSemaphorePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalSemaphorePropertiesRef(ref unsafe.Pointer) *ExternalSemaphoreProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExternalSemaphoreProperties)
	obj.ref87ec1054 = (*C.VkExternalSemaphoreProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalSemaphoreProperties) PassRef() (*C.VkExternalSemaphoreProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref87ec1054 != nil {
		return x.ref87ec1054, nil
	}
	mem87ec1054 := allocExternalSemaphorePropertiesMemory(1)
	ref87ec1054 := (*C.VkExternalSemaphoreProperties)(mem87ec1054)
	allocs87ec1054 := new(cgoAllocMap)
	allocs87ec1054.Add(mem87ec1054)

	var csType_allocs *cgoAllocMap
	ref87ec1054.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs87ec1054.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref87ec1054.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs87ec1054.Borrow(cpNext_allocs)

	var cexportFromImportedHandleTypes_allocs *cgoAllocMap
	ref87ec1054.exportFromImportedHandleTypes, cexportFromImportedHandleTypes_allocs = (C.VkExternalSemaphoreHandleTypeFlags)(x.ExportFromImportedHandleTypes), cgoAllocsUnknown
	allocs87ec1054.Borrow(cexportFromImportedHandleTypes_allocs)

	var ccompatibleHandleTypes_allocs *cgoAllocMap
	ref87ec1054.compatibleHandleTypes, ccompatibleHandleTypes_allocs = (C.VkExternalSemaphoreHandleTypeFlags)(x.CompatibleHandleTypes), cgoAllocsUnknown
	allocs87ec1054.Borrow(ccompatibleHandleTypes_allocs)

	var cexternalSemaphoreFeatures_allocs *cgoAllocMap
	ref87ec1054.externalSemaphoreFeatures, cexternalSemaphoreFeatures_allocs = (C.VkExternalSemaphoreFeatureFlags)(x.ExternalSemaphoreFeatures), cgoAllocsUnknown
	allocs87ec1054.Borrow(cexternalSemaphoreFeatures_allocs)

	x.ref87ec1054 = ref87ec1054
	x.allocs87ec1054 = allocs87ec1054
	return ref87ec1054, allocs87ec1054

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalSemaphoreProperties) PassValue() (C.VkExternalSemaphoreProperties, *cgoAllocMap) {
	if x.ref87ec1054 != nil {
		return *x.ref87ec1054, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalSemaphoreProperties) Deref() {
	if x.ref87ec1054 == nil {
		return
	}
	x.SType = (StructureType)(x.ref87ec1054.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref87ec1054.pNext))
	x.ExportFromImportedHandleTypes = (ExternalSemaphoreHandleTypeFlags)(x.ref87ec1054.exportFromImportedHandleTypes)
	x.CompatibleHandleTypes = (ExternalSemaphoreHandleTypeFlags)(x.ref87ec1054.compatibleHandleTypes)
	x.ExternalSemaphoreFeatures = (ExternalSemaphoreFeatureFlags)(x.ref87ec1054.externalSemaphoreFeatures)
}

// allocPhysicalDeviceMaintenance3PropertiesMemory allocates memory for type C.VkPhysicalDeviceMaintenance3Properties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMaintenance3PropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMaintenance3PropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceMaintenance3PropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMaintenance3Properties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMaintenance3Properties) Ref() *C.VkPhysicalDeviceMaintenance3Properties {
	if x == nil {
		return nil
	}
	return x.ref12c07777
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMaintenance3Properties) Free() {
	if x != nil && x.allocs12c07777 != nil {
		x.allocs12c07777.(*cgoAllocMap).Free()
		x.ref12c07777 = nil
	}
}

// NewPhysicalDeviceMaintenance3PropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMaintenance3PropertiesRef(ref unsafe.Pointer) *PhysicalDeviceMaintenance3Properties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMaintenance3Properties)
	obj.ref12c07777 = (*C.VkPhysicalDeviceMaintenance3Properties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMaintenance3Properties) PassRef() (*C.VkPhysicalDeviceMaintenance3Properties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref12c07777 != nil {
		return x.ref12c07777, nil
	}
	mem12c07777 := allocPhysicalDeviceMaintenance3PropertiesMemory(1)
	ref12c07777 := (*C.VkPhysicalDeviceMaintenance3Properties)(mem12c07777)
	allocs12c07777 := new(cgoAllocMap)
	allocs12c07777.Add(mem12c07777)

	var csType_allocs *cgoAllocMap
	ref12c07777.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs12c07777.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref12c07777.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs12c07777.Borrow(cpNext_allocs)

	var cmaxPerSetDescriptors_allocs *cgoAllocMap
	ref12c07777.maxPerSetDescriptors, cmaxPerSetDescriptors_allocs = (C.uint32_t)(x.MaxPerSetDescriptors), cgoAllocsUnknown
	allocs12c07777.Borrow(cmaxPerSetDescriptors_allocs)

	var cmaxMemoryAllocationSize_allocs *cgoAllocMap
	ref12c07777.maxMemoryAllocationSize, cmaxMemoryAllocationSize_allocs = (C.VkDeviceSize)(x.MaxMemoryAllocationSize), cgoAllocsUnknown
	allocs12c07777.Borrow(cmaxMemoryAllocationSize_allocs)

	x.ref12c07777 = ref12c07777
	x.allocs12c07777 = allocs12c07777
	return ref12c07777, allocs12c07777

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMaintenance3Properties) PassValue() (C.VkPhysicalDeviceMaintenance3Properties, *cgoAllocMap) {
	if x.ref12c07777 != nil {
		return *x.ref12c07777, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMaintenance3Properties) Deref() {
	if x.ref12c07777 == nil {
		return
	}
	x.SType = (StructureType)(x.ref12c07777.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref12c07777.pNext))
	x.MaxPerSetDescriptors = (uint32)(x.ref12c07777.maxPerSetDescriptors)
	x.MaxMemoryAllocationSize = (DeviceSize)(x.ref12c07777.maxMemoryAllocationSize)
}

// allocDescriptorSetLayoutSupportMemory allocates memory for type C.VkDescriptorSetLayoutSupport in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutSupportMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutSupportValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorSetLayoutSupportValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutSupport{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetLayoutSupport) Ref() *C.VkDescriptorSetLayoutSupport {
	if x == nil {
		return nil
	}
	return x.ref5802686c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetLayoutSupport) Free() {
	if x != nil && x.allocs5802686c != nil {
		x.allocs5802686c.(*cgoAllocMap).Free()
		x.ref5802686c = nil
	}
}

// NewDescriptorSetLayoutSupportRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetLayoutSupportRef(ref unsafe.Pointer) *DescriptorSetLayoutSupport {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutSupport)
	obj.ref5802686c = (*C.VkDescriptorSetLayoutSupport)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetLayoutSupport) PassRef() (*C.VkDescriptorSetLayoutSupport, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5802686c != nil {
		return x.ref5802686c, nil
	}
	mem5802686c := allocDescriptorSetLayoutSupportMemory(1)
	ref5802686c := (*C.VkDescriptorSetLayoutSupport)(mem5802686c)
	allocs5802686c := new(cgoAllocMap)
	allocs5802686c.Add(mem5802686c)

	var csType_allocs *cgoAllocMap
	ref5802686c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5802686c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5802686c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5802686c.Borrow(cpNext_allocs)

	var csupported_allocs *cgoAllocMap
	ref5802686c.supported, csupported_allocs = (C.VkBool32)(x.Supported), cgoAllocsUnknown
	allocs5802686c.Borrow(csupported_allocs)

	x.ref5802686c = ref5802686c
	x.allocs5802686c = allocs5802686c
	return ref5802686c, allocs5802686c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetLayoutSupport) PassValue() (C.VkDescriptorSetLayoutSupport, *cgoAllocMap) {
	if x.ref5802686c != nil {
		return *x.ref5802686c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetLayoutSupport) Deref() {
	if x.ref5802686c == nil {
		return
	}
	x.SType = (StructureType)(x.ref5802686c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5802686c.pNext))
	x.Supported = (Bool32)(x.ref5802686c.supported)
}

// allocPhysicalDeviceShaderDrawParametersFeaturesMemory allocates memory for type C.VkPhysicalDeviceShaderDrawParametersFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderDrawParametersFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderDrawParametersFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShaderDrawParametersFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderDrawParametersFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderDrawParametersFeatures) Ref() *C.VkPhysicalDeviceShaderDrawParametersFeatures {
	if x == nil {
		return nil
	}
	return x.ref35d5aa70
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderDrawParametersFeatures) Free() {
	if x != nil && x.allocs35d5aa70 != nil {
		x.allocs35d5aa70.(*cgoAllocMap).Free()
		x.ref35d5aa70 = nil
	}
}

// NewPhysicalDeviceShaderDrawParametersFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderDrawParametersFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceShaderDrawParametersFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderDrawParametersFeatures)
	obj.ref35d5aa70 = (*C.VkPhysicalDeviceShaderDrawParametersFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderDrawParametersFeatures) PassRef() (*C.VkPhysicalDeviceShaderDrawParametersFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref35d5aa70 != nil {
		return x.ref35d5aa70, nil
	}
	mem35d5aa70 := allocPhysicalDeviceShaderDrawParametersFeaturesMemory(1)
	ref35d5aa70 := (*C.VkPhysicalDeviceShaderDrawParametersFeatures)(mem35d5aa70)
	allocs35d5aa70 := new(cgoAllocMap)
	allocs35d5aa70.Add(mem35d5aa70)

	var csType_allocs *cgoAllocMap
	ref35d5aa70.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs35d5aa70.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref35d5aa70.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs35d5aa70.Borrow(cpNext_allocs)

	var cshaderDrawParameters_allocs *cgoAllocMap
	ref35d5aa70.shaderDrawParameters, cshaderDrawParameters_allocs = (C.VkBool32)(x.ShaderDrawParameters), cgoAllocsUnknown
	allocs35d5aa70.Borrow(cshaderDrawParameters_allocs)

	x.ref35d5aa70 = ref35d5aa70
	x.allocs35d5aa70 = allocs35d5aa70
	return ref35d5aa70, allocs35d5aa70

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderDrawParametersFeatures) PassValue() (C.VkPhysicalDeviceShaderDrawParametersFeatures, *cgoAllocMap) {
	if x.ref35d5aa70 != nil {
		return *x.ref35d5aa70, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderDrawParametersFeatures) Deref() {
	if x.ref35d5aa70 == nil {
		return
	}
	x.SType = (StructureType)(x.ref35d5aa70.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref35d5aa70.pNext))
	x.ShaderDrawParameters = (Bool32)(x.ref35d5aa70.shaderDrawParameters)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderDrawParameterFeatures) Ref() *C.VkPhysicalDeviceShaderDrawParametersFeatures {
	if x == nil {
		return nil
	}
	return x.ref35d5aa70
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderDrawParameterFeatures) Free() {
	if x != nil && x.allocs35d5aa70 != nil {
		x.allocs35d5aa70.(*cgoAllocMap).Free()
		x.ref35d5aa70 = nil
	}
}

// NewPhysicalDeviceShaderDrawParameterFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderDrawParameterFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceShaderDrawParameterFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderDrawParameterFeatures)
	obj.ref35d5aa70 = (*C.VkPhysicalDeviceShaderDrawParametersFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderDrawParameterFeatures) PassRef() (*C.VkPhysicalDeviceShaderDrawParametersFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref35d5aa70 != nil {
		return x.ref35d5aa70, nil
	}
	mem35d5aa70 := allocPhysicalDeviceShaderDrawParametersFeaturesMemory(1)
	ref35d5aa70 := (*C.VkPhysicalDeviceShaderDrawParametersFeatures)(mem35d5aa70)
	allocs35d5aa70 := new(cgoAllocMap)
	allocs35d5aa70.Add(mem35d5aa70)

	var csType_allocs *cgoAllocMap
	ref35d5aa70.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs35d5aa70.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref35d5aa70.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs35d5aa70.Borrow(cpNext_allocs)

	var cshaderDrawParameters_allocs *cgoAllocMap
	ref35d5aa70.shaderDrawParameters, cshaderDrawParameters_allocs = (C.VkBool32)(x.ShaderDrawParameters), cgoAllocsUnknown
	allocs35d5aa70.Borrow(cshaderDrawParameters_allocs)

	x.ref35d5aa70 = ref35d5aa70
	x.allocs35d5aa70 = allocs35d5aa70
	return ref35d5aa70, allocs35d5aa70

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderDrawParameterFeatures) PassValue() (C.VkPhysicalDeviceShaderDrawParametersFeatures, *cgoAllocMap) {
	if x.ref35d5aa70 != nil {
		return *x.ref35d5aa70, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderDrawParameterFeatures) Deref() {
	if x.ref35d5aa70 == nil {
		return
	}
	x.SType = (StructureType)(x.ref35d5aa70.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref35d5aa70.pNext))
	x.ShaderDrawParameters = (Bool32)(x.ref35d5aa70.shaderDrawParameters)
}

// allocPhysicalDeviceVulkan11FeaturesMemory allocates memory for type C.VkPhysicalDeviceVulkan11Features in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVulkan11FeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVulkan11FeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceVulkan11FeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVulkan11Features{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVulkan11Features) Ref() *C.VkPhysicalDeviceVulkan11Features {
	if x == nil {
		return nil
	}
	return x.refd5335cef
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVulkan11Features) Free() {
	if x != nil && x.allocsd5335cef != nil {
		x.allocsd5335cef.(*cgoAllocMap).Free()
		x.refd5335cef = nil
	}
}

// NewPhysicalDeviceVulkan11FeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVulkan11FeaturesRef(ref unsafe.Pointer) *PhysicalDeviceVulkan11Features {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVulkan11Features)
	obj.refd5335cef = (*C.VkPhysicalDeviceVulkan11Features)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVulkan11Features) PassRef() (*C.VkPhysicalDeviceVulkan11Features, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd5335cef != nil {
		return x.refd5335cef, nil
	}
	memd5335cef := allocPhysicalDeviceVulkan11FeaturesMemory(1)
	refd5335cef := (*C.VkPhysicalDeviceVulkan11Features)(memd5335cef)
	allocsd5335cef := new(cgoAllocMap)
	allocsd5335cef.Add(memd5335cef)

	var csType_allocs *cgoAllocMap
	refd5335cef.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd5335cef.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd5335cef.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd5335cef.Borrow(cpNext_allocs)

	var cstorageBuffer16BitAccess_allocs *cgoAllocMap
	refd5335cef.storageBuffer16BitAccess, cstorageBuffer16BitAccess_allocs = (C.VkBool32)(x.StorageBuffer16BitAccess), cgoAllocsUnknown
	allocsd5335cef.Borrow(cstorageBuffer16BitAccess_allocs)

	var cuniformAndStorageBuffer16BitAccess_allocs *cgoAllocMap
	refd5335cef.uniformAndStorageBuffer16BitAccess, cuniformAndStorageBuffer16BitAccess_allocs = (C.VkBool32)(x.UniformAndStorageBuffer16BitAccess), cgoAllocsUnknown
	allocsd5335cef.Borrow(cuniformAndStorageBuffer16BitAccess_allocs)

	var cstoragePushConstant16_allocs *cgoAllocMap
	refd5335cef.storagePushConstant16, cstoragePushConstant16_allocs = (C.VkBool32)(x.StoragePushConstant16), cgoAllocsUnknown
	allocsd5335cef.Borrow(cstoragePushConstant16_allocs)

	var cstorageInputOutput16_allocs *cgoAllocMap
	refd5335cef.storageInputOutput16, cstorageInputOutput16_allocs = (C.VkBool32)(x.StorageInputOutput16), cgoAllocsUnknown
	allocsd5335cef.Borrow(cstorageInputOutput16_allocs)

	var cmultiview_allocs *cgoAllocMap
	refd5335cef.multiview, cmultiview_allocs = (C.VkBool32)(x.Multiview), cgoAllocsUnknown
	allocsd5335cef.Borrow(cmultiview_allocs)

	var cmultiviewGeometryShader_allocs *cgoAllocMap
	refd5335cef.multiviewGeometryShader, cmultiviewGeometryShader_allocs = (C.VkBool32)(x.MultiviewGeometryShader), cgoAllocsUnknown
	allocsd5335cef.Borrow(cmultiviewGeometryShader_allocs)

	var cmultiviewTessellationShader_allocs *cgoAllocMap
	refd5335cef.multiviewTessellationShader, cmultiviewTessellationShader_allocs = (C.VkBool32)(x.MultiviewTessellationShader), cgoAllocsUnknown
	allocsd5335cef.Borrow(cmultiviewTessellationShader_allocs)

	var cvariablePointersStorageBuffer_allocs *cgoAllocMap
	refd5335cef.variablePointersStorageBuffer, cvariablePointersStorageBuffer_allocs = (C.VkBool32)(x.VariablePointersStorageBuffer), cgoAllocsUnknown
	allocsd5335cef.Borrow(cvariablePointersStorageBuffer_allocs)

	var cvariablePointers_allocs *cgoAllocMap
	refd5335cef.variablePointers, cvariablePointers_allocs = (C.VkBool32)(x.VariablePointers), cgoAllocsUnknown
	allocsd5335cef.Borrow(cvariablePointers_allocs)

	var cprotectedMemory_allocs *cgoAllocMap
	refd5335cef.protectedMemory, cprotectedMemory_allocs = (C.VkBool32)(x.ProtectedMemory), cgoAllocsUnknown
	allocsd5335cef.Borrow(cprotectedMemory_allocs)

	var csamplerYcbcrConversion_allocs *cgoAllocMap
	refd5335cef.samplerYcbcrConversion, csamplerYcbcrConversion_allocs = (C.VkBool32)(x.SamplerYcbcrConversion), cgoAllocsUnknown
	allocsd5335cef.Borrow(csamplerYcbcrConversion_allocs)

	var cshaderDrawParameters_allocs *cgoAllocMap
	refd5335cef.shaderDrawParameters, cshaderDrawParameters_allocs = (C.VkBool32)(x.ShaderDrawParameters), cgoAllocsUnknown
	allocsd5335cef.Borrow(cshaderDrawParameters_allocs)

	x.refd5335cef = refd5335cef
	x.allocsd5335cef = allocsd5335cef
	return refd5335cef, allocsd5335cef

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVulkan11Features) PassValue() (C.VkPhysicalDeviceVulkan11Features, *cgoAllocMap) {
	if x.refd5335cef != nil {
		return *x.refd5335cef, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVulkan11Features) Deref() {
	if x.refd5335cef == nil {
		return
	}
	x.SType = (StructureType)(x.refd5335cef.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd5335cef.pNext))
	x.StorageBuffer16BitAccess = (Bool32)(x.refd5335cef.storageBuffer16BitAccess)
	x.UniformAndStorageBuffer16BitAccess = (Bool32)(x.refd5335cef.uniformAndStorageBuffer16BitAccess)
	x.StoragePushConstant16 = (Bool32)(x.refd5335cef.storagePushConstant16)
	x.StorageInputOutput16 = (Bool32)(x.refd5335cef.storageInputOutput16)
	x.Multiview = (Bool32)(x.refd5335cef.multiview)
	x.MultiviewGeometryShader = (Bool32)(x.refd5335cef.multiviewGeometryShader)
	x.MultiviewTessellationShader = (Bool32)(x.refd5335cef.multiviewTessellationShader)
	x.VariablePointersStorageBuffer = (Bool32)(x.refd5335cef.variablePointersStorageBuffer)
	x.VariablePointers = (Bool32)(x.refd5335cef.variablePointers)
	x.ProtectedMemory = (Bool32)(x.refd5335cef.protectedMemory)
	x.SamplerYcbcrConversion = (Bool32)(x.refd5335cef.samplerYcbcrConversion)
	x.ShaderDrawParameters = (Bool32)(x.refd5335cef.shaderDrawParameters)
}

// allocPhysicalDeviceVulkan11PropertiesMemory allocates memory for type C.VkPhysicalDeviceVulkan11Properties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVulkan11PropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVulkan11PropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceVulkan11PropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVulkan11Properties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVulkan11Properties) Ref() *C.VkPhysicalDeviceVulkan11Properties {
	if x == nil {
		return nil
	}
	return x.refd27276a5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVulkan11Properties) Free() {
	if x != nil && x.allocsd27276a5 != nil {
		x.allocsd27276a5.(*cgoAllocMap).Free()
		x.refd27276a5 = nil
	}
}

// NewPhysicalDeviceVulkan11PropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVulkan11PropertiesRef(ref unsafe.Pointer) *PhysicalDeviceVulkan11Properties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVulkan11Properties)
	obj.refd27276a5 = (*C.VkPhysicalDeviceVulkan11Properties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVulkan11Properties) PassRef() (*C.VkPhysicalDeviceVulkan11Properties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd27276a5 != nil {
		return x.refd27276a5, nil
	}
	memd27276a5 := allocPhysicalDeviceVulkan11PropertiesMemory(1)
	refd27276a5 := (*C.VkPhysicalDeviceVulkan11Properties)(memd27276a5)
	allocsd27276a5 := new(cgoAllocMap)
	allocsd27276a5.Add(memd27276a5)

	var csType_allocs *cgoAllocMap
	refd27276a5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd27276a5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd27276a5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd27276a5.Borrow(cpNext_allocs)

	var cdeviceUUID_allocs *cgoAllocMap
	refd27276a5.deviceUUID, cdeviceUUID_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.DeviceUUID)), cgoAllocsUnknown
	allocsd27276a5.Borrow(cdeviceUUID_allocs)

	var cdriverUUID_allocs *cgoAllocMap
	refd27276a5.driverUUID, cdriverUUID_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.DriverUUID)), cgoAllocsUnknown
	allocsd27276a5.Borrow(cdriverUUID_allocs)

	var cdeviceLUID_allocs *cgoAllocMap
	refd27276a5.deviceLUID, cdeviceLUID_allocs = *(*[8]C.uint8_t)(unsafe.Pointer(&x.DeviceLUID)), cgoAllocsUnknown
	allocsd27276a5.Borrow(cdeviceLUID_allocs)

	var cdeviceNodeMask_allocs *cgoAllocMap
	refd27276a5.deviceNodeMask, cdeviceNodeMask_allocs = (C.uint32_t)(x.DeviceNodeMask), cgoAllocsUnknown
	allocsd27276a5.Borrow(cdeviceNodeMask_allocs)

	var cdeviceLUIDValid_allocs *cgoAllocMap
	refd27276a5.deviceLUIDValid, cdeviceLUIDValid_allocs = (C.VkBool32)(x.DeviceLUIDValid), cgoAllocsUnknown
	allocsd27276a5.Borrow(cdeviceLUIDValid_allocs)

	var csubgroupSize_allocs *cgoAllocMap
	refd27276a5.subgroupSize, csubgroupSize_allocs = (C.uint32_t)(x.SubgroupSize), cgoAllocsUnknown
	allocsd27276a5.Borrow(csubgroupSize_allocs)

	var csubgroupSupportedStages_allocs *cgoAllocMap
	refd27276a5.subgroupSupportedStages, csubgroupSupportedStages_allocs = (C.VkShaderStageFlags)(x.SubgroupSupportedStages), cgoAllocsUnknown
	allocsd27276a5.Borrow(csubgroupSupportedStages_allocs)

	var csubgroupSupportedOperations_allocs *cgoAllocMap
	refd27276a5.subgroupSupportedOperations, csubgroupSupportedOperations_allocs = (C.VkSubgroupFeatureFlags)(x.SubgroupSupportedOperations), cgoAllocsUnknown
	allocsd27276a5.Borrow(csubgroupSupportedOperations_allocs)

	var csubgroupQuadOperationsInAllStages_allocs *cgoAllocMap
	refd27276a5.subgroupQuadOperationsInAllStages, csubgroupQuadOperationsInAllStages_allocs = (C.VkBool32)(x.SubgroupQuadOperationsInAllStages), cgoAllocsUnknown
	allocsd27276a5.Borrow(csubgroupQuadOperationsInAllStages_allocs)

	var cpointClippingBehavior_allocs *cgoAllocMap
	refd27276a5.pointClippingBehavior, cpointClippingBehavior_allocs = (C.VkPointClippingBehavior)(x.PointClippingBehavior), cgoAllocsUnknown
	allocsd27276a5.Borrow(cpointClippingBehavior_allocs)

	var cmaxMultiviewViewCount_allocs *cgoAllocMap
	refd27276a5.maxMultiviewViewCount, cmaxMultiviewViewCount_allocs = (C.uint32_t)(x.MaxMultiviewViewCount), cgoAllocsUnknown
	allocsd27276a5.Borrow(cmaxMultiviewViewCount_allocs)

	var cmaxMultiviewInstanceIndex_allocs *cgoAllocMap
	refd27276a5.maxMultiviewInstanceIndex, cmaxMultiviewInstanceIndex_allocs = (C.uint32_t)(x.MaxMultiviewInstanceIndex), cgoAllocsUnknown
	allocsd27276a5.Borrow(cmaxMultiviewInstanceIndex_allocs)

	var cprotectedNoFault_allocs *cgoAllocMap
	refd27276a5.protectedNoFault, cprotectedNoFault_allocs = (C.VkBool32)(x.ProtectedNoFault), cgoAllocsUnknown
	allocsd27276a5.Borrow(cprotectedNoFault_allocs)

	var cmaxPerSetDescriptors_allocs *cgoAllocMap
	refd27276a5.maxPerSetDescriptors, cmaxPerSetDescriptors_allocs = (C.uint32_t)(x.MaxPerSetDescriptors), cgoAllocsUnknown
	allocsd27276a5.Borrow(cmaxPerSetDescriptors_allocs)

	var cmaxMemoryAllocationSize_allocs *cgoAllocMap
	refd27276a5.maxMemoryAllocationSize, cmaxMemoryAllocationSize_allocs = (C.VkDeviceSize)(x.MaxMemoryAllocationSize), cgoAllocsUnknown
	allocsd27276a5.Borrow(cmaxMemoryAllocationSize_allocs)

	x.refd27276a5 = refd27276a5
	x.allocsd27276a5 = allocsd27276a5
	return refd27276a5, allocsd27276a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVulkan11Properties) PassValue() (C.VkPhysicalDeviceVulkan11Properties, *cgoAllocMap) {
	if x.refd27276a5 != nil {
		return *x.refd27276a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVulkan11Properties) Deref() {
	if x.refd27276a5 == nil {
		return
	}
	x.SType = (StructureType)(x.refd27276a5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd27276a5.pNext))
	x.DeviceUUID = *(*[16]byte)(unsafe.Pointer(&x.refd27276a5.deviceUUID))
	x.DriverUUID = *(*[16]byte)(unsafe.Pointer(&x.refd27276a5.driverUUID))
	x.DeviceLUID = *(*[8]byte)(unsafe.Pointer(&x.refd27276a5.deviceLUID))
	x.DeviceNodeMask = (uint32)(x.refd27276a5.deviceNodeMask)
	x.DeviceLUIDValid = (Bool32)(x.refd27276a5.deviceLUIDValid)
	x.SubgroupSize = (uint32)(x.refd27276a5.subgroupSize)
	x.SubgroupSupportedStages = (ShaderStageFlags)(x.refd27276a5.subgroupSupportedStages)
	x.SubgroupSupportedOperations = (SubgroupFeatureFlags)(x.refd27276a5.subgroupSupportedOperations)
	x.SubgroupQuadOperationsInAllStages = (Bool32)(x.refd27276a5.subgroupQuadOperationsInAllStages)
	x.PointClippingBehavior = (PointClippingBehavior)(x.refd27276a5.pointClippingBehavior)
	x.MaxMultiviewViewCount = (uint32)(x.refd27276a5.maxMultiviewViewCount)
	x.MaxMultiviewInstanceIndex = (uint32)(x.refd27276a5.maxMultiviewInstanceIndex)
	x.ProtectedNoFault = (Bool32)(x.refd27276a5.protectedNoFault)
	x.MaxPerSetDescriptors = (uint32)(x.refd27276a5.maxPerSetDescriptors)
	x.MaxMemoryAllocationSize = (DeviceSize)(x.refd27276a5.maxMemoryAllocationSize)
}

// allocPhysicalDeviceVulkan12FeaturesMemory allocates memory for type C.VkPhysicalDeviceVulkan12Features in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVulkan12FeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVulkan12FeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceVulkan12FeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVulkan12Features{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVulkan12Features) Ref() *C.VkPhysicalDeviceVulkan12Features {
	if x == nil {
		return nil
	}
	return x.refecbe602a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVulkan12Features) Free() {
	if x != nil && x.allocsecbe602a != nil {
		x.allocsecbe602a.(*cgoAllocMap).Free()
		x.refecbe602a = nil
	}
}

// NewPhysicalDeviceVulkan12FeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVulkan12FeaturesRef(ref unsafe.Pointer) *PhysicalDeviceVulkan12Features {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVulkan12Features)
	obj.refecbe602a = (*C.VkPhysicalDeviceVulkan12Features)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVulkan12Features) PassRef() (*C.VkPhysicalDeviceVulkan12Features, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refecbe602a != nil {
		return x.refecbe602a, nil
	}
	memecbe602a := allocPhysicalDeviceVulkan12FeaturesMemory(1)
	refecbe602a := (*C.VkPhysicalDeviceVulkan12Features)(memecbe602a)
	allocsecbe602a := new(cgoAllocMap)
	allocsecbe602a.Add(memecbe602a)

	var csType_allocs *cgoAllocMap
	refecbe602a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsecbe602a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refecbe602a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsecbe602a.Borrow(cpNext_allocs)

	var csamplerMirrorClampToEdge_allocs *cgoAllocMap
	refecbe602a.samplerMirrorClampToEdge, csamplerMirrorClampToEdge_allocs = (C.VkBool32)(x.SamplerMirrorClampToEdge), cgoAllocsUnknown
	allocsecbe602a.Borrow(csamplerMirrorClampToEdge_allocs)

	var cdrawIndirectCount_allocs *cgoAllocMap
	refecbe602a.drawIndirectCount, cdrawIndirectCount_allocs = (C.VkBool32)(x.DrawIndirectCount), cgoAllocsUnknown
	allocsecbe602a.Borrow(cdrawIndirectCount_allocs)

	var cstorageBuffer8BitAccess_allocs *cgoAllocMap
	refecbe602a.storageBuffer8BitAccess, cstorageBuffer8BitAccess_allocs = (C.VkBool32)(x.StorageBuffer8BitAccess), cgoAllocsUnknown
	allocsecbe602a.Borrow(cstorageBuffer8BitAccess_allocs)

	var cuniformAndStorageBuffer8BitAccess_allocs *cgoAllocMap
	refecbe602a.uniformAndStorageBuffer8BitAccess, cuniformAndStorageBuffer8BitAccess_allocs = (C.VkBool32)(x.UniformAndStorageBuffer8BitAccess), cgoAllocsUnknown
	allocsecbe602a.Borrow(cuniformAndStorageBuffer8BitAccess_allocs)

	var cstoragePushConstant8_allocs *cgoAllocMap
	refecbe602a.storagePushConstant8, cstoragePushConstant8_allocs = (C.VkBool32)(x.StoragePushConstant8), cgoAllocsUnknown
	allocsecbe602a.Borrow(cstoragePushConstant8_allocs)

	var cshaderBufferInt64Atomics_allocs *cgoAllocMap
	refecbe602a.shaderBufferInt64Atomics, cshaderBufferInt64Atomics_allocs = (C.VkBool32)(x.ShaderBufferInt64Atomics), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderBufferInt64Atomics_allocs)

	var cshaderSharedInt64Atomics_allocs *cgoAllocMap
	refecbe602a.shaderSharedInt64Atomics, cshaderSharedInt64Atomics_allocs = (C.VkBool32)(x.ShaderSharedInt64Atomics), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderSharedInt64Atomics_allocs)

	var cshaderFloat16_allocs *cgoAllocMap
	refecbe602a.shaderFloat16, cshaderFloat16_allocs = (C.VkBool32)(x.ShaderFloat16), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderFloat16_allocs)

	var cshaderInt8_allocs *cgoAllocMap
	refecbe602a.shaderInt8, cshaderInt8_allocs = (C.VkBool32)(x.ShaderInt8), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderInt8_allocs)

	var cdescriptorIndexing_allocs *cgoAllocMap
	refecbe602a.descriptorIndexing, cdescriptorIndexing_allocs = (C.VkBool32)(x.DescriptorIndexing), cgoAllocsUnknown
	allocsecbe602a.Borrow(cdescriptorIndexing_allocs)

	var cshaderInputAttachmentArrayDynamicIndexing_allocs *cgoAllocMap
	refecbe602a.shaderInputAttachmentArrayDynamicIndexing, cshaderInputAttachmentArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderInputAttachmentArrayDynamicIndexing), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderInputAttachmentArrayDynamicIndexing_allocs)

	var cshaderUniformTexelBufferArrayDynamicIndexing_allocs *cgoAllocMap
	refecbe602a.shaderUniformTexelBufferArrayDynamicIndexing, cshaderUniformTexelBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderUniformTexelBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderUniformTexelBufferArrayDynamicIndexing_allocs)

	var cshaderStorageTexelBufferArrayDynamicIndexing_allocs *cgoAllocMap
	refecbe602a.shaderStorageTexelBufferArrayDynamicIndexing, cshaderStorageTexelBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderStorageTexelBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderStorageTexelBufferArrayDynamicIndexing_allocs)

	var cshaderUniformBufferArrayNonUniformIndexing_allocs *cgoAllocMap
	refecbe602a.shaderUniformBufferArrayNonUniformIndexing, cshaderUniformBufferArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderUniformBufferArrayNonUniformIndexing), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderUniformBufferArrayNonUniformIndexing_allocs)

	var cshaderSampledImageArrayNonUniformIndexing_allocs *cgoAllocMap
	refecbe602a.shaderSampledImageArrayNonUniformIndexing, cshaderSampledImageArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderSampledImageArrayNonUniformIndexing), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderSampledImageArrayNonUniformIndexing_allocs)

	var cshaderStorageBufferArrayNonUniformIndexing_allocs *cgoAllocMap
	refecbe602a.shaderStorageBufferArrayNonUniformIndexing, cshaderStorageBufferArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderStorageBufferArrayNonUniformIndexing), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderStorageBufferArrayNonUniformIndexing_allocs)

	var cshaderStorageImageArrayNonUniformIndexing_allocs *cgoAllocMap
	refecbe602a.shaderStorageImageArrayNonUniformIndexing, cshaderStorageImageArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderStorageImageArrayNonUniformIndexing), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderStorageImageArrayNonUniformIndexing_allocs)

	var cshaderInputAttachmentArrayNonUniformIndexing_allocs *cgoAllocMap
	refecbe602a.shaderInputAttachmentArrayNonUniformIndexing, cshaderInputAttachmentArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderInputAttachmentArrayNonUniformIndexing), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderInputAttachmentArrayNonUniformIndexing_allocs)

	var cshaderUniformTexelBufferArrayNonUniformIndexing_allocs *cgoAllocMap
	refecbe602a.shaderUniformTexelBufferArrayNonUniformIndexing, cshaderUniformTexelBufferArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderUniformTexelBufferArrayNonUniformIndexing), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderUniformTexelBufferArrayNonUniformIndexing_allocs)

	var cshaderStorageTexelBufferArrayNonUniformIndexing_allocs *cgoAllocMap
	refecbe602a.shaderStorageTexelBufferArrayNonUniformIndexing, cshaderStorageTexelBufferArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderStorageTexelBufferArrayNonUniformIndexing), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderStorageTexelBufferArrayNonUniformIndexing_allocs)

	var cdescriptorBindingUniformBufferUpdateAfterBind_allocs *cgoAllocMap
	refecbe602a.descriptorBindingUniformBufferUpdateAfterBind, cdescriptorBindingUniformBufferUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingUniformBufferUpdateAfterBind), cgoAllocsUnknown
	allocsecbe602a.Borrow(cdescriptorBindingUniformBufferUpdateAfterBind_allocs)

	var cdescriptorBindingSampledImageUpdateAfterBind_allocs *cgoAllocMap
	refecbe602a.descriptorBindingSampledImageUpdateAfterBind, cdescriptorBindingSampledImageUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingSampledImageUpdateAfterBind), cgoAllocsUnknown
	allocsecbe602a.Borrow(cdescriptorBindingSampledImageUpdateAfterBind_allocs)

	var cdescriptorBindingStorageImageUpdateAfterBind_allocs *cgoAllocMap
	refecbe602a.descriptorBindingStorageImageUpdateAfterBind, cdescriptorBindingStorageImageUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingStorageImageUpdateAfterBind), cgoAllocsUnknown
	allocsecbe602a.Borrow(cdescriptorBindingStorageImageUpdateAfterBind_allocs)

	var cdescriptorBindingStorageBufferUpdateAfterBind_allocs *cgoAllocMap
	refecbe602a.descriptorBindingStorageBufferUpdateAfterBind, cdescriptorBindingStorageBufferUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingStorageBufferUpdateAfterBind), cgoAllocsUnknown
	allocsecbe602a.Borrow(cdescriptorBindingStorageBufferUpdateAfterBind_allocs)

	var cdescriptorBindingUniformTexelBufferUpdateAfterBind_allocs *cgoAllocMap
	refecbe602a.descriptorBindingUniformTexelBufferUpdateAfterBind, cdescriptorBindingUniformTexelBufferUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingUniformTexelBufferUpdateAfterBind), cgoAllocsUnknown
	allocsecbe602a.Borrow(cdescriptorBindingUniformTexelBufferUpdateAfterBind_allocs)

	var cdescriptorBindingStorageTexelBufferUpdateAfterBind_allocs *cgoAllocMap
	refecbe602a.descriptorBindingStorageTexelBufferUpdateAfterBind, cdescriptorBindingStorageTexelBufferUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingStorageTexelBufferUpdateAfterBind), cgoAllocsUnknown
	allocsecbe602a.Borrow(cdescriptorBindingStorageTexelBufferUpdateAfterBind_allocs)

	var cdescriptorBindingUpdateUnusedWhilePending_allocs *cgoAllocMap
	refecbe602a.descriptorBindingUpdateUnusedWhilePending, cdescriptorBindingUpdateUnusedWhilePending_allocs = (C.VkBool32)(x.DescriptorBindingUpdateUnusedWhilePending), cgoAllocsUnknown
	allocsecbe602a.Borrow(cdescriptorBindingUpdateUnusedWhilePending_allocs)

	var cdescriptorBindingPartiallyBound_allocs *cgoAllocMap
	refecbe602a.descriptorBindingPartiallyBound, cdescriptorBindingPartiallyBound_allocs = (C.VkBool32)(x.DescriptorBindingPartiallyBound), cgoAllocsUnknown
	allocsecbe602a.Borrow(cdescriptorBindingPartiallyBound_allocs)

	var cdescriptorBindingVariableDescriptorCount_allocs *cgoAllocMap
	refecbe602a.descriptorBindingVariableDescriptorCount, cdescriptorBindingVariableDescriptorCount_allocs = (C.VkBool32)(x.DescriptorBindingVariableDescriptorCount), cgoAllocsUnknown
	allocsecbe602a.Borrow(cdescriptorBindingVariableDescriptorCount_allocs)

	var cruntimeDescriptorArray_allocs *cgoAllocMap
	refecbe602a.runtimeDescriptorArray, cruntimeDescriptorArray_allocs = (C.VkBool32)(x.RuntimeDescriptorArray), cgoAllocsUnknown
	allocsecbe602a.Borrow(cruntimeDescriptorArray_allocs)

	var csamplerFilterMinmax_allocs *cgoAllocMap
	refecbe602a.samplerFilterMinmax, csamplerFilterMinmax_allocs = (C.VkBool32)(x.SamplerFilterMinmax), cgoAllocsUnknown
	allocsecbe602a.Borrow(csamplerFilterMinmax_allocs)

	var cscalarBlockLayout_allocs *cgoAllocMap
	refecbe602a.scalarBlockLayout, cscalarBlockLayout_allocs = (C.VkBool32)(x.ScalarBlockLayout), cgoAllocsUnknown
	allocsecbe602a.Borrow(cscalarBlockLayout_allocs)

	var cimagelessFramebuffer_allocs *cgoAllocMap
	refecbe602a.imagelessFramebuffer, cimagelessFramebuffer_allocs = (C.VkBool32)(x.ImagelessFramebuffer), cgoAllocsUnknown
	allocsecbe602a.Borrow(cimagelessFramebuffer_allocs)

	var cuniformBufferStandardLayout_allocs *cgoAllocMap
	refecbe602a.uniformBufferStandardLayout, cuniformBufferStandardLayout_allocs = (C.VkBool32)(x.UniformBufferStandardLayout), cgoAllocsUnknown
	allocsecbe602a.Borrow(cuniformBufferStandardLayout_allocs)

	var cshaderSubgroupExtendedTypes_allocs *cgoAllocMap
	refecbe602a.shaderSubgroupExtendedTypes, cshaderSubgroupExtendedTypes_allocs = (C.VkBool32)(x.ShaderSubgroupExtendedTypes), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderSubgroupExtendedTypes_allocs)

	var cseparateDepthStencilLayouts_allocs *cgoAllocMap
	refecbe602a.separateDepthStencilLayouts, cseparateDepthStencilLayouts_allocs = (C.VkBool32)(x.SeparateDepthStencilLayouts), cgoAllocsUnknown
	allocsecbe602a.Borrow(cseparateDepthStencilLayouts_allocs)

	var chostQueryReset_allocs *cgoAllocMap
	refecbe602a.hostQueryReset, chostQueryReset_allocs = (C.VkBool32)(x.HostQueryReset), cgoAllocsUnknown
	allocsecbe602a.Borrow(chostQueryReset_allocs)

	var ctimelineSemaphore_allocs *cgoAllocMap
	refecbe602a.timelineSemaphore, ctimelineSemaphore_allocs = (C.VkBool32)(x.TimelineSemaphore), cgoAllocsUnknown
	allocsecbe602a.Borrow(ctimelineSemaphore_allocs)

	var cbufferDeviceAddress_allocs *cgoAllocMap
	refecbe602a.bufferDeviceAddress, cbufferDeviceAddress_allocs = (C.VkBool32)(x.BufferDeviceAddress), cgoAllocsUnknown
	allocsecbe602a.Borrow(cbufferDeviceAddress_allocs)

	var cbufferDeviceAddressCaptureReplay_allocs *cgoAllocMap
	refecbe602a.bufferDeviceAddressCaptureReplay, cbufferDeviceAddressCaptureReplay_allocs = (C.VkBool32)(x.BufferDeviceAddressCaptureReplay), cgoAllocsUnknown
	allocsecbe602a.Borrow(cbufferDeviceAddressCaptureReplay_allocs)

	var cbufferDeviceAddressMultiDevice_allocs *cgoAllocMap
	refecbe602a.bufferDeviceAddressMultiDevice, cbufferDeviceAddressMultiDevice_allocs = (C.VkBool32)(x.BufferDeviceAddressMultiDevice), cgoAllocsUnknown
	allocsecbe602a.Borrow(cbufferDeviceAddressMultiDevice_allocs)

	var cvulkanMemoryModel_allocs *cgoAllocMap
	refecbe602a.vulkanMemoryModel, cvulkanMemoryModel_allocs = (C.VkBool32)(x.VulkanMemoryModel), cgoAllocsUnknown
	allocsecbe602a.Borrow(cvulkanMemoryModel_allocs)

	var cvulkanMemoryModelDeviceScope_allocs *cgoAllocMap
	refecbe602a.vulkanMemoryModelDeviceScope, cvulkanMemoryModelDeviceScope_allocs = (C.VkBool32)(x.VulkanMemoryModelDeviceScope), cgoAllocsUnknown
	allocsecbe602a.Borrow(cvulkanMemoryModelDeviceScope_allocs)

	var cvulkanMemoryModelAvailabilityVisibilityChains_allocs *cgoAllocMap
	refecbe602a.vulkanMemoryModelAvailabilityVisibilityChains, cvulkanMemoryModelAvailabilityVisibilityChains_allocs = (C.VkBool32)(x.VulkanMemoryModelAvailabilityVisibilityChains), cgoAllocsUnknown
	allocsecbe602a.Borrow(cvulkanMemoryModelAvailabilityVisibilityChains_allocs)

	var cshaderOutputViewportIndex_allocs *cgoAllocMap
	refecbe602a.shaderOutputViewportIndex, cshaderOutputViewportIndex_allocs = (C.VkBool32)(x.ShaderOutputViewportIndex), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderOutputViewportIndex_allocs)

	var cshaderOutputLayer_allocs *cgoAllocMap
	refecbe602a.shaderOutputLayer, cshaderOutputLayer_allocs = (C.VkBool32)(x.ShaderOutputLayer), cgoAllocsUnknown
	allocsecbe602a.Borrow(cshaderOutputLayer_allocs)

	var csubgroupBroadcastDynamicId_allocs *cgoAllocMap
	refecbe602a.subgroupBroadcastDynamicId, csubgroupBroadcastDynamicId_allocs = (C.VkBool32)(x.SubgroupBroadcastDynamicId), cgoAllocsUnknown
	allocsecbe602a.Borrow(csubgroupBroadcastDynamicId_allocs)

	x.refecbe602a = refecbe602a
	x.allocsecbe602a = allocsecbe602a
	return refecbe602a, allocsecbe602a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVulkan12Features) PassValue() (C.VkPhysicalDeviceVulkan12Features, *cgoAllocMap) {
	if x.refecbe602a != nil {
		return *x.refecbe602a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVulkan12Features) Deref() {
	if x.refecbe602a == nil {
		return
	}
	x.SType = (StructureType)(x.refecbe602a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refecbe602a.pNext))
	x.SamplerMirrorClampToEdge = (Bool32)(x.refecbe602a.samplerMirrorClampToEdge)
	x.DrawIndirectCount = (Bool32)(x.refecbe602a.drawIndirectCount)
	x.StorageBuffer8BitAccess = (Bool32)(x.refecbe602a.storageBuffer8BitAccess)
	x.UniformAndStorageBuffer8BitAccess = (Bool32)(x.refecbe602a.uniformAndStorageBuffer8BitAccess)
	x.StoragePushConstant8 = (Bool32)(x.refecbe602a.storagePushConstant8)
	x.ShaderBufferInt64Atomics = (Bool32)(x.refecbe602a.shaderBufferInt64Atomics)
	x.ShaderSharedInt64Atomics = (Bool32)(x.refecbe602a.shaderSharedInt64Atomics)
	x.ShaderFloat16 = (Bool32)(x.refecbe602a.shaderFloat16)
	x.ShaderInt8 = (Bool32)(x.refecbe602a.shaderInt8)
	x.DescriptorIndexing = (Bool32)(x.refecbe602a.descriptorIndexing)
	x.ShaderInputAttachmentArrayDynamicIndexing = (Bool32)(x.refecbe602a.shaderInputAttachmentArrayDynamicIndexing)
	x.ShaderUniformTexelBufferArrayDynamicIndexing = (Bool32)(x.refecbe602a.shaderUniformTexelBufferArrayDynamicIndexing)
	x.ShaderStorageTexelBufferArrayDynamicIndexing = (Bool32)(x.refecbe602a.shaderStorageTexelBufferArrayDynamicIndexing)
	x.ShaderUniformBufferArrayNonUniformIndexing = (Bool32)(x.refecbe602a.shaderUniformBufferArrayNonUniformIndexing)
	x.ShaderSampledImageArrayNonUniformIndexing = (Bool32)(x.refecbe602a.shaderSampledImageArrayNonUniformIndexing)
	x.ShaderStorageBufferArrayNonUniformIndexing = (Bool32)(x.refecbe602a.shaderStorageBufferArrayNonUniformIndexing)
	x.ShaderStorageImageArrayNonUniformIndexing = (Bool32)(x.refecbe602a.shaderStorageImageArrayNonUniformIndexing)
	x.ShaderInputAttachmentArrayNonUniformIndexing = (Bool32)(x.refecbe602a.shaderInputAttachmentArrayNonUniformIndexing)
	x.ShaderUniformTexelBufferArrayNonUniformIndexing = (Bool32)(x.refecbe602a.shaderUniformTexelBufferArrayNonUniformIndexing)
	x.ShaderStorageTexelBufferArrayNonUniformIndexing = (Bool32)(x.refecbe602a.shaderStorageTexelBufferArrayNonUniformIndexing)
	x.DescriptorBindingUniformBufferUpdateAfterBind = (Bool32)(x.refecbe602a.descriptorBindingUniformBufferUpdateAfterBind)
	x.DescriptorBindingSampledImageUpdateAfterBind = (Bool32)(x.refecbe602a.descriptorBindingSampledImageUpdateAfterBind)
	x.DescriptorBindingStorageImageUpdateAfterBind = (Bool32)(x.refecbe602a.descriptorBindingStorageImageUpdateAfterBind)
	x.DescriptorBindingStorageBufferUpdateAfterBind = (Bool32)(x.refecbe602a.descriptorBindingStorageBufferUpdateAfterBind)
	x.DescriptorBindingUniformTexelBufferUpdateAfterBind = (Bool32)(x.refecbe602a.descriptorBindingUniformTexelBufferUpdateAfterBind)
	x.DescriptorBindingStorageTexelBufferUpdateAfterBind = (Bool32)(x.refecbe602a.descriptorBindingStorageTexelBufferUpdateAfterBind)
	x.DescriptorBindingUpdateUnusedWhilePending = (Bool32)(x.refecbe602a.descriptorBindingUpdateUnusedWhilePending)
	x.DescriptorBindingPartiallyBound = (Bool32)(x.refecbe602a.descriptorBindingPartiallyBound)
	x.DescriptorBindingVariableDescriptorCount = (Bool32)(x.refecbe602a.descriptorBindingVariableDescriptorCount)
	x.RuntimeDescriptorArray = (Bool32)(x.refecbe602a.runtimeDescriptorArray)
	x.SamplerFilterMinmax = (Bool32)(x.refecbe602a.samplerFilterMinmax)
	x.ScalarBlockLayout = (Bool32)(x.refecbe602a.scalarBlockLayout)
	x.ImagelessFramebuffer = (Bool32)(x.refecbe602a.imagelessFramebuffer)
	x.UniformBufferStandardLayout = (Bool32)(x.refecbe602a.uniformBufferStandardLayout)
	x.ShaderSubgroupExtendedTypes = (Bool32)(x.refecbe602a.shaderSubgroupExtendedTypes)
	x.SeparateDepthStencilLayouts = (Bool32)(x.refecbe602a.separateDepthStencilLayouts)
	x.HostQueryReset = (Bool32)(x.refecbe602a.hostQueryReset)
	x.TimelineSemaphore = (Bool32)(x.refecbe602a.timelineSemaphore)
	x.BufferDeviceAddress = (Bool32)(x.refecbe602a.bufferDeviceAddress)
	x.BufferDeviceAddressCaptureReplay = (Bool32)(x.refecbe602a.bufferDeviceAddressCaptureReplay)
	x.BufferDeviceAddressMultiDevice = (Bool32)(x.refecbe602a.bufferDeviceAddressMultiDevice)
	x.VulkanMemoryModel = (Bool32)(x.refecbe602a.vulkanMemoryModel)
	x.VulkanMemoryModelDeviceScope = (Bool32)(x.refecbe602a.vulkanMemoryModelDeviceScope)
	x.VulkanMemoryModelAvailabilityVisibilityChains = (Bool32)(x.refecbe602a.vulkanMemoryModelAvailabilityVisibilityChains)
	x.ShaderOutputViewportIndex = (Bool32)(x.refecbe602a.shaderOutputViewportIndex)
	x.ShaderOutputLayer = (Bool32)(x.refecbe602a.shaderOutputLayer)
	x.SubgroupBroadcastDynamicId = (Bool32)(x.refecbe602a.subgroupBroadcastDynamicId)
}

// allocConformanceVersionMemory allocates memory for type C.VkConformanceVersion in C.
// The caller is responsible for freeing the this memory via C.free.
func allocConformanceVersionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfConformanceVersionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfConformanceVersionValue = unsafe.Sizeof([1]C.VkConformanceVersion{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConformanceVersion) Ref() *C.VkConformanceVersion {
	if x == nil {
		return nil
	}
	return x.reffb98ebcd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConformanceVersion) Free() {
	if x != nil && x.allocsfb98ebcd != nil {
		x.allocsfb98ebcd.(*cgoAllocMap).Free()
		x.reffb98ebcd = nil
	}
}

// NewConformanceVersionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConformanceVersionRef(ref unsafe.Pointer) *ConformanceVersion {
	if ref == nil {
		return nil
	}
	obj := new(ConformanceVersion)
	obj.reffb98ebcd = (*C.VkConformanceVersion)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConformanceVersion) PassRef() (*C.VkConformanceVersion, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffb98ebcd != nil {
		return x.reffb98ebcd, nil
	}
	memfb98ebcd := allocConformanceVersionMemory(1)
	reffb98ebcd := (*C.VkConformanceVersion)(memfb98ebcd)
	allocsfb98ebcd := new(cgoAllocMap)
	allocsfb98ebcd.Add(memfb98ebcd)

	var cmajor_allocs *cgoAllocMap
	reffb98ebcd.major, cmajor_allocs = (C.uint8_t)(x.Major), cgoAllocsUnknown
	allocsfb98ebcd.Borrow(cmajor_allocs)

	var cminor_allocs *cgoAllocMap
	reffb98ebcd.minor, cminor_allocs = (C.uint8_t)(x.Minor), cgoAllocsUnknown
	allocsfb98ebcd.Borrow(cminor_allocs)

	var csubminor_allocs *cgoAllocMap
	reffb98ebcd.subminor, csubminor_allocs = (C.uint8_t)(x.Subminor), cgoAllocsUnknown
	allocsfb98ebcd.Borrow(csubminor_allocs)

	var cpatch_allocs *cgoAllocMap
	reffb98ebcd.patch, cpatch_allocs = (C.uint8_t)(x.Patch), cgoAllocsUnknown
	allocsfb98ebcd.Borrow(cpatch_allocs)

	x.reffb98ebcd = reffb98ebcd
	x.allocsfb98ebcd = allocsfb98ebcd
	return reffb98ebcd, allocsfb98ebcd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConformanceVersion) PassValue() (C.VkConformanceVersion, *cgoAllocMap) {
	if x.reffb98ebcd != nil {
		return *x.reffb98ebcd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConformanceVersion) Deref() {
	if x.reffb98ebcd == nil {
		return
	}
	x.Major = (byte)(x.reffb98ebcd.major)
	x.Minor = (byte)(x.reffb98ebcd.minor)
	x.Subminor = (byte)(x.reffb98ebcd.subminor)
	x.Patch = (byte)(x.reffb98ebcd.patch)
}

// allocPhysicalDeviceVulkan12PropertiesMemory allocates memory for type C.VkPhysicalDeviceVulkan12Properties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVulkan12PropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVulkan12PropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceVulkan12PropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVulkan12Properties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVulkan12Properties) Ref() *C.VkPhysicalDeviceVulkan12Properties {
	if x == nil {
		return nil
	}
	return x.ref4b9010a4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVulkan12Properties) Free() {
	if x != nil && x.allocs4b9010a4 != nil {
		x.allocs4b9010a4.(*cgoAllocMap).Free()
		x.ref4b9010a4 = nil
	}
}

// NewPhysicalDeviceVulkan12PropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVulkan12PropertiesRef(ref unsafe.Pointer) *PhysicalDeviceVulkan12Properties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVulkan12Properties)
	obj.ref4b9010a4 = (*C.VkPhysicalDeviceVulkan12Properties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVulkan12Properties) PassRef() (*C.VkPhysicalDeviceVulkan12Properties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b9010a4 != nil {
		return x.ref4b9010a4, nil
	}
	mem4b9010a4 := allocPhysicalDeviceVulkan12PropertiesMemory(1)
	ref4b9010a4 := (*C.VkPhysicalDeviceVulkan12Properties)(mem4b9010a4)
	allocs4b9010a4 := new(cgoAllocMap)
	allocs4b9010a4.Add(mem4b9010a4)

	var csType_allocs *cgoAllocMap
	ref4b9010a4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4b9010a4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4b9010a4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cpNext_allocs)

	var cdriverID_allocs *cgoAllocMap
	ref4b9010a4.driverID, cdriverID_allocs = (C.VkDriverId)(x.DriverID), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cdriverID_allocs)

	var cdriverName_allocs *cgoAllocMap
	ref4b9010a4.driverName, cdriverName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.DriverName)), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cdriverName_allocs)

	var cdriverInfo_allocs *cgoAllocMap
	ref4b9010a4.driverInfo, cdriverInfo_allocs = *(*[256]C.char)(unsafe.Pointer(&x.DriverInfo)), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cdriverInfo_allocs)

	var cconformanceVersion_allocs *cgoAllocMap
	ref4b9010a4.conformanceVersion, cconformanceVersion_allocs = x.ConformanceVersion.PassValue()
	allocs4b9010a4.Borrow(cconformanceVersion_allocs)

	var cdenormBehaviorIndependence_allocs *cgoAllocMap
	ref4b9010a4.denormBehaviorIndependence, cdenormBehaviorIndependence_allocs = (C.VkShaderFloatControlsIndependence)(x.DenormBehaviorIndependence), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cdenormBehaviorIndependence_allocs)

	var croundingModeIndependence_allocs *cgoAllocMap
	ref4b9010a4.roundingModeIndependence, croundingModeIndependence_allocs = (C.VkShaderFloatControlsIndependence)(x.RoundingModeIndependence), cgoAllocsUnknown
	allocs4b9010a4.Borrow(croundingModeIndependence_allocs)

	var cshaderSignedZeroInfNanPreserveFloat16_allocs *cgoAllocMap
	ref4b9010a4.shaderSignedZeroInfNanPreserveFloat16, cshaderSignedZeroInfNanPreserveFloat16_allocs = (C.VkBool32)(x.ShaderSignedZeroInfNanPreserveFloat16), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderSignedZeroInfNanPreserveFloat16_allocs)

	var cshaderSignedZeroInfNanPreserveFloat32_allocs *cgoAllocMap
	ref4b9010a4.shaderSignedZeroInfNanPreserveFloat32, cshaderSignedZeroInfNanPreserveFloat32_allocs = (C.VkBool32)(x.ShaderSignedZeroInfNanPreserveFloat32), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderSignedZeroInfNanPreserveFloat32_allocs)

	var cshaderSignedZeroInfNanPreserveFloat64_allocs *cgoAllocMap
	ref4b9010a4.shaderSignedZeroInfNanPreserveFloat64, cshaderSignedZeroInfNanPreserveFloat64_allocs = (C.VkBool32)(x.ShaderSignedZeroInfNanPreserveFloat64), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderSignedZeroInfNanPreserveFloat64_allocs)

	var cshaderDenormPreserveFloat16_allocs *cgoAllocMap
	ref4b9010a4.shaderDenormPreserveFloat16, cshaderDenormPreserveFloat16_allocs = (C.VkBool32)(x.ShaderDenormPreserveFloat16), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderDenormPreserveFloat16_allocs)

	var cshaderDenormPreserveFloat32_allocs *cgoAllocMap
	ref4b9010a4.shaderDenormPreserveFloat32, cshaderDenormPreserveFloat32_allocs = (C.VkBool32)(x.ShaderDenormPreserveFloat32), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderDenormPreserveFloat32_allocs)

	var cshaderDenormPreserveFloat64_allocs *cgoAllocMap
	ref4b9010a4.shaderDenormPreserveFloat64, cshaderDenormPreserveFloat64_allocs = (C.VkBool32)(x.ShaderDenormPreserveFloat64), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderDenormPreserveFloat64_allocs)

	var cshaderDenormFlushToZeroFloat16_allocs *cgoAllocMap
	ref4b9010a4.shaderDenormFlushToZeroFloat16, cshaderDenormFlushToZeroFloat16_allocs = (C.VkBool32)(x.ShaderDenormFlushToZeroFloat16), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderDenormFlushToZeroFloat16_allocs)

	var cshaderDenormFlushToZeroFloat32_allocs *cgoAllocMap
	ref4b9010a4.shaderDenormFlushToZeroFloat32, cshaderDenormFlushToZeroFloat32_allocs = (C.VkBool32)(x.ShaderDenormFlushToZeroFloat32), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderDenormFlushToZeroFloat32_allocs)

	var cshaderDenormFlushToZeroFloat64_allocs *cgoAllocMap
	ref4b9010a4.shaderDenormFlushToZeroFloat64, cshaderDenormFlushToZeroFloat64_allocs = (C.VkBool32)(x.ShaderDenormFlushToZeroFloat64), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderDenormFlushToZeroFloat64_allocs)

	var cshaderRoundingModeRTEFloat16_allocs *cgoAllocMap
	ref4b9010a4.shaderRoundingModeRTEFloat16, cshaderRoundingModeRTEFloat16_allocs = (C.VkBool32)(x.ShaderRoundingModeRTEFloat16), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderRoundingModeRTEFloat16_allocs)

	var cshaderRoundingModeRTEFloat32_allocs *cgoAllocMap
	ref4b9010a4.shaderRoundingModeRTEFloat32, cshaderRoundingModeRTEFloat32_allocs = (C.VkBool32)(x.ShaderRoundingModeRTEFloat32), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderRoundingModeRTEFloat32_allocs)

	var cshaderRoundingModeRTEFloat64_allocs *cgoAllocMap
	ref4b9010a4.shaderRoundingModeRTEFloat64, cshaderRoundingModeRTEFloat64_allocs = (C.VkBool32)(x.ShaderRoundingModeRTEFloat64), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderRoundingModeRTEFloat64_allocs)

	var cshaderRoundingModeRTZFloat16_allocs *cgoAllocMap
	ref4b9010a4.shaderRoundingModeRTZFloat16, cshaderRoundingModeRTZFloat16_allocs = (C.VkBool32)(x.ShaderRoundingModeRTZFloat16), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderRoundingModeRTZFloat16_allocs)

	var cshaderRoundingModeRTZFloat32_allocs *cgoAllocMap
	ref4b9010a4.shaderRoundingModeRTZFloat32, cshaderRoundingModeRTZFloat32_allocs = (C.VkBool32)(x.ShaderRoundingModeRTZFloat32), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderRoundingModeRTZFloat32_allocs)

	var cshaderRoundingModeRTZFloat64_allocs *cgoAllocMap
	ref4b9010a4.shaderRoundingModeRTZFloat64, cshaderRoundingModeRTZFloat64_allocs = (C.VkBool32)(x.ShaderRoundingModeRTZFloat64), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderRoundingModeRTZFloat64_allocs)

	var cmaxUpdateAfterBindDescriptorsInAllPools_allocs *cgoAllocMap
	ref4b9010a4.maxUpdateAfterBindDescriptorsInAllPools, cmaxUpdateAfterBindDescriptorsInAllPools_allocs = (C.uint32_t)(x.MaxUpdateAfterBindDescriptorsInAllPools), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxUpdateAfterBindDescriptorsInAllPools_allocs)

	var cshaderUniformBufferArrayNonUniformIndexingNative_allocs *cgoAllocMap
	ref4b9010a4.shaderUniformBufferArrayNonUniformIndexingNative, cshaderUniformBufferArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderUniformBufferArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderUniformBufferArrayNonUniformIndexingNative_allocs)

	var cshaderSampledImageArrayNonUniformIndexingNative_allocs *cgoAllocMap
	ref4b9010a4.shaderSampledImageArrayNonUniformIndexingNative, cshaderSampledImageArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderSampledImageArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderSampledImageArrayNonUniformIndexingNative_allocs)

	var cshaderStorageBufferArrayNonUniformIndexingNative_allocs *cgoAllocMap
	ref4b9010a4.shaderStorageBufferArrayNonUniformIndexingNative, cshaderStorageBufferArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderStorageBufferArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderStorageBufferArrayNonUniformIndexingNative_allocs)

	var cshaderStorageImageArrayNonUniformIndexingNative_allocs *cgoAllocMap
	ref4b9010a4.shaderStorageImageArrayNonUniformIndexingNative, cshaderStorageImageArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderStorageImageArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderStorageImageArrayNonUniformIndexingNative_allocs)

	var cshaderInputAttachmentArrayNonUniformIndexingNative_allocs *cgoAllocMap
	ref4b9010a4.shaderInputAttachmentArrayNonUniformIndexingNative, cshaderInputAttachmentArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderInputAttachmentArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cshaderInputAttachmentArrayNonUniformIndexingNative_allocs)

	var crobustBufferAccessUpdateAfterBind_allocs *cgoAllocMap
	ref4b9010a4.robustBufferAccessUpdateAfterBind, crobustBufferAccessUpdateAfterBind_allocs = (C.VkBool32)(x.RobustBufferAccessUpdateAfterBind), cgoAllocsUnknown
	allocs4b9010a4.Borrow(crobustBufferAccessUpdateAfterBind_allocs)

	var cquadDivergentImplicitLod_allocs *cgoAllocMap
	ref4b9010a4.quadDivergentImplicitLod, cquadDivergentImplicitLod_allocs = (C.VkBool32)(x.QuadDivergentImplicitLod), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cquadDivergentImplicitLod_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindSamplers_allocs *cgoAllocMap
	ref4b9010a4.maxPerStageDescriptorUpdateAfterBindSamplers, cmaxPerStageDescriptorUpdateAfterBindSamplers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindSamplers), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxPerStageDescriptorUpdateAfterBindSamplers_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindUniformBuffers_allocs *cgoAllocMap
	ref4b9010a4.maxPerStageDescriptorUpdateAfterBindUniformBuffers, cmaxPerStageDescriptorUpdateAfterBindUniformBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindUniformBuffers), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxPerStageDescriptorUpdateAfterBindUniformBuffers_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindStorageBuffers_allocs *cgoAllocMap
	ref4b9010a4.maxPerStageDescriptorUpdateAfterBindStorageBuffers, cmaxPerStageDescriptorUpdateAfterBindStorageBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindStorageBuffers), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxPerStageDescriptorUpdateAfterBindStorageBuffers_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindSampledImages_allocs *cgoAllocMap
	ref4b9010a4.maxPerStageDescriptorUpdateAfterBindSampledImages, cmaxPerStageDescriptorUpdateAfterBindSampledImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindSampledImages), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxPerStageDescriptorUpdateAfterBindSampledImages_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindStorageImages_allocs *cgoAllocMap
	ref4b9010a4.maxPerStageDescriptorUpdateAfterBindStorageImages, cmaxPerStageDescriptorUpdateAfterBindStorageImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindStorageImages), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxPerStageDescriptorUpdateAfterBindStorageImages_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindInputAttachments_allocs *cgoAllocMap
	ref4b9010a4.maxPerStageDescriptorUpdateAfterBindInputAttachments, cmaxPerStageDescriptorUpdateAfterBindInputAttachments_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindInputAttachments), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxPerStageDescriptorUpdateAfterBindInputAttachments_allocs)

	var cmaxPerStageUpdateAfterBindResources_allocs *cgoAllocMap
	ref4b9010a4.maxPerStageUpdateAfterBindResources, cmaxPerStageUpdateAfterBindResources_allocs = (C.uint32_t)(x.MaxPerStageUpdateAfterBindResources), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxPerStageUpdateAfterBindResources_allocs)

	var cmaxDescriptorSetUpdateAfterBindSamplers_allocs *cgoAllocMap
	ref4b9010a4.maxDescriptorSetUpdateAfterBindSamplers, cmaxDescriptorSetUpdateAfterBindSamplers_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindSamplers), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxDescriptorSetUpdateAfterBindSamplers_allocs)

	var cmaxDescriptorSetUpdateAfterBindUniformBuffers_allocs *cgoAllocMap
	ref4b9010a4.maxDescriptorSetUpdateAfterBindUniformBuffers, cmaxDescriptorSetUpdateAfterBindUniformBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindUniformBuffers), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxDescriptorSetUpdateAfterBindUniformBuffers_allocs)

	var cmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic_allocs *cgoAllocMap
	ref4b9010a4.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, cmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic_allocs)

	var cmaxDescriptorSetUpdateAfterBindStorageBuffers_allocs *cgoAllocMap
	ref4b9010a4.maxDescriptorSetUpdateAfterBindStorageBuffers, cmaxDescriptorSetUpdateAfterBindStorageBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindStorageBuffers), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxDescriptorSetUpdateAfterBindStorageBuffers_allocs)

	var cmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic_allocs *cgoAllocMap
	ref4b9010a4.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, cmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic_allocs)

	var cmaxDescriptorSetUpdateAfterBindSampledImages_allocs *cgoAllocMap
	ref4b9010a4.maxDescriptorSetUpdateAfterBindSampledImages, cmaxDescriptorSetUpdateAfterBindSampledImages_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindSampledImages), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxDescriptorSetUpdateAfterBindSampledImages_allocs)

	var cmaxDescriptorSetUpdateAfterBindStorageImages_allocs *cgoAllocMap
	ref4b9010a4.maxDescriptorSetUpdateAfterBindStorageImages, cmaxDescriptorSetUpdateAfterBindStorageImages_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindStorageImages), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxDescriptorSetUpdateAfterBindStorageImages_allocs)

	var cmaxDescriptorSetUpdateAfterBindInputAttachments_allocs *cgoAllocMap
	ref4b9010a4.maxDescriptorSetUpdateAfterBindInputAttachments, cmaxDescriptorSetUpdateAfterBindInputAttachments_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindInputAttachments), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxDescriptorSetUpdateAfterBindInputAttachments_allocs)

	var csupportedDepthResolveModes_allocs *cgoAllocMap
	ref4b9010a4.supportedDepthResolveModes, csupportedDepthResolveModes_allocs = (C.VkResolveModeFlags)(x.SupportedDepthResolveModes), cgoAllocsUnknown
	allocs4b9010a4.Borrow(csupportedDepthResolveModes_allocs)

	var csupportedStencilResolveModes_allocs *cgoAllocMap
	ref4b9010a4.supportedStencilResolveModes, csupportedStencilResolveModes_allocs = (C.VkResolveModeFlags)(x.SupportedStencilResolveModes), cgoAllocsUnknown
	allocs4b9010a4.Borrow(csupportedStencilResolveModes_allocs)

	var cindependentResolveNone_allocs *cgoAllocMap
	ref4b9010a4.independentResolveNone, cindependentResolveNone_allocs = (C.VkBool32)(x.IndependentResolveNone), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cindependentResolveNone_allocs)

	var cindependentResolve_allocs *cgoAllocMap
	ref4b9010a4.independentResolve, cindependentResolve_allocs = (C.VkBool32)(x.IndependentResolve), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cindependentResolve_allocs)

	var cfilterMinmaxSingleComponentFormats_allocs *cgoAllocMap
	ref4b9010a4.filterMinmaxSingleComponentFormats, cfilterMinmaxSingleComponentFormats_allocs = (C.VkBool32)(x.FilterMinmaxSingleComponentFormats), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cfilterMinmaxSingleComponentFormats_allocs)

	var cfilterMinmaxImageComponentMapping_allocs *cgoAllocMap
	ref4b9010a4.filterMinmaxImageComponentMapping, cfilterMinmaxImageComponentMapping_allocs = (C.VkBool32)(x.FilterMinmaxImageComponentMapping), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cfilterMinmaxImageComponentMapping_allocs)

	var cmaxTimelineSemaphoreValueDifference_allocs *cgoAllocMap
	ref4b9010a4.maxTimelineSemaphoreValueDifference, cmaxTimelineSemaphoreValueDifference_allocs = (C.uint64_t)(x.MaxTimelineSemaphoreValueDifference), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cmaxTimelineSemaphoreValueDifference_allocs)

	var cframebufferIntegerColorSampleCounts_allocs *cgoAllocMap
	ref4b9010a4.framebufferIntegerColorSampleCounts, cframebufferIntegerColorSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferIntegerColorSampleCounts), cgoAllocsUnknown
	allocs4b9010a4.Borrow(cframebufferIntegerColorSampleCounts_allocs)

	x.ref4b9010a4 = ref4b9010a4
	x.allocs4b9010a4 = allocs4b9010a4
	return ref4b9010a4, allocs4b9010a4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVulkan12Properties) PassValue() (C.VkPhysicalDeviceVulkan12Properties, *cgoAllocMap) {
	if x.ref4b9010a4 != nil {
		return *x.ref4b9010a4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVulkan12Properties) Deref() {
	if x.ref4b9010a4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref4b9010a4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4b9010a4.pNext))
	x.DriverID = (DriverId)(x.ref4b9010a4.driverID)
	x.DriverName = *(*[256]byte)(unsafe.Pointer(&x.ref4b9010a4.driverName))
	x.DriverInfo = *(*[256]byte)(unsafe.Pointer(&x.ref4b9010a4.driverInfo))
	x.ConformanceVersion = *NewConformanceVersionRef(unsafe.Pointer(&x.ref4b9010a4.conformanceVersion))
	x.DenormBehaviorIndependence = (ShaderFloatControlsIndependence)(x.ref4b9010a4.denormBehaviorIndependence)
	x.RoundingModeIndependence = (ShaderFloatControlsIndependence)(x.ref4b9010a4.roundingModeIndependence)
	x.ShaderSignedZeroInfNanPreserveFloat16 = (Bool32)(x.ref4b9010a4.shaderSignedZeroInfNanPreserveFloat16)
	x.ShaderSignedZeroInfNanPreserveFloat32 = (Bool32)(x.ref4b9010a4.shaderSignedZeroInfNanPreserveFloat32)
	x.ShaderSignedZeroInfNanPreserveFloat64 = (Bool32)(x.ref4b9010a4.shaderSignedZeroInfNanPreserveFloat64)
	x.ShaderDenormPreserveFloat16 = (Bool32)(x.ref4b9010a4.shaderDenormPreserveFloat16)
	x.ShaderDenormPreserveFloat32 = (Bool32)(x.ref4b9010a4.shaderDenormPreserveFloat32)
	x.ShaderDenormPreserveFloat64 = (Bool32)(x.ref4b9010a4.shaderDenormPreserveFloat64)
	x.ShaderDenormFlushToZeroFloat16 = (Bool32)(x.ref4b9010a4.shaderDenormFlushToZeroFloat16)
	x.ShaderDenormFlushToZeroFloat32 = (Bool32)(x.ref4b9010a4.shaderDenormFlushToZeroFloat32)
	x.ShaderDenormFlushToZeroFloat64 = (Bool32)(x.ref4b9010a4.shaderDenormFlushToZeroFloat64)
	x.ShaderRoundingModeRTEFloat16 = (Bool32)(x.ref4b9010a4.shaderRoundingModeRTEFloat16)
	x.ShaderRoundingModeRTEFloat32 = (Bool32)(x.ref4b9010a4.shaderRoundingModeRTEFloat32)
	x.ShaderRoundingModeRTEFloat64 = (Bool32)(x.ref4b9010a4.shaderRoundingModeRTEFloat64)
	x.ShaderRoundingModeRTZFloat16 = (Bool32)(x.ref4b9010a4.shaderRoundingModeRTZFloat16)
	x.ShaderRoundingModeRTZFloat32 = (Bool32)(x.ref4b9010a4.shaderRoundingModeRTZFloat32)
	x.ShaderRoundingModeRTZFloat64 = (Bool32)(x.ref4b9010a4.shaderRoundingModeRTZFloat64)
	x.MaxUpdateAfterBindDescriptorsInAllPools = (uint32)(x.ref4b9010a4.maxUpdateAfterBindDescriptorsInAllPools)
	x.ShaderUniformBufferArrayNonUniformIndexingNative = (Bool32)(x.ref4b9010a4.shaderUniformBufferArrayNonUniformIndexingNative)
	x.ShaderSampledImageArrayNonUniformIndexingNative = (Bool32)(x.ref4b9010a4.shaderSampledImageArrayNonUniformIndexingNative)
	x.ShaderStorageBufferArrayNonUniformIndexingNative = (Bool32)(x.ref4b9010a4.shaderStorageBufferArrayNonUniformIndexingNative)
	x.ShaderStorageImageArrayNonUniformIndexingNative = (Bool32)(x.ref4b9010a4.shaderStorageImageArrayNonUniformIndexingNative)
	x.ShaderInputAttachmentArrayNonUniformIndexingNative = (Bool32)(x.ref4b9010a4.shaderInputAttachmentArrayNonUniformIndexingNative)
	x.RobustBufferAccessUpdateAfterBind = (Bool32)(x.ref4b9010a4.robustBufferAccessUpdateAfterBind)
	x.QuadDivergentImplicitLod = (Bool32)(x.ref4b9010a4.quadDivergentImplicitLod)
	x.MaxPerStageDescriptorUpdateAfterBindSamplers = (uint32)(x.ref4b9010a4.maxPerStageDescriptorUpdateAfterBindSamplers)
	x.MaxPerStageDescriptorUpdateAfterBindUniformBuffers = (uint32)(x.ref4b9010a4.maxPerStageDescriptorUpdateAfterBindUniformBuffers)
	x.MaxPerStageDescriptorUpdateAfterBindStorageBuffers = (uint32)(x.ref4b9010a4.maxPerStageDescriptorUpdateAfterBindStorageBuffers)
	x.MaxPerStageDescriptorUpdateAfterBindSampledImages = (uint32)(x.ref4b9010a4.maxPerStageDescriptorUpdateAfterBindSampledImages)
	x.MaxPerStageDescriptorUpdateAfterBindStorageImages = (uint32)(x.ref4b9010a4.maxPerStageDescriptorUpdateAfterBindStorageImages)
	x.MaxPerStageDescriptorUpdateAfterBindInputAttachments = (uint32)(x.ref4b9010a4.maxPerStageDescriptorUpdateAfterBindInputAttachments)
	x.MaxPerStageUpdateAfterBindResources = (uint32)(x.ref4b9010a4.maxPerStageUpdateAfterBindResources)
	x.MaxDescriptorSetUpdateAfterBindSamplers = (uint32)(x.ref4b9010a4.maxDescriptorSetUpdateAfterBindSamplers)
	x.MaxDescriptorSetUpdateAfterBindUniformBuffers = (uint32)(x.ref4b9010a4.maxDescriptorSetUpdateAfterBindUniformBuffers)
	x.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic = (uint32)(x.ref4b9010a4.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
	x.MaxDescriptorSetUpdateAfterBindStorageBuffers = (uint32)(x.ref4b9010a4.maxDescriptorSetUpdateAfterBindStorageBuffers)
	x.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic = (uint32)(x.ref4b9010a4.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
	x.MaxDescriptorSetUpdateAfterBindSampledImages = (uint32)(x.ref4b9010a4.maxDescriptorSetUpdateAfterBindSampledImages)
	x.MaxDescriptorSetUpdateAfterBindStorageImages = (uint32)(x.ref4b9010a4.maxDescriptorSetUpdateAfterBindStorageImages)
	x.MaxDescriptorSetUpdateAfterBindInputAttachments = (uint32)(x.ref4b9010a4.maxDescriptorSetUpdateAfterBindInputAttachments)
	x.SupportedDepthResolveModes = (ResolveModeFlags)(x.ref4b9010a4.supportedDepthResolveModes)
	x.SupportedStencilResolveModes = (ResolveModeFlags)(x.ref4b9010a4.supportedStencilResolveModes)
	x.IndependentResolveNone = (Bool32)(x.ref4b9010a4.independentResolveNone)
	x.IndependentResolve = (Bool32)(x.ref4b9010a4.independentResolve)
	x.FilterMinmaxSingleComponentFormats = (Bool32)(x.ref4b9010a4.filterMinmaxSingleComponentFormats)
	x.FilterMinmaxImageComponentMapping = (Bool32)(x.ref4b9010a4.filterMinmaxImageComponentMapping)
	x.MaxTimelineSemaphoreValueDifference = (uint32)(x.ref4b9010a4.maxTimelineSemaphoreValueDifference)
	x.FramebufferIntegerColorSampleCounts = (SampleCountFlags)(x.ref4b9010a4.framebufferIntegerColorSampleCounts)
}

// allocImageFormatListCreateInfoMemory allocates memory for type C.VkImageFormatListCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageFormatListCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageFormatListCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageFormatListCreateInfoValue = unsafe.Sizeof([1]C.VkImageFormatListCreateInfo{})

// copyPFormatBytes copies the data from Go slice as *C.VkFormat.
func copyPFormatBytes(slice *sliceHeader) (*C.VkFormat, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfFormatValue) * slice.Len,
		Cap:  int(sizeOfFormatValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkFormat)(mem0), allocs
}

// allocFormatMemory allocates memory for type C.VkFormat in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFormatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFormatValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFormatValue = unsafe.Sizeof([1]C.VkFormat{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageFormatListCreateInfo) Ref() *C.VkImageFormatListCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref76fdc95e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageFormatListCreateInfo) Free() {
	if x != nil && x.allocs76fdc95e != nil {
		x.allocs76fdc95e.(*cgoAllocMap).Free()
		x.ref76fdc95e = nil
	}
}

// NewImageFormatListCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageFormatListCreateInfoRef(ref unsafe.Pointer) *ImageFormatListCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageFormatListCreateInfo)
	obj.ref76fdc95e = (*C.VkImageFormatListCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageFormatListCreateInfo) PassRef() (*C.VkImageFormatListCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref76fdc95e != nil {
		return x.ref76fdc95e, nil
	}
	mem76fdc95e := allocImageFormatListCreateInfoMemory(1)
	ref76fdc95e := (*C.VkImageFormatListCreateInfo)(mem76fdc95e)
	allocs76fdc95e := new(cgoAllocMap)
	allocs76fdc95e.Add(mem76fdc95e)

	var csType_allocs *cgoAllocMap
	ref76fdc95e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs76fdc95e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref76fdc95e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs76fdc95e.Borrow(cpNext_allocs)

	var cviewFormatCount_allocs *cgoAllocMap
	ref76fdc95e.viewFormatCount, cviewFormatCount_allocs = (C.uint32_t)(x.ViewFormatCount), cgoAllocsUnknown
	allocs76fdc95e.Borrow(cviewFormatCount_allocs)

	var cpViewFormats_allocs *cgoAllocMap
	ref76fdc95e.pViewFormats, cpViewFormats_allocs = copyPFormatBytes((*sliceHeader)(unsafe.Pointer(&x.PViewFormats)))
	allocs76fdc95e.Borrow(cpViewFormats_allocs)

	x.ref76fdc95e = ref76fdc95e
	x.allocs76fdc95e = allocs76fdc95e
	return ref76fdc95e, allocs76fdc95e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageFormatListCreateInfo) PassValue() (C.VkImageFormatListCreateInfo, *cgoAllocMap) {
	if x.ref76fdc95e != nil {
		return *x.ref76fdc95e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageFormatListCreateInfo) Deref() {
	if x.ref76fdc95e == nil {
		return
	}
	x.SType = (StructureType)(x.ref76fdc95e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref76fdc95e.pNext))
	x.ViewFormatCount = (uint32)(x.ref76fdc95e.viewFormatCount)
	hxffe3496 := (*sliceHeader)(unsafe.Pointer(&x.PViewFormats))
	hxffe3496.Data = unsafe.Pointer(x.ref76fdc95e.pViewFormats)
	hxffe3496.Cap = 0x7fffffff
	// hxffe3496.Len = ?

}

// allocAttachmentDescription2Memory allocates memory for type C.VkAttachmentDescription2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentDescription2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentDescription2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAttachmentDescription2Value = unsafe.Sizeof([1]C.VkAttachmentDescription2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentDescription2) Ref() *C.VkAttachmentDescription2 {
	if x == nil {
		return nil
	}
	return x.refae7bd6bf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentDescription2) Free() {
	if x != nil && x.allocsae7bd6bf != nil {
		x.allocsae7bd6bf.(*cgoAllocMap).Free()
		x.refae7bd6bf = nil
	}
}

// NewAttachmentDescription2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentDescription2Ref(ref unsafe.Pointer) *AttachmentDescription2 {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentDescription2)
	obj.refae7bd6bf = (*C.VkAttachmentDescription2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentDescription2) PassRef() (*C.VkAttachmentDescription2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refae7bd6bf != nil {
		return x.refae7bd6bf, nil
	}
	memae7bd6bf := allocAttachmentDescription2Memory(1)
	refae7bd6bf := (*C.VkAttachmentDescription2)(memae7bd6bf)
	allocsae7bd6bf := new(cgoAllocMap)
	allocsae7bd6bf.Add(memae7bd6bf)

	var csType_allocs *cgoAllocMap
	refae7bd6bf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsae7bd6bf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refae7bd6bf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsae7bd6bf.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refae7bd6bf.flags, cflags_allocs = (C.VkAttachmentDescriptionFlags)(x.Flags), cgoAllocsUnknown
	allocsae7bd6bf.Borrow(cflags_allocs)

	var cformat_allocs *cgoAllocMap
	refae7bd6bf.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsae7bd6bf.Borrow(cformat_allocs)

	var csamples_allocs *cgoAllocMap
	refae7bd6bf.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocsae7bd6bf.Borrow(csamples_allocs)

	var cloadOp_allocs *cgoAllocMap
	refae7bd6bf.loadOp, cloadOp_allocs = (C.VkAttachmentLoadOp)(x.LoadOp), cgoAllocsUnknown
	allocsae7bd6bf.Borrow(cloadOp_allocs)

	var cstoreOp_allocs *cgoAllocMap
	refae7bd6bf.storeOp, cstoreOp_allocs = (C.VkAttachmentStoreOp)(x.StoreOp), cgoAllocsUnknown
	allocsae7bd6bf.Borrow(cstoreOp_allocs)

	var cstencilLoadOp_allocs *cgoAllocMap
	refae7bd6bf.stencilLoadOp, cstencilLoadOp_allocs = (C.VkAttachmentLoadOp)(x.StencilLoadOp), cgoAllocsUnknown
	allocsae7bd6bf.Borrow(cstencilLoadOp_allocs)

	var cstencilStoreOp_allocs *cgoAllocMap
	refae7bd6bf.stencilStoreOp, cstencilStoreOp_allocs = (C.VkAttachmentStoreOp)(x.StencilStoreOp), cgoAllocsUnknown
	allocsae7bd6bf.Borrow(cstencilStoreOp_allocs)

	var cinitialLayout_allocs *cgoAllocMap
	refae7bd6bf.initialLayout, cinitialLayout_allocs = (C.VkImageLayout)(x.InitialLayout), cgoAllocsUnknown
	allocsae7bd6bf.Borrow(cinitialLayout_allocs)

	var cfinalLayout_allocs *cgoAllocMap
	refae7bd6bf.finalLayout, cfinalLayout_allocs = (C.VkImageLayout)(x.FinalLayout), cgoAllocsUnknown
	allocsae7bd6bf.Borrow(cfinalLayout_allocs)

	x.refae7bd6bf = refae7bd6bf
	x.allocsae7bd6bf = allocsae7bd6bf
	return refae7bd6bf, allocsae7bd6bf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentDescription2) PassValue() (C.VkAttachmentDescription2, *cgoAllocMap) {
	if x.refae7bd6bf != nil {
		return *x.refae7bd6bf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentDescription2) Deref() {
	if x.refae7bd6bf == nil {
		return
	}
	x.SType = (StructureType)(x.refae7bd6bf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refae7bd6bf.pNext))
	x.Flags = (AttachmentDescriptionFlags)(x.refae7bd6bf.flags)
	x.Format = (Format)(x.refae7bd6bf.format)
	x.Samples = (SampleCountFlagBits)(x.refae7bd6bf.samples)
	x.LoadOp = (AttachmentLoadOp)(x.refae7bd6bf.loadOp)
	x.StoreOp = (AttachmentStoreOp)(x.refae7bd6bf.storeOp)
	x.StencilLoadOp = (AttachmentLoadOp)(x.refae7bd6bf.stencilLoadOp)
	x.StencilStoreOp = (AttachmentStoreOp)(x.refae7bd6bf.stencilStoreOp)
	x.InitialLayout = (ImageLayout)(x.refae7bd6bf.initialLayout)
	x.FinalLayout = (ImageLayout)(x.refae7bd6bf.finalLayout)
}

// allocAttachmentReference2Memory allocates memory for type C.VkAttachmentReference2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentReference2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentReference2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAttachmentReference2Value = unsafe.Sizeof([1]C.VkAttachmentReference2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentReference2) Ref() *C.VkAttachmentReference2 {
	if x == nil {
		return nil
	}
	return x.ref7b5106a8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentReference2) Free() {
	if x != nil && x.allocs7b5106a8 != nil {
		x.allocs7b5106a8.(*cgoAllocMap).Free()
		x.ref7b5106a8 = nil
	}
}

// NewAttachmentReference2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentReference2Ref(ref unsafe.Pointer) *AttachmentReference2 {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentReference2)
	obj.ref7b5106a8 = (*C.VkAttachmentReference2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentReference2) PassRef() (*C.VkAttachmentReference2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7b5106a8 != nil {
		return x.ref7b5106a8, nil
	}
	mem7b5106a8 := allocAttachmentReference2Memory(1)
	ref7b5106a8 := (*C.VkAttachmentReference2)(mem7b5106a8)
	allocs7b5106a8 := new(cgoAllocMap)
	allocs7b5106a8.Add(mem7b5106a8)

	var csType_allocs *cgoAllocMap
	ref7b5106a8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7b5106a8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7b5106a8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7b5106a8.Borrow(cpNext_allocs)

	var cattachment_allocs *cgoAllocMap
	ref7b5106a8.attachment, cattachment_allocs = (C.uint32_t)(x.Attachment), cgoAllocsUnknown
	allocs7b5106a8.Borrow(cattachment_allocs)

	var clayout_allocs *cgoAllocMap
	ref7b5106a8.layout, clayout_allocs = (C.VkImageLayout)(x.Layout), cgoAllocsUnknown
	allocs7b5106a8.Borrow(clayout_allocs)

	var caspectMask_allocs *cgoAllocMap
	ref7b5106a8.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs7b5106a8.Borrow(caspectMask_allocs)

	x.ref7b5106a8 = ref7b5106a8
	x.allocs7b5106a8 = allocs7b5106a8
	return ref7b5106a8, allocs7b5106a8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentReference2) PassValue() (C.VkAttachmentReference2, *cgoAllocMap) {
	if x.ref7b5106a8 != nil {
		return *x.ref7b5106a8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentReference2) Deref() {
	if x.ref7b5106a8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7b5106a8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7b5106a8.pNext))
	x.Attachment = (uint32)(x.ref7b5106a8.attachment)
	x.Layout = (ImageLayout)(x.ref7b5106a8.layout)
	x.AspectMask = (ImageAspectFlags)(x.ref7b5106a8.aspectMask)
}

// allocSubpassDescription2Memory allocates memory for type C.VkSubpassDescription2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDescription2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDescription2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubpassDescription2Value = unsafe.Sizeof([1]C.VkSubpassDescription2{})

// unpackSAttachmentReference2 transforms a sliced Go data structure into plain C format.
func unpackSAttachmentReference2(x []AttachmentReference2) (unpacked *C.VkAttachmentReference2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentReference2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentReference2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentReference2)(h.Data)
	return
}

// packSAttachmentReference2 reads sliced Go data structure out from plain C format.
func packSAttachmentReference2(v []AttachmentReference2, ptr0 *C.VkAttachmentReference2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentReference2Value]C.VkAttachmentReference2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentReference2Ref(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassDescription2) Ref() *C.VkSubpassDescription2 {
	if x == nil {
		return nil
	}
	return x.ref7cdffe39
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassDescription2) Free() {
	if x != nil && x.allocs7cdffe39 != nil {
		x.allocs7cdffe39.(*cgoAllocMap).Free()
		x.ref7cdffe39 = nil
	}
}

// NewSubpassDescription2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassDescription2Ref(ref unsafe.Pointer) *SubpassDescription2 {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDescription2)
	obj.ref7cdffe39 = (*C.VkSubpassDescription2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassDescription2) PassRef() (*C.VkSubpassDescription2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7cdffe39 != nil {
		return x.ref7cdffe39, nil
	}
	mem7cdffe39 := allocSubpassDescription2Memory(1)
	ref7cdffe39 := (*C.VkSubpassDescription2)(mem7cdffe39)
	allocs7cdffe39 := new(cgoAllocMap)
	allocs7cdffe39.Add(mem7cdffe39)

	var csType_allocs *cgoAllocMap
	ref7cdffe39.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7cdffe39.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7cdffe39.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7cdffe39.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref7cdffe39.flags, cflags_allocs = (C.VkSubpassDescriptionFlags)(x.Flags), cgoAllocsUnknown
	allocs7cdffe39.Borrow(cflags_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	ref7cdffe39.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocs7cdffe39.Borrow(cpipelineBindPoint_allocs)

	var cviewMask_allocs *cgoAllocMap
	ref7cdffe39.viewMask, cviewMask_allocs = (C.uint32_t)(x.ViewMask), cgoAllocsUnknown
	allocs7cdffe39.Borrow(cviewMask_allocs)

	var cinputAttachmentCount_allocs *cgoAllocMap
	ref7cdffe39.inputAttachmentCount, cinputAttachmentCount_allocs = (C.uint32_t)(x.InputAttachmentCount), cgoAllocsUnknown
	allocs7cdffe39.Borrow(cinputAttachmentCount_allocs)

	var cpInputAttachments_allocs *cgoAllocMap
	ref7cdffe39.pInputAttachments, cpInputAttachments_allocs = unpackSAttachmentReference2(x.PInputAttachments)
	allocs7cdffe39.Borrow(cpInputAttachments_allocs)

	var ccolorAttachmentCount_allocs *cgoAllocMap
	ref7cdffe39.colorAttachmentCount, ccolorAttachmentCount_allocs = (C.uint32_t)(x.ColorAttachmentCount), cgoAllocsUnknown
	allocs7cdffe39.Borrow(ccolorAttachmentCount_allocs)

	var cpColorAttachments_allocs *cgoAllocMap
	ref7cdffe39.pColorAttachments, cpColorAttachments_allocs = unpackSAttachmentReference2(x.PColorAttachments)
	allocs7cdffe39.Borrow(cpColorAttachments_allocs)

	var cpResolveAttachments_allocs *cgoAllocMap
	ref7cdffe39.pResolveAttachments, cpResolveAttachments_allocs = unpackSAttachmentReference2(x.PResolveAttachments)
	allocs7cdffe39.Borrow(cpResolveAttachments_allocs)

	var cpDepthStencilAttachment_allocs *cgoAllocMap
	ref7cdffe39.pDepthStencilAttachment, cpDepthStencilAttachment_allocs = unpackSAttachmentReference2(x.PDepthStencilAttachment)
	allocs7cdffe39.Borrow(cpDepthStencilAttachment_allocs)

	var cpreserveAttachmentCount_allocs *cgoAllocMap
	ref7cdffe39.preserveAttachmentCount, cpreserveAttachmentCount_allocs = (C.uint32_t)(x.PreserveAttachmentCount), cgoAllocsUnknown
	allocs7cdffe39.Borrow(cpreserveAttachmentCount_allocs)

	var cpPreserveAttachments_allocs *cgoAllocMap
	ref7cdffe39.pPreserveAttachments, cpPreserveAttachments_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments)))
	allocs7cdffe39.Borrow(cpPreserveAttachments_allocs)

	x.ref7cdffe39 = ref7cdffe39
	x.allocs7cdffe39 = allocs7cdffe39
	return ref7cdffe39, allocs7cdffe39

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassDescription2) PassValue() (C.VkSubpassDescription2, *cgoAllocMap) {
	if x.ref7cdffe39 != nil {
		return *x.ref7cdffe39, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassDescription2) Deref() {
	if x.ref7cdffe39 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7cdffe39.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7cdffe39.pNext))
	x.Flags = (SubpassDescriptionFlags)(x.ref7cdffe39.flags)
	x.PipelineBindPoint = (PipelineBindPoint)(x.ref7cdffe39.pipelineBindPoint)
	x.ViewMask = (uint32)(x.ref7cdffe39.viewMask)
	x.InputAttachmentCount = (uint32)(x.ref7cdffe39.inputAttachmentCount)
	packSAttachmentReference2(x.PInputAttachments, x.ref7cdffe39.pInputAttachments)
	x.ColorAttachmentCount = (uint32)(x.ref7cdffe39.colorAttachmentCount)
	packSAttachmentReference2(x.PColorAttachments, x.ref7cdffe39.pColorAttachments)
	packSAttachmentReference2(x.PResolveAttachments, x.ref7cdffe39.pResolveAttachments)
	packSAttachmentReference2(x.PDepthStencilAttachment, x.ref7cdffe39.pDepthStencilAttachment)
	x.PreserveAttachmentCount = (uint32)(x.ref7cdffe39.preserveAttachmentCount)
	hxf5d48a6 := (*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments))
	hxf5d48a6.Data = unsafe.Pointer(x.ref7cdffe39.pPreserveAttachments)
	hxf5d48a6.Cap = 0x7fffffff
	// hxf5d48a6.Len = ?

}

// allocSubpassDependency2Memory allocates memory for type C.VkSubpassDependency2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDependency2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDependency2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubpassDependency2Value = unsafe.Sizeof([1]C.VkSubpassDependency2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassDependency2) Ref() *C.VkSubpassDependency2 {
	if x == nil {
		return nil
	}
	return x.refb0fac2b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassDependency2) Free() {
	if x != nil && x.allocsb0fac2b != nil {
		x.allocsb0fac2b.(*cgoAllocMap).Free()
		x.refb0fac2b = nil
	}
}

// NewSubpassDependency2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassDependency2Ref(ref unsafe.Pointer) *SubpassDependency2 {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDependency2)
	obj.refb0fac2b = (*C.VkSubpassDependency2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassDependency2) PassRef() (*C.VkSubpassDependency2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0fac2b != nil {
		return x.refb0fac2b, nil
	}
	memb0fac2b := allocSubpassDependency2Memory(1)
	refb0fac2b := (*C.VkSubpassDependency2)(memb0fac2b)
	allocsb0fac2b := new(cgoAllocMap)
	allocsb0fac2b.Add(memb0fac2b)

	var csType_allocs *cgoAllocMap
	refb0fac2b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb0fac2b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb0fac2b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb0fac2b.Borrow(cpNext_allocs)

	var csrcSubpass_allocs *cgoAllocMap
	refb0fac2b.srcSubpass, csrcSubpass_allocs = (C.uint32_t)(x.SrcSubpass), cgoAllocsUnknown
	allocsb0fac2b.Borrow(csrcSubpass_allocs)

	var cdstSubpass_allocs *cgoAllocMap
	refb0fac2b.dstSubpass, cdstSubpass_allocs = (C.uint32_t)(x.DstSubpass), cgoAllocsUnknown
	allocsb0fac2b.Borrow(cdstSubpass_allocs)

	var csrcStageMask_allocs *cgoAllocMap
	refb0fac2b.srcStageMask, csrcStageMask_allocs = (C.VkPipelineStageFlags)(x.SrcStageMask), cgoAllocsUnknown
	allocsb0fac2b.Borrow(csrcStageMask_allocs)

	var cdstStageMask_allocs *cgoAllocMap
	refb0fac2b.dstStageMask, cdstStageMask_allocs = (C.VkPipelineStageFlags)(x.DstStageMask), cgoAllocsUnknown
	allocsb0fac2b.Borrow(cdstStageMask_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refb0fac2b.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocsb0fac2b.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refb0fac2b.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocsb0fac2b.Borrow(cdstAccessMask_allocs)

	var cdependencyFlags_allocs *cgoAllocMap
	refb0fac2b.dependencyFlags, cdependencyFlags_allocs = (C.VkDependencyFlags)(x.DependencyFlags), cgoAllocsUnknown
	allocsb0fac2b.Borrow(cdependencyFlags_allocs)

	var cviewOffset_allocs *cgoAllocMap
	refb0fac2b.viewOffset, cviewOffset_allocs = (C.int32_t)(x.ViewOffset), cgoAllocsUnknown
	allocsb0fac2b.Borrow(cviewOffset_allocs)

	x.refb0fac2b = refb0fac2b
	x.allocsb0fac2b = allocsb0fac2b
	return refb0fac2b, allocsb0fac2b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassDependency2) PassValue() (C.VkSubpassDependency2, *cgoAllocMap) {
	if x.refb0fac2b != nil {
		return *x.refb0fac2b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassDependency2) Deref() {
	if x.refb0fac2b == nil {
		return
	}
	x.SType = (StructureType)(x.refb0fac2b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb0fac2b.pNext))
	x.SrcSubpass = (uint32)(x.refb0fac2b.srcSubpass)
	x.DstSubpass = (uint32)(x.refb0fac2b.dstSubpass)
	x.SrcStageMask = (PipelineStageFlags)(x.refb0fac2b.srcStageMask)
	x.DstStageMask = (PipelineStageFlags)(x.refb0fac2b.dstStageMask)
	x.SrcAccessMask = (AccessFlags)(x.refb0fac2b.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refb0fac2b.dstAccessMask)
	x.DependencyFlags = (DependencyFlags)(x.refb0fac2b.dependencyFlags)
	x.ViewOffset = (int32)(x.refb0fac2b.viewOffset)
}

// allocRenderPassCreateInfo2Memory allocates memory for type C.VkRenderPassCreateInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassCreateInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassCreateInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderPassCreateInfo2Value = unsafe.Sizeof([1]C.VkRenderPassCreateInfo2{})

// unpackSAttachmentDescription2 transforms a sliced Go data structure into plain C format.
func unpackSAttachmentDescription2(x []AttachmentDescription2) (unpacked *C.VkAttachmentDescription2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentDescription2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentDescription2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentDescription2)(h.Data)
	return
}

// unpackSSubpassDescription2 transforms a sliced Go data structure into plain C format.
func unpackSSubpassDescription2(x []SubpassDescription2) (unpacked *C.VkSubpassDescription2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDescription2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDescription2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDescription2)(h.Data)
	return
}

// unpackSSubpassDependency2 transforms a sliced Go data structure into plain C format.
func unpackSSubpassDependency2(x []SubpassDependency2) (unpacked *C.VkSubpassDependency2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDependency2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDependency2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDependency2)(h.Data)
	return
}

// packSAttachmentDescription2 reads sliced Go data structure out from plain C format.
func packSAttachmentDescription2(v []AttachmentDescription2, ptr0 *C.VkAttachmentDescription2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentDescription2Value]C.VkAttachmentDescription2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentDescription2Ref(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassDescription2 reads sliced Go data structure out from plain C format.
func packSSubpassDescription2(v []SubpassDescription2, ptr0 *C.VkSubpassDescription2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDescription2Value]C.VkSubpassDescription2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDescription2Ref(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassDependency2 reads sliced Go data structure out from plain C format.
func packSSubpassDependency2(v []SubpassDependency2, ptr0 *C.VkSubpassDependency2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDependency2Value]C.VkSubpassDependency2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDependency2Ref(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassCreateInfo2) Ref() *C.VkRenderPassCreateInfo2 {
	if x == nil {
		return nil
	}
	return x.ref1e86f565
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassCreateInfo2) Free() {
	if x != nil && x.allocs1e86f565 != nil {
		x.allocs1e86f565.(*cgoAllocMap).Free()
		x.ref1e86f565 = nil
	}
}

// NewRenderPassCreateInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassCreateInfo2Ref(ref unsafe.Pointer) *RenderPassCreateInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassCreateInfo2)
	obj.ref1e86f565 = (*C.VkRenderPassCreateInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassCreateInfo2) PassRef() (*C.VkRenderPassCreateInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1e86f565 != nil {
		return x.ref1e86f565, nil
	}
	mem1e86f565 := allocRenderPassCreateInfo2Memory(1)
	ref1e86f565 := (*C.VkRenderPassCreateInfo2)(mem1e86f565)
	allocs1e86f565 := new(cgoAllocMap)
	allocs1e86f565.Add(mem1e86f565)

	var csType_allocs *cgoAllocMap
	ref1e86f565.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1e86f565.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1e86f565.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1e86f565.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref1e86f565.flags, cflags_allocs = (C.VkRenderPassCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs1e86f565.Borrow(cflags_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	ref1e86f565.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocs1e86f565.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	ref1e86f565.pAttachments, cpAttachments_allocs = unpackSAttachmentDescription2(x.PAttachments)
	allocs1e86f565.Borrow(cpAttachments_allocs)

	var csubpassCount_allocs *cgoAllocMap
	ref1e86f565.subpassCount, csubpassCount_allocs = (C.uint32_t)(x.SubpassCount), cgoAllocsUnknown
	allocs1e86f565.Borrow(csubpassCount_allocs)

	var cpSubpasses_allocs *cgoAllocMap
	ref1e86f565.pSubpasses, cpSubpasses_allocs = unpackSSubpassDescription2(x.PSubpasses)
	allocs1e86f565.Borrow(cpSubpasses_allocs)

	var cdependencyCount_allocs *cgoAllocMap
	ref1e86f565.dependencyCount, cdependencyCount_allocs = (C.uint32_t)(x.DependencyCount), cgoAllocsUnknown
	allocs1e86f565.Borrow(cdependencyCount_allocs)

	var cpDependencies_allocs *cgoAllocMap
	ref1e86f565.pDependencies, cpDependencies_allocs = unpackSSubpassDependency2(x.PDependencies)
	allocs1e86f565.Borrow(cpDependencies_allocs)

	var ccorrelatedViewMaskCount_allocs *cgoAllocMap
	ref1e86f565.correlatedViewMaskCount, ccorrelatedViewMaskCount_allocs = (C.uint32_t)(x.CorrelatedViewMaskCount), cgoAllocsUnknown
	allocs1e86f565.Borrow(ccorrelatedViewMaskCount_allocs)

	var cpCorrelatedViewMasks_allocs *cgoAllocMap
	ref1e86f565.pCorrelatedViewMasks, cpCorrelatedViewMasks_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PCorrelatedViewMasks)))
	allocs1e86f565.Borrow(cpCorrelatedViewMasks_allocs)

	x.ref1e86f565 = ref1e86f565
	x.allocs1e86f565 = allocs1e86f565
	return ref1e86f565, allocs1e86f565

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassCreateInfo2) PassValue() (C.VkRenderPassCreateInfo2, *cgoAllocMap) {
	if x.ref1e86f565 != nil {
		return *x.ref1e86f565, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassCreateInfo2) Deref() {
	if x.ref1e86f565 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1e86f565.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1e86f565.pNext))
	x.Flags = (RenderPassCreateFlags)(x.ref1e86f565.flags)
	x.AttachmentCount = (uint32)(x.ref1e86f565.attachmentCount)
	packSAttachmentDescription2(x.PAttachments, x.ref1e86f565.pAttachments)
	x.SubpassCount = (uint32)(x.ref1e86f565.subpassCount)
	packSSubpassDescription2(x.PSubpasses, x.ref1e86f565.pSubpasses)
	x.DependencyCount = (uint32)(x.ref1e86f565.dependencyCount)
	packSSubpassDependency2(x.PDependencies, x.ref1e86f565.pDependencies)
	x.CorrelatedViewMaskCount = (uint32)(x.ref1e86f565.correlatedViewMaskCount)
	hxf685469 := (*sliceHeader)(unsafe.Pointer(&x.PCorrelatedViewMasks))
	hxf685469.Data = unsafe.Pointer(x.ref1e86f565.pCorrelatedViewMasks)
	hxf685469.Cap = 0x7fffffff
	// hxf685469.Len = ?

}

// allocSubpassBeginInfoMemory allocates memory for type C.VkSubpassBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassBeginInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubpassBeginInfoValue = unsafe.Sizeof([1]C.VkSubpassBeginInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassBeginInfo) Ref() *C.VkSubpassBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref941a38e5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassBeginInfo) Free() {
	if x != nil && x.allocs941a38e5 != nil {
		x.allocs941a38e5.(*cgoAllocMap).Free()
		x.ref941a38e5 = nil
	}
}

// NewSubpassBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassBeginInfoRef(ref unsafe.Pointer) *SubpassBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(SubpassBeginInfo)
	obj.ref941a38e5 = (*C.VkSubpassBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassBeginInfo) PassRef() (*C.VkSubpassBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref941a38e5 != nil {
		return x.ref941a38e5, nil
	}
	mem941a38e5 := allocSubpassBeginInfoMemory(1)
	ref941a38e5 := (*C.VkSubpassBeginInfo)(mem941a38e5)
	allocs941a38e5 := new(cgoAllocMap)
	allocs941a38e5.Add(mem941a38e5)

	var csType_allocs *cgoAllocMap
	ref941a38e5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs941a38e5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref941a38e5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs941a38e5.Borrow(cpNext_allocs)

	var ccontents_allocs *cgoAllocMap
	ref941a38e5.contents, ccontents_allocs = (C.VkSubpassContents)(x.Contents), cgoAllocsUnknown
	allocs941a38e5.Borrow(ccontents_allocs)

	x.ref941a38e5 = ref941a38e5
	x.allocs941a38e5 = allocs941a38e5
	return ref941a38e5, allocs941a38e5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassBeginInfo) PassValue() (C.VkSubpassBeginInfo, *cgoAllocMap) {
	if x.ref941a38e5 != nil {
		return *x.ref941a38e5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassBeginInfo) Deref() {
	if x.ref941a38e5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref941a38e5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref941a38e5.pNext))
	x.Contents = (SubpassContents)(x.ref941a38e5.contents)
}

// allocSubpassEndInfoMemory allocates memory for type C.VkSubpassEndInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassEndInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassEndInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubpassEndInfoValue = unsafe.Sizeof([1]C.VkSubpassEndInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassEndInfo) Ref() *C.VkSubpassEndInfo {
	if x == nil {
		return nil
	}
	return x.reffa172a5c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassEndInfo) Free() {
	if x != nil && x.allocsfa172a5c != nil {
		x.allocsfa172a5c.(*cgoAllocMap).Free()
		x.reffa172a5c = nil
	}
}

// NewSubpassEndInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassEndInfoRef(ref unsafe.Pointer) *SubpassEndInfo {
	if ref == nil {
		return nil
	}
	obj := new(SubpassEndInfo)
	obj.reffa172a5c = (*C.VkSubpassEndInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassEndInfo) PassRef() (*C.VkSubpassEndInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffa172a5c != nil {
		return x.reffa172a5c, nil
	}
	memfa172a5c := allocSubpassEndInfoMemory(1)
	reffa172a5c := (*C.VkSubpassEndInfo)(memfa172a5c)
	allocsfa172a5c := new(cgoAllocMap)
	allocsfa172a5c.Add(memfa172a5c)

	var csType_allocs *cgoAllocMap
	reffa172a5c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfa172a5c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffa172a5c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfa172a5c.Borrow(cpNext_allocs)

	x.reffa172a5c = reffa172a5c
	x.allocsfa172a5c = allocsfa172a5c
	return reffa172a5c, allocsfa172a5c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassEndInfo) PassValue() (C.VkSubpassEndInfo, *cgoAllocMap) {
	if x.reffa172a5c != nil {
		return *x.reffa172a5c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassEndInfo) Deref() {
	if x.reffa172a5c == nil {
		return
	}
	x.SType = (StructureType)(x.reffa172a5c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffa172a5c.pNext))
}

// allocPhysicalDevice8BitStorageFeaturesMemory allocates memory for type C.VkPhysicalDevice8BitStorageFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevice8BitStorageFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevice8BitStorageFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDevice8BitStorageFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDevice8BitStorageFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevice8BitStorageFeatures) Ref() *C.VkPhysicalDevice8BitStorageFeatures {
	if x == nil {
		return nil
	}
	return x.ref4c9f0386
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevice8BitStorageFeatures) Free() {
	if x != nil && x.allocs4c9f0386 != nil {
		x.allocs4c9f0386.(*cgoAllocMap).Free()
		x.ref4c9f0386 = nil
	}
}

// NewPhysicalDevice8BitStorageFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevice8BitStorageFeaturesRef(ref unsafe.Pointer) *PhysicalDevice8BitStorageFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevice8BitStorageFeatures)
	obj.ref4c9f0386 = (*C.VkPhysicalDevice8BitStorageFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevice8BitStorageFeatures) PassRef() (*C.VkPhysicalDevice8BitStorageFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4c9f0386 != nil {
		return x.ref4c9f0386, nil
	}
	mem4c9f0386 := allocPhysicalDevice8BitStorageFeaturesMemory(1)
	ref4c9f0386 := (*C.VkPhysicalDevice8BitStorageFeatures)(mem4c9f0386)
	allocs4c9f0386 := new(cgoAllocMap)
	allocs4c9f0386.Add(mem4c9f0386)

	var csType_allocs *cgoAllocMap
	ref4c9f0386.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4c9f0386.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4c9f0386.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4c9f0386.Borrow(cpNext_allocs)

	var cstorageBuffer8BitAccess_allocs *cgoAllocMap
	ref4c9f0386.storageBuffer8BitAccess, cstorageBuffer8BitAccess_allocs = (C.VkBool32)(x.StorageBuffer8BitAccess), cgoAllocsUnknown
	allocs4c9f0386.Borrow(cstorageBuffer8BitAccess_allocs)

	var cuniformAndStorageBuffer8BitAccess_allocs *cgoAllocMap
	ref4c9f0386.uniformAndStorageBuffer8BitAccess, cuniformAndStorageBuffer8BitAccess_allocs = (C.VkBool32)(x.UniformAndStorageBuffer8BitAccess), cgoAllocsUnknown
	allocs4c9f0386.Borrow(cuniformAndStorageBuffer8BitAccess_allocs)

	var cstoragePushConstant8_allocs *cgoAllocMap
	ref4c9f0386.storagePushConstant8, cstoragePushConstant8_allocs = (C.VkBool32)(x.StoragePushConstant8), cgoAllocsUnknown
	allocs4c9f0386.Borrow(cstoragePushConstant8_allocs)

	x.ref4c9f0386 = ref4c9f0386
	x.allocs4c9f0386 = allocs4c9f0386
	return ref4c9f0386, allocs4c9f0386

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevice8BitStorageFeatures) PassValue() (C.VkPhysicalDevice8BitStorageFeatures, *cgoAllocMap) {
	if x.ref4c9f0386 != nil {
		return *x.ref4c9f0386, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevice8BitStorageFeatures) Deref() {
	if x.ref4c9f0386 == nil {
		return
	}
	x.SType = (StructureType)(x.ref4c9f0386.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4c9f0386.pNext))
	x.StorageBuffer8BitAccess = (Bool32)(x.ref4c9f0386.storageBuffer8BitAccess)
	x.UniformAndStorageBuffer8BitAccess = (Bool32)(x.ref4c9f0386.uniformAndStorageBuffer8BitAccess)
	x.StoragePushConstant8 = (Bool32)(x.ref4c9f0386.storagePushConstant8)
}

// allocPhysicalDeviceDriverPropertiesMemory allocates memory for type C.VkPhysicalDeviceDriverProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDriverPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDriverPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceDriverPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDriverProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDriverProperties) Ref() *C.VkPhysicalDeviceDriverProperties {
	if x == nil {
		return nil
	}
	return x.ref492c8b68
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDriverProperties) Free() {
	if x != nil && x.allocs492c8b68 != nil {
		x.allocs492c8b68.(*cgoAllocMap).Free()
		x.ref492c8b68 = nil
	}
}

// NewPhysicalDeviceDriverPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDriverPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceDriverProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDriverProperties)
	obj.ref492c8b68 = (*C.VkPhysicalDeviceDriverProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDriverProperties) PassRef() (*C.VkPhysicalDeviceDriverProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref492c8b68 != nil {
		return x.ref492c8b68, nil
	}
	mem492c8b68 := allocPhysicalDeviceDriverPropertiesMemory(1)
	ref492c8b68 := (*C.VkPhysicalDeviceDriverProperties)(mem492c8b68)
	allocs492c8b68 := new(cgoAllocMap)
	allocs492c8b68.Add(mem492c8b68)

	var csType_allocs *cgoAllocMap
	ref492c8b68.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs492c8b68.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref492c8b68.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs492c8b68.Borrow(cpNext_allocs)

	var cdriverID_allocs *cgoAllocMap
	ref492c8b68.driverID, cdriverID_allocs = (C.VkDriverId)(x.DriverID), cgoAllocsUnknown
	allocs492c8b68.Borrow(cdriverID_allocs)

	var cdriverName_allocs *cgoAllocMap
	ref492c8b68.driverName, cdriverName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.DriverName)), cgoAllocsUnknown
	allocs492c8b68.Borrow(cdriverName_allocs)

	var cdriverInfo_allocs *cgoAllocMap
	ref492c8b68.driverInfo, cdriverInfo_allocs = *(*[256]C.char)(unsafe.Pointer(&x.DriverInfo)), cgoAllocsUnknown
	allocs492c8b68.Borrow(cdriverInfo_allocs)

	var cconformanceVersion_allocs *cgoAllocMap
	ref492c8b68.conformanceVersion, cconformanceVersion_allocs = x.ConformanceVersion.PassValue()
	allocs492c8b68.Borrow(cconformanceVersion_allocs)

	x.ref492c8b68 = ref492c8b68
	x.allocs492c8b68 = allocs492c8b68
	return ref492c8b68, allocs492c8b68

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDriverProperties) PassValue() (C.VkPhysicalDeviceDriverProperties, *cgoAllocMap) {
	if x.ref492c8b68 != nil {
		return *x.ref492c8b68, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDriverProperties) Deref() {
	if x.ref492c8b68 == nil {
		return
	}
	x.SType = (StructureType)(x.ref492c8b68.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref492c8b68.pNext))
	x.DriverID = (DriverId)(x.ref492c8b68.driverID)
	x.DriverName = *(*[256]byte)(unsafe.Pointer(&x.ref492c8b68.driverName))
	x.DriverInfo = *(*[256]byte)(unsafe.Pointer(&x.ref492c8b68.driverInfo))
	x.ConformanceVersion = *NewConformanceVersionRef(unsafe.Pointer(&x.ref492c8b68.conformanceVersion))
}

// allocPhysicalDeviceShaderAtomicInt64FeaturesMemory allocates memory for type C.VkPhysicalDeviceShaderAtomicInt64Features in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderAtomicInt64FeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderAtomicInt64FeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShaderAtomicInt64FeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderAtomicInt64Features{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderAtomicInt64Features) Ref() *C.VkPhysicalDeviceShaderAtomicInt64Features {
	if x == nil {
		return nil
	}
	return x.refa23b7e52
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderAtomicInt64Features) Free() {
	if x != nil && x.allocsa23b7e52 != nil {
		x.allocsa23b7e52.(*cgoAllocMap).Free()
		x.refa23b7e52 = nil
	}
}

// NewPhysicalDeviceShaderAtomicInt64FeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderAtomicInt64FeaturesRef(ref unsafe.Pointer) *PhysicalDeviceShaderAtomicInt64Features {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderAtomicInt64Features)
	obj.refa23b7e52 = (*C.VkPhysicalDeviceShaderAtomicInt64Features)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderAtomicInt64Features) PassRef() (*C.VkPhysicalDeviceShaderAtomicInt64Features, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa23b7e52 != nil {
		return x.refa23b7e52, nil
	}
	mema23b7e52 := allocPhysicalDeviceShaderAtomicInt64FeaturesMemory(1)
	refa23b7e52 := (*C.VkPhysicalDeviceShaderAtomicInt64Features)(mema23b7e52)
	allocsa23b7e52 := new(cgoAllocMap)
	allocsa23b7e52.Add(mema23b7e52)

	var csType_allocs *cgoAllocMap
	refa23b7e52.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa23b7e52.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa23b7e52.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa23b7e52.Borrow(cpNext_allocs)

	var cshaderBufferInt64Atomics_allocs *cgoAllocMap
	refa23b7e52.shaderBufferInt64Atomics, cshaderBufferInt64Atomics_allocs = (C.VkBool32)(x.ShaderBufferInt64Atomics), cgoAllocsUnknown
	allocsa23b7e52.Borrow(cshaderBufferInt64Atomics_allocs)

	var cshaderSharedInt64Atomics_allocs *cgoAllocMap
	refa23b7e52.shaderSharedInt64Atomics, cshaderSharedInt64Atomics_allocs = (C.VkBool32)(x.ShaderSharedInt64Atomics), cgoAllocsUnknown
	allocsa23b7e52.Borrow(cshaderSharedInt64Atomics_allocs)

	x.refa23b7e52 = refa23b7e52
	x.allocsa23b7e52 = allocsa23b7e52
	return refa23b7e52, allocsa23b7e52

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderAtomicInt64Features) PassValue() (C.VkPhysicalDeviceShaderAtomicInt64Features, *cgoAllocMap) {
	if x.refa23b7e52 != nil {
		return *x.refa23b7e52, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderAtomicInt64Features) Deref() {
	if x.refa23b7e52 == nil {
		return
	}
	x.SType = (StructureType)(x.refa23b7e52.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa23b7e52.pNext))
	x.ShaderBufferInt64Atomics = (Bool32)(x.refa23b7e52.shaderBufferInt64Atomics)
	x.ShaderSharedInt64Atomics = (Bool32)(x.refa23b7e52.shaderSharedInt64Atomics)
}

// allocPhysicalDeviceShaderFloat16Int8FeaturesMemory allocates memory for type C.VkPhysicalDeviceShaderFloat16Int8Features in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderFloat16Int8FeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderFloat16Int8FeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShaderFloat16Int8FeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderFloat16Int8Features{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderFloat16Int8Features) Ref() *C.VkPhysicalDeviceShaderFloat16Int8Features {
	if x == nil {
		return nil
	}
	return x.refc9d315b6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderFloat16Int8Features) Free() {
	if x != nil && x.allocsc9d315b6 != nil {
		x.allocsc9d315b6.(*cgoAllocMap).Free()
		x.refc9d315b6 = nil
	}
}

// NewPhysicalDeviceShaderFloat16Int8FeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderFloat16Int8FeaturesRef(ref unsafe.Pointer) *PhysicalDeviceShaderFloat16Int8Features {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderFloat16Int8Features)
	obj.refc9d315b6 = (*C.VkPhysicalDeviceShaderFloat16Int8Features)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderFloat16Int8Features) PassRef() (*C.VkPhysicalDeviceShaderFloat16Int8Features, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc9d315b6 != nil {
		return x.refc9d315b6, nil
	}
	memc9d315b6 := allocPhysicalDeviceShaderFloat16Int8FeaturesMemory(1)
	refc9d315b6 := (*C.VkPhysicalDeviceShaderFloat16Int8Features)(memc9d315b6)
	allocsc9d315b6 := new(cgoAllocMap)
	allocsc9d315b6.Add(memc9d315b6)

	var csType_allocs *cgoAllocMap
	refc9d315b6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc9d315b6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc9d315b6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc9d315b6.Borrow(cpNext_allocs)

	var cshaderFloat16_allocs *cgoAllocMap
	refc9d315b6.shaderFloat16, cshaderFloat16_allocs = (C.VkBool32)(x.ShaderFloat16), cgoAllocsUnknown
	allocsc9d315b6.Borrow(cshaderFloat16_allocs)

	var cshaderInt8_allocs *cgoAllocMap
	refc9d315b6.shaderInt8, cshaderInt8_allocs = (C.VkBool32)(x.ShaderInt8), cgoAllocsUnknown
	allocsc9d315b6.Borrow(cshaderInt8_allocs)

	x.refc9d315b6 = refc9d315b6
	x.allocsc9d315b6 = allocsc9d315b6
	return refc9d315b6, allocsc9d315b6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderFloat16Int8Features) PassValue() (C.VkPhysicalDeviceShaderFloat16Int8Features, *cgoAllocMap) {
	if x.refc9d315b6 != nil {
		return *x.refc9d315b6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderFloat16Int8Features) Deref() {
	if x.refc9d315b6 == nil {
		return
	}
	x.SType = (StructureType)(x.refc9d315b6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc9d315b6.pNext))
	x.ShaderFloat16 = (Bool32)(x.refc9d315b6.shaderFloat16)
	x.ShaderInt8 = (Bool32)(x.refc9d315b6.shaderInt8)
}

// allocPhysicalDeviceFloatControlsPropertiesMemory allocates memory for type C.VkPhysicalDeviceFloatControlsProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFloatControlsPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFloatControlsPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceFloatControlsPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFloatControlsProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFloatControlsProperties) Ref() *C.VkPhysicalDeviceFloatControlsProperties {
	if x == nil {
		return nil
	}
	return x.ref92190a8a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFloatControlsProperties) Free() {
	if x != nil && x.allocs92190a8a != nil {
		x.allocs92190a8a.(*cgoAllocMap).Free()
		x.ref92190a8a = nil
	}
}

// NewPhysicalDeviceFloatControlsPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFloatControlsPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceFloatControlsProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFloatControlsProperties)
	obj.ref92190a8a = (*C.VkPhysicalDeviceFloatControlsProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFloatControlsProperties) PassRef() (*C.VkPhysicalDeviceFloatControlsProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref92190a8a != nil {
		return x.ref92190a8a, nil
	}
	mem92190a8a := allocPhysicalDeviceFloatControlsPropertiesMemory(1)
	ref92190a8a := (*C.VkPhysicalDeviceFloatControlsProperties)(mem92190a8a)
	allocs92190a8a := new(cgoAllocMap)
	allocs92190a8a.Add(mem92190a8a)

	var csType_allocs *cgoAllocMap
	ref92190a8a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs92190a8a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref92190a8a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs92190a8a.Borrow(cpNext_allocs)

	var cdenormBehaviorIndependence_allocs *cgoAllocMap
	ref92190a8a.denormBehaviorIndependence, cdenormBehaviorIndependence_allocs = (C.VkShaderFloatControlsIndependence)(x.DenormBehaviorIndependence), cgoAllocsUnknown
	allocs92190a8a.Borrow(cdenormBehaviorIndependence_allocs)

	var croundingModeIndependence_allocs *cgoAllocMap
	ref92190a8a.roundingModeIndependence, croundingModeIndependence_allocs = (C.VkShaderFloatControlsIndependence)(x.RoundingModeIndependence), cgoAllocsUnknown
	allocs92190a8a.Borrow(croundingModeIndependence_allocs)

	var cshaderSignedZeroInfNanPreserveFloat16_allocs *cgoAllocMap
	ref92190a8a.shaderSignedZeroInfNanPreserveFloat16, cshaderSignedZeroInfNanPreserveFloat16_allocs = (C.VkBool32)(x.ShaderSignedZeroInfNanPreserveFloat16), cgoAllocsUnknown
	allocs92190a8a.Borrow(cshaderSignedZeroInfNanPreserveFloat16_allocs)

	var cshaderSignedZeroInfNanPreserveFloat32_allocs *cgoAllocMap
	ref92190a8a.shaderSignedZeroInfNanPreserveFloat32, cshaderSignedZeroInfNanPreserveFloat32_allocs = (C.VkBool32)(x.ShaderSignedZeroInfNanPreserveFloat32), cgoAllocsUnknown
	allocs92190a8a.Borrow(cshaderSignedZeroInfNanPreserveFloat32_allocs)

	var cshaderSignedZeroInfNanPreserveFloat64_allocs *cgoAllocMap
	ref92190a8a.shaderSignedZeroInfNanPreserveFloat64, cshaderSignedZeroInfNanPreserveFloat64_allocs = (C.VkBool32)(x.ShaderSignedZeroInfNanPreserveFloat64), cgoAllocsUnknown
	allocs92190a8a.Borrow(cshaderSignedZeroInfNanPreserveFloat64_allocs)

	var cshaderDenormPreserveFloat16_allocs *cgoAllocMap
	ref92190a8a.shaderDenormPreserveFloat16, cshaderDenormPreserveFloat16_allocs = (C.VkBool32)(x.ShaderDenormPreserveFloat16), cgoAllocsUnknown
	allocs92190a8a.Borrow(cshaderDenormPreserveFloat16_allocs)

	var cshaderDenormPreserveFloat32_allocs *cgoAllocMap
	ref92190a8a.shaderDenormPreserveFloat32, cshaderDenormPreserveFloat32_allocs = (C.VkBool32)(x.ShaderDenormPreserveFloat32), cgoAllocsUnknown
	allocs92190a8a.Borrow(cshaderDenormPreserveFloat32_allocs)

	var cshaderDenormPreserveFloat64_allocs *cgoAllocMap
	ref92190a8a.shaderDenormPreserveFloat64, cshaderDenormPreserveFloat64_allocs = (C.VkBool32)(x.ShaderDenormPreserveFloat64), cgoAllocsUnknown
	allocs92190a8a.Borrow(cshaderDenormPreserveFloat64_allocs)

	var cshaderDenormFlushToZeroFloat16_allocs *cgoAllocMap
	ref92190a8a.shaderDenormFlushToZeroFloat16, cshaderDenormFlushToZeroFloat16_allocs = (C.VkBool32)(x.ShaderDenormFlushToZeroFloat16), cgoAllocsUnknown
	allocs92190a8a.Borrow(cshaderDenormFlushToZeroFloat16_allocs)

	var cshaderDenormFlushToZeroFloat32_allocs *cgoAllocMap
	ref92190a8a.shaderDenormFlushToZeroFloat32, cshaderDenormFlushToZeroFloat32_allocs = (C.VkBool32)(x.ShaderDenormFlushToZeroFloat32), cgoAllocsUnknown
	allocs92190a8a.Borrow(cshaderDenormFlushToZeroFloat32_allocs)

	var cshaderDenormFlushToZeroFloat64_allocs *cgoAllocMap
	ref92190a8a.shaderDenormFlushToZeroFloat64, cshaderDenormFlushToZeroFloat64_allocs = (C.VkBool32)(x.ShaderDenormFlushToZeroFloat64), cgoAllocsUnknown
	allocs92190a8a.Borrow(cshaderDenormFlushToZeroFloat64_allocs)

	var cshaderRoundingModeRTEFloat16_allocs *cgoAllocMap
	ref92190a8a.shaderRoundingModeRTEFloat16, cshaderRoundingModeRTEFloat16_allocs = (C.VkBool32)(x.ShaderRoundingModeRTEFloat16), cgoAllocsUnknown
	allocs92190a8a.Borrow(cshaderRoundingModeRTEFloat16_allocs)

	var cshaderRoundingModeRTEFloat32_allocs *cgoAllocMap
	ref92190a8a.shaderRoundingModeRTEFloat32, cshaderRoundingModeRTEFloat32_allocs = (C.VkBool32)(x.ShaderRoundingModeRTEFloat32), cgoAllocsUnknown
	allocs92190a8a.Borrow(cshaderRoundingModeRTEFloat32_allocs)

	var cshaderRoundingModeRTEFloat64_allocs *cgoAllocMap
	ref92190a8a.shaderRoundingModeRTEFloat64, cshaderRoundingModeRTEFloat64_allocs = (C.VkBool32)(x.ShaderRoundingModeRTEFloat64), cgoAllocsUnknown
	allocs92190a8a.Borrow(cshaderRoundingModeRTEFloat64_allocs)

	var cshaderRoundingModeRTZFloat16_allocs *cgoAllocMap
	ref92190a8a.shaderRoundingModeRTZFloat16, cshaderRoundingModeRTZFloat16_allocs = (C.VkBool32)(x.ShaderRoundingModeRTZFloat16), cgoAllocsUnknown
	allocs92190a8a.Borrow(cshaderRoundingModeRTZFloat16_allocs)

	var cshaderRoundingModeRTZFloat32_allocs *cgoAllocMap
	ref92190a8a.shaderRoundingModeRTZFloat32, cshaderRoundingModeRTZFloat32_allocs = (C.VkBool32)(x.ShaderRoundingModeRTZFloat32), cgoAllocsUnknown
	allocs92190a8a.Borrow(cshaderRoundingModeRTZFloat32_allocs)

	var cshaderRoundingModeRTZFloat64_allocs *cgoAllocMap
	ref92190a8a.shaderRoundingModeRTZFloat64, cshaderRoundingModeRTZFloat64_allocs = (C.VkBool32)(x.ShaderRoundingModeRTZFloat64), cgoAllocsUnknown
	allocs92190a8a.Borrow(cshaderRoundingModeRTZFloat64_allocs)

	x.ref92190a8a = ref92190a8a
	x.allocs92190a8a = allocs92190a8a
	return ref92190a8a, allocs92190a8a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFloatControlsProperties) PassValue() (C.VkPhysicalDeviceFloatControlsProperties, *cgoAllocMap) {
	if x.ref92190a8a != nil {
		return *x.ref92190a8a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFloatControlsProperties) Deref() {
	if x.ref92190a8a == nil {
		return
	}
	x.SType = (StructureType)(x.ref92190a8a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref92190a8a.pNext))
	x.DenormBehaviorIndependence = (ShaderFloatControlsIndependence)(x.ref92190a8a.denormBehaviorIndependence)
	x.RoundingModeIndependence = (ShaderFloatControlsIndependence)(x.ref92190a8a.roundingModeIndependence)
	x.ShaderSignedZeroInfNanPreserveFloat16 = (Bool32)(x.ref92190a8a.shaderSignedZeroInfNanPreserveFloat16)
	x.ShaderSignedZeroInfNanPreserveFloat32 = (Bool32)(x.ref92190a8a.shaderSignedZeroInfNanPreserveFloat32)
	x.ShaderSignedZeroInfNanPreserveFloat64 = (Bool32)(x.ref92190a8a.shaderSignedZeroInfNanPreserveFloat64)
	x.ShaderDenormPreserveFloat16 = (Bool32)(x.ref92190a8a.shaderDenormPreserveFloat16)
	x.ShaderDenormPreserveFloat32 = (Bool32)(x.ref92190a8a.shaderDenormPreserveFloat32)
	x.ShaderDenormPreserveFloat64 = (Bool32)(x.ref92190a8a.shaderDenormPreserveFloat64)
	x.ShaderDenormFlushToZeroFloat16 = (Bool32)(x.ref92190a8a.shaderDenormFlushToZeroFloat16)
	x.ShaderDenormFlushToZeroFloat32 = (Bool32)(x.ref92190a8a.shaderDenormFlushToZeroFloat32)
	x.ShaderDenormFlushToZeroFloat64 = (Bool32)(x.ref92190a8a.shaderDenormFlushToZeroFloat64)
	x.ShaderRoundingModeRTEFloat16 = (Bool32)(x.ref92190a8a.shaderRoundingModeRTEFloat16)
	x.ShaderRoundingModeRTEFloat32 = (Bool32)(x.ref92190a8a.shaderRoundingModeRTEFloat32)
	x.ShaderRoundingModeRTEFloat64 = (Bool32)(x.ref92190a8a.shaderRoundingModeRTEFloat64)
	x.ShaderRoundingModeRTZFloat16 = (Bool32)(x.ref92190a8a.shaderRoundingModeRTZFloat16)
	x.ShaderRoundingModeRTZFloat32 = (Bool32)(x.ref92190a8a.shaderRoundingModeRTZFloat32)
	x.ShaderRoundingModeRTZFloat64 = (Bool32)(x.ref92190a8a.shaderRoundingModeRTZFloat64)
}

// allocDescriptorSetLayoutBindingFlagsCreateInfoMemory allocates memory for type C.VkDescriptorSetLayoutBindingFlagsCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutBindingFlagsCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutBindingFlagsCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorSetLayoutBindingFlagsCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutBindingFlagsCreateInfo{})

// copyPDescriptorBindingFlagsBytes copies the data from Go slice as *C.VkDescriptorBindingFlags.
func copyPDescriptorBindingFlagsBytes(slice *sliceHeader) (*C.VkDescriptorBindingFlags, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDescriptorBindingFlagsValue) * slice.Len,
		Cap:  int(sizeOfDescriptorBindingFlagsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDescriptorBindingFlags)(mem0), allocs
}

// allocDescriptorBindingFlagsMemory allocates memory for type C.VkDescriptorBindingFlags in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorBindingFlagsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorBindingFlagsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorBindingFlagsValue = unsafe.Sizeof([1]C.VkDescriptorBindingFlags{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) Ref() *C.VkDescriptorSetLayoutBindingFlagsCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref84838c4d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) Free() {
	if x != nil && x.allocs84838c4d != nil {
		x.allocs84838c4d.(*cgoAllocMap).Free()
		x.ref84838c4d = nil
	}
}

// NewDescriptorSetLayoutBindingFlagsCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetLayoutBindingFlagsCreateInfoRef(ref unsafe.Pointer) *DescriptorSetLayoutBindingFlagsCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutBindingFlagsCreateInfo)
	obj.ref84838c4d = (*C.VkDescriptorSetLayoutBindingFlagsCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) PassRef() (*C.VkDescriptorSetLayoutBindingFlagsCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref84838c4d != nil {
		return x.ref84838c4d, nil
	}
	mem84838c4d := allocDescriptorSetLayoutBindingFlagsCreateInfoMemory(1)
	ref84838c4d := (*C.VkDescriptorSetLayoutBindingFlagsCreateInfo)(mem84838c4d)
	allocs84838c4d := new(cgoAllocMap)
	allocs84838c4d.Add(mem84838c4d)

	var csType_allocs *cgoAllocMap
	ref84838c4d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs84838c4d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref84838c4d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs84838c4d.Borrow(cpNext_allocs)

	var cbindingCount_allocs *cgoAllocMap
	ref84838c4d.bindingCount, cbindingCount_allocs = (C.uint32_t)(x.BindingCount), cgoAllocsUnknown
	allocs84838c4d.Borrow(cbindingCount_allocs)

	var cpBindingFlags_allocs *cgoAllocMap
	ref84838c4d.pBindingFlags, cpBindingFlags_allocs = copyPDescriptorBindingFlagsBytes((*sliceHeader)(unsafe.Pointer(&x.PBindingFlags)))
	allocs84838c4d.Borrow(cpBindingFlags_allocs)

	x.ref84838c4d = ref84838c4d
	x.allocs84838c4d = allocs84838c4d
	return ref84838c4d, allocs84838c4d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) PassValue() (C.VkDescriptorSetLayoutBindingFlagsCreateInfo, *cgoAllocMap) {
	if x.ref84838c4d != nil {
		return *x.ref84838c4d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) Deref() {
	if x.ref84838c4d == nil {
		return
	}
	x.SType = (StructureType)(x.ref84838c4d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref84838c4d.pNext))
	x.BindingCount = (uint32)(x.ref84838c4d.bindingCount)
	hxf03a9a7 := (*sliceHeader)(unsafe.Pointer(&x.PBindingFlags))
	hxf03a9a7.Data = unsafe.Pointer(x.ref84838c4d.pBindingFlags)
	hxf03a9a7.Cap = 0x7fffffff
	// hxf03a9a7.Len = ?

}

// allocPhysicalDeviceDescriptorIndexingFeaturesMemory allocates memory for type C.VkPhysicalDeviceDescriptorIndexingFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDescriptorIndexingFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDescriptorIndexingFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceDescriptorIndexingFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDescriptorIndexingFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDescriptorIndexingFeatures) Ref() *C.VkPhysicalDeviceDescriptorIndexingFeatures {
	if x == nil {
		return nil
	}
	return x.reff599863
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDescriptorIndexingFeatures) Free() {
	if x != nil && x.allocsf599863 != nil {
		x.allocsf599863.(*cgoAllocMap).Free()
		x.reff599863 = nil
	}
}

// NewPhysicalDeviceDescriptorIndexingFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDescriptorIndexingFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceDescriptorIndexingFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDescriptorIndexingFeatures)
	obj.reff599863 = (*C.VkPhysicalDeviceDescriptorIndexingFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDescriptorIndexingFeatures) PassRef() (*C.VkPhysicalDeviceDescriptorIndexingFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff599863 != nil {
		return x.reff599863, nil
	}
	memf599863 := allocPhysicalDeviceDescriptorIndexingFeaturesMemory(1)
	reff599863 := (*C.VkPhysicalDeviceDescriptorIndexingFeatures)(memf599863)
	allocsf599863 := new(cgoAllocMap)
	allocsf599863.Add(memf599863)

	var csType_allocs *cgoAllocMap
	reff599863.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf599863.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff599863.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf599863.Borrow(cpNext_allocs)

	var cshaderInputAttachmentArrayDynamicIndexing_allocs *cgoAllocMap
	reff599863.shaderInputAttachmentArrayDynamicIndexing, cshaderInputAttachmentArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderInputAttachmentArrayDynamicIndexing), cgoAllocsUnknown
	allocsf599863.Borrow(cshaderInputAttachmentArrayDynamicIndexing_allocs)

	var cshaderUniformTexelBufferArrayDynamicIndexing_allocs *cgoAllocMap
	reff599863.shaderUniformTexelBufferArrayDynamicIndexing, cshaderUniformTexelBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderUniformTexelBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocsf599863.Borrow(cshaderUniformTexelBufferArrayDynamicIndexing_allocs)

	var cshaderStorageTexelBufferArrayDynamicIndexing_allocs *cgoAllocMap
	reff599863.shaderStorageTexelBufferArrayDynamicIndexing, cshaderStorageTexelBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderStorageTexelBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocsf599863.Borrow(cshaderStorageTexelBufferArrayDynamicIndexing_allocs)

	var cshaderUniformBufferArrayNonUniformIndexing_allocs *cgoAllocMap
	reff599863.shaderUniformBufferArrayNonUniformIndexing, cshaderUniformBufferArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderUniformBufferArrayNonUniformIndexing), cgoAllocsUnknown
	allocsf599863.Borrow(cshaderUniformBufferArrayNonUniformIndexing_allocs)

	var cshaderSampledImageArrayNonUniformIndexing_allocs *cgoAllocMap
	reff599863.shaderSampledImageArrayNonUniformIndexing, cshaderSampledImageArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderSampledImageArrayNonUniformIndexing), cgoAllocsUnknown
	allocsf599863.Borrow(cshaderSampledImageArrayNonUniformIndexing_allocs)

	var cshaderStorageBufferArrayNonUniformIndexing_allocs *cgoAllocMap
	reff599863.shaderStorageBufferArrayNonUniformIndexing, cshaderStorageBufferArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderStorageBufferArrayNonUniformIndexing), cgoAllocsUnknown
	allocsf599863.Borrow(cshaderStorageBufferArrayNonUniformIndexing_allocs)

	var cshaderStorageImageArrayNonUniformIndexing_allocs *cgoAllocMap
	reff599863.shaderStorageImageArrayNonUniformIndexing, cshaderStorageImageArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderStorageImageArrayNonUniformIndexing), cgoAllocsUnknown
	allocsf599863.Borrow(cshaderStorageImageArrayNonUniformIndexing_allocs)

	var cshaderInputAttachmentArrayNonUniformIndexing_allocs *cgoAllocMap
	reff599863.shaderInputAttachmentArrayNonUniformIndexing, cshaderInputAttachmentArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderInputAttachmentArrayNonUniformIndexing), cgoAllocsUnknown
	allocsf599863.Borrow(cshaderInputAttachmentArrayNonUniformIndexing_allocs)

	var cshaderUniformTexelBufferArrayNonUniformIndexing_allocs *cgoAllocMap
	reff599863.shaderUniformTexelBufferArrayNonUniformIndexing, cshaderUniformTexelBufferArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderUniformTexelBufferArrayNonUniformIndexing), cgoAllocsUnknown
	allocsf599863.Borrow(cshaderUniformTexelBufferArrayNonUniformIndexing_allocs)

	var cshaderStorageTexelBufferArrayNonUniformIndexing_allocs *cgoAllocMap
	reff599863.shaderStorageTexelBufferArrayNonUniformIndexing, cshaderStorageTexelBufferArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderStorageTexelBufferArrayNonUniformIndexing), cgoAllocsUnknown
	allocsf599863.Borrow(cshaderStorageTexelBufferArrayNonUniformIndexing_allocs)

	var cdescriptorBindingUniformBufferUpdateAfterBind_allocs *cgoAllocMap
	reff599863.descriptorBindingUniformBufferUpdateAfterBind, cdescriptorBindingUniformBufferUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingUniformBufferUpdateAfterBind), cgoAllocsUnknown
	allocsf599863.Borrow(cdescriptorBindingUniformBufferUpdateAfterBind_allocs)

	var cdescriptorBindingSampledImageUpdateAfterBind_allocs *cgoAllocMap
	reff599863.descriptorBindingSampledImageUpdateAfterBind, cdescriptorBindingSampledImageUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingSampledImageUpdateAfterBind), cgoAllocsUnknown
	allocsf599863.Borrow(cdescriptorBindingSampledImageUpdateAfterBind_allocs)

	var cdescriptorBindingStorageImageUpdateAfterBind_allocs *cgoAllocMap
	reff599863.descriptorBindingStorageImageUpdateAfterBind, cdescriptorBindingStorageImageUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingStorageImageUpdateAfterBind), cgoAllocsUnknown
	allocsf599863.Borrow(cdescriptorBindingStorageImageUpdateAfterBind_allocs)

	var cdescriptorBindingStorageBufferUpdateAfterBind_allocs *cgoAllocMap
	reff599863.descriptorBindingStorageBufferUpdateAfterBind, cdescriptorBindingStorageBufferUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingStorageBufferUpdateAfterBind), cgoAllocsUnknown
	allocsf599863.Borrow(cdescriptorBindingStorageBufferUpdateAfterBind_allocs)

	var cdescriptorBindingUniformTexelBufferUpdateAfterBind_allocs *cgoAllocMap
	reff599863.descriptorBindingUniformTexelBufferUpdateAfterBind, cdescriptorBindingUniformTexelBufferUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingUniformTexelBufferUpdateAfterBind), cgoAllocsUnknown
	allocsf599863.Borrow(cdescriptorBindingUniformTexelBufferUpdateAfterBind_allocs)

	var cdescriptorBindingStorageTexelBufferUpdateAfterBind_allocs *cgoAllocMap
	reff599863.descriptorBindingStorageTexelBufferUpdateAfterBind, cdescriptorBindingStorageTexelBufferUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingStorageTexelBufferUpdateAfterBind), cgoAllocsUnknown
	allocsf599863.Borrow(cdescriptorBindingStorageTexelBufferUpdateAfterBind_allocs)

	var cdescriptorBindingUpdateUnusedWhilePending_allocs *cgoAllocMap
	reff599863.descriptorBindingUpdateUnusedWhilePending, cdescriptorBindingUpdateUnusedWhilePending_allocs = (C.VkBool32)(x.DescriptorBindingUpdateUnusedWhilePending), cgoAllocsUnknown
	allocsf599863.Borrow(cdescriptorBindingUpdateUnusedWhilePending_allocs)

	var cdescriptorBindingPartiallyBound_allocs *cgoAllocMap
	reff599863.descriptorBindingPartiallyBound, cdescriptorBindingPartiallyBound_allocs = (C.VkBool32)(x.DescriptorBindingPartiallyBound), cgoAllocsUnknown
	allocsf599863.Borrow(cdescriptorBindingPartiallyBound_allocs)

	var cdescriptorBindingVariableDescriptorCount_allocs *cgoAllocMap
	reff599863.descriptorBindingVariableDescriptorCount, cdescriptorBindingVariableDescriptorCount_allocs = (C.VkBool32)(x.DescriptorBindingVariableDescriptorCount), cgoAllocsUnknown
	allocsf599863.Borrow(cdescriptorBindingVariableDescriptorCount_allocs)

	var cruntimeDescriptorArray_allocs *cgoAllocMap
	reff599863.runtimeDescriptorArray, cruntimeDescriptorArray_allocs = (C.VkBool32)(x.RuntimeDescriptorArray), cgoAllocsUnknown
	allocsf599863.Borrow(cruntimeDescriptorArray_allocs)

	x.reff599863 = reff599863
	x.allocsf599863 = allocsf599863
	return reff599863, allocsf599863

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDescriptorIndexingFeatures) PassValue() (C.VkPhysicalDeviceDescriptorIndexingFeatures, *cgoAllocMap) {
	if x.reff599863 != nil {
		return *x.reff599863, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDescriptorIndexingFeatures) Deref() {
	if x.reff599863 == nil {
		return
	}
	x.SType = (StructureType)(x.reff599863.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff599863.pNext))
	x.ShaderInputAttachmentArrayDynamicIndexing = (Bool32)(x.reff599863.shaderInputAttachmentArrayDynamicIndexing)
	x.ShaderUniformTexelBufferArrayDynamicIndexing = (Bool32)(x.reff599863.shaderUniformTexelBufferArrayDynamicIndexing)
	x.ShaderStorageTexelBufferArrayDynamicIndexing = (Bool32)(x.reff599863.shaderStorageTexelBufferArrayDynamicIndexing)
	x.ShaderUniformBufferArrayNonUniformIndexing = (Bool32)(x.reff599863.shaderUniformBufferArrayNonUniformIndexing)
	x.ShaderSampledImageArrayNonUniformIndexing = (Bool32)(x.reff599863.shaderSampledImageArrayNonUniformIndexing)
	x.ShaderStorageBufferArrayNonUniformIndexing = (Bool32)(x.reff599863.shaderStorageBufferArrayNonUniformIndexing)
	x.ShaderStorageImageArrayNonUniformIndexing = (Bool32)(x.reff599863.shaderStorageImageArrayNonUniformIndexing)
	x.ShaderInputAttachmentArrayNonUniformIndexing = (Bool32)(x.reff599863.shaderInputAttachmentArrayNonUniformIndexing)
	x.ShaderUniformTexelBufferArrayNonUniformIndexing = (Bool32)(x.reff599863.shaderUniformTexelBufferArrayNonUniformIndexing)
	x.ShaderStorageTexelBufferArrayNonUniformIndexing = (Bool32)(x.reff599863.shaderStorageTexelBufferArrayNonUniformIndexing)
	x.DescriptorBindingUniformBufferUpdateAfterBind = (Bool32)(x.reff599863.descriptorBindingUniformBufferUpdateAfterBind)
	x.DescriptorBindingSampledImageUpdateAfterBind = (Bool32)(x.reff599863.descriptorBindingSampledImageUpdateAfterBind)
	x.DescriptorBindingStorageImageUpdateAfterBind = (Bool32)(x.reff599863.descriptorBindingStorageImageUpdateAfterBind)
	x.DescriptorBindingStorageBufferUpdateAfterBind = (Bool32)(x.reff599863.descriptorBindingStorageBufferUpdateAfterBind)
	x.DescriptorBindingUniformTexelBufferUpdateAfterBind = (Bool32)(x.reff599863.descriptorBindingUniformTexelBufferUpdateAfterBind)
	x.DescriptorBindingStorageTexelBufferUpdateAfterBind = (Bool32)(x.reff599863.descriptorBindingStorageTexelBufferUpdateAfterBind)
	x.DescriptorBindingUpdateUnusedWhilePending = (Bool32)(x.reff599863.descriptorBindingUpdateUnusedWhilePending)
	x.DescriptorBindingPartiallyBound = (Bool32)(x.reff599863.descriptorBindingPartiallyBound)
	x.DescriptorBindingVariableDescriptorCount = (Bool32)(x.reff599863.descriptorBindingVariableDescriptorCount)
	x.RuntimeDescriptorArray = (Bool32)(x.reff599863.runtimeDescriptorArray)
}

// allocPhysicalDeviceDescriptorIndexingPropertiesMemory allocates memory for type C.VkPhysicalDeviceDescriptorIndexingProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDescriptorIndexingPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDescriptorIndexingPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceDescriptorIndexingPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDescriptorIndexingProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDescriptorIndexingProperties) Ref() *C.VkPhysicalDeviceDescriptorIndexingProperties {
	if x == nil {
		return nil
	}
	return x.refd94d7d21
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDescriptorIndexingProperties) Free() {
	if x != nil && x.allocsd94d7d21 != nil {
		x.allocsd94d7d21.(*cgoAllocMap).Free()
		x.refd94d7d21 = nil
	}
}

// NewPhysicalDeviceDescriptorIndexingPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDescriptorIndexingPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceDescriptorIndexingProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDescriptorIndexingProperties)
	obj.refd94d7d21 = (*C.VkPhysicalDeviceDescriptorIndexingProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDescriptorIndexingProperties) PassRef() (*C.VkPhysicalDeviceDescriptorIndexingProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd94d7d21 != nil {
		return x.refd94d7d21, nil
	}
	memd94d7d21 := allocPhysicalDeviceDescriptorIndexingPropertiesMemory(1)
	refd94d7d21 := (*C.VkPhysicalDeviceDescriptorIndexingProperties)(memd94d7d21)
	allocsd94d7d21 := new(cgoAllocMap)
	allocsd94d7d21.Add(memd94d7d21)

	var csType_allocs *cgoAllocMap
	refd94d7d21.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd94d7d21.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd94d7d21.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cpNext_allocs)

	var cmaxUpdateAfterBindDescriptorsInAllPools_allocs *cgoAllocMap
	refd94d7d21.maxUpdateAfterBindDescriptorsInAllPools, cmaxUpdateAfterBindDescriptorsInAllPools_allocs = (C.uint32_t)(x.MaxUpdateAfterBindDescriptorsInAllPools), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cmaxUpdateAfterBindDescriptorsInAllPools_allocs)

	var cshaderUniformBufferArrayNonUniformIndexingNative_allocs *cgoAllocMap
	refd94d7d21.shaderUniformBufferArrayNonUniformIndexingNative, cshaderUniformBufferArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderUniformBufferArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cshaderUniformBufferArrayNonUniformIndexingNative_allocs)

	var cshaderSampledImageArrayNonUniformIndexingNative_allocs *cgoAllocMap
	refd94d7d21.shaderSampledImageArrayNonUniformIndexingNative, cshaderSampledImageArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderSampledImageArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cshaderSampledImageArrayNonUniformIndexingNative_allocs)

	var cshaderStorageBufferArrayNonUniformIndexingNative_allocs *cgoAllocMap
	refd94d7d21.shaderStorageBufferArrayNonUniformIndexingNative, cshaderStorageBufferArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderStorageBufferArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cshaderStorageBufferArrayNonUniformIndexingNative_allocs)

	var cshaderStorageImageArrayNonUniformIndexingNative_allocs *cgoAllocMap
	refd94d7d21.shaderStorageImageArrayNonUniformIndexingNative, cshaderStorageImageArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderStorageImageArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cshaderStorageImageArrayNonUniformIndexingNative_allocs)

	var cshaderInputAttachmentArrayNonUniformIndexingNative_allocs *cgoAllocMap
	refd94d7d21.shaderInputAttachmentArrayNonUniformIndexingNative, cshaderInputAttachmentArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderInputAttachmentArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cshaderInputAttachmentArrayNonUniformIndexingNative_allocs)

	var crobustBufferAccessUpdateAfterBind_allocs *cgoAllocMap
	refd94d7d21.robustBufferAccessUpdateAfterBind, crobustBufferAccessUpdateAfterBind_allocs = (C.VkBool32)(x.RobustBufferAccessUpdateAfterBind), cgoAllocsUnknown
	allocsd94d7d21.Borrow(crobustBufferAccessUpdateAfterBind_allocs)

	var cquadDivergentImplicitLod_allocs *cgoAllocMap
	refd94d7d21.quadDivergentImplicitLod, cquadDivergentImplicitLod_allocs = (C.VkBool32)(x.QuadDivergentImplicitLod), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cquadDivergentImplicitLod_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindSamplers_allocs *cgoAllocMap
	refd94d7d21.maxPerStageDescriptorUpdateAfterBindSamplers, cmaxPerStageDescriptorUpdateAfterBindSamplers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindSamplers), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cmaxPerStageDescriptorUpdateAfterBindSamplers_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindUniformBuffers_allocs *cgoAllocMap
	refd94d7d21.maxPerStageDescriptorUpdateAfterBindUniformBuffers, cmaxPerStageDescriptorUpdateAfterBindUniformBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindUniformBuffers), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cmaxPerStageDescriptorUpdateAfterBindUniformBuffers_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindStorageBuffers_allocs *cgoAllocMap
	refd94d7d21.maxPerStageDescriptorUpdateAfterBindStorageBuffers, cmaxPerStageDescriptorUpdateAfterBindStorageBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindStorageBuffers), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cmaxPerStageDescriptorUpdateAfterBindStorageBuffers_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindSampledImages_allocs *cgoAllocMap
	refd94d7d21.maxPerStageDescriptorUpdateAfterBindSampledImages, cmaxPerStageDescriptorUpdateAfterBindSampledImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindSampledImages), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cmaxPerStageDescriptorUpdateAfterBindSampledImages_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindStorageImages_allocs *cgoAllocMap
	refd94d7d21.maxPerStageDescriptorUpdateAfterBindStorageImages, cmaxPerStageDescriptorUpdateAfterBindStorageImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindStorageImages), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cmaxPerStageDescriptorUpdateAfterBindStorageImages_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindInputAttachments_allocs *cgoAllocMap
	refd94d7d21.maxPerStageDescriptorUpdateAfterBindInputAttachments, cmaxPerStageDescriptorUpdateAfterBindInputAttachments_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindInputAttachments), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cmaxPerStageDescriptorUpdateAfterBindInputAttachments_allocs)

	var cmaxPerStageUpdateAfterBindResources_allocs *cgoAllocMap
	refd94d7d21.maxPerStageUpdateAfterBindResources, cmaxPerStageUpdateAfterBindResources_allocs = (C.uint32_t)(x.MaxPerStageUpdateAfterBindResources), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cmaxPerStageUpdateAfterBindResources_allocs)

	var cmaxDescriptorSetUpdateAfterBindSamplers_allocs *cgoAllocMap
	refd94d7d21.maxDescriptorSetUpdateAfterBindSamplers, cmaxDescriptorSetUpdateAfterBindSamplers_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindSamplers), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cmaxDescriptorSetUpdateAfterBindSamplers_allocs)

	var cmaxDescriptorSetUpdateAfterBindUniformBuffers_allocs *cgoAllocMap
	refd94d7d21.maxDescriptorSetUpdateAfterBindUniformBuffers, cmaxDescriptorSetUpdateAfterBindUniformBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindUniformBuffers), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cmaxDescriptorSetUpdateAfterBindUniformBuffers_allocs)

	var cmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic_allocs *cgoAllocMap
	refd94d7d21.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, cmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic_allocs)

	var cmaxDescriptorSetUpdateAfterBindStorageBuffers_allocs *cgoAllocMap
	refd94d7d21.maxDescriptorSetUpdateAfterBindStorageBuffers, cmaxDescriptorSetUpdateAfterBindStorageBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindStorageBuffers), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cmaxDescriptorSetUpdateAfterBindStorageBuffers_allocs)

	var cmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic_allocs *cgoAllocMap
	refd94d7d21.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, cmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic_allocs)

	var cmaxDescriptorSetUpdateAfterBindSampledImages_allocs *cgoAllocMap
	refd94d7d21.maxDescriptorSetUpdateAfterBindSampledImages, cmaxDescriptorSetUpdateAfterBindSampledImages_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindSampledImages), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cmaxDescriptorSetUpdateAfterBindSampledImages_allocs)

	var cmaxDescriptorSetUpdateAfterBindStorageImages_allocs *cgoAllocMap
	refd94d7d21.maxDescriptorSetUpdateAfterBindStorageImages, cmaxDescriptorSetUpdateAfterBindStorageImages_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindStorageImages), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cmaxDescriptorSetUpdateAfterBindStorageImages_allocs)

	var cmaxDescriptorSetUpdateAfterBindInputAttachments_allocs *cgoAllocMap
	refd94d7d21.maxDescriptorSetUpdateAfterBindInputAttachments, cmaxDescriptorSetUpdateAfterBindInputAttachments_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindInputAttachments), cgoAllocsUnknown
	allocsd94d7d21.Borrow(cmaxDescriptorSetUpdateAfterBindInputAttachments_allocs)

	x.refd94d7d21 = refd94d7d21
	x.allocsd94d7d21 = allocsd94d7d21
	return refd94d7d21, allocsd94d7d21

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDescriptorIndexingProperties) PassValue() (C.VkPhysicalDeviceDescriptorIndexingProperties, *cgoAllocMap) {
	if x.refd94d7d21 != nil {
		return *x.refd94d7d21, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDescriptorIndexingProperties) Deref() {
	if x.refd94d7d21 == nil {
		return
	}
	x.SType = (StructureType)(x.refd94d7d21.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd94d7d21.pNext))
	x.MaxUpdateAfterBindDescriptorsInAllPools = (uint32)(x.refd94d7d21.maxUpdateAfterBindDescriptorsInAllPools)
	x.ShaderUniformBufferArrayNonUniformIndexingNative = (Bool32)(x.refd94d7d21.shaderUniformBufferArrayNonUniformIndexingNative)
	x.ShaderSampledImageArrayNonUniformIndexingNative = (Bool32)(x.refd94d7d21.shaderSampledImageArrayNonUniformIndexingNative)
	x.ShaderStorageBufferArrayNonUniformIndexingNative = (Bool32)(x.refd94d7d21.shaderStorageBufferArrayNonUniformIndexingNative)
	x.ShaderStorageImageArrayNonUniformIndexingNative = (Bool32)(x.refd94d7d21.shaderStorageImageArrayNonUniformIndexingNative)
	x.ShaderInputAttachmentArrayNonUniformIndexingNative = (Bool32)(x.refd94d7d21.shaderInputAttachmentArrayNonUniformIndexingNative)
	x.RobustBufferAccessUpdateAfterBind = (Bool32)(x.refd94d7d21.robustBufferAccessUpdateAfterBind)
	x.QuadDivergentImplicitLod = (Bool32)(x.refd94d7d21.quadDivergentImplicitLod)
	x.MaxPerStageDescriptorUpdateAfterBindSamplers = (uint32)(x.refd94d7d21.maxPerStageDescriptorUpdateAfterBindSamplers)
	x.MaxPerStageDescriptorUpdateAfterBindUniformBuffers = (uint32)(x.refd94d7d21.maxPerStageDescriptorUpdateAfterBindUniformBuffers)
	x.MaxPerStageDescriptorUpdateAfterBindStorageBuffers = (uint32)(x.refd94d7d21.maxPerStageDescriptorUpdateAfterBindStorageBuffers)
	x.MaxPerStageDescriptorUpdateAfterBindSampledImages = (uint32)(x.refd94d7d21.maxPerStageDescriptorUpdateAfterBindSampledImages)
	x.MaxPerStageDescriptorUpdateAfterBindStorageImages = (uint32)(x.refd94d7d21.maxPerStageDescriptorUpdateAfterBindStorageImages)
	x.MaxPerStageDescriptorUpdateAfterBindInputAttachments = (uint32)(x.refd94d7d21.maxPerStageDescriptorUpdateAfterBindInputAttachments)
	x.MaxPerStageUpdateAfterBindResources = (uint32)(x.refd94d7d21.maxPerStageUpdateAfterBindResources)
	x.MaxDescriptorSetUpdateAfterBindSamplers = (uint32)(x.refd94d7d21.maxDescriptorSetUpdateAfterBindSamplers)
	x.MaxDescriptorSetUpdateAfterBindUniformBuffers = (uint32)(x.refd94d7d21.maxDescriptorSetUpdateAfterBindUniformBuffers)
	x.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic = (uint32)(x.refd94d7d21.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
	x.MaxDescriptorSetUpdateAfterBindStorageBuffers = (uint32)(x.refd94d7d21.maxDescriptorSetUpdateAfterBindStorageBuffers)
	x.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic = (uint32)(x.refd94d7d21.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
	x.MaxDescriptorSetUpdateAfterBindSampledImages = (uint32)(x.refd94d7d21.maxDescriptorSetUpdateAfterBindSampledImages)
	x.MaxDescriptorSetUpdateAfterBindStorageImages = (uint32)(x.refd94d7d21.maxDescriptorSetUpdateAfterBindStorageImages)
	x.MaxDescriptorSetUpdateAfterBindInputAttachments = (uint32)(x.refd94d7d21.maxDescriptorSetUpdateAfterBindInputAttachments)
}

// allocDescriptorSetVariableDescriptorCountAllocateInfoMemory allocates memory for type C.VkDescriptorSetVariableDescriptorCountAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetVariableDescriptorCountAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetVariableDescriptorCountAllocateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorSetVariableDescriptorCountAllocateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetVariableDescriptorCountAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) Ref() *C.VkDescriptorSetVariableDescriptorCountAllocateInfo {
	if x == nil {
		return nil
	}
	return x.ref7969c9a7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) Free() {
	if x != nil && x.allocs7969c9a7 != nil {
		x.allocs7969c9a7.(*cgoAllocMap).Free()
		x.ref7969c9a7 = nil
	}
}

// NewDescriptorSetVariableDescriptorCountAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetVariableDescriptorCountAllocateInfoRef(ref unsafe.Pointer) *DescriptorSetVariableDescriptorCountAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetVariableDescriptorCountAllocateInfo)
	obj.ref7969c9a7 = (*C.VkDescriptorSetVariableDescriptorCountAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) PassRef() (*C.VkDescriptorSetVariableDescriptorCountAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7969c9a7 != nil {
		return x.ref7969c9a7, nil
	}
	mem7969c9a7 := allocDescriptorSetVariableDescriptorCountAllocateInfoMemory(1)
	ref7969c9a7 := (*C.VkDescriptorSetVariableDescriptorCountAllocateInfo)(mem7969c9a7)
	allocs7969c9a7 := new(cgoAllocMap)
	allocs7969c9a7.Add(mem7969c9a7)

	var csType_allocs *cgoAllocMap
	ref7969c9a7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7969c9a7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7969c9a7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7969c9a7.Borrow(cpNext_allocs)

	var cdescriptorSetCount_allocs *cgoAllocMap
	ref7969c9a7.descriptorSetCount, cdescriptorSetCount_allocs = (C.uint32_t)(x.DescriptorSetCount), cgoAllocsUnknown
	allocs7969c9a7.Borrow(cdescriptorSetCount_allocs)

	var cpDescriptorCounts_allocs *cgoAllocMap
	ref7969c9a7.pDescriptorCounts, cpDescriptorCounts_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PDescriptorCounts)))
	allocs7969c9a7.Borrow(cpDescriptorCounts_allocs)

	x.ref7969c9a7 = ref7969c9a7
	x.allocs7969c9a7 = allocs7969c9a7
	return ref7969c9a7, allocs7969c9a7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) PassValue() (C.VkDescriptorSetVariableDescriptorCountAllocateInfo, *cgoAllocMap) {
	if x.ref7969c9a7 != nil {
		return *x.ref7969c9a7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) Deref() {
	if x.ref7969c9a7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7969c9a7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7969c9a7.pNext))
	x.DescriptorSetCount = (uint32)(x.ref7969c9a7.descriptorSetCount)
	hxff24242 := (*sliceHeader)(unsafe.Pointer(&x.PDescriptorCounts))
	hxff24242.Data = unsafe.Pointer(x.ref7969c9a7.pDescriptorCounts)
	hxff24242.Cap = 0x7fffffff
	// hxff24242.Len = ?

}

// allocDescriptorSetVariableDescriptorCountLayoutSupportMemory allocates memory for type C.VkDescriptorSetVariableDescriptorCountLayoutSupport in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetVariableDescriptorCountLayoutSupportMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetVariableDescriptorCountLayoutSupportValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorSetVariableDescriptorCountLayoutSupportValue = unsafe.Sizeof([1]C.VkDescriptorSetVariableDescriptorCountLayoutSupport{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetVariableDescriptorCountLayoutSupport) Ref() *C.VkDescriptorSetVariableDescriptorCountLayoutSupport {
	if x == nil {
		return nil
	}
	return x.refc584a0c6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetVariableDescriptorCountLayoutSupport) Free() {
	if x != nil && x.allocsc584a0c6 != nil {
		x.allocsc584a0c6.(*cgoAllocMap).Free()
		x.refc584a0c6 = nil
	}
}

// NewDescriptorSetVariableDescriptorCountLayoutSupportRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetVariableDescriptorCountLayoutSupportRef(ref unsafe.Pointer) *DescriptorSetVariableDescriptorCountLayoutSupport {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetVariableDescriptorCountLayoutSupport)
	obj.refc584a0c6 = (*C.VkDescriptorSetVariableDescriptorCountLayoutSupport)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetVariableDescriptorCountLayoutSupport) PassRef() (*C.VkDescriptorSetVariableDescriptorCountLayoutSupport, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc584a0c6 != nil {
		return x.refc584a0c6, nil
	}
	memc584a0c6 := allocDescriptorSetVariableDescriptorCountLayoutSupportMemory(1)
	refc584a0c6 := (*C.VkDescriptorSetVariableDescriptorCountLayoutSupport)(memc584a0c6)
	allocsc584a0c6 := new(cgoAllocMap)
	allocsc584a0c6.Add(memc584a0c6)

	var csType_allocs *cgoAllocMap
	refc584a0c6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc584a0c6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc584a0c6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc584a0c6.Borrow(cpNext_allocs)

	var cmaxVariableDescriptorCount_allocs *cgoAllocMap
	refc584a0c6.maxVariableDescriptorCount, cmaxVariableDescriptorCount_allocs = (C.uint32_t)(x.MaxVariableDescriptorCount), cgoAllocsUnknown
	allocsc584a0c6.Borrow(cmaxVariableDescriptorCount_allocs)

	x.refc584a0c6 = refc584a0c6
	x.allocsc584a0c6 = allocsc584a0c6
	return refc584a0c6, allocsc584a0c6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetVariableDescriptorCountLayoutSupport) PassValue() (C.VkDescriptorSetVariableDescriptorCountLayoutSupport, *cgoAllocMap) {
	if x.refc584a0c6 != nil {
		return *x.refc584a0c6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetVariableDescriptorCountLayoutSupport) Deref() {
	if x.refc584a0c6 == nil {
		return
	}
	x.SType = (StructureType)(x.refc584a0c6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc584a0c6.pNext))
	x.MaxVariableDescriptorCount = (uint32)(x.refc584a0c6.maxVariableDescriptorCount)
}

// allocSubpassDescriptionDepthStencilResolveMemory allocates memory for type C.VkSubpassDescriptionDepthStencilResolve in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDescriptionDepthStencilResolveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDescriptionDepthStencilResolveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubpassDescriptionDepthStencilResolveValue = unsafe.Sizeof([1]C.VkSubpassDescriptionDepthStencilResolve{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassDescriptionDepthStencilResolve) Ref() *C.VkSubpassDescriptionDepthStencilResolve {
	if x == nil {
		return nil
	}
	return x.refc46545a8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassDescriptionDepthStencilResolve) Free() {
	if x != nil && x.allocsc46545a8 != nil {
		x.allocsc46545a8.(*cgoAllocMap).Free()
		x.refc46545a8 = nil
	}
}

// NewSubpassDescriptionDepthStencilResolveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassDescriptionDepthStencilResolveRef(ref unsafe.Pointer) *SubpassDescriptionDepthStencilResolve {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDescriptionDepthStencilResolve)
	obj.refc46545a8 = (*C.VkSubpassDescriptionDepthStencilResolve)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassDescriptionDepthStencilResolve) PassRef() (*C.VkSubpassDescriptionDepthStencilResolve, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc46545a8 != nil {
		return x.refc46545a8, nil
	}
	memc46545a8 := allocSubpassDescriptionDepthStencilResolveMemory(1)
	refc46545a8 := (*C.VkSubpassDescriptionDepthStencilResolve)(memc46545a8)
	allocsc46545a8 := new(cgoAllocMap)
	allocsc46545a8.Add(memc46545a8)

	var csType_allocs *cgoAllocMap
	refc46545a8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc46545a8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc46545a8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc46545a8.Borrow(cpNext_allocs)

	var cdepthResolveMode_allocs *cgoAllocMap
	refc46545a8.depthResolveMode, cdepthResolveMode_allocs = (C.VkResolveModeFlagBits)(x.DepthResolveMode), cgoAllocsUnknown
	allocsc46545a8.Borrow(cdepthResolveMode_allocs)

	var cstencilResolveMode_allocs *cgoAllocMap
	refc46545a8.stencilResolveMode, cstencilResolveMode_allocs = (C.VkResolveModeFlagBits)(x.StencilResolveMode), cgoAllocsUnknown
	allocsc46545a8.Borrow(cstencilResolveMode_allocs)

	var cpDepthStencilResolveAttachment_allocs *cgoAllocMap
	refc46545a8.pDepthStencilResolveAttachment, cpDepthStencilResolveAttachment_allocs = unpackSAttachmentReference2(x.PDepthStencilResolveAttachment)
	allocsc46545a8.Borrow(cpDepthStencilResolveAttachment_allocs)

	x.refc46545a8 = refc46545a8
	x.allocsc46545a8 = allocsc46545a8
	return refc46545a8, allocsc46545a8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassDescriptionDepthStencilResolve) PassValue() (C.VkSubpassDescriptionDepthStencilResolve, *cgoAllocMap) {
	if x.refc46545a8 != nil {
		return *x.refc46545a8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassDescriptionDepthStencilResolve) Deref() {
	if x.refc46545a8 == nil {
		return
	}
	x.SType = (StructureType)(x.refc46545a8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc46545a8.pNext))
	x.DepthResolveMode = (ResolveModeFlagBits)(x.refc46545a8.depthResolveMode)
	x.StencilResolveMode = (ResolveModeFlagBits)(x.refc46545a8.stencilResolveMode)
	packSAttachmentReference2(x.PDepthStencilResolveAttachment, x.refc46545a8.pDepthStencilResolveAttachment)
}

// allocPhysicalDeviceDepthStencilResolvePropertiesMemory allocates memory for type C.VkPhysicalDeviceDepthStencilResolveProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDepthStencilResolvePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDepthStencilResolvePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceDepthStencilResolvePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDepthStencilResolveProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDepthStencilResolveProperties) Ref() *C.VkPhysicalDeviceDepthStencilResolveProperties {
	if x == nil {
		return nil
	}
	return x.refc9f61da9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDepthStencilResolveProperties) Free() {
	if x != nil && x.allocsc9f61da9 != nil {
		x.allocsc9f61da9.(*cgoAllocMap).Free()
		x.refc9f61da9 = nil
	}
}

// NewPhysicalDeviceDepthStencilResolvePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDepthStencilResolvePropertiesRef(ref unsafe.Pointer) *PhysicalDeviceDepthStencilResolveProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDepthStencilResolveProperties)
	obj.refc9f61da9 = (*C.VkPhysicalDeviceDepthStencilResolveProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDepthStencilResolveProperties) PassRef() (*C.VkPhysicalDeviceDepthStencilResolveProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc9f61da9 != nil {
		return x.refc9f61da9, nil
	}
	memc9f61da9 := allocPhysicalDeviceDepthStencilResolvePropertiesMemory(1)
	refc9f61da9 := (*C.VkPhysicalDeviceDepthStencilResolveProperties)(memc9f61da9)
	allocsc9f61da9 := new(cgoAllocMap)
	allocsc9f61da9.Add(memc9f61da9)

	var csType_allocs *cgoAllocMap
	refc9f61da9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc9f61da9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc9f61da9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc9f61da9.Borrow(cpNext_allocs)

	var csupportedDepthResolveModes_allocs *cgoAllocMap
	refc9f61da9.supportedDepthResolveModes, csupportedDepthResolveModes_allocs = (C.VkResolveModeFlags)(x.SupportedDepthResolveModes), cgoAllocsUnknown
	allocsc9f61da9.Borrow(csupportedDepthResolveModes_allocs)

	var csupportedStencilResolveModes_allocs *cgoAllocMap
	refc9f61da9.supportedStencilResolveModes, csupportedStencilResolveModes_allocs = (C.VkResolveModeFlags)(x.SupportedStencilResolveModes), cgoAllocsUnknown
	allocsc9f61da9.Borrow(csupportedStencilResolveModes_allocs)

	var cindependentResolveNone_allocs *cgoAllocMap
	refc9f61da9.independentResolveNone, cindependentResolveNone_allocs = (C.VkBool32)(x.IndependentResolveNone), cgoAllocsUnknown
	allocsc9f61da9.Borrow(cindependentResolveNone_allocs)

	var cindependentResolve_allocs *cgoAllocMap
	refc9f61da9.independentResolve, cindependentResolve_allocs = (C.VkBool32)(x.IndependentResolve), cgoAllocsUnknown
	allocsc9f61da9.Borrow(cindependentResolve_allocs)

	x.refc9f61da9 = refc9f61da9
	x.allocsc9f61da9 = allocsc9f61da9
	return refc9f61da9, allocsc9f61da9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDepthStencilResolveProperties) PassValue() (C.VkPhysicalDeviceDepthStencilResolveProperties, *cgoAllocMap) {
	if x.refc9f61da9 != nil {
		return *x.refc9f61da9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDepthStencilResolveProperties) Deref() {
	if x.refc9f61da9 == nil {
		return
	}
	x.SType = (StructureType)(x.refc9f61da9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc9f61da9.pNext))
	x.SupportedDepthResolveModes = (ResolveModeFlags)(x.refc9f61da9.supportedDepthResolveModes)
	x.SupportedStencilResolveModes = (ResolveModeFlags)(x.refc9f61da9.supportedStencilResolveModes)
	x.IndependentResolveNone = (Bool32)(x.refc9f61da9.independentResolveNone)
	x.IndependentResolve = (Bool32)(x.refc9f61da9.independentResolve)
}

// allocPhysicalDeviceScalarBlockLayoutFeaturesMemory allocates memory for type C.VkPhysicalDeviceScalarBlockLayoutFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceScalarBlockLayoutFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceScalarBlockLayoutFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceScalarBlockLayoutFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceScalarBlockLayoutFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceScalarBlockLayoutFeatures) Ref() *C.VkPhysicalDeviceScalarBlockLayoutFeatures {
	if x == nil {
		return nil
	}
	return x.refbdf75616
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceScalarBlockLayoutFeatures) Free() {
	if x != nil && x.allocsbdf75616 != nil {
		x.allocsbdf75616.(*cgoAllocMap).Free()
		x.refbdf75616 = nil
	}
}

// NewPhysicalDeviceScalarBlockLayoutFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceScalarBlockLayoutFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceScalarBlockLayoutFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceScalarBlockLayoutFeatures)
	obj.refbdf75616 = (*C.VkPhysicalDeviceScalarBlockLayoutFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceScalarBlockLayoutFeatures) PassRef() (*C.VkPhysicalDeviceScalarBlockLayoutFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbdf75616 != nil {
		return x.refbdf75616, nil
	}
	membdf75616 := allocPhysicalDeviceScalarBlockLayoutFeaturesMemory(1)
	refbdf75616 := (*C.VkPhysicalDeviceScalarBlockLayoutFeatures)(membdf75616)
	allocsbdf75616 := new(cgoAllocMap)
	allocsbdf75616.Add(membdf75616)

	var csType_allocs *cgoAllocMap
	refbdf75616.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbdf75616.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbdf75616.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbdf75616.Borrow(cpNext_allocs)

	var cscalarBlockLayout_allocs *cgoAllocMap
	refbdf75616.scalarBlockLayout, cscalarBlockLayout_allocs = (C.VkBool32)(x.ScalarBlockLayout), cgoAllocsUnknown
	allocsbdf75616.Borrow(cscalarBlockLayout_allocs)

	x.refbdf75616 = refbdf75616
	x.allocsbdf75616 = allocsbdf75616
	return refbdf75616, allocsbdf75616

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceScalarBlockLayoutFeatures) PassValue() (C.VkPhysicalDeviceScalarBlockLayoutFeatures, *cgoAllocMap) {
	if x.refbdf75616 != nil {
		return *x.refbdf75616, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceScalarBlockLayoutFeatures) Deref() {
	if x.refbdf75616 == nil {
		return
	}
	x.SType = (StructureType)(x.refbdf75616.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbdf75616.pNext))
	x.ScalarBlockLayout = (Bool32)(x.refbdf75616.scalarBlockLayout)
}

// allocImageStencilUsageCreateInfoMemory allocates memory for type C.VkImageStencilUsageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageStencilUsageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageStencilUsageCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageStencilUsageCreateInfoValue = unsafe.Sizeof([1]C.VkImageStencilUsageCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageStencilUsageCreateInfo) Ref() *C.VkImageStencilUsageCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref32229fd9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageStencilUsageCreateInfo) Free() {
	if x != nil && x.allocs32229fd9 != nil {
		x.allocs32229fd9.(*cgoAllocMap).Free()
		x.ref32229fd9 = nil
	}
}

// NewImageStencilUsageCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageStencilUsageCreateInfoRef(ref unsafe.Pointer) *ImageStencilUsageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageStencilUsageCreateInfo)
	obj.ref32229fd9 = (*C.VkImageStencilUsageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageStencilUsageCreateInfo) PassRef() (*C.VkImageStencilUsageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref32229fd9 != nil {
		return x.ref32229fd9, nil
	}
	mem32229fd9 := allocImageStencilUsageCreateInfoMemory(1)
	ref32229fd9 := (*C.VkImageStencilUsageCreateInfo)(mem32229fd9)
	allocs32229fd9 := new(cgoAllocMap)
	allocs32229fd9.Add(mem32229fd9)

	var csType_allocs *cgoAllocMap
	ref32229fd9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs32229fd9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref32229fd9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs32229fd9.Borrow(cpNext_allocs)

	var cstencilUsage_allocs *cgoAllocMap
	ref32229fd9.stencilUsage, cstencilUsage_allocs = (C.VkImageUsageFlags)(x.StencilUsage), cgoAllocsUnknown
	allocs32229fd9.Borrow(cstencilUsage_allocs)

	x.ref32229fd9 = ref32229fd9
	x.allocs32229fd9 = allocs32229fd9
	return ref32229fd9, allocs32229fd9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageStencilUsageCreateInfo) PassValue() (C.VkImageStencilUsageCreateInfo, *cgoAllocMap) {
	if x.ref32229fd9 != nil {
		return *x.ref32229fd9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageStencilUsageCreateInfo) Deref() {
	if x.ref32229fd9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref32229fd9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref32229fd9.pNext))
	x.StencilUsage = (ImageUsageFlags)(x.ref32229fd9.stencilUsage)
}

// allocSamplerReductionModeCreateInfoMemory allocates memory for type C.VkSamplerReductionModeCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerReductionModeCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerReductionModeCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSamplerReductionModeCreateInfoValue = unsafe.Sizeof([1]C.VkSamplerReductionModeCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerReductionModeCreateInfo) Ref() *C.VkSamplerReductionModeCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref801424d0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerReductionModeCreateInfo) Free() {
	if x != nil && x.allocs801424d0 != nil {
		x.allocs801424d0.(*cgoAllocMap).Free()
		x.ref801424d0 = nil
	}
}

// NewSamplerReductionModeCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerReductionModeCreateInfoRef(ref unsafe.Pointer) *SamplerReductionModeCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SamplerReductionModeCreateInfo)
	obj.ref801424d0 = (*C.VkSamplerReductionModeCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerReductionModeCreateInfo) PassRef() (*C.VkSamplerReductionModeCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref801424d0 != nil {
		return x.ref801424d0, nil
	}
	mem801424d0 := allocSamplerReductionModeCreateInfoMemory(1)
	ref801424d0 := (*C.VkSamplerReductionModeCreateInfo)(mem801424d0)
	allocs801424d0 := new(cgoAllocMap)
	allocs801424d0.Add(mem801424d0)

	var csType_allocs *cgoAllocMap
	ref801424d0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs801424d0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref801424d0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs801424d0.Borrow(cpNext_allocs)

	var creductionMode_allocs *cgoAllocMap
	ref801424d0.reductionMode, creductionMode_allocs = (C.VkSamplerReductionMode)(x.ReductionMode), cgoAllocsUnknown
	allocs801424d0.Borrow(creductionMode_allocs)

	x.ref801424d0 = ref801424d0
	x.allocs801424d0 = allocs801424d0
	return ref801424d0, allocs801424d0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerReductionModeCreateInfo) PassValue() (C.VkSamplerReductionModeCreateInfo, *cgoAllocMap) {
	if x.ref801424d0 != nil {
		return *x.ref801424d0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerReductionModeCreateInfo) Deref() {
	if x.ref801424d0 == nil {
		return
	}
	x.SType = (StructureType)(x.ref801424d0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref801424d0.pNext))
	x.ReductionMode = (SamplerReductionMode)(x.ref801424d0.reductionMode)
}

// allocPhysicalDeviceSamplerFilterMinmaxPropertiesMemory allocates memory for type C.VkPhysicalDeviceSamplerFilterMinmaxProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSamplerFilterMinmaxPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSamplerFilterMinmaxPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceSamplerFilterMinmaxPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSamplerFilterMinmaxProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSamplerFilterMinmaxProperties) Ref() *C.VkPhysicalDeviceSamplerFilterMinmaxProperties {
	if x == nil {
		return nil
	}
	return x.ref69bbe609
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSamplerFilterMinmaxProperties) Free() {
	if x != nil && x.allocs69bbe609 != nil {
		x.allocs69bbe609.(*cgoAllocMap).Free()
		x.ref69bbe609 = nil
	}
}

// NewPhysicalDeviceSamplerFilterMinmaxPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSamplerFilterMinmaxPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceSamplerFilterMinmaxProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSamplerFilterMinmaxProperties)
	obj.ref69bbe609 = (*C.VkPhysicalDeviceSamplerFilterMinmaxProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSamplerFilterMinmaxProperties) PassRef() (*C.VkPhysicalDeviceSamplerFilterMinmaxProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref69bbe609 != nil {
		return x.ref69bbe609, nil
	}
	mem69bbe609 := allocPhysicalDeviceSamplerFilterMinmaxPropertiesMemory(1)
	ref69bbe609 := (*C.VkPhysicalDeviceSamplerFilterMinmaxProperties)(mem69bbe609)
	allocs69bbe609 := new(cgoAllocMap)
	allocs69bbe609.Add(mem69bbe609)

	var csType_allocs *cgoAllocMap
	ref69bbe609.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs69bbe609.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref69bbe609.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs69bbe609.Borrow(cpNext_allocs)

	var cfilterMinmaxSingleComponentFormats_allocs *cgoAllocMap
	ref69bbe609.filterMinmaxSingleComponentFormats, cfilterMinmaxSingleComponentFormats_allocs = (C.VkBool32)(x.FilterMinmaxSingleComponentFormats), cgoAllocsUnknown
	allocs69bbe609.Borrow(cfilterMinmaxSingleComponentFormats_allocs)

	var cfilterMinmaxImageComponentMapping_allocs *cgoAllocMap
	ref69bbe609.filterMinmaxImageComponentMapping, cfilterMinmaxImageComponentMapping_allocs = (C.VkBool32)(x.FilterMinmaxImageComponentMapping), cgoAllocsUnknown
	allocs69bbe609.Borrow(cfilterMinmaxImageComponentMapping_allocs)

	x.ref69bbe609 = ref69bbe609
	x.allocs69bbe609 = allocs69bbe609
	return ref69bbe609, allocs69bbe609

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSamplerFilterMinmaxProperties) PassValue() (C.VkPhysicalDeviceSamplerFilterMinmaxProperties, *cgoAllocMap) {
	if x.ref69bbe609 != nil {
		return *x.ref69bbe609, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSamplerFilterMinmaxProperties) Deref() {
	if x.ref69bbe609 == nil {
		return
	}
	x.SType = (StructureType)(x.ref69bbe609.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref69bbe609.pNext))
	x.FilterMinmaxSingleComponentFormats = (Bool32)(x.ref69bbe609.filterMinmaxSingleComponentFormats)
	x.FilterMinmaxImageComponentMapping = (Bool32)(x.ref69bbe609.filterMinmaxImageComponentMapping)
}

// allocPhysicalDeviceVulkanMemoryModelFeaturesMemory allocates memory for type C.VkPhysicalDeviceVulkanMemoryModelFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVulkanMemoryModelFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVulkanMemoryModelFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceVulkanMemoryModelFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVulkanMemoryModelFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVulkanMemoryModelFeatures) Ref() *C.VkPhysicalDeviceVulkanMemoryModelFeatures {
	if x == nil {
		return nil
	}
	return x.refedb93263
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVulkanMemoryModelFeatures) Free() {
	if x != nil && x.allocsedb93263 != nil {
		x.allocsedb93263.(*cgoAllocMap).Free()
		x.refedb93263 = nil
	}
}

// NewPhysicalDeviceVulkanMemoryModelFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVulkanMemoryModelFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceVulkanMemoryModelFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVulkanMemoryModelFeatures)
	obj.refedb93263 = (*C.VkPhysicalDeviceVulkanMemoryModelFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVulkanMemoryModelFeatures) PassRef() (*C.VkPhysicalDeviceVulkanMemoryModelFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refedb93263 != nil {
		return x.refedb93263, nil
	}
	memedb93263 := allocPhysicalDeviceVulkanMemoryModelFeaturesMemory(1)
	refedb93263 := (*C.VkPhysicalDeviceVulkanMemoryModelFeatures)(memedb93263)
	allocsedb93263 := new(cgoAllocMap)
	allocsedb93263.Add(memedb93263)

	var csType_allocs *cgoAllocMap
	refedb93263.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsedb93263.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refedb93263.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsedb93263.Borrow(cpNext_allocs)

	var cvulkanMemoryModel_allocs *cgoAllocMap
	refedb93263.vulkanMemoryModel, cvulkanMemoryModel_allocs = (C.VkBool32)(x.VulkanMemoryModel), cgoAllocsUnknown
	allocsedb93263.Borrow(cvulkanMemoryModel_allocs)

	var cvulkanMemoryModelDeviceScope_allocs *cgoAllocMap
	refedb93263.vulkanMemoryModelDeviceScope, cvulkanMemoryModelDeviceScope_allocs = (C.VkBool32)(x.VulkanMemoryModelDeviceScope), cgoAllocsUnknown
	allocsedb93263.Borrow(cvulkanMemoryModelDeviceScope_allocs)

	var cvulkanMemoryModelAvailabilityVisibilityChains_allocs *cgoAllocMap
	refedb93263.vulkanMemoryModelAvailabilityVisibilityChains, cvulkanMemoryModelAvailabilityVisibilityChains_allocs = (C.VkBool32)(x.VulkanMemoryModelAvailabilityVisibilityChains), cgoAllocsUnknown
	allocsedb93263.Borrow(cvulkanMemoryModelAvailabilityVisibilityChains_allocs)

	x.refedb93263 = refedb93263
	x.allocsedb93263 = allocsedb93263
	return refedb93263, allocsedb93263

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVulkanMemoryModelFeatures) PassValue() (C.VkPhysicalDeviceVulkanMemoryModelFeatures, *cgoAllocMap) {
	if x.refedb93263 != nil {
		return *x.refedb93263, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVulkanMemoryModelFeatures) Deref() {
	if x.refedb93263 == nil {
		return
	}
	x.SType = (StructureType)(x.refedb93263.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refedb93263.pNext))
	x.VulkanMemoryModel = (Bool32)(x.refedb93263.vulkanMemoryModel)
	x.VulkanMemoryModelDeviceScope = (Bool32)(x.refedb93263.vulkanMemoryModelDeviceScope)
	x.VulkanMemoryModelAvailabilityVisibilityChains = (Bool32)(x.refedb93263.vulkanMemoryModelAvailabilityVisibilityChains)
}

// allocPhysicalDeviceImagelessFramebufferFeaturesMemory allocates memory for type C.VkPhysicalDeviceImagelessFramebufferFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceImagelessFramebufferFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceImagelessFramebufferFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceImagelessFramebufferFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceImagelessFramebufferFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceImagelessFramebufferFeatures) Ref() *C.VkPhysicalDeviceImagelessFramebufferFeatures {
	if x == nil {
		return nil
	}
	return x.refcd561baf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceImagelessFramebufferFeatures) Free() {
	if x != nil && x.allocscd561baf != nil {
		x.allocscd561baf.(*cgoAllocMap).Free()
		x.refcd561baf = nil
	}
}

// NewPhysicalDeviceImagelessFramebufferFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceImagelessFramebufferFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceImagelessFramebufferFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceImagelessFramebufferFeatures)
	obj.refcd561baf = (*C.VkPhysicalDeviceImagelessFramebufferFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceImagelessFramebufferFeatures) PassRef() (*C.VkPhysicalDeviceImagelessFramebufferFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcd561baf != nil {
		return x.refcd561baf, nil
	}
	memcd561baf := allocPhysicalDeviceImagelessFramebufferFeaturesMemory(1)
	refcd561baf := (*C.VkPhysicalDeviceImagelessFramebufferFeatures)(memcd561baf)
	allocscd561baf := new(cgoAllocMap)
	allocscd561baf.Add(memcd561baf)

	var csType_allocs *cgoAllocMap
	refcd561baf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscd561baf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcd561baf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscd561baf.Borrow(cpNext_allocs)

	var cimagelessFramebuffer_allocs *cgoAllocMap
	refcd561baf.imagelessFramebuffer, cimagelessFramebuffer_allocs = (C.VkBool32)(x.ImagelessFramebuffer), cgoAllocsUnknown
	allocscd561baf.Borrow(cimagelessFramebuffer_allocs)

	x.refcd561baf = refcd561baf
	x.allocscd561baf = allocscd561baf
	return refcd561baf, allocscd561baf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceImagelessFramebufferFeatures) PassValue() (C.VkPhysicalDeviceImagelessFramebufferFeatures, *cgoAllocMap) {
	if x.refcd561baf != nil {
		return *x.refcd561baf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceImagelessFramebufferFeatures) Deref() {
	if x.refcd561baf == nil {
		return
	}
	x.SType = (StructureType)(x.refcd561baf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcd561baf.pNext))
	x.ImagelessFramebuffer = (Bool32)(x.refcd561baf.imagelessFramebuffer)
}

// allocFramebufferAttachmentImageInfoMemory allocates memory for type C.VkFramebufferAttachmentImageInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFramebufferAttachmentImageInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFramebufferAttachmentImageInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFramebufferAttachmentImageInfoValue = unsafe.Sizeof([1]C.VkFramebufferAttachmentImageInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FramebufferAttachmentImageInfo) Ref() *C.VkFramebufferAttachmentImageInfo {
	if x == nil {
		return nil
	}
	return x.refe569691c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FramebufferAttachmentImageInfo) Free() {
	if x != nil && x.allocse569691c != nil {
		x.allocse569691c.(*cgoAllocMap).Free()
		x.refe569691c = nil
	}
}

// NewFramebufferAttachmentImageInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFramebufferAttachmentImageInfoRef(ref unsafe.Pointer) *FramebufferAttachmentImageInfo {
	if ref == nil {
		return nil
	}
	obj := new(FramebufferAttachmentImageInfo)
	obj.refe569691c = (*C.VkFramebufferAttachmentImageInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FramebufferAttachmentImageInfo) PassRef() (*C.VkFramebufferAttachmentImageInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe569691c != nil {
		return x.refe569691c, nil
	}
	meme569691c := allocFramebufferAttachmentImageInfoMemory(1)
	refe569691c := (*C.VkFramebufferAttachmentImageInfo)(meme569691c)
	allocse569691c := new(cgoAllocMap)
	allocse569691c.Add(meme569691c)

	var csType_allocs *cgoAllocMap
	refe569691c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse569691c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe569691c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse569691c.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refe569691c.flags, cflags_allocs = (C.VkImageCreateFlags)(x.Flags), cgoAllocsUnknown
	allocse569691c.Borrow(cflags_allocs)

	var cusage_allocs *cgoAllocMap
	refe569691c.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocse569691c.Borrow(cusage_allocs)

	var cwidth_allocs *cgoAllocMap
	refe569691c.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocse569691c.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refe569691c.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocse569691c.Borrow(cheight_allocs)

	var clayerCount_allocs *cgoAllocMap
	refe569691c.layerCount, clayerCount_allocs = (C.uint32_t)(x.LayerCount), cgoAllocsUnknown
	allocse569691c.Borrow(clayerCount_allocs)

	var cviewFormatCount_allocs *cgoAllocMap
	refe569691c.viewFormatCount, cviewFormatCount_allocs = (C.uint32_t)(x.ViewFormatCount), cgoAllocsUnknown
	allocse569691c.Borrow(cviewFormatCount_allocs)

	var cpViewFormats_allocs *cgoAllocMap
	refe569691c.pViewFormats, cpViewFormats_allocs = copyPFormatBytes((*sliceHeader)(unsafe.Pointer(&x.PViewFormats)))
	allocse569691c.Borrow(cpViewFormats_allocs)

	x.refe569691c = refe569691c
	x.allocse569691c = allocse569691c
	return refe569691c, allocse569691c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FramebufferAttachmentImageInfo) PassValue() (C.VkFramebufferAttachmentImageInfo, *cgoAllocMap) {
	if x.refe569691c != nil {
		return *x.refe569691c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FramebufferAttachmentImageInfo) Deref() {
	if x.refe569691c == nil {
		return
	}
	x.SType = (StructureType)(x.refe569691c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe569691c.pNext))
	x.Flags = (ImageCreateFlags)(x.refe569691c.flags)
	x.Usage = (ImageUsageFlags)(x.refe569691c.usage)
	x.Width = (uint32)(x.refe569691c.width)
	x.Height = (uint32)(x.refe569691c.height)
	x.LayerCount = (uint32)(x.refe569691c.layerCount)
	x.ViewFormatCount = (uint32)(x.refe569691c.viewFormatCount)
	hxfe93325 := (*sliceHeader)(unsafe.Pointer(&x.PViewFormats))
	hxfe93325.Data = unsafe.Pointer(x.refe569691c.pViewFormats)
	hxfe93325.Cap = 0x7fffffff
	// hxfe93325.Len = ?

}

// allocFramebufferAttachmentsCreateInfoMemory allocates memory for type C.VkFramebufferAttachmentsCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFramebufferAttachmentsCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFramebufferAttachmentsCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFramebufferAttachmentsCreateInfoValue = unsafe.Sizeof([1]C.VkFramebufferAttachmentsCreateInfo{})

// unpackSFramebufferAttachmentImageInfo transforms a sliced Go data structure into plain C format.
func unpackSFramebufferAttachmentImageInfo(x []FramebufferAttachmentImageInfo) (unpacked *C.VkFramebufferAttachmentImageInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocFramebufferAttachmentImageInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkFramebufferAttachmentImageInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkFramebufferAttachmentImageInfo)(h.Data)
	return
}

// packSFramebufferAttachmentImageInfo reads sliced Go data structure out from plain C format.
func packSFramebufferAttachmentImageInfo(v []FramebufferAttachmentImageInfo, ptr0 *C.VkFramebufferAttachmentImageInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFramebufferAttachmentImageInfoValue]C.VkFramebufferAttachmentImageInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFramebufferAttachmentImageInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FramebufferAttachmentsCreateInfo) Ref() *C.VkFramebufferAttachmentsCreateInfo {
	if x == nil {
		return nil
	}
	return x.reff3bb4ec3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FramebufferAttachmentsCreateInfo) Free() {
	if x != nil && x.allocsf3bb4ec3 != nil {
		x.allocsf3bb4ec3.(*cgoAllocMap).Free()
		x.reff3bb4ec3 = nil
	}
}

// NewFramebufferAttachmentsCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFramebufferAttachmentsCreateInfoRef(ref unsafe.Pointer) *FramebufferAttachmentsCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(FramebufferAttachmentsCreateInfo)
	obj.reff3bb4ec3 = (*C.VkFramebufferAttachmentsCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FramebufferAttachmentsCreateInfo) PassRef() (*C.VkFramebufferAttachmentsCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff3bb4ec3 != nil {
		return x.reff3bb4ec3, nil
	}
	memf3bb4ec3 := allocFramebufferAttachmentsCreateInfoMemory(1)
	reff3bb4ec3 := (*C.VkFramebufferAttachmentsCreateInfo)(memf3bb4ec3)
	allocsf3bb4ec3 := new(cgoAllocMap)
	allocsf3bb4ec3.Add(memf3bb4ec3)

	var csType_allocs *cgoAllocMap
	reff3bb4ec3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf3bb4ec3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff3bb4ec3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf3bb4ec3.Borrow(cpNext_allocs)

	var cattachmentImageInfoCount_allocs *cgoAllocMap
	reff3bb4ec3.attachmentImageInfoCount, cattachmentImageInfoCount_allocs = (C.uint32_t)(x.AttachmentImageInfoCount), cgoAllocsUnknown
	allocsf3bb4ec3.Borrow(cattachmentImageInfoCount_allocs)

	var cpAttachmentImageInfos_allocs *cgoAllocMap
	reff3bb4ec3.pAttachmentImageInfos, cpAttachmentImageInfos_allocs = unpackSFramebufferAttachmentImageInfo(x.PAttachmentImageInfos)
	allocsf3bb4ec3.Borrow(cpAttachmentImageInfos_allocs)

	x.reff3bb4ec3 = reff3bb4ec3
	x.allocsf3bb4ec3 = allocsf3bb4ec3
	return reff3bb4ec3, allocsf3bb4ec3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FramebufferAttachmentsCreateInfo) PassValue() (C.VkFramebufferAttachmentsCreateInfo, *cgoAllocMap) {
	if x.reff3bb4ec3 != nil {
		return *x.reff3bb4ec3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FramebufferAttachmentsCreateInfo) Deref() {
	if x.reff3bb4ec3 == nil {
		return
	}
	x.SType = (StructureType)(x.reff3bb4ec3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff3bb4ec3.pNext))
	x.AttachmentImageInfoCount = (uint32)(x.reff3bb4ec3.attachmentImageInfoCount)
	packSFramebufferAttachmentImageInfo(x.PAttachmentImageInfos, x.reff3bb4ec3.pAttachmentImageInfos)
}

// allocRenderPassAttachmentBeginInfoMemory allocates memory for type C.VkRenderPassAttachmentBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassAttachmentBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassAttachmentBeginInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderPassAttachmentBeginInfoValue = unsafe.Sizeof([1]C.VkRenderPassAttachmentBeginInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassAttachmentBeginInfo) Ref() *C.VkRenderPassAttachmentBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref5c976537
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassAttachmentBeginInfo) Free() {
	if x != nil && x.allocs5c976537 != nil {
		x.allocs5c976537.(*cgoAllocMap).Free()
		x.ref5c976537 = nil
	}
}

// NewRenderPassAttachmentBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassAttachmentBeginInfoRef(ref unsafe.Pointer) *RenderPassAttachmentBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassAttachmentBeginInfo)
	obj.ref5c976537 = (*C.VkRenderPassAttachmentBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassAttachmentBeginInfo) PassRef() (*C.VkRenderPassAttachmentBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5c976537 != nil {
		return x.ref5c976537, nil
	}
	mem5c976537 := allocRenderPassAttachmentBeginInfoMemory(1)
	ref5c976537 := (*C.VkRenderPassAttachmentBeginInfo)(mem5c976537)
	allocs5c976537 := new(cgoAllocMap)
	allocs5c976537.Add(mem5c976537)

	var csType_allocs *cgoAllocMap
	ref5c976537.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5c976537.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5c976537.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5c976537.Borrow(cpNext_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	ref5c976537.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocs5c976537.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	ref5c976537.pAttachments, cpAttachments_allocs = copyPImageViewBytes((*sliceHeader)(unsafe.Pointer(&x.PAttachments)))
	allocs5c976537.Borrow(cpAttachments_allocs)

	x.ref5c976537 = ref5c976537
	x.allocs5c976537 = allocs5c976537
	return ref5c976537, allocs5c976537

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassAttachmentBeginInfo) PassValue() (C.VkRenderPassAttachmentBeginInfo, *cgoAllocMap) {
	if x.ref5c976537 != nil {
		return *x.ref5c976537, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassAttachmentBeginInfo) Deref() {
	if x.ref5c976537 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5c976537.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5c976537.pNext))
	x.AttachmentCount = (uint32)(x.ref5c976537.attachmentCount)
	hxf09ea94 := (*sliceHeader)(unsafe.Pointer(&x.PAttachments))
	hxf09ea94.Data = unsafe.Pointer(x.ref5c976537.pAttachments)
	hxf09ea94.Cap = 0x7fffffff
	// hxf09ea94.Len = ?

}

// allocPhysicalDeviceUniformBufferStandardLayoutFeaturesMemory allocates memory for type C.VkPhysicalDeviceUniformBufferStandardLayoutFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceUniformBufferStandardLayoutFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceUniformBufferStandardLayoutFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceUniformBufferStandardLayoutFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceUniformBufferStandardLayoutFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceUniformBufferStandardLayoutFeatures) Ref() *C.VkPhysicalDeviceUniformBufferStandardLayoutFeatures {
	if x == nil {
		return nil
	}
	return x.refda381ec5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceUniformBufferStandardLayoutFeatures) Free() {
	if x != nil && x.allocsda381ec5 != nil {
		x.allocsda381ec5.(*cgoAllocMap).Free()
		x.refda381ec5 = nil
	}
}

// NewPhysicalDeviceUniformBufferStandardLayoutFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceUniformBufferStandardLayoutFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceUniformBufferStandardLayoutFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceUniformBufferStandardLayoutFeatures)
	obj.refda381ec5 = (*C.VkPhysicalDeviceUniformBufferStandardLayoutFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceUniformBufferStandardLayoutFeatures) PassRef() (*C.VkPhysicalDeviceUniformBufferStandardLayoutFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refda381ec5 != nil {
		return x.refda381ec5, nil
	}
	memda381ec5 := allocPhysicalDeviceUniformBufferStandardLayoutFeaturesMemory(1)
	refda381ec5 := (*C.VkPhysicalDeviceUniformBufferStandardLayoutFeatures)(memda381ec5)
	allocsda381ec5 := new(cgoAllocMap)
	allocsda381ec5.Add(memda381ec5)

	var csType_allocs *cgoAllocMap
	refda381ec5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsda381ec5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refda381ec5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsda381ec5.Borrow(cpNext_allocs)

	var cuniformBufferStandardLayout_allocs *cgoAllocMap
	refda381ec5.uniformBufferStandardLayout, cuniformBufferStandardLayout_allocs = (C.VkBool32)(x.UniformBufferStandardLayout), cgoAllocsUnknown
	allocsda381ec5.Borrow(cuniformBufferStandardLayout_allocs)

	x.refda381ec5 = refda381ec5
	x.allocsda381ec5 = allocsda381ec5
	return refda381ec5, allocsda381ec5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) PassValue() (C.VkPhysicalDeviceUniformBufferStandardLayoutFeatures, *cgoAllocMap) {
	if x.refda381ec5 != nil {
		return *x.refda381ec5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceUniformBufferStandardLayoutFeatures) Deref() {
	if x.refda381ec5 == nil {
		return
	}
	x.SType = (StructureType)(x.refda381ec5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refda381ec5.pNext))
	x.UniformBufferStandardLayout = (Bool32)(x.refda381ec5.uniformBufferStandardLayout)
}

// allocPhysicalDeviceShaderSubgroupExtendedTypesFeaturesMemory allocates memory for type C.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderSubgroupExtendedTypesFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderSubgroupExtendedTypesFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShaderSubgroupExtendedTypesFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderSubgroupExtendedTypesFeatures) Ref() *C.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	if x == nil {
		return nil
	}
	return x.ref3bdcd2a2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderSubgroupExtendedTypesFeatures) Free() {
	if x != nil && x.allocs3bdcd2a2 != nil {
		x.allocs3bdcd2a2.(*cgoAllocMap).Free()
		x.ref3bdcd2a2 = nil
	}
}

// NewPhysicalDeviceShaderSubgroupExtendedTypesFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderSubgroupExtendedTypesFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderSubgroupExtendedTypesFeatures)
	obj.ref3bdcd2a2 = (*C.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderSubgroupExtendedTypesFeatures) PassRef() (*C.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3bdcd2a2 != nil {
		return x.ref3bdcd2a2, nil
	}
	mem3bdcd2a2 := allocPhysicalDeviceShaderSubgroupExtendedTypesFeaturesMemory(1)
	ref3bdcd2a2 := (*C.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures)(mem3bdcd2a2)
	allocs3bdcd2a2 := new(cgoAllocMap)
	allocs3bdcd2a2.Add(mem3bdcd2a2)

	var csType_allocs *cgoAllocMap
	ref3bdcd2a2.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3bdcd2a2.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3bdcd2a2.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3bdcd2a2.Borrow(cpNext_allocs)

	var cshaderSubgroupExtendedTypes_allocs *cgoAllocMap
	ref3bdcd2a2.shaderSubgroupExtendedTypes, cshaderSubgroupExtendedTypes_allocs = (C.VkBool32)(x.ShaderSubgroupExtendedTypes), cgoAllocsUnknown
	allocs3bdcd2a2.Borrow(cshaderSubgroupExtendedTypes_allocs)

	x.ref3bdcd2a2 = ref3bdcd2a2
	x.allocs3bdcd2a2 = allocs3bdcd2a2
	return ref3bdcd2a2, allocs3bdcd2a2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) PassValue() (C.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, *cgoAllocMap) {
	if x.ref3bdcd2a2 != nil {
		return *x.ref3bdcd2a2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderSubgroupExtendedTypesFeatures) Deref() {
	if x.ref3bdcd2a2 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3bdcd2a2.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3bdcd2a2.pNext))
	x.ShaderSubgroupExtendedTypes = (Bool32)(x.ref3bdcd2a2.shaderSubgroupExtendedTypes)
}

// allocPhysicalDeviceSeparateDepthStencilLayoutsFeaturesMemory allocates memory for type C.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSeparateDepthStencilLayoutsFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSeparateDepthStencilLayoutsFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceSeparateDepthStencilLayoutsFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSeparateDepthStencilLayoutsFeatures) Ref() *C.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	if x == nil {
		return nil
	}
	return x.ref7974377f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSeparateDepthStencilLayoutsFeatures) Free() {
	if x != nil && x.allocs7974377f != nil {
		x.allocs7974377f.(*cgoAllocMap).Free()
		x.ref7974377f = nil
	}
}

// NewPhysicalDeviceSeparateDepthStencilLayoutsFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSeparateDepthStencilLayoutsFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSeparateDepthStencilLayoutsFeatures)
	obj.ref7974377f = (*C.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSeparateDepthStencilLayoutsFeatures) PassRef() (*C.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7974377f != nil {
		return x.ref7974377f, nil
	}
	mem7974377f := allocPhysicalDeviceSeparateDepthStencilLayoutsFeaturesMemory(1)
	ref7974377f := (*C.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures)(mem7974377f)
	allocs7974377f := new(cgoAllocMap)
	allocs7974377f.Add(mem7974377f)

	var csType_allocs *cgoAllocMap
	ref7974377f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7974377f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7974377f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7974377f.Borrow(cpNext_allocs)

	var cseparateDepthStencilLayouts_allocs *cgoAllocMap
	ref7974377f.separateDepthStencilLayouts, cseparateDepthStencilLayouts_allocs = (C.VkBool32)(x.SeparateDepthStencilLayouts), cgoAllocsUnknown
	allocs7974377f.Borrow(cseparateDepthStencilLayouts_allocs)

	x.ref7974377f = ref7974377f
	x.allocs7974377f = allocs7974377f
	return ref7974377f, allocs7974377f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) PassValue() (C.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, *cgoAllocMap) {
	if x.ref7974377f != nil {
		return *x.ref7974377f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSeparateDepthStencilLayoutsFeatures) Deref() {
	if x.ref7974377f == nil {
		return
	}
	x.SType = (StructureType)(x.ref7974377f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7974377f.pNext))
	x.SeparateDepthStencilLayouts = (Bool32)(x.ref7974377f.separateDepthStencilLayouts)
}

// allocAttachmentReferenceStencilLayoutMemory allocates memory for type C.VkAttachmentReferenceStencilLayout in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentReferenceStencilLayoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentReferenceStencilLayoutValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAttachmentReferenceStencilLayoutValue = unsafe.Sizeof([1]C.VkAttachmentReferenceStencilLayout{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentReferenceStencilLayout) Ref() *C.VkAttachmentReferenceStencilLayout {
	if x == nil {
		return nil
	}
	return x.refb936264a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentReferenceStencilLayout) Free() {
	if x != nil && x.allocsb936264a != nil {
		x.allocsb936264a.(*cgoAllocMap).Free()
		x.refb936264a = nil
	}
}

// NewAttachmentReferenceStencilLayoutRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentReferenceStencilLayoutRef(ref unsafe.Pointer) *AttachmentReferenceStencilLayout {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentReferenceStencilLayout)
	obj.refb936264a = (*C.VkAttachmentReferenceStencilLayout)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentReferenceStencilLayout) PassRef() (*C.VkAttachmentReferenceStencilLayout, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb936264a != nil {
		return x.refb936264a, nil
	}
	memb936264a := allocAttachmentReferenceStencilLayoutMemory(1)
	refb936264a := (*C.VkAttachmentReferenceStencilLayout)(memb936264a)
	allocsb936264a := new(cgoAllocMap)
	allocsb936264a.Add(memb936264a)

	var csType_allocs *cgoAllocMap
	refb936264a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb936264a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb936264a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb936264a.Borrow(cpNext_allocs)

	var cstencilLayout_allocs *cgoAllocMap
	refb936264a.stencilLayout, cstencilLayout_allocs = (C.VkImageLayout)(x.StencilLayout), cgoAllocsUnknown
	allocsb936264a.Borrow(cstencilLayout_allocs)

	x.refb936264a = refb936264a
	x.allocsb936264a = allocsb936264a
	return refb936264a, allocsb936264a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentReferenceStencilLayout) PassValue() (C.VkAttachmentReferenceStencilLayout, *cgoAllocMap) {
	if x.refb936264a != nil {
		return *x.refb936264a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentReferenceStencilLayout) Deref() {
	if x.refb936264a == nil {
		return
	}
	x.SType = (StructureType)(x.refb936264a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb936264a.pNext))
	x.StencilLayout = (ImageLayout)(x.refb936264a.stencilLayout)
}

// allocAttachmentDescriptionStencilLayoutMemory allocates memory for type C.VkAttachmentDescriptionStencilLayout in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentDescriptionStencilLayoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentDescriptionStencilLayoutValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAttachmentDescriptionStencilLayoutValue = unsafe.Sizeof([1]C.VkAttachmentDescriptionStencilLayout{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentDescriptionStencilLayout) Ref() *C.VkAttachmentDescriptionStencilLayout {
	if x == nil {
		return nil
	}
	return x.refc8065ded
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentDescriptionStencilLayout) Free() {
	if x != nil && x.allocsc8065ded != nil {
		x.allocsc8065ded.(*cgoAllocMap).Free()
		x.refc8065ded = nil
	}
}

// NewAttachmentDescriptionStencilLayoutRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentDescriptionStencilLayoutRef(ref unsafe.Pointer) *AttachmentDescriptionStencilLayout {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentDescriptionStencilLayout)
	obj.refc8065ded = (*C.VkAttachmentDescriptionStencilLayout)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentDescriptionStencilLayout) PassRef() (*C.VkAttachmentDescriptionStencilLayout, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc8065ded != nil {
		return x.refc8065ded, nil
	}
	memc8065ded := allocAttachmentDescriptionStencilLayoutMemory(1)
	refc8065ded := (*C.VkAttachmentDescriptionStencilLayout)(memc8065ded)
	allocsc8065ded := new(cgoAllocMap)
	allocsc8065ded.Add(memc8065ded)

	var csType_allocs *cgoAllocMap
	refc8065ded.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc8065ded.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc8065ded.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc8065ded.Borrow(cpNext_allocs)

	var cstencilInitialLayout_allocs *cgoAllocMap
	refc8065ded.stencilInitialLayout, cstencilInitialLayout_allocs = (C.VkImageLayout)(x.StencilInitialLayout), cgoAllocsUnknown
	allocsc8065ded.Borrow(cstencilInitialLayout_allocs)

	var cstencilFinalLayout_allocs *cgoAllocMap
	refc8065ded.stencilFinalLayout, cstencilFinalLayout_allocs = (C.VkImageLayout)(x.StencilFinalLayout), cgoAllocsUnknown
	allocsc8065ded.Borrow(cstencilFinalLayout_allocs)

	x.refc8065ded = refc8065ded
	x.allocsc8065ded = allocsc8065ded
	return refc8065ded, allocsc8065ded

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentDescriptionStencilLayout) PassValue() (C.VkAttachmentDescriptionStencilLayout, *cgoAllocMap) {
	if x.refc8065ded != nil {
		return *x.refc8065ded, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentDescriptionStencilLayout) Deref() {
	if x.refc8065ded == nil {
		return
	}
	x.SType = (StructureType)(x.refc8065ded.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc8065ded.pNext))
	x.StencilInitialLayout = (ImageLayout)(x.refc8065ded.stencilInitialLayout)
	x.StencilFinalLayout = (ImageLayout)(x.refc8065ded.stencilFinalLayout)
}

// allocPhysicalDeviceHostQueryResetFeaturesMemory allocates memory for type C.VkPhysicalDeviceHostQueryResetFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceHostQueryResetFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceHostQueryResetFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceHostQueryResetFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceHostQueryResetFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceHostQueryResetFeatures) Ref() *C.VkPhysicalDeviceHostQueryResetFeatures {
	if x == nil {
		return nil
	}
	return x.ref6ff2e40a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceHostQueryResetFeatures) Free() {
	if x != nil && x.allocs6ff2e40a != nil {
		x.allocs6ff2e40a.(*cgoAllocMap).Free()
		x.ref6ff2e40a = nil
	}
}

// NewPhysicalDeviceHostQueryResetFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceHostQueryResetFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceHostQueryResetFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceHostQueryResetFeatures)
	obj.ref6ff2e40a = (*C.VkPhysicalDeviceHostQueryResetFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceHostQueryResetFeatures) PassRef() (*C.VkPhysicalDeviceHostQueryResetFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6ff2e40a != nil {
		return x.ref6ff2e40a, nil
	}
	mem6ff2e40a := allocPhysicalDeviceHostQueryResetFeaturesMemory(1)
	ref6ff2e40a := (*C.VkPhysicalDeviceHostQueryResetFeatures)(mem6ff2e40a)
	allocs6ff2e40a := new(cgoAllocMap)
	allocs6ff2e40a.Add(mem6ff2e40a)

	var csType_allocs *cgoAllocMap
	ref6ff2e40a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6ff2e40a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6ff2e40a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6ff2e40a.Borrow(cpNext_allocs)

	var chostQueryReset_allocs *cgoAllocMap
	ref6ff2e40a.hostQueryReset, chostQueryReset_allocs = (C.VkBool32)(x.HostQueryReset), cgoAllocsUnknown
	allocs6ff2e40a.Borrow(chostQueryReset_allocs)

	x.ref6ff2e40a = ref6ff2e40a
	x.allocs6ff2e40a = allocs6ff2e40a
	return ref6ff2e40a, allocs6ff2e40a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceHostQueryResetFeatures) PassValue() (C.VkPhysicalDeviceHostQueryResetFeatures, *cgoAllocMap) {
	if x.ref6ff2e40a != nil {
		return *x.ref6ff2e40a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceHostQueryResetFeatures) Deref() {
	if x.ref6ff2e40a == nil {
		return
	}
	x.SType = (StructureType)(x.ref6ff2e40a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6ff2e40a.pNext))
	x.HostQueryReset = (Bool32)(x.ref6ff2e40a.hostQueryReset)
}

// allocPhysicalDeviceTimelineSemaphoreFeaturesMemory allocates memory for type C.VkPhysicalDeviceTimelineSemaphoreFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceTimelineSemaphoreFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceTimelineSemaphoreFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceTimelineSemaphoreFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceTimelineSemaphoreFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceTimelineSemaphoreFeatures) Ref() *C.VkPhysicalDeviceTimelineSemaphoreFeatures {
	if x == nil {
		return nil
	}
	return x.ref9260df2e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceTimelineSemaphoreFeatures) Free() {
	if x != nil && x.allocs9260df2e != nil {
		x.allocs9260df2e.(*cgoAllocMap).Free()
		x.ref9260df2e = nil
	}
}

// NewPhysicalDeviceTimelineSemaphoreFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceTimelineSemaphoreFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceTimelineSemaphoreFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceTimelineSemaphoreFeatures)
	obj.ref9260df2e = (*C.VkPhysicalDeviceTimelineSemaphoreFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceTimelineSemaphoreFeatures) PassRef() (*C.VkPhysicalDeviceTimelineSemaphoreFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9260df2e != nil {
		return x.ref9260df2e, nil
	}
	mem9260df2e := allocPhysicalDeviceTimelineSemaphoreFeaturesMemory(1)
	ref9260df2e := (*C.VkPhysicalDeviceTimelineSemaphoreFeatures)(mem9260df2e)
	allocs9260df2e := new(cgoAllocMap)
	allocs9260df2e.Add(mem9260df2e)

	var csType_allocs *cgoAllocMap
	ref9260df2e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9260df2e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9260df2e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9260df2e.Borrow(cpNext_allocs)

	var ctimelineSemaphore_allocs *cgoAllocMap
	ref9260df2e.timelineSemaphore, ctimelineSemaphore_allocs = (C.VkBool32)(x.TimelineSemaphore), cgoAllocsUnknown
	allocs9260df2e.Borrow(ctimelineSemaphore_allocs)

	x.ref9260df2e = ref9260df2e
	x.allocs9260df2e = allocs9260df2e
	return ref9260df2e, allocs9260df2e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceTimelineSemaphoreFeatures) PassValue() (C.VkPhysicalDeviceTimelineSemaphoreFeatures, *cgoAllocMap) {
	if x.ref9260df2e != nil {
		return *x.ref9260df2e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceTimelineSemaphoreFeatures) Deref() {
	if x.ref9260df2e == nil {
		return
	}
	x.SType = (StructureType)(x.ref9260df2e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9260df2e.pNext))
	x.TimelineSemaphore = (Bool32)(x.ref9260df2e.timelineSemaphore)
}

// allocPhysicalDeviceTimelineSemaphorePropertiesMemory allocates memory for type C.VkPhysicalDeviceTimelineSemaphoreProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceTimelineSemaphorePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceTimelineSemaphorePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceTimelineSemaphorePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceTimelineSemaphoreProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceTimelineSemaphoreProperties) Ref() *C.VkPhysicalDeviceTimelineSemaphoreProperties {
	if x == nil {
		return nil
	}
	return x.ref74220563
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceTimelineSemaphoreProperties) Free() {
	if x != nil && x.allocs74220563 != nil {
		x.allocs74220563.(*cgoAllocMap).Free()
		x.ref74220563 = nil
	}
}

// NewPhysicalDeviceTimelineSemaphorePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceTimelineSemaphorePropertiesRef(ref unsafe.Pointer) *PhysicalDeviceTimelineSemaphoreProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceTimelineSemaphoreProperties)
	obj.ref74220563 = (*C.VkPhysicalDeviceTimelineSemaphoreProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceTimelineSemaphoreProperties) PassRef() (*C.VkPhysicalDeviceTimelineSemaphoreProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref74220563 != nil {
		return x.ref74220563, nil
	}
	mem74220563 := allocPhysicalDeviceTimelineSemaphorePropertiesMemory(1)
	ref74220563 := (*C.VkPhysicalDeviceTimelineSemaphoreProperties)(mem74220563)
	allocs74220563 := new(cgoAllocMap)
	allocs74220563.Add(mem74220563)

	var csType_allocs *cgoAllocMap
	ref74220563.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs74220563.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref74220563.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs74220563.Borrow(cpNext_allocs)

	var cmaxTimelineSemaphoreValueDifference_allocs *cgoAllocMap
	ref74220563.maxTimelineSemaphoreValueDifference, cmaxTimelineSemaphoreValueDifference_allocs = (C.uint64_t)(x.MaxTimelineSemaphoreValueDifference), cgoAllocsUnknown
	allocs74220563.Borrow(cmaxTimelineSemaphoreValueDifference_allocs)

	x.ref74220563 = ref74220563
	x.allocs74220563 = allocs74220563
	return ref74220563, allocs74220563

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceTimelineSemaphoreProperties) PassValue() (C.VkPhysicalDeviceTimelineSemaphoreProperties, *cgoAllocMap) {
	if x.ref74220563 != nil {
		return *x.ref74220563, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceTimelineSemaphoreProperties) Deref() {
	if x.ref74220563 == nil {
		return
	}
	x.SType = (StructureType)(x.ref74220563.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref74220563.pNext))
	x.MaxTimelineSemaphoreValueDifference = (uint32)(x.ref74220563.maxTimelineSemaphoreValueDifference)
}

// allocSemaphoreTypeCreateInfoMemory allocates memory for type C.VkSemaphoreTypeCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreTypeCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreTypeCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSemaphoreTypeCreateInfoValue = unsafe.Sizeof([1]C.VkSemaphoreTypeCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SemaphoreTypeCreateInfo) Ref() *C.VkSemaphoreTypeCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref4e668d65
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SemaphoreTypeCreateInfo) Free() {
	if x != nil && x.allocs4e668d65 != nil {
		x.allocs4e668d65.(*cgoAllocMap).Free()
		x.ref4e668d65 = nil
	}
}

// NewSemaphoreTypeCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSemaphoreTypeCreateInfoRef(ref unsafe.Pointer) *SemaphoreTypeCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SemaphoreTypeCreateInfo)
	obj.ref4e668d65 = (*C.VkSemaphoreTypeCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SemaphoreTypeCreateInfo) PassRef() (*C.VkSemaphoreTypeCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4e668d65 != nil {
		return x.ref4e668d65, nil
	}
	mem4e668d65 := allocSemaphoreTypeCreateInfoMemory(1)
	ref4e668d65 := (*C.VkSemaphoreTypeCreateInfo)(mem4e668d65)
	allocs4e668d65 := new(cgoAllocMap)
	allocs4e668d65.Add(mem4e668d65)

	var csType_allocs *cgoAllocMap
	ref4e668d65.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4e668d65.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4e668d65.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4e668d65.Borrow(cpNext_allocs)

	var csemaphoreType_allocs *cgoAllocMap
	ref4e668d65.semaphoreType, csemaphoreType_allocs = (C.VkSemaphoreType)(x.SemaphoreType), cgoAllocsUnknown
	allocs4e668d65.Borrow(csemaphoreType_allocs)

	var cinitialValue_allocs *cgoAllocMap
	ref4e668d65.initialValue, cinitialValue_allocs = (C.uint64_t)(x.InitialValue), cgoAllocsUnknown
	allocs4e668d65.Borrow(cinitialValue_allocs)

	x.ref4e668d65 = ref4e668d65
	x.allocs4e668d65 = allocs4e668d65
	return ref4e668d65, allocs4e668d65

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SemaphoreTypeCreateInfo) PassValue() (C.VkSemaphoreTypeCreateInfo, *cgoAllocMap) {
	if x.ref4e668d65 != nil {
		return *x.ref4e668d65, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SemaphoreTypeCreateInfo) Deref() {
	if x.ref4e668d65 == nil {
		return
	}
	x.SType = (StructureType)(x.ref4e668d65.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4e668d65.pNext))
	x.SemaphoreType = (SemaphoreType)(x.ref4e668d65.semaphoreType)
	x.InitialValue = (uint32)(x.ref4e668d65.initialValue)
}

// allocTimelineSemaphoreSubmitInfoMemory allocates memory for type C.VkTimelineSemaphoreSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTimelineSemaphoreSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTimelineSemaphoreSubmitInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTimelineSemaphoreSubmitInfoValue = unsafe.Sizeof([1]C.VkTimelineSemaphoreSubmitInfo{})

// copyPUint64_tBytes copies the data from Go slice as *C.uint64_t.
func copyPUint64_tBytes(slice *sliceHeader) (*C.uint64_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint64_tValue) * slice.Len,
		Cap:  int(sizeOfUint64_tValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint64_t)(mem0), allocs
}

// allocUint64_tMemory allocates memory for type C.uint64_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint64_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint64_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint64_tValue = unsafe.Sizeof([1]C.uint64_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TimelineSemaphoreSubmitInfo) Ref() *C.VkTimelineSemaphoreSubmitInfo {
	if x == nil {
		return nil
	}
	return x.refc447a049
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TimelineSemaphoreSubmitInfo) Free() {
	if x != nil && x.allocsc447a049 != nil {
		x.allocsc447a049.(*cgoAllocMap).Free()
		x.refc447a049 = nil
	}
}

// NewTimelineSemaphoreSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTimelineSemaphoreSubmitInfoRef(ref unsafe.Pointer) *TimelineSemaphoreSubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(TimelineSemaphoreSubmitInfo)
	obj.refc447a049 = (*C.VkTimelineSemaphoreSubmitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TimelineSemaphoreSubmitInfo) PassRef() (*C.VkTimelineSemaphoreSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc447a049 != nil {
		return x.refc447a049, nil
	}
	memc447a049 := allocTimelineSemaphoreSubmitInfoMemory(1)
	refc447a049 := (*C.VkTimelineSemaphoreSubmitInfo)(memc447a049)
	allocsc447a049 := new(cgoAllocMap)
	allocsc447a049.Add(memc447a049)

	var csType_allocs *cgoAllocMap
	refc447a049.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc447a049.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc447a049.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc447a049.Borrow(cpNext_allocs)

	var cwaitSemaphoreValueCount_allocs *cgoAllocMap
	refc447a049.waitSemaphoreValueCount, cwaitSemaphoreValueCount_allocs = (C.uint32_t)(x.WaitSemaphoreValueCount), cgoAllocsUnknown
	allocsc447a049.Borrow(cwaitSemaphoreValueCount_allocs)

	var cpWaitSemaphoreValues_allocs *cgoAllocMap
	refc447a049.pWaitSemaphoreValues, cpWaitSemaphoreValues_allocs = copyPUint64_tBytes((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphoreValues)))
	allocsc447a049.Borrow(cpWaitSemaphoreValues_allocs)

	var csignalSemaphoreValueCount_allocs *cgoAllocMap
	refc447a049.signalSemaphoreValueCount, csignalSemaphoreValueCount_allocs = (C.uint32_t)(x.SignalSemaphoreValueCount), cgoAllocsUnknown
	allocsc447a049.Borrow(csignalSemaphoreValueCount_allocs)

	var cpSignalSemaphoreValues_allocs *cgoAllocMap
	refc447a049.pSignalSemaphoreValues, cpSignalSemaphoreValues_allocs = copyPUint64_tBytes((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphoreValues)))
	allocsc447a049.Borrow(cpSignalSemaphoreValues_allocs)

	x.refc447a049 = refc447a049
	x.allocsc447a049 = allocsc447a049
	return refc447a049, allocsc447a049

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TimelineSemaphoreSubmitInfo) PassValue() (C.VkTimelineSemaphoreSubmitInfo, *cgoAllocMap) {
	if x.refc447a049 != nil {
		return *x.refc447a049, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TimelineSemaphoreSubmitInfo) Deref() {
	if x.refc447a049 == nil {
		return
	}
	x.SType = (StructureType)(x.refc447a049.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc447a049.pNext))
	x.WaitSemaphoreValueCount = (uint32)(x.refc447a049.waitSemaphoreValueCount)
	hxfd687ee := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphoreValues))
	hxfd687ee.Data = unsafe.Pointer(x.refc447a049.pWaitSemaphoreValues)
	hxfd687ee.Cap = 0x7fffffff
	// hxfd687ee.Len = ?

	x.SignalSemaphoreValueCount = (uint32)(x.refc447a049.signalSemaphoreValueCount)
	hxf15a567 := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphoreValues))
	hxf15a567.Data = unsafe.Pointer(x.refc447a049.pSignalSemaphoreValues)
	hxf15a567.Cap = 0x7fffffff
	// hxf15a567.Len = ?

}

// allocSemaphoreWaitInfoMemory allocates memory for type C.VkSemaphoreWaitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreWaitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreWaitInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSemaphoreWaitInfoValue = unsafe.Sizeof([1]C.VkSemaphoreWaitInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SemaphoreWaitInfo) Ref() *C.VkSemaphoreWaitInfo {
	if x == nil {
		return nil
	}
	return x.ref5e4f71e8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SemaphoreWaitInfo) Free() {
	if x != nil && x.allocs5e4f71e8 != nil {
		x.allocs5e4f71e8.(*cgoAllocMap).Free()
		x.ref5e4f71e8 = nil
	}
}

// NewSemaphoreWaitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSemaphoreWaitInfoRef(ref unsafe.Pointer) *SemaphoreWaitInfo {
	if ref == nil {
		return nil
	}
	obj := new(SemaphoreWaitInfo)
	obj.ref5e4f71e8 = (*C.VkSemaphoreWaitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SemaphoreWaitInfo) PassRef() (*C.VkSemaphoreWaitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e4f71e8 != nil {
		return x.ref5e4f71e8, nil
	}
	mem5e4f71e8 := allocSemaphoreWaitInfoMemory(1)
	ref5e4f71e8 := (*C.VkSemaphoreWaitInfo)(mem5e4f71e8)
	allocs5e4f71e8 := new(cgoAllocMap)
	allocs5e4f71e8.Add(mem5e4f71e8)

	var csType_allocs *cgoAllocMap
	ref5e4f71e8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5e4f71e8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5e4f71e8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5e4f71e8.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref5e4f71e8.flags, cflags_allocs = (C.VkSemaphoreWaitFlags)(x.Flags), cgoAllocsUnknown
	allocs5e4f71e8.Borrow(cflags_allocs)

	var csemaphoreCount_allocs *cgoAllocMap
	ref5e4f71e8.semaphoreCount, csemaphoreCount_allocs = (C.uint32_t)(x.SemaphoreCount), cgoAllocsUnknown
	allocs5e4f71e8.Borrow(csemaphoreCount_allocs)

	var cpSemaphores_allocs *cgoAllocMap
	ref5e4f71e8.pSemaphores, cpSemaphores_allocs = copyPSemaphoreBytes((*sliceHeader)(unsafe.Pointer(&x.PSemaphores)))
	allocs5e4f71e8.Borrow(cpSemaphores_allocs)

	var cpValues_allocs *cgoAllocMap
	ref5e4f71e8.pValues, cpValues_allocs = copyPUint64_tBytes((*sliceHeader)(unsafe.Pointer(&x.PValues)))
	allocs5e4f71e8.Borrow(cpValues_allocs)

	x.ref5e4f71e8 = ref5e4f71e8
	x.allocs5e4f71e8 = allocs5e4f71e8
	return ref5e4f71e8, allocs5e4f71e8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SemaphoreWaitInfo) PassValue() (C.VkSemaphoreWaitInfo, *cgoAllocMap) {
	if x.ref5e4f71e8 != nil {
		return *x.ref5e4f71e8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SemaphoreWaitInfo) Deref() {
	if x.ref5e4f71e8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5e4f71e8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5e4f71e8.pNext))
	x.Flags = (SemaphoreWaitFlags)(x.ref5e4f71e8.flags)
	x.SemaphoreCount = (uint32)(x.ref5e4f71e8.semaphoreCount)
	hxf8aebb5 := (*sliceHeader)(unsafe.Pointer(&x.PSemaphores))
	hxf8aebb5.Data = unsafe.Pointer(x.ref5e4f71e8.pSemaphores)
	hxf8aebb5.Cap = 0x7fffffff
	// hxf8aebb5.Len = ?

	hxf5d30cf := (*sliceHeader)(unsafe.Pointer(&x.PValues))
	hxf5d30cf.Data = unsafe.Pointer(x.ref5e4f71e8.pValues)
	hxf5d30cf.Cap = 0x7fffffff
	// hxf5d30cf.Len = ?

}

// allocSemaphoreSignalInfoMemory allocates memory for type C.VkSemaphoreSignalInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreSignalInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreSignalInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSemaphoreSignalInfoValue = unsafe.Sizeof([1]C.VkSemaphoreSignalInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SemaphoreSignalInfo) Ref() *C.VkSemaphoreSignalInfo {
	if x == nil {
		return nil
	}
	return x.ref126d16a2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SemaphoreSignalInfo) Free() {
	if x != nil && x.allocs126d16a2 != nil {
		x.allocs126d16a2.(*cgoAllocMap).Free()
		x.ref126d16a2 = nil
	}
}

// NewSemaphoreSignalInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSemaphoreSignalInfoRef(ref unsafe.Pointer) *SemaphoreSignalInfo {
	if ref == nil {
		return nil
	}
	obj := new(SemaphoreSignalInfo)
	obj.ref126d16a2 = (*C.VkSemaphoreSignalInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SemaphoreSignalInfo) PassRef() (*C.VkSemaphoreSignalInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref126d16a2 != nil {
		return x.ref126d16a2, nil
	}
	mem126d16a2 := allocSemaphoreSignalInfoMemory(1)
	ref126d16a2 := (*C.VkSemaphoreSignalInfo)(mem126d16a2)
	allocs126d16a2 := new(cgoAllocMap)
	allocs126d16a2.Add(mem126d16a2)

	var csType_allocs *cgoAllocMap
	ref126d16a2.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs126d16a2.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref126d16a2.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs126d16a2.Borrow(cpNext_allocs)

	var csemaphore_allocs *cgoAllocMap
	ref126d16a2.semaphore, csemaphore_allocs = *(*C.VkSemaphore)(unsafe.Pointer(&x.Semaphore)), cgoAllocsUnknown
	allocs126d16a2.Borrow(csemaphore_allocs)

	var cvalue_allocs *cgoAllocMap
	ref126d16a2.value, cvalue_allocs = (C.uint64_t)(x.Value), cgoAllocsUnknown
	allocs126d16a2.Borrow(cvalue_allocs)

	x.ref126d16a2 = ref126d16a2
	x.allocs126d16a2 = allocs126d16a2
	return ref126d16a2, allocs126d16a2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SemaphoreSignalInfo) PassValue() (C.VkSemaphoreSignalInfo, *cgoAllocMap) {
	if x.ref126d16a2 != nil {
		return *x.ref126d16a2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SemaphoreSignalInfo) Deref() {
	if x.ref126d16a2 == nil {
		return
	}
	x.SType = (StructureType)(x.ref126d16a2.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref126d16a2.pNext))
	x.Semaphore = *(*Semaphore)(unsafe.Pointer(&x.ref126d16a2.semaphore))
	x.Value = (uint32)(x.ref126d16a2.value)
}

// allocPhysicalDeviceBufferDeviceAddressFeaturesMemory allocates memory for type C.VkPhysicalDeviceBufferDeviceAddressFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceBufferDeviceAddressFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceBufferDeviceAddressFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceBufferDeviceAddressFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceBufferDeviceAddressFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceBufferDeviceAddressFeatures) Ref() *C.VkPhysicalDeviceBufferDeviceAddressFeatures {
	if x == nil {
		return nil
	}
	return x.ref13b242c3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceBufferDeviceAddressFeatures) Free() {
	if x != nil && x.allocs13b242c3 != nil {
		x.allocs13b242c3.(*cgoAllocMap).Free()
		x.ref13b242c3 = nil
	}
}

// NewPhysicalDeviceBufferDeviceAddressFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceBufferDeviceAddressFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceBufferDeviceAddressFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceBufferDeviceAddressFeatures)
	obj.ref13b242c3 = (*C.VkPhysicalDeviceBufferDeviceAddressFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceBufferDeviceAddressFeatures) PassRef() (*C.VkPhysicalDeviceBufferDeviceAddressFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref13b242c3 != nil {
		return x.ref13b242c3, nil
	}
	mem13b242c3 := allocPhysicalDeviceBufferDeviceAddressFeaturesMemory(1)
	ref13b242c3 := (*C.VkPhysicalDeviceBufferDeviceAddressFeatures)(mem13b242c3)
	allocs13b242c3 := new(cgoAllocMap)
	allocs13b242c3.Add(mem13b242c3)

	var csType_allocs *cgoAllocMap
	ref13b242c3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs13b242c3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref13b242c3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs13b242c3.Borrow(cpNext_allocs)

	var cbufferDeviceAddress_allocs *cgoAllocMap
	ref13b242c3.bufferDeviceAddress, cbufferDeviceAddress_allocs = (C.VkBool32)(x.BufferDeviceAddress), cgoAllocsUnknown
	allocs13b242c3.Borrow(cbufferDeviceAddress_allocs)

	var cbufferDeviceAddressCaptureReplay_allocs *cgoAllocMap
	ref13b242c3.bufferDeviceAddressCaptureReplay, cbufferDeviceAddressCaptureReplay_allocs = (C.VkBool32)(x.BufferDeviceAddressCaptureReplay), cgoAllocsUnknown
	allocs13b242c3.Borrow(cbufferDeviceAddressCaptureReplay_allocs)

	var cbufferDeviceAddressMultiDevice_allocs *cgoAllocMap
	ref13b242c3.bufferDeviceAddressMultiDevice, cbufferDeviceAddressMultiDevice_allocs = (C.VkBool32)(x.BufferDeviceAddressMultiDevice), cgoAllocsUnknown
	allocs13b242c3.Borrow(cbufferDeviceAddressMultiDevice_allocs)

	x.ref13b242c3 = ref13b242c3
	x.allocs13b242c3 = allocs13b242c3
	return ref13b242c3, allocs13b242c3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceBufferDeviceAddressFeatures) PassValue() (C.VkPhysicalDeviceBufferDeviceAddressFeatures, *cgoAllocMap) {
	if x.ref13b242c3 != nil {
		return *x.ref13b242c3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceBufferDeviceAddressFeatures) Deref() {
	if x.ref13b242c3 == nil {
		return
	}
	x.SType = (StructureType)(x.ref13b242c3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref13b242c3.pNext))
	x.BufferDeviceAddress = (Bool32)(x.ref13b242c3.bufferDeviceAddress)
	x.BufferDeviceAddressCaptureReplay = (Bool32)(x.ref13b242c3.bufferDeviceAddressCaptureReplay)
	x.BufferDeviceAddressMultiDevice = (Bool32)(x.ref13b242c3.bufferDeviceAddressMultiDevice)
}

// allocBufferDeviceAddressInfoMemory allocates memory for type C.VkBufferDeviceAddressInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferDeviceAddressInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferDeviceAddressInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferDeviceAddressInfoValue = unsafe.Sizeof([1]C.VkBufferDeviceAddressInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferDeviceAddressInfo) Ref() *C.VkBufferDeviceAddressInfo {
	if x == nil {
		return nil
	}
	return x.ref347b43e3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferDeviceAddressInfo) Free() {
	if x != nil && x.allocs347b43e3 != nil {
		x.allocs347b43e3.(*cgoAllocMap).Free()
		x.ref347b43e3 = nil
	}
}

// NewBufferDeviceAddressInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferDeviceAddressInfoRef(ref unsafe.Pointer) *BufferDeviceAddressInfo {
	if ref == nil {
		return nil
	}
	obj := new(BufferDeviceAddressInfo)
	obj.ref347b43e3 = (*C.VkBufferDeviceAddressInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferDeviceAddressInfo) PassRef() (*C.VkBufferDeviceAddressInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref347b43e3 != nil {
		return x.ref347b43e3, nil
	}
	mem347b43e3 := allocBufferDeviceAddressInfoMemory(1)
	ref347b43e3 := (*C.VkBufferDeviceAddressInfo)(mem347b43e3)
	allocs347b43e3 := new(cgoAllocMap)
	allocs347b43e3.Add(mem347b43e3)

	var csType_allocs *cgoAllocMap
	ref347b43e3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs347b43e3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref347b43e3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs347b43e3.Borrow(cpNext_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref347b43e3.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs347b43e3.Borrow(cbuffer_allocs)

	x.ref347b43e3 = ref347b43e3
	x.allocs347b43e3 = allocs347b43e3
	return ref347b43e3, allocs347b43e3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferDeviceAddressInfo) PassValue() (C.VkBufferDeviceAddressInfo, *cgoAllocMap) {
	if x.ref347b43e3 != nil {
		return *x.ref347b43e3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferDeviceAddressInfo) Deref() {
	if x.ref347b43e3 == nil {
		return
	}
	x.SType = (StructureType)(x.ref347b43e3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref347b43e3.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref347b43e3.buffer))
}

// allocBufferOpaqueCaptureAddressCreateInfoMemory allocates memory for type C.VkBufferOpaqueCaptureAddressCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferOpaqueCaptureAddressCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferOpaqueCaptureAddressCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferOpaqueCaptureAddressCreateInfoValue = unsafe.Sizeof([1]C.VkBufferOpaqueCaptureAddressCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferOpaqueCaptureAddressCreateInfo) Ref() *C.VkBufferOpaqueCaptureAddressCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb0364ded
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferOpaqueCaptureAddressCreateInfo) Free() {
	if x != nil && x.allocsb0364ded != nil {
		x.allocsb0364ded.(*cgoAllocMap).Free()
		x.refb0364ded = nil
	}
}

// NewBufferOpaqueCaptureAddressCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferOpaqueCaptureAddressCreateInfoRef(ref unsafe.Pointer) *BufferOpaqueCaptureAddressCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(BufferOpaqueCaptureAddressCreateInfo)
	obj.refb0364ded = (*C.VkBufferOpaqueCaptureAddressCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferOpaqueCaptureAddressCreateInfo) PassRef() (*C.VkBufferOpaqueCaptureAddressCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0364ded != nil {
		return x.refb0364ded, nil
	}
	memb0364ded := allocBufferOpaqueCaptureAddressCreateInfoMemory(1)
	refb0364ded := (*C.VkBufferOpaqueCaptureAddressCreateInfo)(memb0364ded)
	allocsb0364ded := new(cgoAllocMap)
	allocsb0364ded.Add(memb0364ded)

	var csType_allocs *cgoAllocMap
	refb0364ded.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb0364ded.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb0364ded.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb0364ded.Borrow(cpNext_allocs)

	var copaqueCaptureAddress_allocs *cgoAllocMap
	refb0364ded.opaqueCaptureAddress, copaqueCaptureAddress_allocs = (C.uint64_t)(x.OpaqueCaptureAddress), cgoAllocsUnknown
	allocsb0364ded.Borrow(copaqueCaptureAddress_allocs)

	x.refb0364ded = refb0364ded
	x.allocsb0364ded = allocsb0364ded
	return refb0364ded, allocsb0364ded

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferOpaqueCaptureAddressCreateInfo) PassValue() (C.VkBufferOpaqueCaptureAddressCreateInfo, *cgoAllocMap) {
	if x.refb0364ded != nil {
		return *x.refb0364ded, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferOpaqueCaptureAddressCreateInfo) Deref() {
	if x.refb0364ded == nil {
		return
	}
	x.SType = (StructureType)(x.refb0364ded.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb0364ded.pNext))
	x.OpaqueCaptureAddress = (uint32)(x.refb0364ded.opaqueCaptureAddress)
}

// allocMemoryOpaqueCaptureAddressAllocateInfoMemory allocates memory for type C.VkMemoryOpaqueCaptureAddressAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryOpaqueCaptureAddressAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryOpaqueCaptureAddressAllocateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryOpaqueCaptureAddressAllocateInfoValue = unsafe.Sizeof([1]C.VkMemoryOpaqueCaptureAddressAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryOpaqueCaptureAddressAllocateInfo) Ref() *C.VkMemoryOpaqueCaptureAddressAllocateInfo {
	if x == nil {
		return nil
	}
	return x.refe361764c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryOpaqueCaptureAddressAllocateInfo) Free() {
	if x != nil && x.allocse361764c != nil {
		x.allocse361764c.(*cgoAllocMap).Free()
		x.refe361764c = nil
	}
}

// NewMemoryOpaqueCaptureAddressAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryOpaqueCaptureAddressAllocateInfoRef(ref unsafe.Pointer) *MemoryOpaqueCaptureAddressAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(MemoryOpaqueCaptureAddressAllocateInfo)
	obj.refe361764c = (*C.VkMemoryOpaqueCaptureAddressAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryOpaqueCaptureAddressAllocateInfo) PassRef() (*C.VkMemoryOpaqueCaptureAddressAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe361764c != nil {
		return x.refe361764c, nil
	}
	meme361764c := allocMemoryOpaqueCaptureAddressAllocateInfoMemory(1)
	refe361764c := (*C.VkMemoryOpaqueCaptureAddressAllocateInfo)(meme361764c)
	allocse361764c := new(cgoAllocMap)
	allocse361764c.Add(meme361764c)

	var csType_allocs *cgoAllocMap
	refe361764c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse361764c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe361764c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse361764c.Borrow(cpNext_allocs)

	var copaqueCaptureAddress_allocs *cgoAllocMap
	refe361764c.opaqueCaptureAddress, copaqueCaptureAddress_allocs = (C.uint64_t)(x.OpaqueCaptureAddress), cgoAllocsUnknown
	allocse361764c.Borrow(copaqueCaptureAddress_allocs)

	x.refe361764c = refe361764c
	x.allocse361764c = allocse361764c
	return refe361764c, allocse361764c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryOpaqueCaptureAddressAllocateInfo) PassValue() (C.VkMemoryOpaqueCaptureAddressAllocateInfo, *cgoAllocMap) {
	if x.refe361764c != nil {
		return *x.refe361764c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryOpaqueCaptureAddressAllocateInfo) Deref() {
	if x.refe361764c == nil {
		return
	}
	x.SType = (StructureType)(x.refe361764c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe361764c.pNext))
	x.OpaqueCaptureAddress = (uint32)(x.refe361764c.opaqueCaptureAddress)
}

// allocDeviceMemoryOpaqueCaptureAddressInfoMemory allocates memory for type C.VkDeviceMemoryOpaqueCaptureAddressInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceMemoryOpaqueCaptureAddressInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceMemoryOpaqueCaptureAddressInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceMemoryOpaqueCaptureAddressInfoValue = unsafe.Sizeof([1]C.VkDeviceMemoryOpaqueCaptureAddressInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceMemoryOpaqueCaptureAddressInfo) Ref() *C.VkDeviceMemoryOpaqueCaptureAddressInfo {
	if x == nil {
		return nil
	}
	return x.refbbe30c6e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceMemoryOpaqueCaptureAddressInfo) Free() {
	if x != nil && x.allocsbbe30c6e != nil {
		x.allocsbbe30c6e.(*cgoAllocMap).Free()
		x.refbbe30c6e = nil
	}
}

// NewDeviceMemoryOpaqueCaptureAddressInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceMemoryOpaqueCaptureAddressInfoRef(ref unsafe.Pointer) *DeviceMemoryOpaqueCaptureAddressInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceMemoryOpaqueCaptureAddressInfo)
	obj.refbbe30c6e = (*C.VkDeviceMemoryOpaqueCaptureAddressInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceMemoryOpaqueCaptureAddressInfo) PassRef() (*C.VkDeviceMemoryOpaqueCaptureAddressInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbbe30c6e != nil {
		return x.refbbe30c6e, nil
	}
	membbe30c6e := allocDeviceMemoryOpaqueCaptureAddressInfoMemory(1)
	refbbe30c6e := (*C.VkDeviceMemoryOpaqueCaptureAddressInfo)(membbe30c6e)
	allocsbbe30c6e := new(cgoAllocMap)
	allocsbbe30c6e.Add(membbe30c6e)

	var csType_allocs *cgoAllocMap
	refbbe30c6e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbbe30c6e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbbe30c6e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbbe30c6e.Borrow(cpNext_allocs)

	var cmemory_allocs *cgoAllocMap
	refbbe30c6e.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocsbbe30c6e.Borrow(cmemory_allocs)

	x.refbbe30c6e = refbbe30c6e
	x.allocsbbe30c6e = allocsbbe30c6e
	return refbbe30c6e, allocsbbe30c6e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceMemoryOpaqueCaptureAddressInfo) PassValue() (C.VkDeviceMemoryOpaqueCaptureAddressInfo, *cgoAllocMap) {
	if x.refbbe30c6e != nil {
		return *x.refbbe30c6e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceMemoryOpaqueCaptureAddressInfo) Deref() {
	if x.refbbe30c6e == nil {
		return
	}
	x.SType = (StructureType)(x.refbbe30c6e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbbe30c6e.pNext))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.refbbe30c6e.memory))
}

// allocSurfaceCapabilitiesMemory allocates memory for type C.VkSurfaceCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceCapabilitiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSurfaceCapabilitiesValue = unsafe.Sizeof([1]C.VkSurfaceCapabilitiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SurfaceCapabilities) Ref() *C.VkSurfaceCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.ref11d5f596
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SurfaceCapabilities) Free() {
	if x != nil && x.allocs11d5f596 != nil {
		x.allocs11d5f596.(*cgoAllocMap).Free()
		x.ref11d5f596 = nil
	}
}

// NewSurfaceCapabilitiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSurfaceCapabilitiesRef(ref unsafe.Pointer) *SurfaceCapabilities {
	if ref == nil {
		return nil
	}
	obj := new(SurfaceCapabilities)
	obj.ref11d5f596 = (*C.VkSurfaceCapabilitiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SurfaceCapabilities) PassRef() (*C.VkSurfaceCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11d5f596 != nil {
		return x.ref11d5f596, nil
	}
	mem11d5f596 := allocSurfaceCapabilitiesMemory(1)
	ref11d5f596 := (*C.VkSurfaceCapabilitiesKHR)(mem11d5f596)
	allocs11d5f596 := new(cgoAllocMap)
	allocs11d5f596.Add(mem11d5f596)

	var cminImageCount_allocs *cgoAllocMap
	ref11d5f596.minImageCount, cminImageCount_allocs = (C.uint32_t)(x.MinImageCount), cgoAllocsUnknown
	allocs11d5f596.Borrow(cminImageCount_allocs)

	var cmaxImageCount_allocs *cgoAllocMap
	ref11d5f596.maxImageCount, cmaxImageCount_allocs = (C.uint32_t)(x.MaxImageCount), cgoAllocsUnknown
	allocs11d5f596.Borrow(cmaxImageCount_allocs)

	var ccurrentExtent_allocs *cgoAllocMap
	ref11d5f596.currentExtent, ccurrentExtent_allocs = x.CurrentExtent.PassValue()
	allocs11d5f596.Borrow(ccurrentExtent_allocs)

	var cminImageExtent_allocs *cgoAllocMap
	ref11d5f596.minImageExtent, cminImageExtent_allocs = x.MinImageExtent.PassValue()
	allocs11d5f596.Borrow(cminImageExtent_allocs)

	var cmaxImageExtent_allocs *cgoAllocMap
	ref11d5f596.maxImageExtent, cmaxImageExtent_allocs = x.MaxImageExtent.PassValue()
	allocs11d5f596.Borrow(cmaxImageExtent_allocs)

	var cmaxImageArrayLayers_allocs *cgoAllocMap
	ref11d5f596.maxImageArrayLayers, cmaxImageArrayLayers_allocs = (C.uint32_t)(x.MaxImageArrayLayers), cgoAllocsUnknown
	allocs11d5f596.Borrow(cmaxImageArrayLayers_allocs)

	var csupportedTransforms_allocs *cgoAllocMap
	ref11d5f596.supportedTransforms, csupportedTransforms_allocs = (C.VkSurfaceTransformFlagsKHR)(x.SupportedTransforms), cgoAllocsUnknown
	allocs11d5f596.Borrow(csupportedTransforms_allocs)

	var ccurrentTransform_allocs *cgoAllocMap
	ref11d5f596.currentTransform, ccurrentTransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.CurrentTransform), cgoAllocsUnknown
	allocs11d5f596.Borrow(ccurrentTransform_allocs)

	var csupportedCompositeAlpha_allocs *cgoAllocMap
	ref11d5f596.supportedCompositeAlpha, csupportedCompositeAlpha_allocs = (C.VkCompositeAlphaFlagsKHR)(x.SupportedCompositeAlpha), cgoAllocsUnknown
	allocs11d5f596.Borrow(csupportedCompositeAlpha_allocs)

	var csupportedUsageFlags_allocs *cgoAllocMap
	ref11d5f596.supportedUsageFlags, csupportedUsageFlags_allocs = (C.VkImageUsageFlags)(x.SupportedUsageFlags), cgoAllocsUnknown
	allocs11d5f596.Borrow(csupportedUsageFlags_allocs)

	x.ref11d5f596 = ref11d5f596
	x.allocs11d5f596 = allocs11d5f596
	return ref11d5f596, allocs11d5f596

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SurfaceCapabilities) PassValue() (C.VkSurfaceCapabilitiesKHR, *cgoAllocMap) {
	if x.ref11d5f596 != nil {
		return *x.ref11d5f596, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SurfaceCapabilities) Deref() {
	if x.ref11d5f596 == nil {
		return
	}
	x.MinImageCount = (uint32)(x.ref11d5f596.minImageCount)
	x.MaxImageCount = (uint32)(x.ref11d5f596.maxImageCount)
	x.CurrentExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref11d5f596.currentExtent))
	x.MinImageExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref11d5f596.minImageExtent))
	x.MaxImageExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref11d5f596.maxImageExtent))
	x.MaxImageArrayLayers = (uint32)(x.ref11d5f596.maxImageArrayLayers)
	x.SupportedTransforms = (SurfaceTransformFlags)(x.ref11d5f596.supportedTransforms)
	x.CurrentTransform = (SurfaceTransformFlagBits)(x.ref11d5f596.currentTransform)
	x.SupportedCompositeAlpha = (CompositeAlphaFlags)(x.ref11d5f596.supportedCompositeAlpha)
	x.SupportedUsageFlags = (ImageUsageFlags)(x.ref11d5f596.supportedUsageFlags)
}

// allocSurfaceFormatMemory allocates memory for type C.VkSurfaceFormatKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceFormatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceFormatValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSurfaceFormatValue = unsafe.Sizeof([1]C.VkSurfaceFormatKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SurfaceFormat) Ref() *C.VkSurfaceFormatKHR {
	if x == nil {
		return nil
	}
	return x.refedaf82ca
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SurfaceFormat) Free() {
	if x != nil && x.allocsedaf82ca != nil {
		x.allocsedaf82ca.(*cgoAllocMap).Free()
		x.refedaf82ca = nil
	}
}

// NewSurfaceFormatRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSurfaceFormatRef(ref unsafe.Pointer) *SurfaceFormat {
	if ref == nil {
		return nil
	}
	obj := new(SurfaceFormat)
	obj.refedaf82ca = (*C.VkSurfaceFormatKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SurfaceFormat) PassRef() (*C.VkSurfaceFormatKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refedaf82ca != nil {
		return x.refedaf82ca, nil
	}
	memedaf82ca := allocSurfaceFormatMemory(1)
	refedaf82ca := (*C.VkSurfaceFormatKHR)(memedaf82ca)
	allocsedaf82ca := new(cgoAllocMap)
	allocsedaf82ca.Add(memedaf82ca)

	var cformat_allocs *cgoAllocMap
	refedaf82ca.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsedaf82ca.Borrow(cformat_allocs)

	var ccolorSpace_allocs *cgoAllocMap
	refedaf82ca.colorSpace, ccolorSpace_allocs = (C.VkColorSpaceKHR)(x.ColorSpace), cgoAllocsUnknown
	allocsedaf82ca.Borrow(ccolorSpace_allocs)

	x.refedaf82ca = refedaf82ca
	x.allocsedaf82ca = allocsedaf82ca
	return refedaf82ca, allocsedaf82ca

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SurfaceFormat) PassValue() (C.VkSurfaceFormatKHR, *cgoAllocMap) {
	if x.refedaf82ca != nil {
		return *x.refedaf82ca, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SurfaceFormat) Deref() {
	if x.refedaf82ca == nil {
		return
	}
	x.Format = (Format)(x.refedaf82ca.format)
	x.ColorSpace = (ColorSpace)(x.refedaf82ca.colorSpace)
}

// allocSwapchainCreateInfoMemory allocates memory for type C.VkSwapchainCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSwapchainCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSwapchainCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSwapchainCreateInfoValue = unsafe.Sizeof([1]C.VkSwapchainCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SwapchainCreateInfo) Ref() *C.VkSwapchainCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.refdb619e1c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SwapchainCreateInfo) Free() {
	if x != nil && x.allocsdb619e1c != nil {
		x.allocsdb619e1c.(*cgoAllocMap).Free()
		x.refdb619e1c = nil
	}
}

// NewSwapchainCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSwapchainCreateInfoRef(ref unsafe.Pointer) *SwapchainCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SwapchainCreateInfo)
	obj.refdb619e1c = (*C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SwapchainCreateInfo) PassRef() (*C.VkSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdb619e1c != nil {
		return x.refdb619e1c, nil
	}
	memdb619e1c := allocSwapchainCreateInfoMemory(1)
	refdb619e1c := (*C.VkSwapchainCreateInfoKHR)(memdb619e1c)
	allocsdb619e1c := new(cgoAllocMap)
	allocsdb619e1c.Add(memdb619e1c)

	var csType_allocs *cgoAllocMap
	refdb619e1c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdb619e1c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdb619e1c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refdb619e1c.flags, cflags_allocs = (C.VkSwapchainCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cflags_allocs)

	var csurface_allocs *cgoAllocMap
	refdb619e1c.surface, csurface_allocs = *(*C.VkSurfaceKHR)(unsafe.Pointer(&x.Surface)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(csurface_allocs)

	var cminImageCount_allocs *cgoAllocMap
	refdb619e1c.minImageCount, cminImageCount_allocs = (C.uint32_t)(x.MinImageCount), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cminImageCount_allocs)

	var cimageFormat_allocs *cgoAllocMap
	refdb619e1c.imageFormat, cimageFormat_allocs = (C.VkFormat)(x.ImageFormat), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageFormat_allocs)

	var cimageColorSpace_allocs *cgoAllocMap
	refdb619e1c.imageColorSpace, cimageColorSpace_allocs = (C.VkColorSpaceKHR)(x.ImageColorSpace), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageColorSpace_allocs)

	var cimageExtent_allocs *cgoAllocMap
	refdb619e1c.imageExtent, cimageExtent_allocs = x.ImageExtent.PassValue()
	allocsdb619e1c.Borrow(cimageExtent_allocs)

	var cimageArrayLayers_allocs *cgoAllocMap
	refdb619e1c.imageArrayLayers, cimageArrayLayers_allocs = (C.uint32_t)(x.ImageArrayLayers), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageArrayLayers_allocs)

	var cimageUsage_allocs *cgoAllocMap
	refdb619e1c.imageUsage, cimageUsage_allocs = (C.VkImageUsageFlags)(x.ImageUsage), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageUsage_allocs)

	var cimageSharingMode_allocs *cgoAllocMap
	refdb619e1c.imageSharingMode, cimageSharingMode_allocs = (C.VkSharingMode)(x.ImageSharingMode), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageSharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	refdb619e1c.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	refdb619e1c.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)))
	allocsdb619e1c.Borrow(cpQueueFamilyIndices_allocs)

	var cpreTransform_allocs *cgoAllocMap
	refdb619e1c.preTransform, cpreTransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.PreTransform), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpreTransform_allocs)

	var ccompositeAlpha_allocs *cgoAllocMap
	refdb619e1c.compositeAlpha, ccompositeAlpha_allocs = (C.VkCompositeAlphaFlagBitsKHR)(x.CompositeAlpha), cgoAllocsUnknown
	allocsdb619e1c.Borrow(ccompositeAlpha_allocs)

	var cpresentMode_allocs *cgoAllocMap
	refdb619e1c.presentMode, cpresentMode_allocs = (C.VkPresentModeKHR)(x.PresentMode), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpresentMode_allocs)

	var cclipped_allocs *cgoAllocMap
	refdb619e1c.clipped, cclipped_allocs = (C.VkBool32)(x.Clipped), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cclipped_allocs)

	var coldSwapchain_allocs *cgoAllocMap
	refdb619e1c.oldSwapchain, coldSwapchain_allocs = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.OldSwapchain)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(coldSwapchain_allocs)

	x.refdb619e1c = refdb619e1c
	x.allocsdb619e1c = allocsdb619e1c
	return refdb619e1c, allocsdb619e1c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SwapchainCreateInfo) PassValue() (C.VkSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x.refdb619e1c != nil {
		return *x.refdb619e1c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SwapchainCreateInfo) Deref() {
	if x.refdb619e1c == nil {
		return
	}
	x.SType = (StructureType)(x.refdb619e1c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdb619e1c.pNext))
	x.Flags = (SwapchainCreateFlags)(x.refdb619e1c.flags)
	x.Surface = *(*Surface)(unsafe.Pointer(&x.refdb619e1c.surface))
	x.MinImageCount = (uint32)(x.refdb619e1c.minImageCount)
	x.ImageFormat = (Format)(x.refdb619e1c.imageFormat)
	x.ImageColorSpace = (ColorSpace)(x.refdb619e1c.imageColorSpace)
	x.ImageExtent = *NewExtent2DRef(unsafe.Pointer(&x.refdb619e1c.imageExtent))
	x.ImageArrayLayers = (uint32)(x.refdb619e1c.imageArrayLayers)
	x.ImageUsage = (ImageUsageFlags)(x.refdb619e1c.imageUsage)
	x.ImageSharingMode = (SharingMode)(x.refdb619e1c.imageSharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.refdb619e1c.queueFamilyIndexCount)
	hxf882e98 := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf882e98.Data = unsafe.Pointer(x.refdb619e1c.pQueueFamilyIndices)
	hxf882e98.Cap = 0x7fffffff
	// hxf882e98.Len = ?

	x.PreTransform = (SurfaceTransformFlagBits)(x.refdb619e1c.preTransform)
	x.CompositeAlpha = (CompositeAlphaFlagBits)(x.refdb619e1c.compositeAlpha)
	x.PresentMode = (PresentMode)(x.refdb619e1c.presentMode)
	x.Clipped = (Bool32)(x.refdb619e1c.clipped)
	x.OldSwapchain = *(*Swapchain)(unsafe.Pointer(&x.refdb619e1c.oldSwapchain))
}

// allocPresentInfoMemory allocates memory for type C.VkPresentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPresentInfoValue = unsafe.Sizeof([1]C.VkPresentInfoKHR{})

// copyPSwapchainBytes copies the data from Go slice as *C.VkSwapchainKHR.
func copyPSwapchainBytes(slice *sliceHeader) (*C.VkSwapchainKHR, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSwapchainValue) * slice.Len,
		Cap:  int(sizeOfSwapchainValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSwapchainKHR)(mem0), allocs
}

// allocSwapchainMemory allocates memory for type C.VkSwapchainKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSwapchainMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSwapchainValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSwapchainValue = unsafe.Sizeof([1]C.VkSwapchainKHR{})

// copyPResultBytes copies the data from Go slice as *C.VkResult.
func copyPResultBytes(slice *sliceHeader) (*C.VkResult, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfResultValue) * slice.Len,
		Cap:  int(sizeOfResultValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkResult)(mem0), allocs
}

// allocResultMemory allocates memory for type C.VkResult in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultValue = unsafe.Sizeof([1]C.VkResult{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentInfo) Ref() *C.VkPresentInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref1d0e82d4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentInfo) Free() {
	if x != nil && x.allocs1d0e82d4 != nil {
		x.allocs1d0e82d4.(*cgoAllocMap).Free()
		x.ref1d0e82d4 = nil
	}
}

// NewPresentInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentInfoRef(ref unsafe.Pointer) *PresentInfo {
	if ref == nil {
		return nil
	}
	obj := new(PresentInfo)
	obj.ref1d0e82d4 = (*C.VkPresentInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentInfo) PassRef() (*C.VkPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d0e82d4 != nil {
		return x.ref1d0e82d4, nil
	}
	mem1d0e82d4 := allocPresentInfoMemory(1)
	ref1d0e82d4 := (*C.VkPresentInfoKHR)(mem1d0e82d4)
	allocs1d0e82d4 := new(cgoAllocMap)
	allocs1d0e82d4.Add(mem1d0e82d4)

	var csType_allocs *cgoAllocMap
	ref1d0e82d4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1d0e82d4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	ref1d0e82d4.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphores_allocs *cgoAllocMap
	ref1d0e82d4.pWaitSemaphores, cpWaitSemaphores_allocs = copyPSemaphoreBytes((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)))
	allocs1d0e82d4.Borrow(cpWaitSemaphores_allocs)

	var cswapchainCount_allocs *cgoAllocMap
	ref1d0e82d4.swapchainCount, cswapchainCount_allocs = (C.uint32_t)(x.SwapchainCount), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cswapchainCount_allocs)

	var cpSwapchains_allocs *cgoAllocMap
	ref1d0e82d4.pSwapchains, cpSwapchains_allocs = copyPSwapchainBytes((*sliceHeader)(unsafe.Pointer(&x.PSwapchains)))
	allocs1d0e82d4.Borrow(cpSwapchains_allocs)

	var cpImageIndices_allocs *cgoAllocMap
	ref1d0e82d4.pImageIndices, cpImageIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PImageIndices)))
	allocs1d0e82d4.Borrow(cpImageIndices_allocs)

	var cpResults_allocs *cgoAllocMap
	ref1d0e82d4.pResults, cpResults_allocs = copyPResultBytes((*sliceHeader)(unsafe.Pointer(&x.PResults)))
	allocs1d0e82d4.Borrow(cpResults_allocs)

	x.ref1d0e82d4 = ref1d0e82d4
	x.allocs1d0e82d4 = allocs1d0e82d4
	return ref1d0e82d4, allocs1d0e82d4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentInfo) PassValue() (C.VkPresentInfoKHR, *cgoAllocMap) {
	if x.ref1d0e82d4 != nil {
		return *x.ref1d0e82d4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentInfo) Deref() {
	if x.ref1d0e82d4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1d0e82d4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1d0e82d4.pNext))
	x.WaitSemaphoreCount = (uint32)(x.ref1d0e82d4.waitSemaphoreCount)
	hxf992404 := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxf992404.Data = unsafe.Pointer(x.ref1d0e82d4.pWaitSemaphores)
	hxf992404.Cap = 0x7fffffff
	// hxf992404.Len = ?

	x.SwapchainCount = (uint32)(x.ref1d0e82d4.swapchainCount)
	hxf8e0dd2 := (*sliceHeader)(unsafe.Pointer(&x.PSwapchains))
	hxf8e0dd2.Data = unsafe.Pointer(x.ref1d0e82d4.pSwapchains)
	hxf8e0dd2.Cap = 0x7fffffff
	// hxf8e0dd2.Len = ?

	hxf44d909 := (*sliceHeader)(unsafe.Pointer(&x.PImageIndices))
	hxf44d909.Data = unsafe.Pointer(x.ref1d0e82d4.pImageIndices)
	hxf44d909.Cap = 0x7fffffff
	// hxf44d909.Len = ?

	hxfa835e7 := (*sliceHeader)(unsafe.Pointer(&x.PResults))
	hxfa835e7.Data = unsafe.Pointer(x.ref1d0e82d4.pResults)
	hxfa835e7.Cap = 0x7fffffff
	// hxfa835e7.Len = ?

}

// allocImageSwapchainCreateInfoMemory allocates memory for type C.VkImageSwapchainCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSwapchainCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSwapchainCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageSwapchainCreateInfoValue = unsafe.Sizeof([1]C.VkImageSwapchainCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSwapchainCreateInfo) Ref() *C.VkImageSwapchainCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.refd83cc5d0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSwapchainCreateInfo) Free() {
	if x != nil && x.allocsd83cc5d0 != nil {
		x.allocsd83cc5d0.(*cgoAllocMap).Free()
		x.refd83cc5d0 = nil
	}
}

// NewImageSwapchainCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSwapchainCreateInfoRef(ref unsafe.Pointer) *ImageSwapchainCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageSwapchainCreateInfo)
	obj.refd83cc5d0 = (*C.VkImageSwapchainCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSwapchainCreateInfo) PassRef() (*C.VkImageSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd83cc5d0 != nil {
		return x.refd83cc5d0, nil
	}
	memd83cc5d0 := allocImageSwapchainCreateInfoMemory(1)
	refd83cc5d0 := (*C.VkImageSwapchainCreateInfoKHR)(memd83cc5d0)
	allocsd83cc5d0 := new(cgoAllocMap)
	allocsd83cc5d0.Add(memd83cc5d0)

	var csType_allocs *cgoAllocMap
	refd83cc5d0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd83cc5d0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd83cc5d0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd83cc5d0.Borrow(cpNext_allocs)

	var cswapchain_allocs *cgoAllocMap
	refd83cc5d0.swapchain, cswapchain_allocs = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.Swapchain)), cgoAllocsUnknown
	allocsd83cc5d0.Borrow(cswapchain_allocs)

	x.refd83cc5d0 = refd83cc5d0
	x.allocsd83cc5d0 = allocsd83cc5d0
	return refd83cc5d0, allocsd83cc5d0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSwapchainCreateInfo) PassValue() (C.VkImageSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x.refd83cc5d0 != nil {
		return *x.refd83cc5d0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSwapchainCreateInfo) Deref() {
	if x.refd83cc5d0 == nil {
		return
	}
	x.SType = (StructureType)(x.refd83cc5d0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd83cc5d0.pNext))
	x.Swapchain = *(*Swapchain)(unsafe.Pointer(&x.refd83cc5d0.swapchain))
}

// allocBindImageMemorySwapchainInfoMemory allocates memory for type C.VkBindImageMemorySwapchainInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindImageMemorySwapchainInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindImageMemorySwapchainInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindImageMemorySwapchainInfoValue = unsafe.Sizeof([1]C.VkBindImageMemorySwapchainInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImageMemorySwapchainInfo) Ref() *C.VkBindImageMemorySwapchainInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref1aa25cb6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImageMemorySwapchainInfo) Free() {
	if x != nil && x.allocs1aa25cb6 != nil {
		x.allocs1aa25cb6.(*cgoAllocMap).Free()
		x.ref1aa25cb6 = nil
	}
}

// NewBindImageMemorySwapchainInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImageMemorySwapchainInfoRef(ref unsafe.Pointer) *BindImageMemorySwapchainInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindImageMemorySwapchainInfo)
	obj.ref1aa25cb6 = (*C.VkBindImageMemorySwapchainInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImageMemorySwapchainInfo) PassRef() (*C.VkBindImageMemorySwapchainInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1aa25cb6 != nil {
		return x.ref1aa25cb6, nil
	}
	mem1aa25cb6 := allocBindImageMemorySwapchainInfoMemory(1)
	ref1aa25cb6 := (*C.VkBindImageMemorySwapchainInfoKHR)(mem1aa25cb6)
	allocs1aa25cb6 := new(cgoAllocMap)
	allocs1aa25cb6.Add(mem1aa25cb6)

	var csType_allocs *cgoAllocMap
	ref1aa25cb6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1aa25cb6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1aa25cb6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1aa25cb6.Borrow(cpNext_allocs)

	var cswapchain_allocs *cgoAllocMap
	ref1aa25cb6.swapchain, cswapchain_allocs = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.Swapchain)), cgoAllocsUnknown
	allocs1aa25cb6.Borrow(cswapchain_allocs)

	var cimageIndex_allocs *cgoAllocMap
	ref1aa25cb6.imageIndex, cimageIndex_allocs = (C.uint32_t)(x.ImageIndex), cgoAllocsUnknown
	allocs1aa25cb6.Borrow(cimageIndex_allocs)

	x.ref1aa25cb6 = ref1aa25cb6
	x.allocs1aa25cb6 = allocs1aa25cb6
	return ref1aa25cb6, allocs1aa25cb6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImageMemorySwapchainInfo) PassValue() (C.VkBindImageMemorySwapchainInfoKHR, *cgoAllocMap) {
	if x.ref1aa25cb6 != nil {
		return *x.ref1aa25cb6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImageMemorySwapchainInfo) Deref() {
	if x.ref1aa25cb6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1aa25cb6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1aa25cb6.pNext))
	x.Swapchain = *(*Swapchain)(unsafe.Pointer(&x.ref1aa25cb6.swapchain))
	x.ImageIndex = (uint32)(x.ref1aa25cb6.imageIndex)
}

// allocAcquireNextImageInfoMemory allocates memory for type C.VkAcquireNextImageInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAcquireNextImageInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAcquireNextImageInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAcquireNextImageInfoValue = unsafe.Sizeof([1]C.VkAcquireNextImageInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AcquireNextImageInfo) Ref() *C.VkAcquireNextImageInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref588806a5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AcquireNextImageInfo) Free() {
	if x != nil && x.allocs588806a5 != nil {
		x.allocs588806a5.(*cgoAllocMap).Free()
		x.ref588806a5 = nil
	}
}

// NewAcquireNextImageInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAcquireNextImageInfoRef(ref unsafe.Pointer) *AcquireNextImageInfo {
	if ref == nil {
		return nil
	}
	obj := new(AcquireNextImageInfo)
	obj.ref588806a5 = (*C.VkAcquireNextImageInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AcquireNextImageInfo) PassRef() (*C.VkAcquireNextImageInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref588806a5 != nil {
		return x.ref588806a5, nil
	}
	mem588806a5 := allocAcquireNextImageInfoMemory(1)
	ref588806a5 := (*C.VkAcquireNextImageInfoKHR)(mem588806a5)
	allocs588806a5 := new(cgoAllocMap)
	allocs588806a5.Add(mem588806a5)

	var csType_allocs *cgoAllocMap
	ref588806a5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs588806a5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref588806a5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs588806a5.Borrow(cpNext_allocs)

	var cswapchain_allocs *cgoAllocMap
	ref588806a5.swapchain, cswapchain_allocs = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.Swapchain)), cgoAllocsUnknown
	allocs588806a5.Borrow(cswapchain_allocs)

	var ctimeout_allocs *cgoAllocMap
	ref588806a5.timeout, ctimeout_allocs = (C.uint64_t)(x.Timeout), cgoAllocsUnknown
	allocs588806a5.Borrow(ctimeout_allocs)

	var csemaphore_allocs *cgoAllocMap
	ref588806a5.semaphore, csemaphore_allocs = *(*C.VkSemaphore)(unsafe.Pointer(&x.Semaphore)), cgoAllocsUnknown
	allocs588806a5.Borrow(csemaphore_allocs)

	var cfence_allocs *cgoAllocMap
	ref588806a5.fence, cfence_allocs = *(*C.VkFence)(unsafe.Pointer(&x.Fence)), cgoAllocsUnknown
	allocs588806a5.Borrow(cfence_allocs)

	var cdeviceMask_allocs *cgoAllocMap
	ref588806a5.deviceMask, cdeviceMask_allocs = (C.uint32_t)(x.DeviceMask), cgoAllocsUnknown
	allocs588806a5.Borrow(cdeviceMask_allocs)

	x.ref588806a5 = ref588806a5
	x.allocs588806a5 = allocs588806a5
	return ref588806a5, allocs588806a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AcquireNextImageInfo) PassValue() (C.VkAcquireNextImageInfoKHR, *cgoAllocMap) {
	if x.ref588806a5 != nil {
		return *x.ref588806a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AcquireNextImageInfo) Deref() {
	if x.ref588806a5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref588806a5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref588806a5.pNext))
	x.Swapchain = *(*Swapchain)(unsafe.Pointer(&x.ref588806a5.swapchain))
	x.Timeout = (uint32)(x.ref588806a5.timeout)
	x.Semaphore = *(*Semaphore)(unsafe.Pointer(&x.ref588806a5.semaphore))
	x.Fence = *(*Fence)(unsafe.Pointer(&x.ref588806a5.fence))
	x.DeviceMask = (uint32)(x.ref588806a5.deviceMask)
}

// allocDeviceGroupPresentCapabilitiesMemory allocates memory for type C.VkDeviceGroupPresentCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupPresentCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupPresentCapabilitiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceGroupPresentCapabilitiesValue = unsafe.Sizeof([1]C.VkDeviceGroupPresentCapabilitiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupPresentCapabilities) Ref() *C.VkDeviceGroupPresentCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.refa3962c81
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupPresentCapabilities) Free() {
	if x != nil && x.allocsa3962c81 != nil {
		x.allocsa3962c81.(*cgoAllocMap).Free()
		x.refa3962c81 = nil
	}
}

// NewDeviceGroupPresentCapabilitiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupPresentCapabilitiesRef(ref unsafe.Pointer) *DeviceGroupPresentCapabilities {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupPresentCapabilities)
	obj.refa3962c81 = (*C.VkDeviceGroupPresentCapabilitiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupPresentCapabilities) PassRef() (*C.VkDeviceGroupPresentCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa3962c81 != nil {
		return x.refa3962c81, nil
	}
	mema3962c81 := allocDeviceGroupPresentCapabilitiesMemory(1)
	refa3962c81 := (*C.VkDeviceGroupPresentCapabilitiesKHR)(mema3962c81)
	allocsa3962c81 := new(cgoAllocMap)
	allocsa3962c81.Add(mema3962c81)

	var csType_allocs *cgoAllocMap
	refa3962c81.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa3962c81.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa3962c81.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa3962c81.Borrow(cpNext_allocs)

	var cpresentMask_allocs *cgoAllocMap
	refa3962c81.presentMask, cpresentMask_allocs = *(*[32]C.uint32_t)(unsafe.Pointer(&x.PresentMask)), cgoAllocsUnknown
	allocsa3962c81.Borrow(cpresentMask_allocs)

	var cmodes_allocs *cgoAllocMap
	refa3962c81.modes, cmodes_allocs = (C.VkDeviceGroupPresentModeFlagsKHR)(x.Modes), cgoAllocsUnknown
	allocsa3962c81.Borrow(cmodes_allocs)

	x.refa3962c81 = refa3962c81
	x.allocsa3962c81 = allocsa3962c81
	return refa3962c81, allocsa3962c81

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupPresentCapabilities) PassValue() (C.VkDeviceGroupPresentCapabilitiesKHR, *cgoAllocMap) {
	if x.refa3962c81 != nil {
		return *x.refa3962c81, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupPresentCapabilities) Deref() {
	if x.refa3962c81 == nil {
		return
	}
	x.SType = (StructureType)(x.refa3962c81.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa3962c81.pNext))
	x.PresentMask = *(*[32]uint32)(unsafe.Pointer(&x.refa3962c81.presentMask))
	x.Modes = (DeviceGroupPresentModeFlags)(x.refa3962c81.modes)
}

// allocDeviceGroupPresentInfoMemory allocates memory for type C.VkDeviceGroupPresentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupPresentInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupPresentInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceGroupPresentInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupPresentInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupPresentInfo) Ref() *C.VkDeviceGroupPresentInfoKHR {
	if x == nil {
		return nil
	}
	return x.reff6912d09
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupPresentInfo) Free() {
	if x != nil && x.allocsf6912d09 != nil {
		x.allocsf6912d09.(*cgoAllocMap).Free()
		x.reff6912d09 = nil
	}
}

// NewDeviceGroupPresentInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupPresentInfoRef(ref unsafe.Pointer) *DeviceGroupPresentInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupPresentInfo)
	obj.reff6912d09 = (*C.VkDeviceGroupPresentInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupPresentInfo) PassRef() (*C.VkDeviceGroupPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff6912d09 != nil {
		return x.reff6912d09, nil
	}
	memf6912d09 := allocDeviceGroupPresentInfoMemory(1)
	reff6912d09 := (*C.VkDeviceGroupPresentInfoKHR)(memf6912d09)
	allocsf6912d09 := new(cgoAllocMap)
	allocsf6912d09.Add(memf6912d09)

	var csType_allocs *cgoAllocMap
	reff6912d09.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf6912d09.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff6912d09.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf6912d09.Borrow(cpNext_allocs)

	var cswapchainCount_allocs *cgoAllocMap
	reff6912d09.swapchainCount, cswapchainCount_allocs = (C.uint32_t)(x.SwapchainCount), cgoAllocsUnknown
	allocsf6912d09.Borrow(cswapchainCount_allocs)

	var cpDeviceMasks_allocs *cgoAllocMap
	reff6912d09.pDeviceMasks, cpDeviceMasks_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PDeviceMasks)))
	allocsf6912d09.Borrow(cpDeviceMasks_allocs)

	var cmode_allocs *cgoAllocMap
	reff6912d09.mode, cmode_allocs = (C.VkDeviceGroupPresentModeFlagBitsKHR)(x.Mode), cgoAllocsUnknown
	allocsf6912d09.Borrow(cmode_allocs)

	x.reff6912d09 = reff6912d09
	x.allocsf6912d09 = allocsf6912d09
	return reff6912d09, allocsf6912d09

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupPresentInfo) PassValue() (C.VkDeviceGroupPresentInfoKHR, *cgoAllocMap) {
	if x.reff6912d09 != nil {
		return *x.reff6912d09, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupPresentInfo) Deref() {
	if x.reff6912d09 == nil {
		return
	}
	x.SType = (StructureType)(x.reff6912d09.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff6912d09.pNext))
	x.SwapchainCount = (uint32)(x.reff6912d09.swapchainCount)
	hxf8eae10 := (*sliceHeader)(unsafe.Pointer(&x.PDeviceMasks))
	hxf8eae10.Data = unsafe.Pointer(x.reff6912d09.pDeviceMasks)
	hxf8eae10.Cap = 0x7fffffff
	// hxf8eae10.Len = ?

	x.Mode = (DeviceGroupPresentModeFlagBits)(x.reff6912d09.mode)
}

// allocDeviceGroupSwapchainCreateInfoMemory allocates memory for type C.VkDeviceGroupSwapchainCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupSwapchainCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupSwapchainCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceGroupSwapchainCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupSwapchainCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupSwapchainCreateInfo) Ref() *C.VkDeviceGroupSwapchainCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref44ae0c0e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupSwapchainCreateInfo) Free() {
	if x != nil && x.allocs44ae0c0e != nil {
		x.allocs44ae0c0e.(*cgoAllocMap).Free()
		x.ref44ae0c0e = nil
	}
}

// NewDeviceGroupSwapchainCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupSwapchainCreateInfoRef(ref unsafe.Pointer) *DeviceGroupSwapchainCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupSwapchainCreateInfo)
	obj.ref44ae0c0e = (*C.VkDeviceGroupSwapchainCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupSwapchainCreateInfo) PassRef() (*C.VkDeviceGroupSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref44ae0c0e != nil {
		return x.ref44ae0c0e, nil
	}
	mem44ae0c0e := allocDeviceGroupSwapchainCreateInfoMemory(1)
	ref44ae0c0e := (*C.VkDeviceGroupSwapchainCreateInfoKHR)(mem44ae0c0e)
	allocs44ae0c0e := new(cgoAllocMap)
	allocs44ae0c0e.Add(mem44ae0c0e)

	var csType_allocs *cgoAllocMap
	ref44ae0c0e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs44ae0c0e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref44ae0c0e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs44ae0c0e.Borrow(cpNext_allocs)

	var cmodes_allocs *cgoAllocMap
	ref44ae0c0e.modes, cmodes_allocs = (C.VkDeviceGroupPresentModeFlagsKHR)(x.Modes), cgoAllocsUnknown
	allocs44ae0c0e.Borrow(cmodes_allocs)

	x.ref44ae0c0e = ref44ae0c0e
	x.allocs44ae0c0e = allocs44ae0c0e
	return ref44ae0c0e, allocs44ae0c0e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupSwapchainCreateInfo) PassValue() (C.VkDeviceGroupSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x.ref44ae0c0e != nil {
		return *x.ref44ae0c0e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupSwapchainCreateInfo) Deref() {
	if x.ref44ae0c0e == nil {
		return
	}
	x.SType = (StructureType)(x.ref44ae0c0e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref44ae0c0e.pNext))
	x.Modes = (DeviceGroupPresentModeFlags)(x.ref44ae0c0e.modes)
}

// allocDisplayModeParametersMemory allocates memory for type C.VkDisplayModeParametersKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModeParametersMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModeParametersValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayModeParametersValue = unsafe.Sizeof([1]C.VkDisplayModeParametersKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayModeParameters) Ref() *C.VkDisplayModeParametersKHR {
	if x == nil {
		return nil
	}
	return x.refe016f77f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayModeParameters) Free() {
	if x != nil && x.allocse016f77f != nil {
		x.allocse016f77f.(*cgoAllocMap).Free()
		x.refe016f77f = nil
	}
}

// NewDisplayModeParametersRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayModeParametersRef(ref unsafe.Pointer) *DisplayModeParameters {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModeParameters)
	obj.refe016f77f = (*C.VkDisplayModeParametersKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayModeParameters) PassRef() (*C.VkDisplayModeParametersKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe016f77f != nil {
		return x.refe016f77f, nil
	}
	meme016f77f := allocDisplayModeParametersMemory(1)
	refe016f77f := (*C.VkDisplayModeParametersKHR)(meme016f77f)
	allocse016f77f := new(cgoAllocMap)
	allocse016f77f.Add(meme016f77f)

	var cvisibleRegion_allocs *cgoAllocMap
	refe016f77f.visibleRegion, cvisibleRegion_allocs = x.VisibleRegion.PassValue()
	allocse016f77f.Borrow(cvisibleRegion_allocs)

	var crefreshRate_allocs *cgoAllocMap
	refe016f77f.refreshRate, crefreshRate_allocs = (C.uint32_t)(x.RefreshRate), cgoAllocsUnknown
	allocse016f77f.Borrow(crefreshRate_allocs)

	x.refe016f77f = refe016f77f
	x.allocse016f77f = allocse016f77f
	return refe016f77f, allocse016f77f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayModeParameters) PassValue() (C.VkDisplayModeParametersKHR, *cgoAllocMap) {
	if x.refe016f77f != nil {
		return *x.refe016f77f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayModeParameters) Deref() {
	if x.refe016f77f == nil {
		return
	}
	x.VisibleRegion = *NewExtent2DRef(unsafe.Pointer(&x.refe016f77f.visibleRegion))
	x.RefreshRate = (uint32)(x.refe016f77f.refreshRate)
}

// allocDisplayModeCreateInfoMemory allocates memory for type C.VkDisplayModeCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModeCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModeCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayModeCreateInfoValue = unsafe.Sizeof([1]C.VkDisplayModeCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayModeCreateInfo) Ref() *C.VkDisplayModeCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref392fca31
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayModeCreateInfo) Free() {
	if x != nil && x.allocs392fca31 != nil {
		x.allocs392fca31.(*cgoAllocMap).Free()
		x.ref392fca31 = nil
	}
}

// NewDisplayModeCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayModeCreateInfoRef(ref unsafe.Pointer) *DisplayModeCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModeCreateInfo)
	obj.ref392fca31 = (*C.VkDisplayModeCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayModeCreateInfo) PassRef() (*C.VkDisplayModeCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref392fca31 != nil {
		return x.ref392fca31, nil
	}
	mem392fca31 := allocDisplayModeCreateInfoMemory(1)
	ref392fca31 := (*C.VkDisplayModeCreateInfoKHR)(mem392fca31)
	allocs392fca31 := new(cgoAllocMap)
	allocs392fca31.Add(mem392fca31)

	var csType_allocs *cgoAllocMap
	ref392fca31.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs392fca31.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref392fca31.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs392fca31.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref392fca31.flags, cflags_allocs = (C.VkDisplayModeCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs392fca31.Borrow(cflags_allocs)

	var cparameters_allocs *cgoAllocMap
	ref392fca31.parameters, cparameters_allocs = x.Parameters.PassValue()
	allocs392fca31.Borrow(cparameters_allocs)

	x.ref392fca31 = ref392fca31
	x.allocs392fca31 = allocs392fca31
	return ref392fca31, allocs392fca31

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayModeCreateInfo) PassValue() (C.VkDisplayModeCreateInfoKHR, *cgoAllocMap) {
	if x.ref392fca31 != nil {
		return *x.ref392fca31, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayModeCreateInfo) Deref() {
	if x.ref392fca31 == nil {
		return
	}
	x.SType = (StructureType)(x.ref392fca31.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref392fca31.pNext))
	x.Flags = (DisplayModeCreateFlags)(x.ref392fca31.flags)
	x.Parameters = *NewDisplayModeParametersRef(unsafe.Pointer(&x.ref392fca31.parameters))
}

// allocDisplayModePropertiesMemory allocates memory for type C.VkDisplayModePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayModePropertiesValue = unsafe.Sizeof([1]C.VkDisplayModePropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayModeProperties) Ref() *C.VkDisplayModePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref5e3abaaa
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayModeProperties) Free() {
	if x != nil && x.allocs5e3abaaa != nil {
		x.allocs5e3abaaa.(*cgoAllocMap).Free()
		x.ref5e3abaaa = nil
	}
}

// NewDisplayModePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayModePropertiesRef(ref unsafe.Pointer) *DisplayModeProperties {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModeProperties)
	obj.ref5e3abaaa = (*C.VkDisplayModePropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayModeProperties) PassRef() (*C.VkDisplayModePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e3abaaa != nil {
		return x.ref5e3abaaa, nil
	}
	mem5e3abaaa := allocDisplayModePropertiesMemory(1)
	ref5e3abaaa := (*C.VkDisplayModePropertiesKHR)(mem5e3abaaa)
	allocs5e3abaaa := new(cgoAllocMap)
	allocs5e3abaaa.Add(mem5e3abaaa)

	var cdisplayMode_allocs *cgoAllocMap
	ref5e3abaaa.displayMode, cdisplayMode_allocs = *(*C.VkDisplayModeKHR)(unsafe.Pointer(&x.DisplayMode)), cgoAllocsUnknown
	allocs5e3abaaa.Borrow(cdisplayMode_allocs)

	var cparameters_allocs *cgoAllocMap
	ref5e3abaaa.parameters, cparameters_allocs = x.Parameters.PassValue()
	allocs5e3abaaa.Borrow(cparameters_allocs)

	x.ref5e3abaaa = ref5e3abaaa
	x.allocs5e3abaaa = allocs5e3abaaa
	return ref5e3abaaa, allocs5e3abaaa

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayModeProperties) PassValue() (C.VkDisplayModePropertiesKHR, *cgoAllocMap) {
	if x.ref5e3abaaa != nil {
		return *x.ref5e3abaaa, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayModeProperties) Deref() {
	if x.ref5e3abaaa == nil {
		return
	}
	x.DisplayMode = *(*DisplayMode)(unsafe.Pointer(&x.ref5e3abaaa.displayMode))
	x.Parameters = *NewDisplayModeParametersRef(unsafe.Pointer(&x.ref5e3abaaa.parameters))
}

// allocDisplayPlaneCapabilitiesMemory allocates memory for type C.VkDisplayPlaneCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlaneCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlaneCapabilitiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayPlaneCapabilitiesValue = unsafe.Sizeof([1]C.VkDisplayPlaneCapabilitiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneCapabilities) Ref() *C.VkDisplayPlaneCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.ref6f31fcaf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneCapabilities) Free() {
	if x != nil && x.allocs6f31fcaf != nil {
		x.allocs6f31fcaf.(*cgoAllocMap).Free()
		x.ref6f31fcaf = nil
	}
}

// NewDisplayPlaneCapabilitiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlaneCapabilitiesRef(ref unsafe.Pointer) *DisplayPlaneCapabilities {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneCapabilities)
	obj.ref6f31fcaf = (*C.VkDisplayPlaneCapabilitiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneCapabilities) PassRef() (*C.VkDisplayPlaneCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6f31fcaf != nil {
		return x.ref6f31fcaf, nil
	}
	mem6f31fcaf := allocDisplayPlaneCapabilitiesMemory(1)
	ref6f31fcaf := (*C.VkDisplayPlaneCapabilitiesKHR)(mem6f31fcaf)
	allocs6f31fcaf := new(cgoAllocMap)
	allocs6f31fcaf.Add(mem6f31fcaf)

	var csupportedAlpha_allocs *cgoAllocMap
	ref6f31fcaf.supportedAlpha, csupportedAlpha_allocs = (C.VkDisplayPlaneAlphaFlagsKHR)(x.SupportedAlpha), cgoAllocsUnknown
	allocs6f31fcaf.Borrow(csupportedAlpha_allocs)

	var cminSrcPosition_allocs *cgoAllocMap
	ref6f31fcaf.minSrcPosition, cminSrcPosition_allocs = x.MinSrcPosition.PassValue()
	allocs6f31fcaf.Borrow(cminSrcPosition_allocs)

	var cmaxSrcPosition_allocs *cgoAllocMap
	ref6f31fcaf.maxSrcPosition, cmaxSrcPosition_allocs = x.MaxSrcPosition.PassValue()
	allocs6f31fcaf.Borrow(cmaxSrcPosition_allocs)

	var cminSrcExtent_allocs *cgoAllocMap
	ref6f31fcaf.minSrcExtent, cminSrcExtent_allocs = x.MinSrcExtent.PassValue()
	allocs6f31fcaf.Borrow(cminSrcExtent_allocs)

	var cmaxSrcExtent_allocs *cgoAllocMap
	ref6f31fcaf.maxSrcExtent, cmaxSrcExtent_allocs = x.MaxSrcExtent.PassValue()
	allocs6f31fcaf.Borrow(cmaxSrcExtent_allocs)

	var cminDstPosition_allocs *cgoAllocMap
	ref6f31fcaf.minDstPosition, cminDstPosition_allocs = x.MinDstPosition.PassValue()
	allocs6f31fcaf.Borrow(cminDstPosition_allocs)

	var cmaxDstPosition_allocs *cgoAllocMap
	ref6f31fcaf.maxDstPosition, cmaxDstPosition_allocs = x.MaxDstPosition.PassValue()
	allocs6f31fcaf.Borrow(cmaxDstPosition_allocs)

	var cminDstExtent_allocs *cgoAllocMap
	ref6f31fcaf.minDstExtent, cminDstExtent_allocs = x.MinDstExtent.PassValue()
	allocs6f31fcaf.Borrow(cminDstExtent_allocs)

	var cmaxDstExtent_allocs *cgoAllocMap
	ref6f31fcaf.maxDstExtent, cmaxDstExtent_allocs = x.MaxDstExtent.PassValue()
	allocs6f31fcaf.Borrow(cmaxDstExtent_allocs)

	x.ref6f31fcaf = ref6f31fcaf
	x.allocs6f31fcaf = allocs6f31fcaf
	return ref6f31fcaf, allocs6f31fcaf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneCapabilities) PassValue() (C.VkDisplayPlaneCapabilitiesKHR, *cgoAllocMap) {
	if x.ref6f31fcaf != nil {
		return *x.ref6f31fcaf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneCapabilities) Deref() {
	if x.ref6f31fcaf == nil {
		return
	}
	x.SupportedAlpha = (DisplayPlaneAlphaFlags)(x.ref6f31fcaf.supportedAlpha)
	x.MinSrcPosition = *NewOffset2DRef(unsafe.Pointer(&x.ref6f31fcaf.minSrcPosition))
	x.MaxSrcPosition = *NewOffset2DRef(unsafe.Pointer(&x.ref6f31fcaf.maxSrcPosition))
	x.MinSrcExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref6f31fcaf.minSrcExtent))
	x.MaxSrcExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref6f31fcaf.maxSrcExtent))
	x.MinDstPosition = *NewOffset2DRef(unsafe.Pointer(&x.ref6f31fcaf.minDstPosition))
	x.MaxDstPosition = *NewOffset2DRef(unsafe.Pointer(&x.ref6f31fcaf.maxDstPosition))
	x.MinDstExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref6f31fcaf.minDstExtent))
	x.MaxDstExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref6f31fcaf.maxDstExtent))
}

// allocDisplayPlanePropertiesMemory allocates memory for type C.VkDisplayPlanePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlanePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlanePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayPlanePropertiesValue = unsafe.Sizeof([1]C.VkDisplayPlanePropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneProperties) Ref() *C.VkDisplayPlanePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.refce3db3f6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneProperties) Free() {
	if x != nil && x.allocsce3db3f6 != nil {
		x.allocsce3db3f6.(*cgoAllocMap).Free()
		x.refce3db3f6 = nil
	}
}

// NewDisplayPlanePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlanePropertiesRef(ref unsafe.Pointer) *DisplayPlaneProperties {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneProperties)
	obj.refce3db3f6 = (*C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneProperties) PassRef() (*C.VkDisplayPlanePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refce3db3f6 != nil {
		return x.refce3db3f6, nil
	}
	memce3db3f6 := allocDisplayPlanePropertiesMemory(1)
	refce3db3f6 := (*C.VkDisplayPlanePropertiesKHR)(memce3db3f6)
	allocsce3db3f6 := new(cgoAllocMap)
	allocsce3db3f6.Add(memce3db3f6)

	var ccurrentDisplay_allocs *cgoAllocMap
	refce3db3f6.currentDisplay, ccurrentDisplay_allocs = *(*C.VkDisplayKHR)(unsafe.Pointer(&x.CurrentDisplay)), cgoAllocsUnknown
	allocsce3db3f6.Borrow(ccurrentDisplay_allocs)

	var ccurrentStackIndex_allocs *cgoAllocMap
	refce3db3f6.currentStackIndex, ccurrentStackIndex_allocs = (C.uint32_t)(x.CurrentStackIndex), cgoAllocsUnknown
	allocsce3db3f6.Borrow(ccurrentStackIndex_allocs)

	x.refce3db3f6 = refce3db3f6
	x.allocsce3db3f6 = allocsce3db3f6
	return refce3db3f6, allocsce3db3f6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneProperties) PassValue() (C.VkDisplayPlanePropertiesKHR, *cgoAllocMap) {
	if x.refce3db3f6 != nil {
		return *x.refce3db3f6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneProperties) Deref() {
	if x.refce3db3f6 == nil {
		return
	}
	x.CurrentDisplay = *(*Display)(unsafe.Pointer(&x.refce3db3f6.currentDisplay))
	x.CurrentStackIndex = (uint32)(x.refce3db3f6.currentStackIndex)
}

// allocDisplayPropertiesMemory allocates memory for type C.VkDisplayPropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayPropertiesValue = unsafe.Sizeof([1]C.VkDisplayPropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayProperties) Ref() *C.VkDisplayPropertiesKHR {
	if x == nil {
		return nil
	}
	return x.reffe2a7187
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayProperties) Free() {
	if x != nil && x.allocsfe2a7187 != nil {
		x.allocsfe2a7187.(*cgoAllocMap).Free()
		x.reffe2a7187 = nil
	}
}

// NewDisplayPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPropertiesRef(ref unsafe.Pointer) *DisplayProperties {
	if ref == nil {
		return nil
	}
	obj := new(DisplayProperties)
	obj.reffe2a7187 = (*C.VkDisplayPropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayProperties) PassRef() (*C.VkDisplayPropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe2a7187 != nil {
		return x.reffe2a7187, nil
	}
	memfe2a7187 := allocDisplayPropertiesMemory(1)
	reffe2a7187 := (*C.VkDisplayPropertiesKHR)(memfe2a7187)
	allocsfe2a7187 := new(cgoAllocMap)
	allocsfe2a7187.Add(memfe2a7187)

	var cdisplay_allocs *cgoAllocMap
	reffe2a7187.display, cdisplay_allocs = *(*C.VkDisplayKHR)(unsafe.Pointer(&x.Display)), cgoAllocsUnknown
	allocsfe2a7187.Borrow(cdisplay_allocs)

	var cdisplayName_allocs *cgoAllocMap
	reffe2a7187.displayName, cdisplayName_allocs = unpackPCharString(x.DisplayName)
	allocsfe2a7187.Borrow(cdisplayName_allocs)

	var cphysicalDimensions_allocs *cgoAllocMap
	reffe2a7187.physicalDimensions, cphysicalDimensions_allocs = x.PhysicalDimensions.PassValue()
	allocsfe2a7187.Borrow(cphysicalDimensions_allocs)

	var cphysicalResolution_allocs *cgoAllocMap
	reffe2a7187.physicalResolution, cphysicalResolution_allocs = x.PhysicalResolution.PassValue()
	allocsfe2a7187.Borrow(cphysicalResolution_allocs)

	var csupportedTransforms_allocs *cgoAllocMap
	reffe2a7187.supportedTransforms, csupportedTransforms_allocs = (C.VkSurfaceTransformFlagsKHR)(x.SupportedTransforms), cgoAllocsUnknown
	allocsfe2a7187.Borrow(csupportedTransforms_allocs)

	var cplaneReorderPossible_allocs *cgoAllocMap
	reffe2a7187.planeReorderPossible, cplaneReorderPossible_allocs = (C.VkBool32)(x.PlaneReorderPossible), cgoAllocsUnknown
	allocsfe2a7187.Borrow(cplaneReorderPossible_allocs)

	var cpersistentContent_allocs *cgoAllocMap
	reffe2a7187.persistentContent, cpersistentContent_allocs = (C.VkBool32)(x.PersistentContent), cgoAllocsUnknown
	allocsfe2a7187.Borrow(cpersistentContent_allocs)

	x.reffe2a7187 = reffe2a7187
	x.allocsfe2a7187 = allocsfe2a7187
	return reffe2a7187, allocsfe2a7187

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayProperties) PassValue() (C.VkDisplayPropertiesKHR, *cgoAllocMap) {
	if x.reffe2a7187 != nil {
		return *x.reffe2a7187, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayProperties) Deref() {
	if x.reffe2a7187 == nil {
		return
	}
	x.Display = *(*Display)(unsafe.Pointer(&x.reffe2a7187.display))
	x.DisplayName = packPCharString(x.reffe2a7187.displayName)
	x.PhysicalDimensions = *NewExtent2DRef(unsafe.Pointer(&x.reffe2a7187.physicalDimensions))
	x.PhysicalResolution = *NewExtent2DRef(unsafe.Pointer(&x.reffe2a7187.physicalResolution))
	x.SupportedTransforms = (SurfaceTransformFlags)(x.reffe2a7187.supportedTransforms)
	x.PlaneReorderPossible = (Bool32)(x.reffe2a7187.planeReorderPossible)
	x.PersistentContent = (Bool32)(x.reffe2a7187.persistentContent)
}

// allocDisplaySurfaceCreateInfoMemory allocates memory for type C.VkDisplaySurfaceCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplaySurfaceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplaySurfaceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplaySurfaceCreateInfoValue = unsafe.Sizeof([1]C.VkDisplaySurfaceCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplaySurfaceCreateInfo) Ref() *C.VkDisplaySurfaceCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref58445c35
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplaySurfaceCreateInfo) Free() {
	if x != nil && x.allocs58445c35 != nil {
		x.allocs58445c35.(*cgoAllocMap).Free()
		x.ref58445c35 = nil
	}
}

// NewDisplaySurfaceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplaySurfaceCreateInfoRef(ref unsafe.Pointer) *DisplaySurfaceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DisplaySurfaceCreateInfo)
	obj.ref58445c35 = (*C.VkDisplaySurfaceCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplaySurfaceCreateInfo) PassRef() (*C.VkDisplaySurfaceCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref58445c35 != nil {
		return x.ref58445c35, nil
	}
	mem58445c35 := allocDisplaySurfaceCreateInfoMemory(1)
	ref58445c35 := (*C.VkDisplaySurfaceCreateInfoKHR)(mem58445c35)
	allocs58445c35 := new(cgoAllocMap)
	allocs58445c35.Add(mem58445c35)

	var csType_allocs *cgoAllocMap
	ref58445c35.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs58445c35.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref58445c35.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs58445c35.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref58445c35.flags, cflags_allocs = (C.VkDisplaySurfaceCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs58445c35.Borrow(cflags_allocs)

	var cdisplayMode_allocs *cgoAllocMap
	ref58445c35.displayMode, cdisplayMode_allocs = *(*C.VkDisplayModeKHR)(unsafe.Pointer(&x.DisplayMode)), cgoAllocsUnknown
	allocs58445c35.Borrow(cdisplayMode_allocs)

	var cplaneIndex_allocs *cgoAllocMap
	ref58445c35.planeIndex, cplaneIndex_allocs = (C.uint32_t)(x.PlaneIndex), cgoAllocsUnknown
	allocs58445c35.Borrow(cplaneIndex_allocs)

	var cplaneStackIndex_allocs *cgoAllocMap
	ref58445c35.planeStackIndex, cplaneStackIndex_allocs = (C.uint32_t)(x.PlaneStackIndex), cgoAllocsUnknown
	allocs58445c35.Borrow(cplaneStackIndex_allocs)

	var ctransform_allocs *cgoAllocMap
	ref58445c35.transform, ctransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.Transform), cgoAllocsUnknown
	allocs58445c35.Borrow(ctransform_allocs)

	var cglobalAlpha_allocs *cgoAllocMap
	ref58445c35.globalAlpha, cglobalAlpha_allocs = (C.float)(x.GlobalAlpha), cgoAllocsUnknown
	allocs58445c35.Borrow(cglobalAlpha_allocs)

	var calphaMode_allocs *cgoAllocMap
	ref58445c35.alphaMode, calphaMode_allocs = (C.VkDisplayPlaneAlphaFlagBitsKHR)(x.AlphaMode), cgoAllocsUnknown
	allocs58445c35.Borrow(calphaMode_allocs)

	var cimageExtent_allocs *cgoAllocMap
	ref58445c35.imageExtent, cimageExtent_allocs = x.ImageExtent.PassValue()
	allocs58445c35.Borrow(cimageExtent_allocs)

	x.ref58445c35 = ref58445c35
	x.allocs58445c35 = allocs58445c35
	return ref58445c35, allocs58445c35

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplaySurfaceCreateInfo) PassValue() (C.VkDisplaySurfaceCreateInfoKHR, *cgoAllocMap) {
	if x.ref58445c35 != nil {
		return *x.ref58445c35, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplaySurfaceCreateInfo) Deref() {
	if x.ref58445c35 == nil {
		return
	}
	x.SType = (StructureType)(x.ref58445c35.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref58445c35.pNext))
	x.Flags = (DisplaySurfaceCreateFlags)(x.ref58445c35.flags)
	x.DisplayMode = *(*DisplayMode)(unsafe.Pointer(&x.ref58445c35.displayMode))
	x.PlaneIndex = (uint32)(x.ref58445c35.planeIndex)
	x.PlaneStackIndex = (uint32)(x.ref58445c35.planeStackIndex)
	x.Transform = (SurfaceTransformFlagBits)(x.ref58445c35.transform)
	x.GlobalAlpha = (float32)(x.ref58445c35.globalAlpha)
	x.AlphaMode = (DisplayPlaneAlphaFlagBits)(x.ref58445c35.alphaMode)
	x.ImageExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref58445c35.imageExtent))
}

// allocDisplayPresentInfoMemory allocates memory for type C.VkDisplayPresentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPresentInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPresentInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayPresentInfoValue = unsafe.Sizeof([1]C.VkDisplayPresentInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPresentInfo) Ref() *C.VkDisplayPresentInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref8d2571e4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPresentInfo) Free() {
	if x != nil && x.allocs8d2571e4 != nil {
		x.allocs8d2571e4.(*cgoAllocMap).Free()
		x.ref8d2571e4 = nil
	}
}

// NewDisplayPresentInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPresentInfoRef(ref unsafe.Pointer) *DisplayPresentInfo {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPresentInfo)
	obj.ref8d2571e4 = (*C.VkDisplayPresentInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPresentInfo) PassRef() (*C.VkDisplayPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8d2571e4 != nil {
		return x.ref8d2571e4, nil
	}
	mem8d2571e4 := allocDisplayPresentInfoMemory(1)
	ref8d2571e4 := (*C.VkDisplayPresentInfoKHR)(mem8d2571e4)
	allocs8d2571e4 := new(cgoAllocMap)
	allocs8d2571e4.Add(mem8d2571e4)

	var csType_allocs *cgoAllocMap
	ref8d2571e4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8d2571e4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8d2571e4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8d2571e4.Borrow(cpNext_allocs)

	var csrcRect_allocs *cgoAllocMap
	ref8d2571e4.srcRect, csrcRect_allocs = x.SrcRect.PassValue()
	allocs8d2571e4.Borrow(csrcRect_allocs)

	var cdstRect_allocs *cgoAllocMap
	ref8d2571e4.dstRect, cdstRect_allocs = x.DstRect.PassValue()
	allocs8d2571e4.Borrow(cdstRect_allocs)

	var cpersistent_allocs *cgoAllocMap
	ref8d2571e4.persistent, cpersistent_allocs = (C.VkBool32)(x.Persistent), cgoAllocsUnknown
	allocs8d2571e4.Borrow(cpersistent_allocs)

	x.ref8d2571e4 = ref8d2571e4
	x.allocs8d2571e4 = allocs8d2571e4
	return ref8d2571e4, allocs8d2571e4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPresentInfo) PassValue() (C.VkDisplayPresentInfoKHR, *cgoAllocMap) {
	if x.ref8d2571e4 != nil {
		return *x.ref8d2571e4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPresentInfo) Deref() {
	if x.ref8d2571e4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8d2571e4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8d2571e4.pNext))
	x.SrcRect = *NewRect2DRef(unsafe.Pointer(&x.ref8d2571e4.srcRect))
	x.DstRect = *NewRect2DRef(unsafe.Pointer(&x.ref8d2571e4.dstRect))
	x.Persistent = (Bool32)(x.ref8d2571e4.persistent)
}

// allocImportMemoryFdInfoMemory allocates memory for type C.VkImportMemoryFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImportMemoryFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImportMemoryFdInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImportMemoryFdInfoValue = unsafe.Sizeof([1]C.VkImportMemoryFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImportMemoryFdInfo) Ref() *C.VkImportMemoryFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref73f83287
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImportMemoryFdInfo) Free() {
	if x != nil && x.allocs73f83287 != nil {
		x.allocs73f83287.(*cgoAllocMap).Free()
		x.ref73f83287 = nil
	}
}

// NewImportMemoryFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImportMemoryFdInfoRef(ref unsafe.Pointer) *ImportMemoryFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImportMemoryFdInfo)
	obj.ref73f83287 = (*C.VkImportMemoryFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImportMemoryFdInfo) PassRef() (*C.VkImportMemoryFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref73f83287 != nil {
		return x.ref73f83287, nil
	}
	mem73f83287 := allocImportMemoryFdInfoMemory(1)
	ref73f83287 := (*C.VkImportMemoryFdInfoKHR)(mem73f83287)
	allocs73f83287 := new(cgoAllocMap)
	allocs73f83287.Add(mem73f83287)

	var csType_allocs *cgoAllocMap
	ref73f83287.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs73f83287.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref73f83287.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs73f83287.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	ref73f83287.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs73f83287.Borrow(chandleType_allocs)

	var cfd_allocs *cgoAllocMap
	ref73f83287.fd, cfd_allocs = (C.int)(x.Fd), cgoAllocsUnknown
	allocs73f83287.Borrow(cfd_allocs)

	x.ref73f83287 = ref73f83287
	x.allocs73f83287 = allocs73f83287
	return ref73f83287, allocs73f83287

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImportMemoryFdInfo) PassValue() (C.VkImportMemoryFdInfoKHR, *cgoAllocMap) {
	if x.ref73f83287 != nil {
		return *x.ref73f83287, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImportMemoryFdInfo) Deref() {
	if x.ref73f83287 == nil {
		return
	}
	x.SType = (StructureType)(x.ref73f83287.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref73f83287.pNext))
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.ref73f83287.handleType)
	x.Fd = (int32)(x.ref73f83287.fd)
}

// allocMemoryFdPropertiesMemory allocates memory for type C.VkMemoryFdPropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryFdPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryFdPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryFdPropertiesValue = unsafe.Sizeof([1]C.VkMemoryFdPropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryFdProperties) Ref() *C.VkMemoryFdPropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref51e16d38
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryFdProperties) Free() {
	if x != nil && x.allocs51e16d38 != nil {
		x.allocs51e16d38.(*cgoAllocMap).Free()
		x.ref51e16d38 = nil
	}
}

// NewMemoryFdPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryFdPropertiesRef(ref unsafe.Pointer) *MemoryFdProperties {
	if ref == nil {
		return nil
	}
	obj := new(MemoryFdProperties)
	obj.ref51e16d38 = (*C.VkMemoryFdPropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryFdProperties) PassRef() (*C.VkMemoryFdPropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref51e16d38 != nil {
		return x.ref51e16d38, nil
	}
	mem51e16d38 := allocMemoryFdPropertiesMemory(1)
	ref51e16d38 := (*C.VkMemoryFdPropertiesKHR)(mem51e16d38)
	allocs51e16d38 := new(cgoAllocMap)
	allocs51e16d38.Add(mem51e16d38)

	var csType_allocs *cgoAllocMap
	ref51e16d38.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs51e16d38.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref51e16d38.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs51e16d38.Borrow(cpNext_allocs)

	var cmemoryTypeBits_allocs *cgoAllocMap
	ref51e16d38.memoryTypeBits, cmemoryTypeBits_allocs = (C.uint32_t)(x.MemoryTypeBits), cgoAllocsUnknown
	allocs51e16d38.Borrow(cmemoryTypeBits_allocs)

	x.ref51e16d38 = ref51e16d38
	x.allocs51e16d38 = allocs51e16d38
	return ref51e16d38, allocs51e16d38

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryFdProperties) PassValue() (C.VkMemoryFdPropertiesKHR, *cgoAllocMap) {
	if x.ref51e16d38 != nil {
		return *x.ref51e16d38, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryFdProperties) Deref() {
	if x.ref51e16d38 == nil {
		return
	}
	x.SType = (StructureType)(x.ref51e16d38.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref51e16d38.pNext))
	x.MemoryTypeBits = (uint32)(x.ref51e16d38.memoryTypeBits)
}

// allocMemoryGetFdInfoMemory allocates memory for type C.VkMemoryGetFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryGetFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryGetFdInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryGetFdInfoValue = unsafe.Sizeof([1]C.VkMemoryGetFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryGetFdInfo) Ref() *C.VkMemoryGetFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref75a079b1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryGetFdInfo) Free() {
	if x != nil && x.allocs75a079b1 != nil {
		x.allocs75a079b1.(*cgoAllocMap).Free()
		x.ref75a079b1 = nil
	}
}

// NewMemoryGetFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryGetFdInfoRef(ref unsafe.Pointer) *MemoryGetFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(MemoryGetFdInfo)
	obj.ref75a079b1 = (*C.VkMemoryGetFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryGetFdInfo) PassRef() (*C.VkMemoryGetFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75a079b1 != nil {
		return x.ref75a079b1, nil
	}
	mem75a079b1 := allocMemoryGetFdInfoMemory(1)
	ref75a079b1 := (*C.VkMemoryGetFdInfoKHR)(mem75a079b1)
	allocs75a079b1 := new(cgoAllocMap)
	allocs75a079b1.Add(mem75a079b1)

	var csType_allocs *cgoAllocMap
	ref75a079b1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs75a079b1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref75a079b1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs75a079b1.Borrow(cpNext_allocs)

	var cmemory_allocs *cgoAllocMap
	ref75a079b1.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs75a079b1.Borrow(cmemory_allocs)

	var chandleType_allocs *cgoAllocMap
	ref75a079b1.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs75a079b1.Borrow(chandleType_allocs)

	x.ref75a079b1 = ref75a079b1
	x.allocs75a079b1 = allocs75a079b1
	return ref75a079b1, allocs75a079b1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryGetFdInfo) PassValue() (C.VkMemoryGetFdInfoKHR, *cgoAllocMap) {
	if x.ref75a079b1 != nil {
		return *x.ref75a079b1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryGetFdInfo) Deref() {
	if x.ref75a079b1 == nil {
		return
	}
	x.SType = (StructureType)(x.ref75a079b1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref75a079b1.pNext))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref75a079b1.memory))
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.ref75a079b1.handleType)
}

// allocImportSemaphoreFdInfoMemory allocates memory for type C.VkImportSemaphoreFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImportSemaphoreFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImportSemaphoreFdInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImportSemaphoreFdInfoValue = unsafe.Sizeof([1]C.VkImportSemaphoreFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImportSemaphoreFdInfo) Ref() *C.VkImportSemaphoreFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.refbc2f829a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImportSemaphoreFdInfo) Free() {
	if x != nil && x.allocsbc2f829a != nil {
		x.allocsbc2f829a.(*cgoAllocMap).Free()
		x.refbc2f829a = nil
	}
}

// NewImportSemaphoreFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImportSemaphoreFdInfoRef(ref unsafe.Pointer) *ImportSemaphoreFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImportSemaphoreFdInfo)
	obj.refbc2f829a = (*C.VkImportSemaphoreFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImportSemaphoreFdInfo) PassRef() (*C.VkImportSemaphoreFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbc2f829a != nil {
		return x.refbc2f829a, nil
	}
	membc2f829a := allocImportSemaphoreFdInfoMemory(1)
	refbc2f829a := (*C.VkImportSemaphoreFdInfoKHR)(membc2f829a)
	allocsbc2f829a := new(cgoAllocMap)
	allocsbc2f829a.Add(membc2f829a)

	var csType_allocs *cgoAllocMap
	refbc2f829a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbc2f829a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbc2f829a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbc2f829a.Borrow(cpNext_allocs)

	var csemaphore_allocs *cgoAllocMap
	refbc2f829a.semaphore, csemaphore_allocs = *(*C.VkSemaphore)(unsafe.Pointer(&x.Semaphore)), cgoAllocsUnknown
	allocsbc2f829a.Borrow(csemaphore_allocs)

	var cflags_allocs *cgoAllocMap
	refbc2f829a.flags, cflags_allocs = (C.VkSemaphoreImportFlags)(x.Flags), cgoAllocsUnknown
	allocsbc2f829a.Borrow(cflags_allocs)

	var chandleType_allocs *cgoAllocMap
	refbc2f829a.handleType, chandleType_allocs = (C.VkExternalSemaphoreHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocsbc2f829a.Borrow(chandleType_allocs)

	var cfd_allocs *cgoAllocMap
	refbc2f829a.fd, cfd_allocs = (C.int)(x.Fd), cgoAllocsUnknown
	allocsbc2f829a.Borrow(cfd_allocs)

	x.refbc2f829a = refbc2f829a
	x.allocsbc2f829a = allocsbc2f829a
	return refbc2f829a, allocsbc2f829a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImportSemaphoreFdInfo) PassValue() (C.VkImportSemaphoreFdInfoKHR, *cgoAllocMap) {
	if x.refbc2f829a != nil {
		return *x.refbc2f829a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImportSemaphoreFdInfo) Deref() {
	if x.refbc2f829a == nil {
		return
	}
	x.SType = (StructureType)(x.refbc2f829a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbc2f829a.pNext))
	x.Semaphore = *(*Semaphore)(unsafe.Pointer(&x.refbc2f829a.semaphore))
	x.Flags = (SemaphoreImportFlags)(x.refbc2f829a.flags)
	x.HandleType = (ExternalSemaphoreHandleTypeFlagBits)(x.refbc2f829a.handleType)
	x.Fd = (int32)(x.refbc2f829a.fd)
}

// allocSemaphoreGetFdInfoMemory allocates memory for type C.VkSemaphoreGetFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreGetFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreGetFdInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSemaphoreGetFdInfoValue = unsafe.Sizeof([1]C.VkSemaphoreGetFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SemaphoreGetFdInfo) Ref() *C.VkSemaphoreGetFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.refd9bd07cf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SemaphoreGetFdInfo) Free() {
	if x != nil && x.allocsd9bd07cf != nil {
		x.allocsd9bd07cf.(*cgoAllocMap).Free()
		x.refd9bd07cf = nil
	}
}

// NewSemaphoreGetFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSemaphoreGetFdInfoRef(ref unsafe.Pointer) *SemaphoreGetFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(SemaphoreGetFdInfo)
	obj.refd9bd07cf = (*C.VkSemaphoreGetFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SemaphoreGetFdInfo) PassRef() (*C.VkSemaphoreGetFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9bd07cf != nil {
		return x.refd9bd07cf, nil
	}
	memd9bd07cf := allocSemaphoreGetFdInfoMemory(1)
	refd9bd07cf := (*C.VkSemaphoreGetFdInfoKHR)(memd9bd07cf)
	allocsd9bd07cf := new(cgoAllocMap)
	allocsd9bd07cf.Add(memd9bd07cf)

	var csType_allocs *cgoAllocMap
	refd9bd07cf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd9bd07cf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd9bd07cf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd9bd07cf.Borrow(cpNext_allocs)

	var csemaphore_allocs *cgoAllocMap
	refd9bd07cf.semaphore, csemaphore_allocs = *(*C.VkSemaphore)(unsafe.Pointer(&x.Semaphore)), cgoAllocsUnknown
	allocsd9bd07cf.Borrow(csemaphore_allocs)

	var chandleType_allocs *cgoAllocMap
	refd9bd07cf.handleType, chandleType_allocs = (C.VkExternalSemaphoreHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocsd9bd07cf.Borrow(chandleType_allocs)

	x.refd9bd07cf = refd9bd07cf
	x.allocsd9bd07cf = allocsd9bd07cf
	return refd9bd07cf, allocsd9bd07cf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SemaphoreGetFdInfo) PassValue() (C.VkSemaphoreGetFdInfoKHR, *cgoAllocMap) {
	if x.refd9bd07cf != nil {
		return *x.refd9bd07cf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SemaphoreGetFdInfo) Deref() {
	if x.refd9bd07cf == nil {
		return
	}
	x.SType = (StructureType)(x.refd9bd07cf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd9bd07cf.pNext))
	x.Semaphore = *(*Semaphore)(unsafe.Pointer(&x.refd9bd07cf.semaphore))
	x.HandleType = (ExternalSemaphoreHandleTypeFlagBits)(x.refd9bd07cf.handleType)
}

// allocPhysicalDevicePushDescriptorPropertiesMemory allocates memory for type C.VkPhysicalDevicePushDescriptorPropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePushDescriptorPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePushDescriptorPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDevicePushDescriptorPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDevicePushDescriptorPropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevicePushDescriptorProperties) Ref() *C.VkPhysicalDevicePushDescriptorPropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref8c58a1a5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevicePushDescriptorProperties) Free() {
	if x != nil && x.allocs8c58a1a5 != nil {
		x.allocs8c58a1a5.(*cgoAllocMap).Free()
		x.ref8c58a1a5 = nil
	}
}

// NewPhysicalDevicePushDescriptorPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePushDescriptorPropertiesRef(ref unsafe.Pointer) *PhysicalDevicePushDescriptorProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevicePushDescriptorProperties)
	obj.ref8c58a1a5 = (*C.VkPhysicalDevicePushDescriptorPropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevicePushDescriptorProperties) PassRef() (*C.VkPhysicalDevicePushDescriptorPropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8c58a1a5 != nil {
		return x.ref8c58a1a5, nil
	}
	mem8c58a1a5 := allocPhysicalDevicePushDescriptorPropertiesMemory(1)
	ref8c58a1a5 := (*C.VkPhysicalDevicePushDescriptorPropertiesKHR)(mem8c58a1a5)
	allocs8c58a1a5 := new(cgoAllocMap)
	allocs8c58a1a5.Add(mem8c58a1a5)

	var csType_allocs *cgoAllocMap
	ref8c58a1a5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8c58a1a5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8c58a1a5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8c58a1a5.Borrow(cpNext_allocs)

	var cmaxPushDescriptors_allocs *cgoAllocMap
	ref8c58a1a5.maxPushDescriptors, cmaxPushDescriptors_allocs = (C.uint32_t)(x.MaxPushDescriptors), cgoAllocsUnknown
	allocs8c58a1a5.Borrow(cmaxPushDescriptors_allocs)

	x.ref8c58a1a5 = ref8c58a1a5
	x.allocs8c58a1a5 = allocs8c58a1a5
	return ref8c58a1a5, allocs8c58a1a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevicePushDescriptorProperties) PassValue() (C.VkPhysicalDevicePushDescriptorPropertiesKHR, *cgoAllocMap) {
	if x.ref8c58a1a5 != nil {
		return *x.ref8c58a1a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevicePushDescriptorProperties) Deref() {
	if x.ref8c58a1a5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8c58a1a5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8c58a1a5.pNext))
	x.MaxPushDescriptors = (uint32)(x.ref8c58a1a5.maxPushDescriptors)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFloat16Int8Features) Ref() *C.VkPhysicalDeviceShaderFloat16Int8Features {
	if x == nil {
		return nil
	}
	return x.refc9d315b6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFloat16Int8Features) Free() {
	if x != nil && x.allocsc9d315b6 != nil {
		x.allocsc9d315b6.(*cgoAllocMap).Free()
		x.refc9d315b6 = nil
	}
}

// NewPhysicalDeviceFloat16Int8FeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFloat16Int8FeaturesRef(ref unsafe.Pointer) *PhysicalDeviceFloat16Int8Features {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFloat16Int8Features)
	obj.refc9d315b6 = (*C.VkPhysicalDeviceShaderFloat16Int8Features)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFloat16Int8Features) PassRef() (*C.VkPhysicalDeviceShaderFloat16Int8Features, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc9d315b6 != nil {
		return x.refc9d315b6, nil
	}
	memc9d315b6 := allocPhysicalDeviceShaderFloat16Int8FeaturesMemory(1)
	refc9d315b6 := (*C.VkPhysicalDeviceShaderFloat16Int8Features)(memc9d315b6)
	allocsc9d315b6 := new(cgoAllocMap)
	allocsc9d315b6.Add(memc9d315b6)

	var csType_allocs *cgoAllocMap
	refc9d315b6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc9d315b6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc9d315b6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc9d315b6.Borrow(cpNext_allocs)

	var cshaderFloat16_allocs *cgoAllocMap
	refc9d315b6.shaderFloat16, cshaderFloat16_allocs = (C.VkBool32)(x.ShaderFloat16), cgoAllocsUnknown
	allocsc9d315b6.Borrow(cshaderFloat16_allocs)

	var cshaderInt8_allocs *cgoAllocMap
	refc9d315b6.shaderInt8, cshaderInt8_allocs = (C.VkBool32)(x.ShaderInt8), cgoAllocsUnknown
	allocsc9d315b6.Borrow(cshaderInt8_allocs)

	x.refc9d315b6 = refc9d315b6
	x.allocsc9d315b6 = allocsc9d315b6
	return refc9d315b6, allocsc9d315b6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFloat16Int8Features) PassValue() (C.VkPhysicalDeviceShaderFloat16Int8Features, *cgoAllocMap) {
	if x.refc9d315b6 != nil {
		return *x.refc9d315b6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFloat16Int8Features) Deref() {
	if x.refc9d315b6 == nil {
		return
	}
	x.SType = (StructureType)(x.refc9d315b6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc9d315b6.pNext))
	x.ShaderFloat16 = (Bool32)(x.refc9d315b6.shaderFloat16)
	x.ShaderInt8 = (Bool32)(x.refc9d315b6.shaderInt8)
}

// allocRectLayerMemory allocates memory for type C.VkRectLayerKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectLayerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectLayerValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRectLayerValue = unsafe.Sizeof([1]C.VkRectLayerKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RectLayer) Ref() *C.VkRectLayerKHR {
	if x == nil {
		return nil
	}
	return x.refaf248476
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RectLayer) Free() {
	if x != nil && x.allocsaf248476 != nil {
		x.allocsaf248476.(*cgoAllocMap).Free()
		x.refaf248476 = nil
	}
}

// NewRectLayerRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRectLayerRef(ref unsafe.Pointer) *RectLayer {
	if ref == nil {
		return nil
	}
	obj := new(RectLayer)
	obj.refaf248476 = (*C.VkRectLayerKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RectLayer) PassRef() (*C.VkRectLayerKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaf248476 != nil {
		return x.refaf248476, nil
	}
	memaf248476 := allocRectLayerMemory(1)
	refaf248476 := (*C.VkRectLayerKHR)(memaf248476)
	allocsaf248476 := new(cgoAllocMap)
	allocsaf248476.Add(memaf248476)

	var coffset_allocs *cgoAllocMap
	refaf248476.offset, coffset_allocs = x.Offset.PassValue()
	allocsaf248476.Borrow(coffset_allocs)

	var cextent_allocs *cgoAllocMap
	refaf248476.extent, cextent_allocs = x.Extent.PassValue()
	allocsaf248476.Borrow(cextent_allocs)

	var clayer_allocs *cgoAllocMap
	refaf248476.layer, clayer_allocs = (C.uint32_t)(x.Layer), cgoAllocsUnknown
	allocsaf248476.Borrow(clayer_allocs)

	x.refaf248476 = refaf248476
	x.allocsaf248476 = allocsaf248476
	return refaf248476, allocsaf248476

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RectLayer) PassValue() (C.VkRectLayerKHR, *cgoAllocMap) {
	if x.refaf248476 != nil {
		return *x.refaf248476, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RectLayer) Deref() {
	if x.refaf248476 == nil {
		return
	}
	x.Offset = *NewOffset2DRef(unsafe.Pointer(&x.refaf248476.offset))
	x.Extent = *NewExtent2DRef(unsafe.Pointer(&x.refaf248476.extent))
	x.Layer = (uint32)(x.refaf248476.layer)
}

// allocPresentRegionMemory allocates memory for type C.VkPresentRegionKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentRegionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentRegionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPresentRegionValue = unsafe.Sizeof([1]C.VkPresentRegionKHR{})

// unpackSRectLayer transforms a sliced Go data structure into plain C format.
func unpackSRectLayer(x []RectLayer) (unpacked *C.VkRectLayerKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRectLayerMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRectLayerKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRectLayerKHR)(h.Data)
	return
}

// packSRectLayer reads sliced Go data structure out from plain C format.
func packSRectLayer(v []RectLayer, ptr0 *C.VkRectLayerKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRectLayerValue]C.VkRectLayerKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRectLayerRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentRegion) Ref() *C.VkPresentRegionKHR {
	if x == nil {
		return nil
	}
	return x.refbbc0d1b9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentRegion) Free() {
	if x != nil && x.allocsbbc0d1b9 != nil {
		x.allocsbbc0d1b9.(*cgoAllocMap).Free()
		x.refbbc0d1b9 = nil
	}
}

// NewPresentRegionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentRegionRef(ref unsafe.Pointer) *PresentRegion {
	if ref == nil {
		return nil
	}
	obj := new(PresentRegion)
	obj.refbbc0d1b9 = (*C.VkPresentRegionKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentRegion) PassRef() (*C.VkPresentRegionKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbbc0d1b9 != nil {
		return x.refbbc0d1b9, nil
	}
	membbc0d1b9 := allocPresentRegionMemory(1)
	refbbc0d1b9 := (*C.VkPresentRegionKHR)(membbc0d1b9)
	allocsbbc0d1b9 := new(cgoAllocMap)
	allocsbbc0d1b9.Add(membbc0d1b9)

	var crectangleCount_allocs *cgoAllocMap
	refbbc0d1b9.rectangleCount, crectangleCount_allocs = (C.uint32_t)(x.RectangleCount), cgoAllocsUnknown
	allocsbbc0d1b9.Borrow(crectangleCount_allocs)

	var cpRectangles_allocs *cgoAllocMap
	refbbc0d1b9.pRectangles, cpRectangles_allocs = unpackSRectLayer(x.PRectangles)
	allocsbbc0d1b9.Borrow(cpRectangles_allocs)

	x.refbbc0d1b9 = refbbc0d1b9
	x.allocsbbc0d1b9 = allocsbbc0d1b9
	return refbbc0d1b9, allocsbbc0d1b9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentRegion) PassValue() (C.VkPresentRegionKHR, *cgoAllocMap) {
	if x.refbbc0d1b9 != nil {
		return *x.refbbc0d1b9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentRegion) Deref() {
	if x.refbbc0d1b9 == nil {
		return
	}
	x.RectangleCount = (uint32)(x.refbbc0d1b9.rectangleCount)
	packSRectLayer(x.PRectangles, x.refbbc0d1b9.pRectangles)
}

// allocPresentRegionsMemory allocates memory for type C.VkPresentRegionsKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentRegionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentRegionsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPresentRegionsValue = unsafe.Sizeof([1]C.VkPresentRegionsKHR{})

// unpackSPresentRegion transforms a sliced Go data structure into plain C format.
func unpackSPresentRegion(x []PresentRegion) (unpacked *C.VkPresentRegionKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPresentRegionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPresentRegionKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPresentRegionKHR)(h.Data)
	return
}

// packSPresentRegion reads sliced Go data structure out from plain C format.
func packSPresentRegion(v []PresentRegion, ptr0 *C.VkPresentRegionKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPresentRegionValue]C.VkPresentRegionKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPresentRegionRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentRegions) Ref() *C.VkPresentRegionsKHR {
	if x == nil {
		return nil
	}
	return x.ref62958060
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentRegions) Free() {
	if x != nil && x.allocs62958060 != nil {
		x.allocs62958060.(*cgoAllocMap).Free()
		x.ref62958060 = nil
	}
}

// NewPresentRegionsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentRegionsRef(ref unsafe.Pointer) *PresentRegions {
	if ref == nil {
		return nil
	}
	obj := new(PresentRegions)
	obj.ref62958060 = (*C.VkPresentRegionsKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentRegions) PassRef() (*C.VkPresentRegionsKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref62958060 != nil {
		return x.ref62958060, nil
	}
	mem62958060 := allocPresentRegionsMemory(1)
	ref62958060 := (*C.VkPresentRegionsKHR)(mem62958060)
	allocs62958060 := new(cgoAllocMap)
	allocs62958060.Add(mem62958060)

	var csType_allocs *cgoAllocMap
	ref62958060.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs62958060.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref62958060.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs62958060.Borrow(cpNext_allocs)

	var cswapchainCount_allocs *cgoAllocMap
	ref62958060.swapchainCount, cswapchainCount_allocs = (C.uint32_t)(x.SwapchainCount), cgoAllocsUnknown
	allocs62958060.Borrow(cswapchainCount_allocs)

	var cpRegions_allocs *cgoAllocMap
	ref62958060.pRegions, cpRegions_allocs = unpackSPresentRegion(x.PRegions)
	allocs62958060.Borrow(cpRegions_allocs)

	x.ref62958060 = ref62958060
	x.allocs62958060 = allocs62958060
	return ref62958060, allocs62958060

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentRegions) PassValue() (C.VkPresentRegionsKHR, *cgoAllocMap) {
	if x.ref62958060 != nil {
		return *x.ref62958060, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentRegions) Deref() {
	if x.ref62958060 == nil {
		return
	}
	x.SType = (StructureType)(x.ref62958060.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref62958060.pNext))
	x.SwapchainCount = (uint32)(x.ref62958060.swapchainCount)
	packSPresentRegion(x.PRegions, x.ref62958060.pRegions)
}

// allocSharedPresentSurfaceCapabilitiesMemory allocates memory for type C.VkSharedPresentSurfaceCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSharedPresentSurfaceCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSharedPresentSurfaceCapabilitiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSharedPresentSurfaceCapabilitiesValue = unsafe.Sizeof([1]C.VkSharedPresentSurfaceCapabilitiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SharedPresentSurfaceCapabilities) Ref() *C.VkSharedPresentSurfaceCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.ref3f98a814
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SharedPresentSurfaceCapabilities) Free() {
	if x != nil && x.allocs3f98a814 != nil {
		x.allocs3f98a814.(*cgoAllocMap).Free()
		x.ref3f98a814 = nil
	}
}

// NewSharedPresentSurfaceCapabilitiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSharedPresentSurfaceCapabilitiesRef(ref unsafe.Pointer) *SharedPresentSurfaceCapabilities {
	if ref == nil {
		return nil
	}
	obj := new(SharedPresentSurfaceCapabilities)
	obj.ref3f98a814 = (*C.VkSharedPresentSurfaceCapabilitiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SharedPresentSurfaceCapabilities) PassRef() (*C.VkSharedPresentSurfaceCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3f98a814 != nil {
		return x.ref3f98a814, nil
	}
	mem3f98a814 := allocSharedPresentSurfaceCapabilitiesMemory(1)
	ref3f98a814 := (*C.VkSharedPresentSurfaceCapabilitiesKHR)(mem3f98a814)
	allocs3f98a814 := new(cgoAllocMap)
	allocs3f98a814.Add(mem3f98a814)

	var csType_allocs *cgoAllocMap
	ref3f98a814.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3f98a814.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3f98a814.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3f98a814.Borrow(cpNext_allocs)

	var csharedPresentSupportedUsageFlags_allocs *cgoAllocMap
	ref3f98a814.sharedPresentSupportedUsageFlags, csharedPresentSupportedUsageFlags_allocs = (C.VkImageUsageFlags)(x.SharedPresentSupportedUsageFlags), cgoAllocsUnknown
	allocs3f98a814.Borrow(csharedPresentSupportedUsageFlags_allocs)

	x.ref3f98a814 = ref3f98a814
	x.allocs3f98a814 = allocs3f98a814
	return ref3f98a814, allocs3f98a814

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SharedPresentSurfaceCapabilities) PassValue() (C.VkSharedPresentSurfaceCapabilitiesKHR, *cgoAllocMap) {
	if x.ref3f98a814 != nil {
		return *x.ref3f98a814, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SharedPresentSurfaceCapabilities) Deref() {
	if x.ref3f98a814 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3f98a814.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3f98a814.pNext))
	x.SharedPresentSupportedUsageFlags = (ImageUsageFlags)(x.ref3f98a814.sharedPresentSupportedUsageFlags)
}

// allocImportFenceFdInfoMemory allocates memory for type C.VkImportFenceFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImportFenceFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImportFenceFdInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImportFenceFdInfoValue = unsafe.Sizeof([1]C.VkImportFenceFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImportFenceFdInfo) Ref() *C.VkImportFenceFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref86ebd28c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImportFenceFdInfo) Free() {
	if x != nil && x.allocs86ebd28c != nil {
		x.allocs86ebd28c.(*cgoAllocMap).Free()
		x.ref86ebd28c = nil
	}
}

// NewImportFenceFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImportFenceFdInfoRef(ref unsafe.Pointer) *ImportFenceFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImportFenceFdInfo)
	obj.ref86ebd28c = (*C.VkImportFenceFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImportFenceFdInfo) PassRef() (*C.VkImportFenceFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref86ebd28c != nil {
		return x.ref86ebd28c, nil
	}
	mem86ebd28c := allocImportFenceFdInfoMemory(1)
	ref86ebd28c := (*C.VkImportFenceFdInfoKHR)(mem86ebd28c)
	allocs86ebd28c := new(cgoAllocMap)
	allocs86ebd28c.Add(mem86ebd28c)

	var csType_allocs *cgoAllocMap
	ref86ebd28c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs86ebd28c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref86ebd28c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs86ebd28c.Borrow(cpNext_allocs)

	var cfence_allocs *cgoAllocMap
	ref86ebd28c.fence, cfence_allocs = *(*C.VkFence)(unsafe.Pointer(&x.Fence)), cgoAllocsUnknown
	allocs86ebd28c.Borrow(cfence_allocs)

	var cflags_allocs *cgoAllocMap
	ref86ebd28c.flags, cflags_allocs = (C.VkFenceImportFlags)(x.Flags), cgoAllocsUnknown
	allocs86ebd28c.Borrow(cflags_allocs)

	var chandleType_allocs *cgoAllocMap
	ref86ebd28c.handleType, chandleType_allocs = (C.VkExternalFenceHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs86ebd28c.Borrow(chandleType_allocs)

	var cfd_allocs *cgoAllocMap
	ref86ebd28c.fd, cfd_allocs = (C.int)(x.Fd), cgoAllocsUnknown
	allocs86ebd28c.Borrow(cfd_allocs)

	x.ref86ebd28c = ref86ebd28c
	x.allocs86ebd28c = allocs86ebd28c
	return ref86ebd28c, allocs86ebd28c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImportFenceFdInfo) PassValue() (C.VkImportFenceFdInfoKHR, *cgoAllocMap) {
	if x.ref86ebd28c != nil {
		return *x.ref86ebd28c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImportFenceFdInfo) Deref() {
	if x.ref86ebd28c == nil {
		return
	}
	x.SType = (StructureType)(x.ref86ebd28c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref86ebd28c.pNext))
	x.Fence = *(*Fence)(unsafe.Pointer(&x.ref86ebd28c.fence))
	x.Flags = (FenceImportFlags)(x.ref86ebd28c.flags)
	x.HandleType = (ExternalFenceHandleTypeFlagBits)(x.ref86ebd28c.handleType)
	x.Fd = (int32)(x.ref86ebd28c.fd)
}

// allocFenceGetFdInfoMemory allocates memory for type C.VkFenceGetFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFenceGetFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFenceGetFdInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFenceGetFdInfoValue = unsafe.Sizeof([1]C.VkFenceGetFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FenceGetFdInfo) Ref() *C.VkFenceGetFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.refc2668bc3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FenceGetFdInfo) Free() {
	if x != nil && x.allocsc2668bc3 != nil {
		x.allocsc2668bc3.(*cgoAllocMap).Free()
		x.refc2668bc3 = nil
	}
}

// NewFenceGetFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFenceGetFdInfoRef(ref unsafe.Pointer) *FenceGetFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(FenceGetFdInfo)
	obj.refc2668bc3 = (*C.VkFenceGetFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FenceGetFdInfo) PassRef() (*C.VkFenceGetFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc2668bc3 != nil {
		return x.refc2668bc3, nil
	}
	memc2668bc3 := allocFenceGetFdInfoMemory(1)
	refc2668bc3 := (*C.VkFenceGetFdInfoKHR)(memc2668bc3)
	allocsc2668bc3 := new(cgoAllocMap)
	allocsc2668bc3.Add(memc2668bc3)

	var csType_allocs *cgoAllocMap
	refc2668bc3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc2668bc3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc2668bc3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc2668bc3.Borrow(cpNext_allocs)

	var cfence_allocs *cgoAllocMap
	refc2668bc3.fence, cfence_allocs = *(*C.VkFence)(unsafe.Pointer(&x.Fence)), cgoAllocsUnknown
	allocsc2668bc3.Borrow(cfence_allocs)

	var chandleType_allocs *cgoAllocMap
	refc2668bc3.handleType, chandleType_allocs = (C.VkExternalFenceHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocsc2668bc3.Borrow(chandleType_allocs)

	x.refc2668bc3 = refc2668bc3
	x.allocsc2668bc3 = allocsc2668bc3
	return refc2668bc3, allocsc2668bc3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FenceGetFdInfo) PassValue() (C.VkFenceGetFdInfoKHR, *cgoAllocMap) {
	if x.refc2668bc3 != nil {
		return *x.refc2668bc3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FenceGetFdInfo) Deref() {
	if x.refc2668bc3 == nil {
		return
	}
	x.SType = (StructureType)(x.refc2668bc3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc2668bc3.pNext))
	x.Fence = *(*Fence)(unsafe.Pointer(&x.refc2668bc3.fence))
	x.HandleType = (ExternalFenceHandleTypeFlagBits)(x.refc2668bc3.handleType)
}

// allocPhysicalDevicePerformanceQueryFeaturesMemory allocates memory for type C.VkPhysicalDevicePerformanceQueryFeaturesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePerformanceQueryFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePerformanceQueryFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDevicePerformanceQueryFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDevicePerformanceQueryFeaturesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevicePerformanceQueryFeatures) Ref() *C.VkPhysicalDevicePerformanceQueryFeaturesKHR {
	if x == nil {
		return nil
	}
	return x.ref8e4527cb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevicePerformanceQueryFeatures) Free() {
	if x != nil && x.allocs8e4527cb != nil {
		x.allocs8e4527cb.(*cgoAllocMap).Free()
		x.ref8e4527cb = nil
	}
}

// NewPhysicalDevicePerformanceQueryFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePerformanceQueryFeaturesRef(ref unsafe.Pointer) *PhysicalDevicePerformanceQueryFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevicePerformanceQueryFeatures)
	obj.ref8e4527cb = (*C.VkPhysicalDevicePerformanceQueryFeaturesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevicePerformanceQueryFeatures) PassRef() (*C.VkPhysicalDevicePerformanceQueryFeaturesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8e4527cb != nil {
		return x.ref8e4527cb, nil
	}
	mem8e4527cb := allocPhysicalDevicePerformanceQueryFeaturesMemory(1)
	ref8e4527cb := (*C.VkPhysicalDevicePerformanceQueryFeaturesKHR)(mem8e4527cb)
	allocs8e4527cb := new(cgoAllocMap)
	allocs8e4527cb.Add(mem8e4527cb)

	var csType_allocs *cgoAllocMap
	ref8e4527cb.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8e4527cb.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8e4527cb.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8e4527cb.Borrow(cpNext_allocs)

	var cperformanceCounterQueryPools_allocs *cgoAllocMap
	ref8e4527cb.performanceCounterQueryPools, cperformanceCounterQueryPools_allocs = (C.VkBool32)(x.PerformanceCounterQueryPools), cgoAllocsUnknown
	allocs8e4527cb.Borrow(cperformanceCounterQueryPools_allocs)

	var cperformanceCounterMultipleQueryPools_allocs *cgoAllocMap
	ref8e4527cb.performanceCounterMultipleQueryPools, cperformanceCounterMultipleQueryPools_allocs = (C.VkBool32)(x.PerformanceCounterMultipleQueryPools), cgoAllocsUnknown
	allocs8e4527cb.Borrow(cperformanceCounterMultipleQueryPools_allocs)

	x.ref8e4527cb = ref8e4527cb
	x.allocs8e4527cb = allocs8e4527cb
	return ref8e4527cb, allocs8e4527cb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevicePerformanceQueryFeatures) PassValue() (C.VkPhysicalDevicePerformanceQueryFeaturesKHR, *cgoAllocMap) {
	if x.ref8e4527cb != nil {
		return *x.ref8e4527cb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevicePerformanceQueryFeatures) Deref() {
	if x.ref8e4527cb == nil {
		return
	}
	x.SType = (StructureType)(x.ref8e4527cb.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8e4527cb.pNext))
	x.PerformanceCounterQueryPools = (Bool32)(x.ref8e4527cb.performanceCounterQueryPools)
	x.PerformanceCounterMultipleQueryPools = (Bool32)(x.ref8e4527cb.performanceCounterMultipleQueryPools)
}

// allocPhysicalDevicePerformanceQueryPropertiesMemory allocates memory for type C.VkPhysicalDevicePerformanceQueryPropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePerformanceQueryPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePerformanceQueryPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDevicePerformanceQueryPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDevicePerformanceQueryPropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevicePerformanceQueryProperties) Ref() *C.VkPhysicalDevicePerformanceQueryPropertiesKHR {
	if x == nil {
		return nil
	}
	return x.refc3efa645
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevicePerformanceQueryProperties) Free() {
	if x != nil && x.allocsc3efa645 != nil {
		x.allocsc3efa645.(*cgoAllocMap).Free()
		x.refc3efa645 = nil
	}
}

// NewPhysicalDevicePerformanceQueryPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePerformanceQueryPropertiesRef(ref unsafe.Pointer) *PhysicalDevicePerformanceQueryProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevicePerformanceQueryProperties)
	obj.refc3efa645 = (*C.VkPhysicalDevicePerformanceQueryPropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevicePerformanceQueryProperties) PassRef() (*C.VkPhysicalDevicePerformanceQueryPropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc3efa645 != nil {
		return x.refc3efa645, nil
	}
	memc3efa645 := allocPhysicalDevicePerformanceQueryPropertiesMemory(1)
	refc3efa645 := (*C.VkPhysicalDevicePerformanceQueryPropertiesKHR)(memc3efa645)
	allocsc3efa645 := new(cgoAllocMap)
	allocsc3efa645.Add(memc3efa645)

	var csType_allocs *cgoAllocMap
	refc3efa645.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc3efa645.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc3efa645.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc3efa645.Borrow(cpNext_allocs)

	var callowCommandBufferQueryCopies_allocs *cgoAllocMap
	refc3efa645.allowCommandBufferQueryCopies, callowCommandBufferQueryCopies_allocs = (C.VkBool32)(x.AllowCommandBufferQueryCopies), cgoAllocsUnknown
	allocsc3efa645.Borrow(callowCommandBufferQueryCopies_allocs)

	x.refc3efa645 = refc3efa645
	x.allocsc3efa645 = allocsc3efa645
	return refc3efa645, allocsc3efa645

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevicePerformanceQueryProperties) PassValue() (C.VkPhysicalDevicePerformanceQueryPropertiesKHR, *cgoAllocMap) {
	if x.refc3efa645 != nil {
		return *x.refc3efa645, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevicePerformanceQueryProperties) Deref() {
	if x.refc3efa645 == nil {
		return
	}
	x.SType = (StructureType)(x.refc3efa645.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc3efa645.pNext))
	x.AllowCommandBufferQueryCopies = (Bool32)(x.refc3efa645.allowCommandBufferQueryCopies)
}

// allocPerformanceCounterMemory allocates memory for type C.VkPerformanceCounterKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPerformanceCounterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPerformanceCounterValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPerformanceCounterValue = unsafe.Sizeof([1]C.VkPerformanceCounterKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PerformanceCounter) Ref() *C.VkPerformanceCounterKHR {
	if x == nil {
		return nil
	}
	return x.refc754b4e5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PerformanceCounter) Free() {
	if x != nil && x.allocsc754b4e5 != nil {
		x.allocsc754b4e5.(*cgoAllocMap).Free()
		x.refc754b4e5 = nil
	}
}

// NewPerformanceCounterRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPerformanceCounterRef(ref unsafe.Pointer) *PerformanceCounter {
	if ref == nil {
		return nil
	}
	obj := new(PerformanceCounter)
	obj.refc754b4e5 = (*C.VkPerformanceCounterKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PerformanceCounter) PassRef() (*C.VkPerformanceCounterKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc754b4e5 != nil {
		return x.refc754b4e5, nil
	}
	memc754b4e5 := allocPerformanceCounterMemory(1)
	refc754b4e5 := (*C.VkPerformanceCounterKHR)(memc754b4e5)
	allocsc754b4e5 := new(cgoAllocMap)
	allocsc754b4e5.Add(memc754b4e5)

	var csType_allocs *cgoAllocMap
	refc754b4e5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc754b4e5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc754b4e5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc754b4e5.Borrow(cpNext_allocs)

	var cunit_allocs *cgoAllocMap
	refc754b4e5.unit, cunit_allocs = (C.VkPerformanceCounterUnitKHR)(x.Unit), cgoAllocsUnknown
	allocsc754b4e5.Borrow(cunit_allocs)

	var cscope_allocs *cgoAllocMap
	refc754b4e5.scope, cscope_allocs = (C.VkPerformanceCounterScopeKHR)(x.Scope), cgoAllocsUnknown
	allocsc754b4e5.Borrow(cscope_allocs)

	var cstorage_allocs *cgoAllocMap
	refc754b4e5.storage, cstorage_allocs = (C.VkPerformanceCounterStorageKHR)(x.Storage), cgoAllocsUnknown
	allocsc754b4e5.Borrow(cstorage_allocs)

	var cuuid_allocs *cgoAllocMap
	refc754b4e5.uuid, cuuid_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.Uuid)), cgoAllocsUnknown
	allocsc754b4e5.Borrow(cuuid_allocs)

	x.refc754b4e5 = refc754b4e5
	x.allocsc754b4e5 = allocsc754b4e5
	return refc754b4e5, allocsc754b4e5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PerformanceCounter) PassValue() (C.VkPerformanceCounterKHR, *cgoAllocMap) {
	if x.refc754b4e5 != nil {
		return *x.refc754b4e5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PerformanceCounter) Deref() {
	if x.refc754b4e5 == nil {
		return
	}
	x.SType = (StructureType)(x.refc754b4e5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc754b4e5.pNext))
	x.Unit = (PerformanceCounterUnit)(x.refc754b4e5.unit)
	x.Scope = (PerformanceCounterScope)(x.refc754b4e5.scope)
	x.Storage = (PerformanceCounterStorage)(x.refc754b4e5.storage)
	x.Uuid = *(*[16]byte)(unsafe.Pointer(&x.refc754b4e5.uuid))
}

// allocPerformanceCounterDescriptionMemory allocates memory for type C.VkPerformanceCounterDescriptionKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPerformanceCounterDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPerformanceCounterDescriptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPerformanceCounterDescriptionValue = unsafe.Sizeof([1]C.VkPerformanceCounterDescriptionKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PerformanceCounterDescription) Ref() *C.VkPerformanceCounterDescriptionKHR {
	if x == nil {
		return nil
	}
	return x.ref95209df5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PerformanceCounterDescription) Free() {
	if x != nil && x.allocs95209df5 != nil {
		x.allocs95209df5.(*cgoAllocMap).Free()
		x.ref95209df5 = nil
	}
}

// NewPerformanceCounterDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPerformanceCounterDescriptionRef(ref unsafe.Pointer) *PerformanceCounterDescription {
	if ref == nil {
		return nil
	}
	obj := new(PerformanceCounterDescription)
	obj.ref95209df5 = (*C.VkPerformanceCounterDescriptionKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PerformanceCounterDescription) PassRef() (*C.VkPerformanceCounterDescriptionKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref95209df5 != nil {
		return x.ref95209df5, nil
	}
	mem95209df5 := allocPerformanceCounterDescriptionMemory(1)
	ref95209df5 := (*C.VkPerformanceCounterDescriptionKHR)(mem95209df5)
	allocs95209df5 := new(cgoAllocMap)
	allocs95209df5.Add(mem95209df5)

	var csType_allocs *cgoAllocMap
	ref95209df5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs95209df5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref95209df5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs95209df5.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref95209df5.flags, cflags_allocs = (C.VkPerformanceCounterDescriptionFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs95209df5.Borrow(cflags_allocs)

	var cname_allocs *cgoAllocMap
	ref95209df5.name, cname_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Name)), cgoAllocsUnknown
	allocs95209df5.Borrow(cname_allocs)

	var ccategory_allocs *cgoAllocMap
	ref95209df5.category, ccategory_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Category)), cgoAllocsUnknown
	allocs95209df5.Borrow(ccategory_allocs)

	var cdescription_allocs *cgoAllocMap
	ref95209df5.description, cdescription_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Description)), cgoAllocsUnknown
	allocs95209df5.Borrow(cdescription_allocs)

	x.ref95209df5 = ref95209df5
	x.allocs95209df5 = allocs95209df5
	return ref95209df5, allocs95209df5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PerformanceCounterDescription) PassValue() (C.VkPerformanceCounterDescriptionKHR, *cgoAllocMap) {
	if x.ref95209df5 != nil {
		return *x.ref95209df5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PerformanceCounterDescription) Deref() {
	if x.ref95209df5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref95209df5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref95209df5.pNext))
	x.Flags = (PerformanceCounterDescriptionFlags)(x.ref95209df5.flags)
	x.Name = *(*[256]byte)(unsafe.Pointer(&x.ref95209df5.name))
	x.Category = *(*[256]byte)(unsafe.Pointer(&x.ref95209df5.category))
	x.Description = *(*[256]byte)(unsafe.Pointer(&x.ref95209df5.description))
}

// allocQueryPoolPerformanceCreateInfoMemory allocates memory for type C.VkQueryPoolPerformanceCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueryPoolPerformanceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueryPoolPerformanceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfQueryPoolPerformanceCreateInfoValue = unsafe.Sizeof([1]C.VkQueryPoolPerformanceCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueryPoolPerformanceCreateInfo) Ref() *C.VkQueryPoolPerformanceCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref55afa561
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueryPoolPerformanceCreateInfo) Free() {
	if x != nil && x.allocs55afa561 != nil {
		x.allocs55afa561.(*cgoAllocMap).Free()
		x.ref55afa561 = nil
	}
}

// NewQueryPoolPerformanceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueryPoolPerformanceCreateInfoRef(ref unsafe.Pointer) *QueryPoolPerformanceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(QueryPoolPerformanceCreateInfo)
	obj.ref55afa561 = (*C.VkQueryPoolPerformanceCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueryPoolPerformanceCreateInfo) PassRef() (*C.VkQueryPoolPerformanceCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref55afa561 != nil {
		return x.ref55afa561, nil
	}
	mem55afa561 := allocQueryPoolPerformanceCreateInfoMemory(1)
	ref55afa561 := (*C.VkQueryPoolPerformanceCreateInfoKHR)(mem55afa561)
	allocs55afa561 := new(cgoAllocMap)
	allocs55afa561.Add(mem55afa561)

	var csType_allocs *cgoAllocMap
	ref55afa561.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs55afa561.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref55afa561.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs55afa561.Borrow(cpNext_allocs)

	var cqueueFamilyIndex_allocs *cgoAllocMap
	ref55afa561.queueFamilyIndex, cqueueFamilyIndex_allocs = (C.uint32_t)(x.QueueFamilyIndex), cgoAllocsUnknown
	allocs55afa561.Borrow(cqueueFamilyIndex_allocs)

	var ccounterIndexCount_allocs *cgoAllocMap
	ref55afa561.counterIndexCount, ccounterIndexCount_allocs = (C.uint32_t)(x.CounterIndexCount), cgoAllocsUnknown
	allocs55afa561.Borrow(ccounterIndexCount_allocs)

	var cpCounterIndices_allocs *cgoAllocMap
	ref55afa561.pCounterIndices, cpCounterIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PCounterIndices)))
	allocs55afa561.Borrow(cpCounterIndices_allocs)

	x.ref55afa561 = ref55afa561
	x.allocs55afa561 = allocs55afa561
	return ref55afa561, allocs55afa561

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueryPoolPerformanceCreateInfo) PassValue() (C.VkQueryPoolPerformanceCreateInfoKHR, *cgoAllocMap) {
	if x.ref55afa561 != nil {
		return *x.ref55afa561, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueryPoolPerformanceCreateInfo) Deref() {
	if x.ref55afa561 == nil {
		return
	}
	x.SType = (StructureType)(x.ref55afa561.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref55afa561.pNext))
	x.QueueFamilyIndex = (uint32)(x.ref55afa561.queueFamilyIndex)
	x.CounterIndexCount = (uint32)(x.ref55afa561.counterIndexCount)
	hxfeb55cf := (*sliceHeader)(unsafe.Pointer(&x.PCounterIndices))
	hxfeb55cf.Data = unsafe.Pointer(x.ref55afa561.pCounterIndices)
	hxfeb55cf.Cap = 0x7fffffff
	// hxfeb55cf.Len = ?

}

// allocAcquireProfilingLockInfoMemory allocates memory for type C.VkAcquireProfilingLockInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAcquireProfilingLockInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAcquireProfilingLockInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAcquireProfilingLockInfoValue = unsafe.Sizeof([1]C.VkAcquireProfilingLockInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AcquireProfilingLockInfo) Ref() *C.VkAcquireProfilingLockInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref73cbb121
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AcquireProfilingLockInfo) Free() {
	if x != nil && x.allocs73cbb121 != nil {
		x.allocs73cbb121.(*cgoAllocMap).Free()
		x.ref73cbb121 = nil
	}
}

// NewAcquireProfilingLockInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAcquireProfilingLockInfoRef(ref unsafe.Pointer) *AcquireProfilingLockInfo {
	if ref == nil {
		return nil
	}
	obj := new(AcquireProfilingLockInfo)
	obj.ref73cbb121 = (*C.VkAcquireProfilingLockInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AcquireProfilingLockInfo) PassRef() (*C.VkAcquireProfilingLockInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref73cbb121 != nil {
		return x.ref73cbb121, nil
	}
	mem73cbb121 := allocAcquireProfilingLockInfoMemory(1)
	ref73cbb121 := (*C.VkAcquireProfilingLockInfoKHR)(mem73cbb121)
	allocs73cbb121 := new(cgoAllocMap)
	allocs73cbb121.Add(mem73cbb121)

	var csType_allocs *cgoAllocMap
	ref73cbb121.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs73cbb121.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref73cbb121.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs73cbb121.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref73cbb121.flags, cflags_allocs = (C.VkAcquireProfilingLockFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs73cbb121.Borrow(cflags_allocs)

	var ctimeout_allocs *cgoAllocMap
	ref73cbb121.timeout, ctimeout_allocs = (C.uint64_t)(x.Timeout), cgoAllocsUnknown
	allocs73cbb121.Borrow(ctimeout_allocs)

	x.ref73cbb121 = ref73cbb121
	x.allocs73cbb121 = allocs73cbb121
	return ref73cbb121, allocs73cbb121

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AcquireProfilingLockInfo) PassValue() (C.VkAcquireProfilingLockInfoKHR, *cgoAllocMap) {
	if x.ref73cbb121 != nil {
		return *x.ref73cbb121, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AcquireProfilingLockInfo) Deref() {
	if x.ref73cbb121 == nil {
		return
	}
	x.SType = (StructureType)(x.ref73cbb121.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref73cbb121.pNext))
	x.Flags = (AcquireProfilingLockFlags)(x.ref73cbb121.flags)
	x.Timeout = (uint32)(x.ref73cbb121.timeout)
}

// allocPerformanceQuerySubmitInfoMemory allocates memory for type C.VkPerformanceQuerySubmitInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPerformanceQuerySubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPerformanceQuerySubmitInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPerformanceQuerySubmitInfoValue = unsafe.Sizeof([1]C.VkPerformanceQuerySubmitInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PerformanceQuerySubmitInfo) Ref() *C.VkPerformanceQuerySubmitInfoKHR {
	if x == nil {
		return nil
	}
	return x.refbccd2736
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PerformanceQuerySubmitInfo) Free() {
	if x != nil && x.allocsbccd2736 != nil {
		x.allocsbccd2736.(*cgoAllocMap).Free()
		x.refbccd2736 = nil
	}
}

// NewPerformanceQuerySubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPerformanceQuerySubmitInfoRef(ref unsafe.Pointer) *PerformanceQuerySubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(PerformanceQuerySubmitInfo)
	obj.refbccd2736 = (*C.VkPerformanceQuerySubmitInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PerformanceQuerySubmitInfo) PassRef() (*C.VkPerformanceQuerySubmitInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbccd2736 != nil {
		return x.refbccd2736, nil
	}
	membccd2736 := allocPerformanceQuerySubmitInfoMemory(1)
	refbccd2736 := (*C.VkPerformanceQuerySubmitInfoKHR)(membccd2736)
	allocsbccd2736 := new(cgoAllocMap)
	allocsbccd2736.Add(membccd2736)

	var csType_allocs *cgoAllocMap
	refbccd2736.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbccd2736.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbccd2736.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbccd2736.Borrow(cpNext_allocs)

	var ccounterPassIndex_allocs *cgoAllocMap
	refbccd2736.counterPassIndex, ccounterPassIndex_allocs = (C.uint32_t)(x.CounterPassIndex), cgoAllocsUnknown
	allocsbccd2736.Borrow(ccounterPassIndex_allocs)

	x.refbccd2736 = refbccd2736
	x.allocsbccd2736 = allocsbccd2736
	return refbccd2736, allocsbccd2736

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PerformanceQuerySubmitInfo) PassValue() (C.VkPerformanceQuerySubmitInfoKHR, *cgoAllocMap) {
	if x.refbccd2736 != nil {
		return *x.refbccd2736, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PerformanceQuerySubmitInfo) Deref() {
	if x.refbccd2736 == nil {
		return
	}
	x.SType = (StructureType)(x.refbccd2736.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbccd2736.pNext))
	x.CounterPassIndex = (uint32)(x.refbccd2736.counterPassIndex)
}

// allocPhysicalDeviceSurfaceInfo2Memory allocates memory for type C.VkPhysicalDeviceSurfaceInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSurfaceInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSurfaceInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceSurfaceInfo2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceSurfaceInfo2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSurfaceInfo2) Ref() *C.VkPhysicalDeviceSurfaceInfo2KHR {
	if x == nil {
		return nil
	}
	return x.refd22370ae
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSurfaceInfo2) Free() {
	if x != nil && x.allocsd22370ae != nil {
		x.allocsd22370ae.(*cgoAllocMap).Free()
		x.refd22370ae = nil
	}
}

// NewPhysicalDeviceSurfaceInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSurfaceInfo2Ref(ref unsafe.Pointer) *PhysicalDeviceSurfaceInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSurfaceInfo2)
	obj.refd22370ae = (*C.VkPhysicalDeviceSurfaceInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSurfaceInfo2) PassRef() (*C.VkPhysicalDeviceSurfaceInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd22370ae != nil {
		return x.refd22370ae, nil
	}
	memd22370ae := allocPhysicalDeviceSurfaceInfo2Memory(1)
	refd22370ae := (*C.VkPhysicalDeviceSurfaceInfo2KHR)(memd22370ae)
	allocsd22370ae := new(cgoAllocMap)
	allocsd22370ae.Add(memd22370ae)

	var csType_allocs *cgoAllocMap
	refd22370ae.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd22370ae.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd22370ae.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd22370ae.Borrow(cpNext_allocs)

	var csurface_allocs *cgoAllocMap
	refd22370ae.surface, csurface_allocs = *(*C.VkSurfaceKHR)(unsafe.Pointer(&x.Surface)), cgoAllocsUnknown
	allocsd22370ae.Borrow(csurface_allocs)

	x.refd22370ae = refd22370ae
	x.allocsd22370ae = allocsd22370ae
	return refd22370ae, allocsd22370ae

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSurfaceInfo2) PassValue() (C.VkPhysicalDeviceSurfaceInfo2KHR, *cgoAllocMap) {
	if x.refd22370ae != nil {
		return *x.refd22370ae, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSurfaceInfo2) Deref() {
	if x.refd22370ae == nil {
		return
	}
	x.SType = (StructureType)(x.refd22370ae.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd22370ae.pNext))
	x.Surface = *(*Surface)(unsafe.Pointer(&x.refd22370ae.surface))
}

// allocSurfaceCapabilities2Memory allocates memory for type C.VkSurfaceCapabilities2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceCapabilities2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceCapabilities2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSurfaceCapabilities2Value = unsafe.Sizeof([1]C.VkSurfaceCapabilities2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SurfaceCapabilities2) Ref() *C.VkSurfaceCapabilities2KHR {
	if x == nil {
		return nil
	}
	return x.refea469745
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SurfaceCapabilities2) Free() {
	if x != nil && x.allocsea469745 != nil {
		x.allocsea469745.(*cgoAllocMap).Free()
		x.refea469745 = nil
	}
}

// NewSurfaceCapabilities2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSurfaceCapabilities2Ref(ref unsafe.Pointer) *SurfaceCapabilities2 {
	if ref == nil {
		return nil
	}
	obj := new(SurfaceCapabilities2)
	obj.refea469745 = (*C.VkSurfaceCapabilities2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SurfaceCapabilities2) PassRef() (*C.VkSurfaceCapabilities2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refea469745 != nil {
		return x.refea469745, nil
	}
	memea469745 := allocSurfaceCapabilities2Memory(1)
	refea469745 := (*C.VkSurfaceCapabilities2KHR)(memea469745)
	allocsea469745 := new(cgoAllocMap)
	allocsea469745.Add(memea469745)

	var csType_allocs *cgoAllocMap
	refea469745.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsea469745.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refea469745.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsea469745.Borrow(cpNext_allocs)

	var csurfaceCapabilities_allocs *cgoAllocMap
	refea469745.surfaceCapabilities, csurfaceCapabilities_allocs = x.SurfaceCapabilities.PassValue()
	allocsea469745.Borrow(csurfaceCapabilities_allocs)

	x.refea469745 = refea469745
	x.allocsea469745 = allocsea469745
	return refea469745, allocsea469745

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SurfaceCapabilities2) PassValue() (C.VkSurfaceCapabilities2KHR, *cgoAllocMap) {
	if x.refea469745 != nil {
		return *x.refea469745, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SurfaceCapabilities2) Deref() {
	if x.refea469745 == nil {
		return
	}
	x.SType = (StructureType)(x.refea469745.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refea469745.pNext))
	x.SurfaceCapabilities = *NewSurfaceCapabilitiesRef(unsafe.Pointer(&x.refea469745.surfaceCapabilities))
}

// allocSurfaceFormat2Memory allocates memory for type C.VkSurfaceFormat2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceFormat2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceFormat2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSurfaceFormat2Value = unsafe.Sizeof([1]C.VkSurfaceFormat2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SurfaceFormat2) Ref() *C.VkSurfaceFormat2KHR {
	if x == nil {
		return nil
	}
	return x.ref8867f0ed
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SurfaceFormat2) Free() {
	if x != nil && x.allocs8867f0ed != nil {
		x.allocs8867f0ed.(*cgoAllocMap).Free()
		x.ref8867f0ed = nil
	}
}

// NewSurfaceFormat2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSurfaceFormat2Ref(ref unsafe.Pointer) *SurfaceFormat2 {
	if ref == nil {
		return nil
	}
	obj := new(SurfaceFormat2)
	obj.ref8867f0ed = (*C.VkSurfaceFormat2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SurfaceFormat2) PassRef() (*C.VkSurfaceFormat2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8867f0ed != nil {
		return x.ref8867f0ed, nil
	}
	mem8867f0ed := allocSurfaceFormat2Memory(1)
	ref8867f0ed := (*C.VkSurfaceFormat2KHR)(mem8867f0ed)
	allocs8867f0ed := new(cgoAllocMap)
	allocs8867f0ed.Add(mem8867f0ed)

	var csType_allocs *cgoAllocMap
	ref8867f0ed.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8867f0ed.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8867f0ed.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8867f0ed.Borrow(cpNext_allocs)

	var csurfaceFormat_allocs *cgoAllocMap
	ref8867f0ed.surfaceFormat, csurfaceFormat_allocs = x.SurfaceFormat.PassValue()
	allocs8867f0ed.Borrow(csurfaceFormat_allocs)

	x.ref8867f0ed = ref8867f0ed
	x.allocs8867f0ed = allocs8867f0ed
	return ref8867f0ed, allocs8867f0ed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SurfaceFormat2) PassValue() (C.VkSurfaceFormat2KHR, *cgoAllocMap) {
	if x.ref8867f0ed != nil {
		return *x.ref8867f0ed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SurfaceFormat2) Deref() {
	if x.ref8867f0ed == nil {
		return
	}
	x.SType = (StructureType)(x.ref8867f0ed.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8867f0ed.pNext))
	x.SurfaceFormat = *NewSurfaceFormatRef(unsafe.Pointer(&x.ref8867f0ed.surfaceFormat))
}

// allocDisplayProperties2Memory allocates memory for type C.VkDisplayProperties2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayProperties2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayProperties2Value = unsafe.Sizeof([1]C.VkDisplayProperties2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayProperties2) Ref() *C.VkDisplayProperties2KHR {
	if x == nil {
		return nil
	}
	return x.ref80194833
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayProperties2) Free() {
	if x != nil && x.allocs80194833 != nil {
		x.allocs80194833.(*cgoAllocMap).Free()
		x.ref80194833 = nil
	}
}

// NewDisplayProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayProperties2Ref(ref unsafe.Pointer) *DisplayProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(DisplayProperties2)
	obj.ref80194833 = (*C.VkDisplayProperties2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayProperties2) PassRef() (*C.VkDisplayProperties2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref80194833 != nil {
		return x.ref80194833, nil
	}
	mem80194833 := allocDisplayProperties2Memory(1)
	ref80194833 := (*C.VkDisplayProperties2KHR)(mem80194833)
	allocs80194833 := new(cgoAllocMap)
	allocs80194833.Add(mem80194833)

	var csType_allocs *cgoAllocMap
	ref80194833.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs80194833.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref80194833.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs80194833.Borrow(cpNext_allocs)

	var cdisplayProperties_allocs *cgoAllocMap
	ref80194833.displayProperties, cdisplayProperties_allocs = x.DisplayProperties.PassValue()
	allocs80194833.Borrow(cdisplayProperties_allocs)

	x.ref80194833 = ref80194833
	x.allocs80194833 = allocs80194833
	return ref80194833, allocs80194833

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayProperties2) PassValue() (C.VkDisplayProperties2KHR, *cgoAllocMap) {
	if x.ref80194833 != nil {
		return *x.ref80194833, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayProperties2) Deref() {
	if x.ref80194833 == nil {
		return
	}
	x.SType = (StructureType)(x.ref80194833.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref80194833.pNext))
	x.DisplayProperties = *NewDisplayPropertiesRef(unsafe.Pointer(&x.ref80194833.displayProperties))
}

// allocDisplayPlaneProperties2Memory allocates memory for type C.VkDisplayPlaneProperties2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlaneProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlaneProperties2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayPlaneProperties2Value = unsafe.Sizeof([1]C.VkDisplayPlaneProperties2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneProperties2) Ref() *C.VkDisplayPlaneProperties2KHR {
	if x == nil {
		return nil
	}
	return x.refa72b1e5b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneProperties2) Free() {
	if x != nil && x.allocsa72b1e5b != nil {
		x.allocsa72b1e5b.(*cgoAllocMap).Free()
		x.refa72b1e5b = nil
	}
}

// NewDisplayPlaneProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlaneProperties2Ref(ref unsafe.Pointer) *DisplayPlaneProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneProperties2)
	obj.refa72b1e5b = (*C.VkDisplayPlaneProperties2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneProperties2) PassRef() (*C.VkDisplayPlaneProperties2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa72b1e5b != nil {
		return x.refa72b1e5b, nil
	}
	mema72b1e5b := allocDisplayPlaneProperties2Memory(1)
	refa72b1e5b := (*C.VkDisplayPlaneProperties2KHR)(mema72b1e5b)
	allocsa72b1e5b := new(cgoAllocMap)
	allocsa72b1e5b.Add(mema72b1e5b)

	var csType_allocs *cgoAllocMap
	refa72b1e5b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa72b1e5b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa72b1e5b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa72b1e5b.Borrow(cpNext_allocs)

	var cdisplayPlaneProperties_allocs *cgoAllocMap
	refa72b1e5b.displayPlaneProperties, cdisplayPlaneProperties_allocs = x.DisplayPlaneProperties.PassValue()
	allocsa72b1e5b.Borrow(cdisplayPlaneProperties_allocs)

	x.refa72b1e5b = refa72b1e5b
	x.allocsa72b1e5b = allocsa72b1e5b
	return refa72b1e5b, allocsa72b1e5b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneProperties2) PassValue() (C.VkDisplayPlaneProperties2KHR, *cgoAllocMap) {
	if x.refa72b1e5b != nil {
		return *x.refa72b1e5b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneProperties2) Deref() {
	if x.refa72b1e5b == nil {
		return
	}
	x.SType = (StructureType)(x.refa72b1e5b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa72b1e5b.pNext))
	x.DisplayPlaneProperties = *NewDisplayPlanePropertiesRef(unsafe.Pointer(&x.refa72b1e5b.displayPlaneProperties))
}

// allocDisplayModeProperties2Memory allocates memory for type C.VkDisplayModeProperties2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModeProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModeProperties2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayModeProperties2Value = unsafe.Sizeof([1]C.VkDisplayModeProperties2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayModeProperties2) Ref() *C.VkDisplayModeProperties2KHR {
	if x == nil {
		return nil
	}
	return x.refc566048d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayModeProperties2) Free() {
	if x != nil && x.allocsc566048d != nil {
		x.allocsc566048d.(*cgoAllocMap).Free()
		x.refc566048d = nil
	}
}

// NewDisplayModeProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayModeProperties2Ref(ref unsafe.Pointer) *DisplayModeProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModeProperties2)
	obj.refc566048d = (*C.VkDisplayModeProperties2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayModeProperties2) PassRef() (*C.VkDisplayModeProperties2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc566048d != nil {
		return x.refc566048d, nil
	}
	memc566048d := allocDisplayModeProperties2Memory(1)
	refc566048d := (*C.VkDisplayModeProperties2KHR)(memc566048d)
	allocsc566048d := new(cgoAllocMap)
	allocsc566048d.Add(memc566048d)

	var csType_allocs *cgoAllocMap
	refc566048d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc566048d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc566048d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc566048d.Borrow(cpNext_allocs)

	var cdisplayModeProperties_allocs *cgoAllocMap
	refc566048d.displayModeProperties, cdisplayModeProperties_allocs = x.DisplayModeProperties.PassValue()
	allocsc566048d.Borrow(cdisplayModeProperties_allocs)

	x.refc566048d = refc566048d
	x.allocsc566048d = allocsc566048d
	return refc566048d, allocsc566048d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayModeProperties2) PassValue() (C.VkDisplayModeProperties2KHR, *cgoAllocMap) {
	if x.refc566048d != nil {
		return *x.refc566048d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayModeProperties2) Deref() {
	if x.refc566048d == nil {
		return
	}
	x.SType = (StructureType)(x.refc566048d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc566048d.pNext))
	x.DisplayModeProperties = *NewDisplayModePropertiesRef(unsafe.Pointer(&x.refc566048d.displayModeProperties))
}

// allocDisplayPlaneInfo2Memory allocates memory for type C.VkDisplayPlaneInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlaneInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlaneInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayPlaneInfo2Value = unsafe.Sizeof([1]C.VkDisplayPlaneInfo2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneInfo2) Ref() *C.VkDisplayPlaneInfo2KHR {
	if x == nil {
		return nil
	}
	return x.reff355ccbf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneInfo2) Free() {
	if x != nil && x.allocsf355ccbf != nil {
		x.allocsf355ccbf.(*cgoAllocMap).Free()
		x.reff355ccbf = nil
	}
}

// NewDisplayPlaneInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlaneInfo2Ref(ref unsafe.Pointer) *DisplayPlaneInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneInfo2)
	obj.reff355ccbf = (*C.VkDisplayPlaneInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneInfo2) PassRef() (*C.VkDisplayPlaneInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff355ccbf != nil {
		return x.reff355ccbf, nil
	}
	memf355ccbf := allocDisplayPlaneInfo2Memory(1)
	reff355ccbf := (*C.VkDisplayPlaneInfo2KHR)(memf355ccbf)
	allocsf355ccbf := new(cgoAllocMap)
	allocsf355ccbf.Add(memf355ccbf)

	var csType_allocs *cgoAllocMap
	reff355ccbf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf355ccbf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff355ccbf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf355ccbf.Borrow(cpNext_allocs)

	var cmode_allocs *cgoAllocMap
	reff355ccbf.mode, cmode_allocs = *(*C.VkDisplayModeKHR)(unsafe.Pointer(&x.Mode)), cgoAllocsUnknown
	allocsf355ccbf.Borrow(cmode_allocs)

	var cplaneIndex_allocs *cgoAllocMap
	reff355ccbf.planeIndex, cplaneIndex_allocs = (C.uint32_t)(x.PlaneIndex), cgoAllocsUnknown
	allocsf355ccbf.Borrow(cplaneIndex_allocs)

	x.reff355ccbf = reff355ccbf
	x.allocsf355ccbf = allocsf355ccbf
	return reff355ccbf, allocsf355ccbf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneInfo2) PassValue() (C.VkDisplayPlaneInfo2KHR, *cgoAllocMap) {
	if x.reff355ccbf != nil {
		return *x.reff355ccbf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneInfo2) Deref() {
	if x.reff355ccbf == nil {
		return
	}
	x.SType = (StructureType)(x.reff355ccbf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff355ccbf.pNext))
	x.Mode = *(*DisplayMode)(unsafe.Pointer(&x.reff355ccbf.mode))
	x.PlaneIndex = (uint32)(x.reff355ccbf.planeIndex)
}

// allocDisplayPlaneCapabilities2Memory allocates memory for type C.VkDisplayPlaneCapabilities2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlaneCapabilities2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlaneCapabilities2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayPlaneCapabilities2Value = unsafe.Sizeof([1]C.VkDisplayPlaneCapabilities2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneCapabilities2) Ref() *C.VkDisplayPlaneCapabilities2KHR {
	if x == nil {
		return nil
	}
	return x.refb53dfb44
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneCapabilities2) Free() {
	if x != nil && x.allocsb53dfb44 != nil {
		x.allocsb53dfb44.(*cgoAllocMap).Free()
		x.refb53dfb44 = nil
	}
}

// NewDisplayPlaneCapabilities2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlaneCapabilities2Ref(ref unsafe.Pointer) *DisplayPlaneCapabilities2 {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneCapabilities2)
	obj.refb53dfb44 = (*C.VkDisplayPlaneCapabilities2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneCapabilities2) PassRef() (*C.VkDisplayPlaneCapabilities2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb53dfb44 != nil {
		return x.refb53dfb44, nil
	}
	memb53dfb44 := allocDisplayPlaneCapabilities2Memory(1)
	refb53dfb44 := (*C.VkDisplayPlaneCapabilities2KHR)(memb53dfb44)
	allocsb53dfb44 := new(cgoAllocMap)
	allocsb53dfb44.Add(memb53dfb44)

	var csType_allocs *cgoAllocMap
	refb53dfb44.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb53dfb44.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb53dfb44.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb53dfb44.Borrow(cpNext_allocs)

	var ccapabilities_allocs *cgoAllocMap
	refb53dfb44.capabilities, ccapabilities_allocs = x.Capabilities.PassValue()
	allocsb53dfb44.Borrow(ccapabilities_allocs)

	x.refb53dfb44 = refb53dfb44
	x.allocsb53dfb44 = allocsb53dfb44
	return refb53dfb44, allocsb53dfb44

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneCapabilities2) PassValue() (C.VkDisplayPlaneCapabilities2KHR, *cgoAllocMap) {
	if x.refb53dfb44 != nil {
		return *x.refb53dfb44, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneCapabilities2) Deref() {
	if x.refb53dfb44 == nil {
		return
	}
	x.SType = (StructureType)(x.refb53dfb44.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb53dfb44.pNext))
	x.Capabilities = *NewDisplayPlaneCapabilitiesRef(unsafe.Pointer(&x.refb53dfb44.capabilities))
}

// allocPhysicalDeviceShaderClockFeaturesMemory allocates memory for type C.VkPhysicalDeviceShaderClockFeaturesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderClockFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderClockFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShaderClockFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderClockFeaturesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderClockFeatures) Ref() *C.VkPhysicalDeviceShaderClockFeaturesKHR {
	if x == nil {
		return nil
	}
	return x.refab512283
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderClockFeatures) Free() {
	if x != nil && x.allocsab512283 != nil {
		x.allocsab512283.(*cgoAllocMap).Free()
		x.refab512283 = nil
	}
}

// NewPhysicalDeviceShaderClockFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderClockFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceShaderClockFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderClockFeatures)
	obj.refab512283 = (*C.VkPhysicalDeviceShaderClockFeaturesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderClockFeatures) PassRef() (*C.VkPhysicalDeviceShaderClockFeaturesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refab512283 != nil {
		return x.refab512283, nil
	}
	memab512283 := allocPhysicalDeviceShaderClockFeaturesMemory(1)
	refab512283 := (*C.VkPhysicalDeviceShaderClockFeaturesKHR)(memab512283)
	allocsab512283 := new(cgoAllocMap)
	allocsab512283.Add(memab512283)

	var csType_allocs *cgoAllocMap
	refab512283.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsab512283.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refab512283.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsab512283.Borrow(cpNext_allocs)

	var cshaderSubgroupClock_allocs *cgoAllocMap
	refab512283.shaderSubgroupClock, cshaderSubgroupClock_allocs = (C.VkBool32)(x.ShaderSubgroupClock), cgoAllocsUnknown
	allocsab512283.Borrow(cshaderSubgroupClock_allocs)

	var cshaderDeviceClock_allocs *cgoAllocMap
	refab512283.shaderDeviceClock, cshaderDeviceClock_allocs = (C.VkBool32)(x.ShaderDeviceClock), cgoAllocsUnknown
	allocsab512283.Borrow(cshaderDeviceClock_allocs)

	x.refab512283 = refab512283
	x.allocsab512283 = allocsab512283
	return refab512283, allocsab512283

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderClockFeatures) PassValue() (C.VkPhysicalDeviceShaderClockFeaturesKHR, *cgoAllocMap) {
	if x.refab512283 != nil {
		return *x.refab512283, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderClockFeatures) Deref() {
	if x.refab512283 == nil {
		return
	}
	x.SType = (StructureType)(x.refab512283.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refab512283.pNext))
	x.ShaderSubgroupClock = (Bool32)(x.refab512283.shaderSubgroupClock)
	x.ShaderDeviceClock = (Bool32)(x.refab512283.shaderDeviceClock)
}

// allocPhysicalDeviceShaderTerminateInvocationFeaturesMemory allocates memory for type C.VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderTerminateInvocationFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderTerminateInvocationFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShaderTerminateInvocationFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderTerminateInvocationFeatures) Ref() *C.VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR {
	if x == nil {
		return nil
	}
	return x.ref685d8c8f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderTerminateInvocationFeatures) Free() {
	if x != nil && x.allocs685d8c8f != nil {
		x.allocs685d8c8f.(*cgoAllocMap).Free()
		x.ref685d8c8f = nil
	}
}

// NewPhysicalDeviceShaderTerminateInvocationFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderTerminateInvocationFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceShaderTerminateInvocationFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderTerminateInvocationFeatures)
	obj.ref685d8c8f = (*C.VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderTerminateInvocationFeatures) PassRef() (*C.VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref685d8c8f != nil {
		return x.ref685d8c8f, nil
	}
	mem685d8c8f := allocPhysicalDeviceShaderTerminateInvocationFeaturesMemory(1)
	ref685d8c8f := (*C.VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR)(mem685d8c8f)
	allocs685d8c8f := new(cgoAllocMap)
	allocs685d8c8f.Add(mem685d8c8f)

	var csType_allocs *cgoAllocMap
	ref685d8c8f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs685d8c8f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref685d8c8f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs685d8c8f.Borrow(cpNext_allocs)

	var cshaderTerminateInvocation_allocs *cgoAllocMap
	ref685d8c8f.shaderTerminateInvocation, cshaderTerminateInvocation_allocs = (C.VkBool32)(x.ShaderTerminateInvocation), cgoAllocsUnknown
	allocs685d8c8f.Borrow(cshaderTerminateInvocation_allocs)

	x.ref685d8c8f = ref685d8c8f
	x.allocs685d8c8f = allocs685d8c8f
	return ref685d8c8f, allocs685d8c8f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderTerminateInvocationFeatures) PassValue() (C.VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR, *cgoAllocMap) {
	if x.ref685d8c8f != nil {
		return *x.ref685d8c8f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderTerminateInvocationFeatures) Deref() {
	if x.ref685d8c8f == nil {
		return
	}
	x.SType = (StructureType)(x.ref685d8c8f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref685d8c8f.pNext))
	x.ShaderTerminateInvocation = (Bool32)(x.ref685d8c8f.shaderTerminateInvocation)
}

// allocFragmentShadingRateAttachmentInfoMemory allocates memory for type C.VkFragmentShadingRateAttachmentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFragmentShadingRateAttachmentInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFragmentShadingRateAttachmentInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFragmentShadingRateAttachmentInfoValue = unsafe.Sizeof([1]C.VkFragmentShadingRateAttachmentInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FragmentShadingRateAttachmentInfo) Ref() *C.VkFragmentShadingRateAttachmentInfoKHR {
	if x == nil {
		return nil
	}
	return x.refd9f9d390
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FragmentShadingRateAttachmentInfo) Free() {
	if x != nil && x.allocsd9f9d390 != nil {
		x.allocsd9f9d390.(*cgoAllocMap).Free()
		x.refd9f9d390 = nil
	}
}

// NewFragmentShadingRateAttachmentInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFragmentShadingRateAttachmentInfoRef(ref unsafe.Pointer) *FragmentShadingRateAttachmentInfo {
	if ref == nil {
		return nil
	}
	obj := new(FragmentShadingRateAttachmentInfo)
	obj.refd9f9d390 = (*C.VkFragmentShadingRateAttachmentInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FragmentShadingRateAttachmentInfo) PassRef() (*C.VkFragmentShadingRateAttachmentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9f9d390 != nil {
		return x.refd9f9d390, nil
	}
	memd9f9d390 := allocFragmentShadingRateAttachmentInfoMemory(1)
	refd9f9d390 := (*C.VkFragmentShadingRateAttachmentInfoKHR)(memd9f9d390)
	allocsd9f9d390 := new(cgoAllocMap)
	allocsd9f9d390.Add(memd9f9d390)

	var csType_allocs *cgoAllocMap
	refd9f9d390.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd9f9d390.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd9f9d390.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd9f9d390.Borrow(cpNext_allocs)

	var cpFragmentShadingRateAttachment_allocs *cgoAllocMap
	refd9f9d390.pFragmentShadingRateAttachment, cpFragmentShadingRateAttachment_allocs = unpackSAttachmentReference2(x.PFragmentShadingRateAttachment)
	allocsd9f9d390.Borrow(cpFragmentShadingRateAttachment_allocs)

	var cshadingRateAttachmentTexelSize_allocs *cgoAllocMap
	refd9f9d390.shadingRateAttachmentTexelSize, cshadingRateAttachmentTexelSize_allocs = x.ShadingRateAttachmentTexelSize.PassValue()
	allocsd9f9d390.Borrow(cshadingRateAttachmentTexelSize_allocs)

	x.refd9f9d390 = refd9f9d390
	x.allocsd9f9d390 = allocsd9f9d390
	return refd9f9d390, allocsd9f9d390

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FragmentShadingRateAttachmentInfo) PassValue() (C.VkFragmentShadingRateAttachmentInfoKHR, *cgoAllocMap) {
	if x.refd9f9d390 != nil {
		return *x.refd9f9d390, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FragmentShadingRateAttachmentInfo) Deref() {
	if x.refd9f9d390 == nil {
		return
	}
	x.SType = (StructureType)(x.refd9f9d390.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd9f9d390.pNext))
	packSAttachmentReference2(x.PFragmentShadingRateAttachment, x.refd9f9d390.pFragmentShadingRateAttachment)
	x.ShadingRateAttachmentTexelSize = *NewExtent2DRef(unsafe.Pointer(&x.refd9f9d390.shadingRateAttachmentTexelSize))
}

// allocPipelineFragmentShadingRateStateCreateInfoMemory allocates memory for type C.VkPipelineFragmentShadingRateStateCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineFragmentShadingRateStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineFragmentShadingRateStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineFragmentShadingRateStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineFragmentShadingRateStateCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineFragmentShadingRateStateCreateInfo) Ref() *C.VkPipelineFragmentShadingRateStateCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref47a79f27
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineFragmentShadingRateStateCreateInfo) Free() {
	if x != nil && x.allocs47a79f27 != nil {
		x.allocs47a79f27.(*cgoAllocMap).Free()
		x.ref47a79f27 = nil
	}
}

// NewPipelineFragmentShadingRateStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineFragmentShadingRateStateCreateInfoRef(ref unsafe.Pointer) *PipelineFragmentShadingRateStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineFragmentShadingRateStateCreateInfo)
	obj.ref47a79f27 = (*C.VkPipelineFragmentShadingRateStateCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineFragmentShadingRateStateCreateInfo) PassRef() (*C.VkPipelineFragmentShadingRateStateCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref47a79f27 != nil {
		return x.ref47a79f27, nil
	}
	mem47a79f27 := allocPipelineFragmentShadingRateStateCreateInfoMemory(1)
	ref47a79f27 := (*C.VkPipelineFragmentShadingRateStateCreateInfoKHR)(mem47a79f27)
	allocs47a79f27 := new(cgoAllocMap)
	allocs47a79f27.Add(mem47a79f27)

	var csType_allocs *cgoAllocMap
	ref47a79f27.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs47a79f27.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref47a79f27.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs47a79f27.Borrow(cpNext_allocs)

	var cfragmentSize_allocs *cgoAllocMap
	ref47a79f27.fragmentSize, cfragmentSize_allocs = x.FragmentSize.PassValue()
	allocs47a79f27.Borrow(cfragmentSize_allocs)

	var ccombinerOps_allocs *cgoAllocMap
	ref47a79f27.combinerOps, ccombinerOps_allocs = *(*[2]C.VkFragmentShadingRateCombinerOpKHR)(unsafe.Pointer(&x.CombinerOps)), cgoAllocsUnknown
	allocs47a79f27.Borrow(ccombinerOps_allocs)

	x.ref47a79f27 = ref47a79f27
	x.allocs47a79f27 = allocs47a79f27
	return ref47a79f27, allocs47a79f27

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineFragmentShadingRateStateCreateInfo) PassValue() (C.VkPipelineFragmentShadingRateStateCreateInfoKHR, *cgoAllocMap) {
	if x.ref47a79f27 != nil {
		return *x.ref47a79f27, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineFragmentShadingRateStateCreateInfo) Deref() {
	if x.ref47a79f27 == nil {
		return
	}
	x.SType = (StructureType)(x.ref47a79f27.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref47a79f27.pNext))
	x.FragmentSize = *NewExtent2DRef(unsafe.Pointer(&x.ref47a79f27.fragmentSize))
	x.CombinerOps = *(*[2]FragmentShadingRateCombinerOp)(unsafe.Pointer(&x.ref47a79f27.combinerOps))
}

// allocPhysicalDeviceFragmentShadingRateFeaturesMemory allocates memory for type C.VkPhysicalDeviceFragmentShadingRateFeaturesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFragmentShadingRateFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFragmentShadingRateFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceFragmentShadingRateFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFragmentShadingRateFeaturesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFragmentShadingRateFeatures) Ref() *C.VkPhysicalDeviceFragmentShadingRateFeaturesKHR {
	if x == nil {
		return nil
	}
	return x.ref9041f272
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFragmentShadingRateFeatures) Free() {
	if x != nil && x.allocs9041f272 != nil {
		x.allocs9041f272.(*cgoAllocMap).Free()
		x.ref9041f272 = nil
	}
}

// NewPhysicalDeviceFragmentShadingRateFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFragmentShadingRateFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceFragmentShadingRateFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFragmentShadingRateFeatures)
	obj.ref9041f272 = (*C.VkPhysicalDeviceFragmentShadingRateFeaturesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFragmentShadingRateFeatures) PassRef() (*C.VkPhysicalDeviceFragmentShadingRateFeaturesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9041f272 != nil {
		return x.ref9041f272, nil
	}
	mem9041f272 := allocPhysicalDeviceFragmentShadingRateFeaturesMemory(1)
	ref9041f272 := (*C.VkPhysicalDeviceFragmentShadingRateFeaturesKHR)(mem9041f272)
	allocs9041f272 := new(cgoAllocMap)
	allocs9041f272.Add(mem9041f272)

	var csType_allocs *cgoAllocMap
	ref9041f272.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9041f272.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9041f272.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9041f272.Borrow(cpNext_allocs)

	var cpipelineFragmentShadingRate_allocs *cgoAllocMap
	ref9041f272.pipelineFragmentShadingRate, cpipelineFragmentShadingRate_allocs = (C.VkBool32)(x.PipelineFragmentShadingRate), cgoAllocsUnknown
	allocs9041f272.Borrow(cpipelineFragmentShadingRate_allocs)

	var cprimitiveFragmentShadingRate_allocs *cgoAllocMap
	ref9041f272.primitiveFragmentShadingRate, cprimitiveFragmentShadingRate_allocs = (C.VkBool32)(x.PrimitiveFragmentShadingRate), cgoAllocsUnknown
	allocs9041f272.Borrow(cprimitiveFragmentShadingRate_allocs)

	var cattachmentFragmentShadingRate_allocs *cgoAllocMap
	ref9041f272.attachmentFragmentShadingRate, cattachmentFragmentShadingRate_allocs = (C.VkBool32)(x.AttachmentFragmentShadingRate), cgoAllocsUnknown
	allocs9041f272.Borrow(cattachmentFragmentShadingRate_allocs)

	x.ref9041f272 = ref9041f272
	x.allocs9041f272 = allocs9041f272
	return ref9041f272, allocs9041f272

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFragmentShadingRateFeatures) PassValue() (C.VkPhysicalDeviceFragmentShadingRateFeaturesKHR, *cgoAllocMap) {
	if x.ref9041f272 != nil {
		return *x.ref9041f272, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFragmentShadingRateFeatures) Deref() {
	if x.ref9041f272 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9041f272.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9041f272.pNext))
	x.PipelineFragmentShadingRate = (Bool32)(x.ref9041f272.pipelineFragmentShadingRate)
	x.PrimitiveFragmentShadingRate = (Bool32)(x.ref9041f272.primitiveFragmentShadingRate)
	x.AttachmentFragmentShadingRate = (Bool32)(x.ref9041f272.attachmentFragmentShadingRate)
}

// allocPhysicalDeviceFragmentShadingRatePropertiesMemory allocates memory for type C.VkPhysicalDeviceFragmentShadingRatePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFragmentShadingRatePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFragmentShadingRatePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceFragmentShadingRatePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFragmentShadingRatePropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFragmentShadingRateProperties) Ref() *C.VkPhysicalDeviceFragmentShadingRatePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref518beb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFragmentShadingRateProperties) Free() {
	if x != nil && x.allocs518beb != nil {
		x.allocs518beb.(*cgoAllocMap).Free()
		x.ref518beb = nil
	}
}

// NewPhysicalDeviceFragmentShadingRatePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFragmentShadingRatePropertiesRef(ref unsafe.Pointer) *PhysicalDeviceFragmentShadingRateProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFragmentShadingRateProperties)
	obj.ref518beb = (*C.VkPhysicalDeviceFragmentShadingRatePropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFragmentShadingRateProperties) PassRef() (*C.VkPhysicalDeviceFragmentShadingRatePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref518beb != nil {
		return x.ref518beb, nil
	}
	mem518beb := allocPhysicalDeviceFragmentShadingRatePropertiesMemory(1)
	ref518beb := (*C.VkPhysicalDeviceFragmentShadingRatePropertiesKHR)(mem518beb)
	allocs518beb := new(cgoAllocMap)
	allocs518beb.Add(mem518beb)

	var csType_allocs *cgoAllocMap
	ref518beb.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs518beb.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref518beb.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs518beb.Borrow(cpNext_allocs)

	var cminFragmentShadingRateAttachmentTexelSize_allocs *cgoAllocMap
	ref518beb.minFragmentShadingRateAttachmentTexelSize, cminFragmentShadingRateAttachmentTexelSize_allocs = x.MinFragmentShadingRateAttachmentTexelSize.PassValue()
	allocs518beb.Borrow(cminFragmentShadingRateAttachmentTexelSize_allocs)

	var cmaxFragmentShadingRateAttachmentTexelSize_allocs *cgoAllocMap
	ref518beb.maxFragmentShadingRateAttachmentTexelSize, cmaxFragmentShadingRateAttachmentTexelSize_allocs = x.MaxFragmentShadingRateAttachmentTexelSize.PassValue()
	allocs518beb.Borrow(cmaxFragmentShadingRateAttachmentTexelSize_allocs)

	var cmaxFragmentShadingRateAttachmentTexelSizeAspectRatio_allocs *cgoAllocMap
	ref518beb.maxFragmentShadingRateAttachmentTexelSizeAspectRatio, cmaxFragmentShadingRateAttachmentTexelSizeAspectRatio_allocs = (C.uint32_t)(x.MaxFragmentShadingRateAttachmentTexelSizeAspectRatio), cgoAllocsUnknown
	allocs518beb.Borrow(cmaxFragmentShadingRateAttachmentTexelSizeAspectRatio_allocs)

	var cprimitiveFragmentShadingRateWithMultipleViewports_allocs *cgoAllocMap
	ref518beb.primitiveFragmentShadingRateWithMultipleViewports, cprimitiveFragmentShadingRateWithMultipleViewports_allocs = (C.VkBool32)(x.PrimitiveFragmentShadingRateWithMultipleViewports), cgoAllocsUnknown
	allocs518beb.Borrow(cprimitiveFragmentShadingRateWithMultipleViewports_allocs)

	var clayeredShadingRateAttachments_allocs *cgoAllocMap
	ref518beb.layeredShadingRateAttachments, clayeredShadingRateAttachments_allocs = (C.VkBool32)(x.LayeredShadingRateAttachments), cgoAllocsUnknown
	allocs518beb.Borrow(clayeredShadingRateAttachments_allocs)

	var cfragmentShadingRateNonTrivialCombinerOps_allocs *cgoAllocMap
	ref518beb.fragmentShadingRateNonTrivialCombinerOps, cfragmentShadingRateNonTrivialCombinerOps_allocs = (C.VkBool32)(x.FragmentShadingRateNonTrivialCombinerOps), cgoAllocsUnknown
	allocs518beb.Borrow(cfragmentShadingRateNonTrivialCombinerOps_allocs)

	var cmaxFragmentSize_allocs *cgoAllocMap
	ref518beb.maxFragmentSize, cmaxFragmentSize_allocs = x.MaxFragmentSize.PassValue()
	allocs518beb.Borrow(cmaxFragmentSize_allocs)

	var cmaxFragmentSizeAspectRatio_allocs *cgoAllocMap
	ref518beb.maxFragmentSizeAspectRatio, cmaxFragmentSizeAspectRatio_allocs = (C.uint32_t)(x.MaxFragmentSizeAspectRatio), cgoAllocsUnknown
	allocs518beb.Borrow(cmaxFragmentSizeAspectRatio_allocs)

	var cmaxFragmentShadingRateCoverageSamples_allocs *cgoAllocMap
	ref518beb.maxFragmentShadingRateCoverageSamples, cmaxFragmentShadingRateCoverageSamples_allocs = (C.uint32_t)(x.MaxFragmentShadingRateCoverageSamples), cgoAllocsUnknown
	allocs518beb.Borrow(cmaxFragmentShadingRateCoverageSamples_allocs)

	var cmaxFragmentShadingRateRasterizationSamples_allocs *cgoAllocMap
	ref518beb.maxFragmentShadingRateRasterizationSamples, cmaxFragmentShadingRateRasterizationSamples_allocs = (C.VkSampleCountFlagBits)(x.MaxFragmentShadingRateRasterizationSamples), cgoAllocsUnknown
	allocs518beb.Borrow(cmaxFragmentShadingRateRasterizationSamples_allocs)

	var cfragmentShadingRateWithShaderDepthStencilWrites_allocs *cgoAllocMap
	ref518beb.fragmentShadingRateWithShaderDepthStencilWrites, cfragmentShadingRateWithShaderDepthStencilWrites_allocs = (C.VkBool32)(x.FragmentShadingRateWithShaderDepthStencilWrites), cgoAllocsUnknown
	allocs518beb.Borrow(cfragmentShadingRateWithShaderDepthStencilWrites_allocs)

	var cfragmentShadingRateWithSampleMask_allocs *cgoAllocMap
	ref518beb.fragmentShadingRateWithSampleMask, cfragmentShadingRateWithSampleMask_allocs = (C.VkBool32)(x.FragmentShadingRateWithSampleMask), cgoAllocsUnknown
	allocs518beb.Borrow(cfragmentShadingRateWithSampleMask_allocs)

	var cfragmentShadingRateWithShaderSampleMask_allocs *cgoAllocMap
	ref518beb.fragmentShadingRateWithShaderSampleMask, cfragmentShadingRateWithShaderSampleMask_allocs = (C.VkBool32)(x.FragmentShadingRateWithShaderSampleMask), cgoAllocsUnknown
	allocs518beb.Borrow(cfragmentShadingRateWithShaderSampleMask_allocs)

	var cfragmentShadingRateWithConservativeRasterization_allocs *cgoAllocMap
	ref518beb.fragmentShadingRateWithConservativeRasterization, cfragmentShadingRateWithConservativeRasterization_allocs = (C.VkBool32)(x.FragmentShadingRateWithConservativeRasterization), cgoAllocsUnknown
	allocs518beb.Borrow(cfragmentShadingRateWithConservativeRasterization_allocs)

	var cfragmentShadingRateWithFragmentShaderInterlock_allocs *cgoAllocMap
	ref518beb.fragmentShadingRateWithFragmentShaderInterlock, cfragmentShadingRateWithFragmentShaderInterlock_allocs = (C.VkBool32)(x.FragmentShadingRateWithFragmentShaderInterlock), cgoAllocsUnknown
	allocs518beb.Borrow(cfragmentShadingRateWithFragmentShaderInterlock_allocs)

	var cfragmentShadingRateWithCustomSampleLocations_allocs *cgoAllocMap
	ref518beb.fragmentShadingRateWithCustomSampleLocations, cfragmentShadingRateWithCustomSampleLocations_allocs = (C.VkBool32)(x.FragmentShadingRateWithCustomSampleLocations), cgoAllocsUnknown
	allocs518beb.Borrow(cfragmentShadingRateWithCustomSampleLocations_allocs)

	var cfragmentShadingRateStrictMultiplyCombiner_allocs *cgoAllocMap
	ref518beb.fragmentShadingRateStrictMultiplyCombiner, cfragmentShadingRateStrictMultiplyCombiner_allocs = (C.VkBool32)(x.FragmentShadingRateStrictMultiplyCombiner), cgoAllocsUnknown
	allocs518beb.Borrow(cfragmentShadingRateStrictMultiplyCombiner_allocs)

	x.ref518beb = ref518beb
	x.allocs518beb = allocs518beb
	return ref518beb, allocs518beb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFragmentShadingRateProperties) PassValue() (C.VkPhysicalDeviceFragmentShadingRatePropertiesKHR, *cgoAllocMap) {
	if x.ref518beb != nil {
		return *x.ref518beb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFragmentShadingRateProperties) Deref() {
	if x.ref518beb == nil {
		return
	}
	x.SType = (StructureType)(x.ref518beb.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref518beb.pNext))
	x.MinFragmentShadingRateAttachmentTexelSize = *NewExtent2DRef(unsafe.Pointer(&x.ref518beb.minFragmentShadingRateAttachmentTexelSize))
	x.MaxFragmentShadingRateAttachmentTexelSize = *NewExtent2DRef(unsafe.Pointer(&x.ref518beb.maxFragmentShadingRateAttachmentTexelSize))
	x.MaxFragmentShadingRateAttachmentTexelSizeAspectRatio = (uint32)(x.ref518beb.maxFragmentShadingRateAttachmentTexelSizeAspectRatio)
	x.PrimitiveFragmentShadingRateWithMultipleViewports = (Bool32)(x.ref518beb.primitiveFragmentShadingRateWithMultipleViewports)
	x.LayeredShadingRateAttachments = (Bool32)(x.ref518beb.layeredShadingRateAttachments)
	x.FragmentShadingRateNonTrivialCombinerOps = (Bool32)(x.ref518beb.fragmentShadingRateNonTrivialCombinerOps)
	x.MaxFragmentSize = *NewExtent2DRef(unsafe.Pointer(&x.ref518beb.maxFragmentSize))
	x.MaxFragmentSizeAspectRatio = (uint32)(x.ref518beb.maxFragmentSizeAspectRatio)
	x.MaxFragmentShadingRateCoverageSamples = (uint32)(x.ref518beb.maxFragmentShadingRateCoverageSamples)
	x.MaxFragmentShadingRateRasterizationSamples = (SampleCountFlagBits)(x.ref518beb.maxFragmentShadingRateRasterizationSamples)
	x.FragmentShadingRateWithShaderDepthStencilWrites = (Bool32)(x.ref518beb.fragmentShadingRateWithShaderDepthStencilWrites)
	x.FragmentShadingRateWithSampleMask = (Bool32)(x.ref518beb.fragmentShadingRateWithSampleMask)
	x.FragmentShadingRateWithShaderSampleMask = (Bool32)(x.ref518beb.fragmentShadingRateWithShaderSampleMask)
	x.FragmentShadingRateWithConservativeRasterization = (Bool32)(x.ref518beb.fragmentShadingRateWithConservativeRasterization)
	x.FragmentShadingRateWithFragmentShaderInterlock = (Bool32)(x.ref518beb.fragmentShadingRateWithFragmentShaderInterlock)
	x.FragmentShadingRateWithCustomSampleLocations = (Bool32)(x.ref518beb.fragmentShadingRateWithCustomSampleLocations)
	x.FragmentShadingRateStrictMultiplyCombiner = (Bool32)(x.ref518beb.fragmentShadingRateStrictMultiplyCombiner)
}

// allocPhysicalDeviceFragmentShadingRateMemory allocates memory for type C.VkPhysicalDeviceFragmentShadingRateKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFragmentShadingRateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFragmentShadingRateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceFragmentShadingRateValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFragmentShadingRateKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFragmentShadingRate) Ref() *C.VkPhysicalDeviceFragmentShadingRateKHR {
	if x == nil {
		return nil
	}
	return x.ref17914e16
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFragmentShadingRate) Free() {
	if x != nil && x.allocs17914e16 != nil {
		x.allocs17914e16.(*cgoAllocMap).Free()
		x.ref17914e16 = nil
	}
}

// NewPhysicalDeviceFragmentShadingRateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFragmentShadingRateRef(ref unsafe.Pointer) *PhysicalDeviceFragmentShadingRate {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFragmentShadingRate)
	obj.ref17914e16 = (*C.VkPhysicalDeviceFragmentShadingRateKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFragmentShadingRate) PassRef() (*C.VkPhysicalDeviceFragmentShadingRateKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref17914e16 != nil {
		return x.ref17914e16, nil
	}
	mem17914e16 := allocPhysicalDeviceFragmentShadingRateMemory(1)
	ref17914e16 := (*C.VkPhysicalDeviceFragmentShadingRateKHR)(mem17914e16)
	allocs17914e16 := new(cgoAllocMap)
	allocs17914e16.Add(mem17914e16)

	var csType_allocs *cgoAllocMap
	ref17914e16.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs17914e16.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref17914e16.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs17914e16.Borrow(cpNext_allocs)

	var csampleCounts_allocs *cgoAllocMap
	ref17914e16.sampleCounts, csampleCounts_allocs = (C.VkSampleCountFlags)(x.SampleCounts), cgoAllocsUnknown
	allocs17914e16.Borrow(csampleCounts_allocs)

	var cfragmentSize_allocs *cgoAllocMap
	ref17914e16.fragmentSize, cfragmentSize_allocs = x.FragmentSize.PassValue()
	allocs17914e16.Borrow(cfragmentSize_allocs)

	x.ref17914e16 = ref17914e16
	x.allocs17914e16 = allocs17914e16
	return ref17914e16, allocs17914e16

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFragmentShadingRate) PassValue() (C.VkPhysicalDeviceFragmentShadingRateKHR, *cgoAllocMap) {
	if x.ref17914e16 != nil {
		return *x.ref17914e16, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFragmentShadingRate) Deref() {
	if x.ref17914e16 == nil {
		return
	}
	x.SType = (StructureType)(x.ref17914e16.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref17914e16.pNext))
	x.SampleCounts = (SampleCountFlags)(x.ref17914e16.sampleCounts)
	x.FragmentSize = *NewExtent2DRef(unsafe.Pointer(&x.ref17914e16.fragmentSize))
}

// allocSurfaceProtectedCapabilitiesMemory allocates memory for type C.VkSurfaceProtectedCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceProtectedCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceProtectedCapabilitiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSurfaceProtectedCapabilitiesValue = unsafe.Sizeof([1]C.VkSurfaceProtectedCapabilitiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SurfaceProtectedCapabilities) Ref() *C.VkSurfaceProtectedCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.refa5f4111
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SurfaceProtectedCapabilities) Free() {
	if x != nil && x.allocsa5f4111 != nil {
		x.allocsa5f4111.(*cgoAllocMap).Free()
		x.refa5f4111 = nil
	}
}

// NewSurfaceProtectedCapabilitiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSurfaceProtectedCapabilitiesRef(ref unsafe.Pointer) *SurfaceProtectedCapabilities {
	if ref == nil {
		return nil
	}
	obj := new(SurfaceProtectedCapabilities)
	obj.refa5f4111 = (*C.VkSurfaceProtectedCapabilitiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SurfaceProtectedCapabilities) PassRef() (*C.VkSurfaceProtectedCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa5f4111 != nil {
		return x.refa5f4111, nil
	}
	mema5f4111 := allocSurfaceProtectedCapabilitiesMemory(1)
	refa5f4111 := (*C.VkSurfaceProtectedCapabilitiesKHR)(mema5f4111)
	allocsa5f4111 := new(cgoAllocMap)
	allocsa5f4111.Add(mema5f4111)

	var csType_allocs *cgoAllocMap
	refa5f4111.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa5f4111.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa5f4111.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa5f4111.Borrow(cpNext_allocs)

	var csupportsProtected_allocs *cgoAllocMap
	refa5f4111.supportsProtected, csupportsProtected_allocs = (C.VkBool32)(x.SupportsProtected), cgoAllocsUnknown
	allocsa5f4111.Borrow(csupportsProtected_allocs)

	x.refa5f4111 = refa5f4111
	x.allocsa5f4111 = allocsa5f4111
	return refa5f4111, allocsa5f4111

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SurfaceProtectedCapabilities) PassValue() (C.VkSurfaceProtectedCapabilitiesKHR, *cgoAllocMap) {
	if x.refa5f4111 != nil {
		return *x.refa5f4111, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SurfaceProtectedCapabilities) Deref() {
	if x.refa5f4111 == nil {
		return
	}
	x.SType = (StructureType)(x.refa5f4111.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa5f4111.pNext))
	x.SupportsProtected = (Bool32)(x.refa5f4111.supportsProtected)
}

// allocPhysicalDevicePipelineExecutablePropertiesFeaturesMemory allocates memory for type C.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePipelineExecutablePropertiesFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePipelineExecutablePropertiesFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDevicePipelineExecutablePropertiesFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevicePipelineExecutablePropertiesFeatures) Ref() *C.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
	if x == nil {
		return nil
	}
	return x.ref84acf0e1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevicePipelineExecutablePropertiesFeatures) Free() {
	if x != nil && x.allocs84acf0e1 != nil {
		x.allocs84acf0e1.(*cgoAllocMap).Free()
		x.ref84acf0e1 = nil
	}
}

// NewPhysicalDevicePipelineExecutablePropertiesFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePipelineExecutablePropertiesFeaturesRef(ref unsafe.Pointer) *PhysicalDevicePipelineExecutablePropertiesFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevicePipelineExecutablePropertiesFeatures)
	obj.ref84acf0e1 = (*C.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevicePipelineExecutablePropertiesFeatures) PassRef() (*C.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref84acf0e1 != nil {
		return x.ref84acf0e1, nil
	}
	mem84acf0e1 := allocPhysicalDevicePipelineExecutablePropertiesFeaturesMemory(1)
	ref84acf0e1 := (*C.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR)(mem84acf0e1)
	allocs84acf0e1 := new(cgoAllocMap)
	allocs84acf0e1.Add(mem84acf0e1)

	var csType_allocs *cgoAllocMap
	ref84acf0e1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs84acf0e1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref84acf0e1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs84acf0e1.Borrow(cpNext_allocs)

	var cpipelineExecutableInfo_allocs *cgoAllocMap
	ref84acf0e1.pipelineExecutableInfo, cpipelineExecutableInfo_allocs = (C.VkBool32)(x.PipelineExecutableInfo), cgoAllocsUnknown
	allocs84acf0e1.Borrow(cpipelineExecutableInfo_allocs)

	x.ref84acf0e1 = ref84acf0e1
	x.allocs84acf0e1 = allocs84acf0e1
	return ref84acf0e1, allocs84acf0e1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevicePipelineExecutablePropertiesFeatures) PassValue() (C.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, *cgoAllocMap) {
	if x.ref84acf0e1 != nil {
		return *x.ref84acf0e1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevicePipelineExecutablePropertiesFeatures) Deref() {
	if x.ref84acf0e1 == nil {
		return
	}
	x.SType = (StructureType)(x.ref84acf0e1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref84acf0e1.pNext))
	x.PipelineExecutableInfo = (Bool32)(x.ref84acf0e1.pipelineExecutableInfo)
}

// allocPipelineInfoMemory allocates memory for type C.VkPipelineInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineInfoValue = unsafe.Sizeof([1]C.VkPipelineInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineInfo) Ref() *C.VkPipelineInfoKHR {
	if x == nil {
		return nil
	}
	return x.refcd879ca1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineInfo) Free() {
	if x != nil && x.allocscd879ca1 != nil {
		x.allocscd879ca1.(*cgoAllocMap).Free()
		x.refcd879ca1 = nil
	}
}

// NewPipelineInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineInfoRef(ref unsafe.Pointer) *PipelineInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineInfo)
	obj.refcd879ca1 = (*C.VkPipelineInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineInfo) PassRef() (*C.VkPipelineInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcd879ca1 != nil {
		return x.refcd879ca1, nil
	}
	memcd879ca1 := allocPipelineInfoMemory(1)
	refcd879ca1 := (*C.VkPipelineInfoKHR)(memcd879ca1)
	allocscd879ca1 := new(cgoAllocMap)
	allocscd879ca1.Add(memcd879ca1)

	var csType_allocs *cgoAllocMap
	refcd879ca1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscd879ca1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcd879ca1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscd879ca1.Borrow(cpNext_allocs)

	var cpipeline_allocs *cgoAllocMap
	refcd879ca1.pipeline, cpipeline_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.Pipeline)), cgoAllocsUnknown
	allocscd879ca1.Borrow(cpipeline_allocs)

	x.refcd879ca1 = refcd879ca1
	x.allocscd879ca1 = allocscd879ca1
	return refcd879ca1, allocscd879ca1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineInfo) PassValue() (C.VkPipelineInfoKHR, *cgoAllocMap) {
	if x.refcd879ca1 != nil {
		return *x.refcd879ca1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineInfo) Deref() {
	if x.refcd879ca1 == nil {
		return
	}
	x.SType = (StructureType)(x.refcd879ca1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcd879ca1.pNext))
	x.Pipeline = *(*Pipeline)(unsafe.Pointer(&x.refcd879ca1.pipeline))
}

// allocPipelineExecutablePropertiesMemory allocates memory for type C.VkPipelineExecutablePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineExecutablePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineExecutablePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineExecutablePropertiesValue = unsafe.Sizeof([1]C.VkPipelineExecutablePropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineExecutableProperties) Ref() *C.VkPipelineExecutablePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref4eb592a4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineExecutableProperties) Free() {
	if x != nil && x.allocs4eb592a4 != nil {
		x.allocs4eb592a4.(*cgoAllocMap).Free()
		x.ref4eb592a4 = nil
	}
}

// NewPipelineExecutablePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineExecutablePropertiesRef(ref unsafe.Pointer) *PipelineExecutableProperties {
	if ref == nil {
		return nil
	}
	obj := new(PipelineExecutableProperties)
	obj.ref4eb592a4 = (*C.VkPipelineExecutablePropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineExecutableProperties) PassRef() (*C.VkPipelineExecutablePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4eb592a4 != nil {
		return x.ref4eb592a4, nil
	}
	mem4eb592a4 := allocPipelineExecutablePropertiesMemory(1)
	ref4eb592a4 := (*C.VkPipelineExecutablePropertiesKHR)(mem4eb592a4)
	allocs4eb592a4 := new(cgoAllocMap)
	allocs4eb592a4.Add(mem4eb592a4)

	var csType_allocs *cgoAllocMap
	ref4eb592a4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4eb592a4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4eb592a4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4eb592a4.Borrow(cpNext_allocs)

	var cstages_allocs *cgoAllocMap
	ref4eb592a4.stages, cstages_allocs = (C.VkShaderStageFlags)(x.Stages), cgoAllocsUnknown
	allocs4eb592a4.Borrow(cstages_allocs)

	var cname_allocs *cgoAllocMap
	ref4eb592a4.name, cname_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Name)), cgoAllocsUnknown
	allocs4eb592a4.Borrow(cname_allocs)

	var cdescription_allocs *cgoAllocMap
	ref4eb592a4.description, cdescription_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Description)), cgoAllocsUnknown
	allocs4eb592a4.Borrow(cdescription_allocs)

	var csubgroupSize_allocs *cgoAllocMap
	ref4eb592a4.subgroupSize, csubgroupSize_allocs = (C.uint32_t)(x.SubgroupSize), cgoAllocsUnknown
	allocs4eb592a4.Borrow(csubgroupSize_allocs)

	x.ref4eb592a4 = ref4eb592a4
	x.allocs4eb592a4 = allocs4eb592a4
	return ref4eb592a4, allocs4eb592a4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineExecutableProperties) PassValue() (C.VkPipelineExecutablePropertiesKHR, *cgoAllocMap) {
	if x.ref4eb592a4 != nil {
		return *x.ref4eb592a4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineExecutableProperties) Deref() {
	if x.ref4eb592a4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref4eb592a4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4eb592a4.pNext))
	x.Stages = (ShaderStageFlags)(x.ref4eb592a4.stages)
	x.Name = *(*[256]byte)(unsafe.Pointer(&x.ref4eb592a4.name))
	x.Description = *(*[256]byte)(unsafe.Pointer(&x.ref4eb592a4.description))
	x.SubgroupSize = (uint32)(x.ref4eb592a4.subgroupSize)
}

// allocPipelineExecutableInfoMemory allocates memory for type C.VkPipelineExecutableInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineExecutableInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineExecutableInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineExecutableInfoValue = unsafe.Sizeof([1]C.VkPipelineExecutableInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineExecutableInfo) Ref() *C.VkPipelineExecutableInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref9b891dad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineExecutableInfo) Free() {
	if x != nil && x.allocs9b891dad != nil {
		x.allocs9b891dad.(*cgoAllocMap).Free()
		x.ref9b891dad = nil
	}
}

// NewPipelineExecutableInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineExecutableInfoRef(ref unsafe.Pointer) *PipelineExecutableInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineExecutableInfo)
	obj.ref9b891dad = (*C.VkPipelineExecutableInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineExecutableInfo) PassRef() (*C.VkPipelineExecutableInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9b891dad != nil {
		return x.ref9b891dad, nil
	}
	mem9b891dad := allocPipelineExecutableInfoMemory(1)
	ref9b891dad := (*C.VkPipelineExecutableInfoKHR)(mem9b891dad)
	allocs9b891dad := new(cgoAllocMap)
	allocs9b891dad.Add(mem9b891dad)

	var csType_allocs *cgoAllocMap
	ref9b891dad.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9b891dad.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9b891dad.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9b891dad.Borrow(cpNext_allocs)

	var cpipeline_allocs *cgoAllocMap
	ref9b891dad.pipeline, cpipeline_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.Pipeline)), cgoAllocsUnknown
	allocs9b891dad.Borrow(cpipeline_allocs)

	var cexecutableIndex_allocs *cgoAllocMap
	ref9b891dad.executableIndex, cexecutableIndex_allocs = (C.uint32_t)(x.ExecutableIndex), cgoAllocsUnknown
	allocs9b891dad.Borrow(cexecutableIndex_allocs)

	x.ref9b891dad = ref9b891dad
	x.allocs9b891dad = allocs9b891dad
	return ref9b891dad, allocs9b891dad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineExecutableInfo) PassValue() (C.VkPipelineExecutableInfoKHR, *cgoAllocMap) {
	if x.ref9b891dad != nil {
		return *x.ref9b891dad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineExecutableInfo) Deref() {
	if x.ref9b891dad == nil {
		return
	}
	x.SType = (StructureType)(x.ref9b891dad.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9b891dad.pNext))
	x.Pipeline = *(*Pipeline)(unsafe.Pointer(&x.ref9b891dad.pipeline))
	x.ExecutableIndex = (uint32)(x.ref9b891dad.executableIndex)
}

// allocPipelineExecutableStatisticMemory allocates memory for type C.VkPipelineExecutableStatisticKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineExecutableStatisticMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineExecutableStatisticValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineExecutableStatisticValue = unsafe.Sizeof([1]C.VkPipelineExecutableStatisticKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineExecutableStatistic) Ref() *C.VkPipelineExecutableStatisticKHR {
	if x == nil {
		return nil
	}
	return x.ref4af1a62c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineExecutableStatistic) Free() {
	if x != nil && x.allocs4af1a62c != nil {
		x.allocs4af1a62c.(*cgoAllocMap).Free()
		x.ref4af1a62c = nil
	}
}

// NewPipelineExecutableStatisticRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineExecutableStatisticRef(ref unsafe.Pointer) *PipelineExecutableStatistic {
	if ref == nil {
		return nil
	}
	obj := new(PipelineExecutableStatistic)
	obj.ref4af1a62c = (*C.VkPipelineExecutableStatisticKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineExecutableStatistic) PassRef() (*C.VkPipelineExecutableStatisticKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4af1a62c != nil {
		return x.ref4af1a62c, nil
	}
	mem4af1a62c := allocPipelineExecutableStatisticMemory(1)
	ref4af1a62c := (*C.VkPipelineExecutableStatisticKHR)(mem4af1a62c)
	allocs4af1a62c := new(cgoAllocMap)
	allocs4af1a62c.Add(mem4af1a62c)

	var csType_allocs *cgoAllocMap
	ref4af1a62c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4af1a62c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4af1a62c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4af1a62c.Borrow(cpNext_allocs)

	var cname_allocs *cgoAllocMap
	ref4af1a62c.name, cname_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Name)), cgoAllocsUnknown
	allocs4af1a62c.Borrow(cname_allocs)

	var cdescription_allocs *cgoAllocMap
	ref4af1a62c.description, cdescription_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Description)), cgoAllocsUnknown
	allocs4af1a62c.Borrow(cdescription_allocs)

	var cformat_allocs *cgoAllocMap
	ref4af1a62c.format, cformat_allocs = (C.VkPipelineExecutableStatisticFormatKHR)(x.Format), cgoAllocsUnknown
	allocs4af1a62c.Borrow(cformat_allocs)

	var cvalue_allocs *cgoAllocMap
	ref4af1a62c.value, cvalue_allocs = *(*C.VkPipelineExecutableStatisticValueKHR)(unsafe.Pointer(&x.Value)), cgoAllocsUnknown
	allocs4af1a62c.Borrow(cvalue_allocs)

	x.ref4af1a62c = ref4af1a62c
	x.allocs4af1a62c = allocs4af1a62c
	return ref4af1a62c, allocs4af1a62c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineExecutableStatistic) PassValue() (C.VkPipelineExecutableStatisticKHR, *cgoAllocMap) {
	if x.ref4af1a62c != nil {
		return *x.ref4af1a62c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineExecutableStatistic) Deref() {
	if x.ref4af1a62c == nil {
		return
	}
	x.SType = (StructureType)(x.ref4af1a62c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4af1a62c.pNext))
	x.Name = *(*[256]byte)(unsafe.Pointer(&x.ref4af1a62c.name))
	x.Description = *(*[256]byte)(unsafe.Pointer(&x.ref4af1a62c.description))
	x.Format = (PipelineExecutableStatisticFormat)(x.ref4af1a62c.format)
	x.Value = *(*PipelineExecutableStatisticValue)(unsafe.Pointer(&x.ref4af1a62c.value))
}

// allocPipelineExecutableInternalRepresentationMemory allocates memory for type C.VkPipelineExecutableInternalRepresentationKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineExecutableInternalRepresentationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineExecutableInternalRepresentationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineExecutableInternalRepresentationValue = unsafe.Sizeof([1]C.VkPipelineExecutableInternalRepresentationKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineExecutableInternalRepresentation) Ref() *C.VkPipelineExecutableInternalRepresentationKHR {
	if x == nil {
		return nil
	}
	return x.ref20e334f7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineExecutableInternalRepresentation) Free() {
	if x != nil && x.allocs20e334f7 != nil {
		x.allocs20e334f7.(*cgoAllocMap).Free()
		x.ref20e334f7 = nil
	}
}

// NewPipelineExecutableInternalRepresentationRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineExecutableInternalRepresentationRef(ref unsafe.Pointer) *PipelineExecutableInternalRepresentation {
	if ref == nil {
		return nil
	}
	obj := new(PipelineExecutableInternalRepresentation)
	obj.ref20e334f7 = (*C.VkPipelineExecutableInternalRepresentationKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineExecutableInternalRepresentation) PassRef() (*C.VkPipelineExecutableInternalRepresentationKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref20e334f7 != nil {
		return x.ref20e334f7, nil
	}
	mem20e334f7 := allocPipelineExecutableInternalRepresentationMemory(1)
	ref20e334f7 := (*C.VkPipelineExecutableInternalRepresentationKHR)(mem20e334f7)
	allocs20e334f7 := new(cgoAllocMap)
	allocs20e334f7.Add(mem20e334f7)

	var csType_allocs *cgoAllocMap
	ref20e334f7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs20e334f7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref20e334f7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs20e334f7.Borrow(cpNext_allocs)

	var cname_allocs *cgoAllocMap
	ref20e334f7.name, cname_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Name)), cgoAllocsUnknown
	allocs20e334f7.Borrow(cname_allocs)

	var cdescription_allocs *cgoAllocMap
	ref20e334f7.description, cdescription_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Description)), cgoAllocsUnknown
	allocs20e334f7.Borrow(cdescription_allocs)

	var cisText_allocs *cgoAllocMap
	ref20e334f7.isText, cisText_allocs = (C.VkBool32)(x.IsText), cgoAllocsUnknown
	allocs20e334f7.Borrow(cisText_allocs)

	var cdataSize_allocs *cgoAllocMap
	ref20e334f7.dataSize, cdataSize_allocs = (C.size_t)(x.DataSize), cgoAllocsUnknown
	allocs20e334f7.Borrow(cdataSize_allocs)

	var cpData_allocs *cgoAllocMap
	ref20e334f7.pData, cpData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocs20e334f7.Borrow(cpData_allocs)

	x.ref20e334f7 = ref20e334f7
	x.allocs20e334f7 = allocs20e334f7
	return ref20e334f7, allocs20e334f7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineExecutableInternalRepresentation) PassValue() (C.VkPipelineExecutableInternalRepresentationKHR, *cgoAllocMap) {
	if x.ref20e334f7 != nil {
		return *x.ref20e334f7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineExecutableInternalRepresentation) Deref() {
	if x.ref20e334f7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref20e334f7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref20e334f7.pNext))
	x.Name = *(*[256]byte)(unsafe.Pointer(&x.ref20e334f7.name))
	x.Description = *(*[256]byte)(unsafe.Pointer(&x.ref20e334f7.description))
	x.IsText = (Bool32)(x.ref20e334f7.isText)
	x.DataSize = (uint32)(x.ref20e334f7.dataSize)
	x.PData = (unsafe.Pointer)(unsafe.Pointer(x.ref20e334f7.pData))
}

// allocPipelineLibraryCreateInfoMemory allocates memory for type C.VkPipelineLibraryCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineLibraryCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineLibraryCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineLibraryCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineLibraryCreateInfoKHR{})

// copyPPipelineBytes copies the data from Go slice as *C.VkPipeline.
func copyPPipelineBytes(slice *sliceHeader) (*C.VkPipeline, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPipelineValue) * slice.Len,
		Cap:  int(sizeOfPipelineValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkPipeline)(mem0), allocs
}

// allocPipelineMemory allocates memory for type C.VkPipeline in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineValue = unsafe.Sizeof([1]C.VkPipeline{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineLibraryCreateInfo) Ref() *C.VkPipelineLibraryCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref6bb7541b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineLibraryCreateInfo) Free() {
	if x != nil && x.allocs6bb7541b != nil {
		x.allocs6bb7541b.(*cgoAllocMap).Free()
		x.ref6bb7541b = nil
	}
}

// NewPipelineLibraryCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineLibraryCreateInfoRef(ref unsafe.Pointer) *PipelineLibraryCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineLibraryCreateInfo)
	obj.ref6bb7541b = (*C.VkPipelineLibraryCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineLibraryCreateInfo) PassRef() (*C.VkPipelineLibraryCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6bb7541b != nil {
		return x.ref6bb7541b, nil
	}
	mem6bb7541b := allocPipelineLibraryCreateInfoMemory(1)
	ref6bb7541b := (*C.VkPipelineLibraryCreateInfoKHR)(mem6bb7541b)
	allocs6bb7541b := new(cgoAllocMap)
	allocs6bb7541b.Add(mem6bb7541b)

	var csType_allocs *cgoAllocMap
	ref6bb7541b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6bb7541b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6bb7541b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6bb7541b.Borrow(cpNext_allocs)

	var clibraryCount_allocs *cgoAllocMap
	ref6bb7541b.libraryCount, clibraryCount_allocs = (C.uint32_t)(x.LibraryCount), cgoAllocsUnknown
	allocs6bb7541b.Borrow(clibraryCount_allocs)

	var cpLibraries_allocs *cgoAllocMap
	ref6bb7541b.pLibraries, cpLibraries_allocs = copyPPipelineBytes((*sliceHeader)(unsafe.Pointer(&x.PLibraries)))
	allocs6bb7541b.Borrow(cpLibraries_allocs)

	x.ref6bb7541b = ref6bb7541b
	x.allocs6bb7541b = allocs6bb7541b
	return ref6bb7541b, allocs6bb7541b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineLibraryCreateInfo) PassValue() (C.VkPipelineLibraryCreateInfoKHR, *cgoAllocMap) {
	if x.ref6bb7541b != nil {
		return *x.ref6bb7541b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineLibraryCreateInfo) Deref() {
	if x.ref6bb7541b == nil {
		return
	}
	x.SType = (StructureType)(x.ref6bb7541b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6bb7541b.pNext))
	x.LibraryCount = (uint32)(x.ref6bb7541b.libraryCount)
	hxf458096 := (*sliceHeader)(unsafe.Pointer(&x.PLibraries))
	hxf458096.Data = unsafe.Pointer(x.ref6bb7541b.pLibraries)
	hxf458096.Cap = 0x7fffffff
	// hxf458096.Len = ?

}

// allocMemoryBarrier2Memory allocates memory for type C.VkMemoryBarrier2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryBarrier2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryBarrier2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryBarrier2Value = unsafe.Sizeof([1]C.VkMemoryBarrier2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryBarrier2) Ref() *C.VkMemoryBarrier2KHR {
	if x == nil {
		return nil
	}
	return x.refd65c77fd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryBarrier2) Free() {
	if x != nil && x.allocsd65c77fd != nil {
		x.allocsd65c77fd.(*cgoAllocMap).Free()
		x.refd65c77fd = nil
	}
}

// NewMemoryBarrier2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryBarrier2Ref(ref unsafe.Pointer) *MemoryBarrier2 {
	if ref == nil {
		return nil
	}
	obj := new(MemoryBarrier2)
	obj.refd65c77fd = (*C.VkMemoryBarrier2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryBarrier2) PassRef() (*C.VkMemoryBarrier2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd65c77fd != nil {
		return x.refd65c77fd, nil
	}
	memd65c77fd := allocMemoryBarrier2Memory(1)
	refd65c77fd := (*C.VkMemoryBarrier2KHR)(memd65c77fd)
	allocsd65c77fd := new(cgoAllocMap)
	allocsd65c77fd.Add(memd65c77fd)

	var csType_allocs *cgoAllocMap
	refd65c77fd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd65c77fd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd65c77fd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd65c77fd.Borrow(cpNext_allocs)

	var csrcStageMask_allocs *cgoAllocMap
	refd65c77fd.srcStageMask, csrcStageMask_allocs = (C.VkPipelineStageFlags2KHR)(x.SrcStageMask), cgoAllocsUnknown
	allocsd65c77fd.Borrow(csrcStageMask_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refd65c77fd.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags2KHR)(x.SrcAccessMask), cgoAllocsUnknown
	allocsd65c77fd.Borrow(csrcAccessMask_allocs)

	var cdstStageMask_allocs *cgoAllocMap
	refd65c77fd.dstStageMask, cdstStageMask_allocs = (C.VkPipelineStageFlags2KHR)(x.DstStageMask), cgoAllocsUnknown
	allocsd65c77fd.Borrow(cdstStageMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refd65c77fd.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags2KHR)(x.DstAccessMask), cgoAllocsUnknown
	allocsd65c77fd.Borrow(cdstAccessMask_allocs)

	x.refd65c77fd = refd65c77fd
	x.allocsd65c77fd = allocsd65c77fd
	return refd65c77fd, allocsd65c77fd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryBarrier2) PassValue() (C.VkMemoryBarrier2KHR, *cgoAllocMap) {
	if x.refd65c77fd != nil {
		return *x.refd65c77fd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryBarrier2) Deref() {
	if x.refd65c77fd == nil {
		return
	}
	x.SType = (StructureType)(x.refd65c77fd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd65c77fd.pNext))
	x.SrcStageMask = (PipelineStageFlags2)(x.refd65c77fd.srcStageMask)
	x.SrcAccessMask = (AccessFlags2)(x.refd65c77fd.srcAccessMask)
	x.DstStageMask = (PipelineStageFlags2)(x.refd65c77fd.dstStageMask)
	x.DstAccessMask = (AccessFlags2)(x.refd65c77fd.dstAccessMask)
}

// allocBufferMemoryBarrier2Memory allocates memory for type C.VkBufferMemoryBarrier2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferMemoryBarrier2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferMemoryBarrier2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferMemoryBarrier2Value = unsafe.Sizeof([1]C.VkBufferMemoryBarrier2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferMemoryBarrier2) Ref() *C.VkBufferMemoryBarrier2KHR {
	if x == nil {
		return nil
	}
	return x.ref993b84c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferMemoryBarrier2) Free() {
	if x != nil && x.allocs993b84c != nil {
		x.allocs993b84c.(*cgoAllocMap).Free()
		x.ref993b84c = nil
	}
}

// NewBufferMemoryBarrier2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferMemoryBarrier2Ref(ref unsafe.Pointer) *BufferMemoryBarrier2 {
	if ref == nil {
		return nil
	}
	obj := new(BufferMemoryBarrier2)
	obj.ref993b84c = (*C.VkBufferMemoryBarrier2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferMemoryBarrier2) PassRef() (*C.VkBufferMemoryBarrier2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref993b84c != nil {
		return x.ref993b84c, nil
	}
	mem993b84c := allocBufferMemoryBarrier2Memory(1)
	ref993b84c := (*C.VkBufferMemoryBarrier2KHR)(mem993b84c)
	allocs993b84c := new(cgoAllocMap)
	allocs993b84c.Add(mem993b84c)

	var csType_allocs *cgoAllocMap
	ref993b84c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs993b84c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref993b84c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs993b84c.Borrow(cpNext_allocs)

	var csrcStageMask_allocs *cgoAllocMap
	ref993b84c.srcStageMask, csrcStageMask_allocs = (C.VkPipelineStageFlags2KHR)(x.SrcStageMask), cgoAllocsUnknown
	allocs993b84c.Borrow(csrcStageMask_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	ref993b84c.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags2KHR)(x.SrcAccessMask), cgoAllocsUnknown
	allocs993b84c.Borrow(csrcAccessMask_allocs)

	var cdstStageMask_allocs *cgoAllocMap
	ref993b84c.dstStageMask, cdstStageMask_allocs = (C.VkPipelineStageFlags2KHR)(x.DstStageMask), cgoAllocsUnknown
	allocs993b84c.Borrow(cdstStageMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	ref993b84c.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags2KHR)(x.DstAccessMask), cgoAllocsUnknown
	allocs993b84c.Borrow(cdstAccessMask_allocs)

	var csrcQueueFamilyIndex_allocs *cgoAllocMap
	ref993b84c.srcQueueFamilyIndex, csrcQueueFamilyIndex_allocs = (C.uint32_t)(x.SrcQueueFamilyIndex), cgoAllocsUnknown
	allocs993b84c.Borrow(csrcQueueFamilyIndex_allocs)

	var cdstQueueFamilyIndex_allocs *cgoAllocMap
	ref993b84c.dstQueueFamilyIndex, cdstQueueFamilyIndex_allocs = (C.uint32_t)(x.DstQueueFamilyIndex), cgoAllocsUnknown
	allocs993b84c.Borrow(cdstQueueFamilyIndex_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref993b84c.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs993b84c.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	ref993b84c.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs993b84c.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref993b84c.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs993b84c.Borrow(csize_allocs)

	x.ref993b84c = ref993b84c
	x.allocs993b84c = allocs993b84c
	return ref993b84c, allocs993b84c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferMemoryBarrier2) PassValue() (C.VkBufferMemoryBarrier2KHR, *cgoAllocMap) {
	if x.ref993b84c != nil {
		return *x.ref993b84c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferMemoryBarrier2) Deref() {
	if x.ref993b84c == nil {
		return
	}
	x.SType = (StructureType)(x.ref993b84c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref993b84c.pNext))
	x.SrcStageMask = (PipelineStageFlags2)(x.ref993b84c.srcStageMask)
	x.SrcAccessMask = (AccessFlags2)(x.ref993b84c.srcAccessMask)
	x.DstStageMask = (PipelineStageFlags2)(x.ref993b84c.dstStageMask)
	x.DstAccessMask = (AccessFlags2)(x.ref993b84c.dstAccessMask)
	x.SrcQueueFamilyIndex = (uint32)(x.ref993b84c.srcQueueFamilyIndex)
	x.DstQueueFamilyIndex = (uint32)(x.ref993b84c.dstQueueFamilyIndex)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref993b84c.buffer))
	x.Offset = (DeviceSize)(x.ref993b84c.offset)
	x.Size = (DeviceSize)(x.ref993b84c.size)
}

// allocImageMemoryBarrier2Memory allocates memory for type C.VkImageMemoryBarrier2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemoryBarrier2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageMemoryBarrier2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageMemoryBarrier2Value = unsafe.Sizeof([1]C.VkImageMemoryBarrier2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageMemoryBarrier2) Ref() *C.VkImageMemoryBarrier2KHR {
	if x == nil {
		return nil
	}
	return x.ref29db5f30
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageMemoryBarrier2) Free() {
	if x != nil && x.allocs29db5f30 != nil {
		x.allocs29db5f30.(*cgoAllocMap).Free()
		x.ref29db5f30 = nil
	}
}

// NewImageMemoryBarrier2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageMemoryBarrier2Ref(ref unsafe.Pointer) *ImageMemoryBarrier2 {
	if ref == nil {
		return nil
	}
	obj := new(ImageMemoryBarrier2)
	obj.ref29db5f30 = (*C.VkImageMemoryBarrier2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageMemoryBarrier2) PassRef() (*C.VkImageMemoryBarrier2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref29db5f30 != nil {
		return x.ref29db5f30, nil
	}
	mem29db5f30 := allocImageMemoryBarrier2Memory(1)
	ref29db5f30 := (*C.VkImageMemoryBarrier2KHR)(mem29db5f30)
	allocs29db5f30 := new(cgoAllocMap)
	allocs29db5f30.Add(mem29db5f30)

	var csType_allocs *cgoAllocMap
	ref29db5f30.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs29db5f30.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref29db5f30.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs29db5f30.Borrow(cpNext_allocs)

	var csrcStageMask_allocs *cgoAllocMap
	ref29db5f30.srcStageMask, csrcStageMask_allocs = (C.VkPipelineStageFlags2KHR)(x.SrcStageMask), cgoAllocsUnknown
	allocs29db5f30.Borrow(csrcStageMask_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	ref29db5f30.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags2KHR)(x.SrcAccessMask), cgoAllocsUnknown
	allocs29db5f30.Borrow(csrcAccessMask_allocs)

	var cdstStageMask_allocs *cgoAllocMap
	ref29db5f30.dstStageMask, cdstStageMask_allocs = (C.VkPipelineStageFlags2KHR)(x.DstStageMask), cgoAllocsUnknown
	allocs29db5f30.Borrow(cdstStageMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	ref29db5f30.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags2KHR)(x.DstAccessMask), cgoAllocsUnknown
	allocs29db5f30.Borrow(cdstAccessMask_allocs)

	var coldLayout_allocs *cgoAllocMap
	ref29db5f30.oldLayout, coldLayout_allocs = (C.VkImageLayout)(x.OldLayout), cgoAllocsUnknown
	allocs29db5f30.Borrow(coldLayout_allocs)

	var cnewLayout_allocs *cgoAllocMap
	ref29db5f30.newLayout, cnewLayout_allocs = (C.VkImageLayout)(x.NewLayout), cgoAllocsUnknown
	allocs29db5f30.Borrow(cnewLayout_allocs)

	var csrcQueueFamilyIndex_allocs *cgoAllocMap
	ref29db5f30.srcQueueFamilyIndex, csrcQueueFamilyIndex_allocs = (C.uint32_t)(x.SrcQueueFamilyIndex), cgoAllocsUnknown
	allocs29db5f30.Borrow(csrcQueueFamilyIndex_allocs)

	var cdstQueueFamilyIndex_allocs *cgoAllocMap
	ref29db5f30.dstQueueFamilyIndex, cdstQueueFamilyIndex_allocs = (C.uint32_t)(x.DstQueueFamilyIndex), cgoAllocsUnknown
	allocs29db5f30.Borrow(cdstQueueFamilyIndex_allocs)

	var cimage_allocs *cgoAllocMap
	ref29db5f30.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs29db5f30.Borrow(cimage_allocs)

	var csubresourceRange_allocs *cgoAllocMap
	ref29db5f30.subresourceRange, csubresourceRange_allocs = x.SubresourceRange.PassValue()
	allocs29db5f30.Borrow(csubresourceRange_allocs)

	x.ref29db5f30 = ref29db5f30
	x.allocs29db5f30 = allocs29db5f30
	return ref29db5f30, allocs29db5f30

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageMemoryBarrier2) PassValue() (C.VkImageMemoryBarrier2KHR, *cgoAllocMap) {
	if x.ref29db5f30 != nil {
		return *x.ref29db5f30, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageMemoryBarrier2) Deref() {
	if x.ref29db5f30 == nil {
		return
	}
	x.SType = (StructureType)(x.ref29db5f30.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref29db5f30.pNext))
	x.SrcStageMask = (PipelineStageFlags2)(x.ref29db5f30.srcStageMask)
	x.SrcAccessMask = (AccessFlags2)(x.ref29db5f30.srcAccessMask)
	x.DstStageMask = (PipelineStageFlags2)(x.ref29db5f30.dstStageMask)
	x.DstAccessMask = (AccessFlags2)(x.ref29db5f30.dstAccessMask)
	x.OldLayout = (ImageLayout)(x.ref29db5f30.oldLayout)
	x.NewLayout = (ImageLayout)(x.ref29db5f30.newLayout)
	x.SrcQueueFamilyIndex = (uint32)(x.ref29db5f30.srcQueueFamilyIndex)
	x.DstQueueFamilyIndex = (uint32)(x.ref29db5f30.dstQueueFamilyIndex)
	x.Image = *(*Image)(unsafe.Pointer(&x.ref29db5f30.image))
	x.SubresourceRange = *NewImageSubresourceRangeRef(unsafe.Pointer(&x.ref29db5f30.subresourceRange))
}

// allocDependencyInfoMemory allocates memory for type C.VkDependencyInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDependencyInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDependencyInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDependencyInfoValue = unsafe.Sizeof([1]C.VkDependencyInfoKHR{})

// unpackSMemoryBarrier2 transforms a sliced Go data structure into plain C format.
func unpackSMemoryBarrier2(x []MemoryBarrier2) (unpacked *C.VkMemoryBarrier2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocMemoryBarrier2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMemoryBarrier2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMemoryBarrier2KHR)(h.Data)
	return
}

// unpackSBufferMemoryBarrier2 transforms a sliced Go data structure into plain C format.
func unpackSBufferMemoryBarrier2(x []BufferMemoryBarrier2) (unpacked *C.VkBufferMemoryBarrier2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocBufferMemoryBarrier2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferMemoryBarrier2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferMemoryBarrier2KHR)(h.Data)
	return
}

// unpackSImageMemoryBarrier2 transforms a sliced Go data structure into plain C format.
func unpackSImageMemoryBarrier2(x []ImageMemoryBarrier2) (unpacked *C.VkImageMemoryBarrier2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocImageMemoryBarrier2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageMemoryBarrier2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageMemoryBarrier2KHR)(h.Data)
	return
}

// packSMemoryBarrier2 reads sliced Go data structure out from plain C format.
func packSMemoryBarrier2(v []MemoryBarrier2, ptr0 *C.VkMemoryBarrier2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMemoryBarrier2Value]C.VkMemoryBarrier2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMemoryBarrier2Ref(unsafe.Pointer(&ptr1))
	}
}

// packSBufferMemoryBarrier2 reads sliced Go data structure out from plain C format.
func packSBufferMemoryBarrier2(v []BufferMemoryBarrier2, ptr0 *C.VkBufferMemoryBarrier2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferMemoryBarrier2Value]C.VkBufferMemoryBarrier2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferMemoryBarrier2Ref(unsafe.Pointer(&ptr1))
	}
}

// packSImageMemoryBarrier2 reads sliced Go data structure out from plain C format.
func packSImageMemoryBarrier2(v []ImageMemoryBarrier2, ptr0 *C.VkImageMemoryBarrier2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageMemoryBarrier2Value]C.VkImageMemoryBarrier2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageMemoryBarrier2Ref(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DependencyInfo) Ref() *C.VkDependencyInfoKHR {
	if x == nil {
		return nil
	}
	return x.refd0bb9314
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DependencyInfo) Free() {
	if x != nil && x.allocsd0bb9314 != nil {
		x.allocsd0bb9314.(*cgoAllocMap).Free()
		x.refd0bb9314 = nil
	}
}

// NewDependencyInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDependencyInfoRef(ref unsafe.Pointer) *DependencyInfo {
	if ref == nil {
		return nil
	}
	obj := new(DependencyInfo)
	obj.refd0bb9314 = (*C.VkDependencyInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DependencyInfo) PassRef() (*C.VkDependencyInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd0bb9314 != nil {
		return x.refd0bb9314, nil
	}
	memd0bb9314 := allocDependencyInfoMemory(1)
	refd0bb9314 := (*C.VkDependencyInfoKHR)(memd0bb9314)
	allocsd0bb9314 := new(cgoAllocMap)
	allocsd0bb9314.Add(memd0bb9314)

	var csType_allocs *cgoAllocMap
	refd0bb9314.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd0bb9314.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd0bb9314.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd0bb9314.Borrow(cpNext_allocs)

	var cdependencyFlags_allocs *cgoAllocMap
	refd0bb9314.dependencyFlags, cdependencyFlags_allocs = (C.VkDependencyFlags)(x.DependencyFlags), cgoAllocsUnknown
	allocsd0bb9314.Borrow(cdependencyFlags_allocs)

	var cmemoryBarrierCount_allocs *cgoAllocMap
	refd0bb9314.memoryBarrierCount, cmemoryBarrierCount_allocs = (C.uint32_t)(x.MemoryBarrierCount), cgoAllocsUnknown
	allocsd0bb9314.Borrow(cmemoryBarrierCount_allocs)

	var cpMemoryBarriers_allocs *cgoAllocMap
	refd0bb9314.pMemoryBarriers, cpMemoryBarriers_allocs = unpackSMemoryBarrier2(x.PMemoryBarriers)
	allocsd0bb9314.Borrow(cpMemoryBarriers_allocs)

	var cbufferMemoryBarrierCount_allocs *cgoAllocMap
	refd0bb9314.bufferMemoryBarrierCount, cbufferMemoryBarrierCount_allocs = (C.uint32_t)(x.BufferMemoryBarrierCount), cgoAllocsUnknown
	allocsd0bb9314.Borrow(cbufferMemoryBarrierCount_allocs)

	var cpBufferMemoryBarriers_allocs *cgoAllocMap
	refd0bb9314.pBufferMemoryBarriers, cpBufferMemoryBarriers_allocs = unpackSBufferMemoryBarrier2(x.PBufferMemoryBarriers)
	allocsd0bb9314.Borrow(cpBufferMemoryBarriers_allocs)

	var cimageMemoryBarrierCount_allocs *cgoAllocMap
	refd0bb9314.imageMemoryBarrierCount, cimageMemoryBarrierCount_allocs = (C.uint32_t)(x.ImageMemoryBarrierCount), cgoAllocsUnknown
	allocsd0bb9314.Borrow(cimageMemoryBarrierCount_allocs)

	var cpImageMemoryBarriers_allocs *cgoAllocMap
	refd0bb9314.pImageMemoryBarriers, cpImageMemoryBarriers_allocs = unpackSImageMemoryBarrier2(x.PImageMemoryBarriers)
	allocsd0bb9314.Borrow(cpImageMemoryBarriers_allocs)

	x.refd0bb9314 = refd0bb9314
	x.allocsd0bb9314 = allocsd0bb9314
	return refd0bb9314, allocsd0bb9314

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DependencyInfo) PassValue() (C.VkDependencyInfoKHR, *cgoAllocMap) {
	if x.refd0bb9314 != nil {
		return *x.refd0bb9314, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DependencyInfo) Deref() {
	if x.refd0bb9314 == nil {
		return
	}
	x.SType = (StructureType)(x.refd0bb9314.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd0bb9314.pNext))
	x.DependencyFlags = (DependencyFlags)(x.refd0bb9314.dependencyFlags)
	x.MemoryBarrierCount = (uint32)(x.refd0bb9314.memoryBarrierCount)
	packSMemoryBarrier2(x.PMemoryBarriers, x.refd0bb9314.pMemoryBarriers)
	x.BufferMemoryBarrierCount = (uint32)(x.refd0bb9314.bufferMemoryBarrierCount)
	packSBufferMemoryBarrier2(x.PBufferMemoryBarriers, x.refd0bb9314.pBufferMemoryBarriers)
	x.ImageMemoryBarrierCount = (uint32)(x.refd0bb9314.imageMemoryBarrierCount)
	packSImageMemoryBarrier2(x.PImageMemoryBarriers, x.refd0bb9314.pImageMemoryBarriers)
}

// allocSemaphoreSubmitInfoMemory allocates memory for type C.VkSemaphoreSubmitInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreSubmitInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSemaphoreSubmitInfoValue = unsafe.Sizeof([1]C.VkSemaphoreSubmitInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SemaphoreSubmitInfo) Ref() *C.VkSemaphoreSubmitInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref4cd85072
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SemaphoreSubmitInfo) Free() {
	if x != nil && x.allocs4cd85072 != nil {
		x.allocs4cd85072.(*cgoAllocMap).Free()
		x.ref4cd85072 = nil
	}
}

// NewSemaphoreSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSemaphoreSubmitInfoRef(ref unsafe.Pointer) *SemaphoreSubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(SemaphoreSubmitInfo)
	obj.ref4cd85072 = (*C.VkSemaphoreSubmitInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SemaphoreSubmitInfo) PassRef() (*C.VkSemaphoreSubmitInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4cd85072 != nil {
		return x.ref4cd85072, nil
	}
	mem4cd85072 := allocSemaphoreSubmitInfoMemory(1)
	ref4cd85072 := (*C.VkSemaphoreSubmitInfoKHR)(mem4cd85072)
	allocs4cd85072 := new(cgoAllocMap)
	allocs4cd85072.Add(mem4cd85072)

	var csType_allocs *cgoAllocMap
	ref4cd85072.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4cd85072.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4cd85072.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4cd85072.Borrow(cpNext_allocs)

	var csemaphore_allocs *cgoAllocMap
	ref4cd85072.semaphore, csemaphore_allocs = *(*C.VkSemaphore)(unsafe.Pointer(&x.Semaphore)), cgoAllocsUnknown
	allocs4cd85072.Borrow(csemaphore_allocs)

	var cvalue_allocs *cgoAllocMap
	ref4cd85072.value, cvalue_allocs = (C.uint64_t)(x.Value), cgoAllocsUnknown
	allocs4cd85072.Borrow(cvalue_allocs)

	var cstageMask_allocs *cgoAllocMap
	ref4cd85072.stageMask, cstageMask_allocs = (C.VkPipelineStageFlags2KHR)(x.StageMask), cgoAllocsUnknown
	allocs4cd85072.Borrow(cstageMask_allocs)

	var cdeviceIndex_allocs *cgoAllocMap
	ref4cd85072.deviceIndex, cdeviceIndex_allocs = (C.uint32_t)(x.DeviceIndex), cgoAllocsUnknown
	allocs4cd85072.Borrow(cdeviceIndex_allocs)

	x.ref4cd85072 = ref4cd85072
	x.allocs4cd85072 = allocs4cd85072
	return ref4cd85072, allocs4cd85072

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SemaphoreSubmitInfo) PassValue() (C.VkSemaphoreSubmitInfoKHR, *cgoAllocMap) {
	if x.ref4cd85072 != nil {
		return *x.ref4cd85072, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SemaphoreSubmitInfo) Deref() {
	if x.ref4cd85072 == nil {
		return
	}
	x.SType = (StructureType)(x.ref4cd85072.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4cd85072.pNext))
	x.Semaphore = *(*Semaphore)(unsafe.Pointer(&x.ref4cd85072.semaphore))
	x.Value = (uint32)(x.ref4cd85072.value)
	x.StageMask = (PipelineStageFlags2)(x.ref4cd85072.stageMask)
	x.DeviceIndex = (uint32)(x.ref4cd85072.deviceIndex)
}

// allocCommandBufferSubmitInfoMemory allocates memory for type C.VkCommandBufferSubmitInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferSubmitInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCommandBufferSubmitInfoValue = unsafe.Sizeof([1]C.VkCommandBufferSubmitInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferSubmitInfo) Ref() *C.VkCommandBufferSubmitInfoKHR {
	if x == nil {
		return nil
	}
	return x.refc21b3351
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferSubmitInfo) Free() {
	if x != nil && x.allocsc21b3351 != nil {
		x.allocsc21b3351.(*cgoAllocMap).Free()
		x.refc21b3351 = nil
	}
}

// NewCommandBufferSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferSubmitInfoRef(ref unsafe.Pointer) *CommandBufferSubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferSubmitInfo)
	obj.refc21b3351 = (*C.VkCommandBufferSubmitInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferSubmitInfo) PassRef() (*C.VkCommandBufferSubmitInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc21b3351 != nil {
		return x.refc21b3351, nil
	}
	memc21b3351 := allocCommandBufferSubmitInfoMemory(1)
	refc21b3351 := (*C.VkCommandBufferSubmitInfoKHR)(memc21b3351)
	allocsc21b3351 := new(cgoAllocMap)
	allocsc21b3351.Add(memc21b3351)

	var csType_allocs *cgoAllocMap
	refc21b3351.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc21b3351.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc21b3351.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc21b3351.Borrow(cpNext_allocs)

	var ccommandBuffer_allocs *cgoAllocMap
	refc21b3351.commandBuffer, ccommandBuffer_allocs = *(*C.VkCommandBuffer)(unsafe.Pointer(&x.CommandBuffer)), cgoAllocsUnknown
	allocsc21b3351.Borrow(ccommandBuffer_allocs)

	var cdeviceMask_allocs *cgoAllocMap
	refc21b3351.deviceMask, cdeviceMask_allocs = (C.uint32_t)(x.DeviceMask), cgoAllocsUnknown
	allocsc21b3351.Borrow(cdeviceMask_allocs)

	x.refc21b3351 = refc21b3351
	x.allocsc21b3351 = allocsc21b3351
	return refc21b3351, allocsc21b3351

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferSubmitInfo) PassValue() (C.VkCommandBufferSubmitInfoKHR, *cgoAllocMap) {
	if x.refc21b3351 != nil {
		return *x.refc21b3351, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferSubmitInfo) Deref() {
	if x.refc21b3351 == nil {
		return
	}
	x.SType = (StructureType)(x.refc21b3351.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc21b3351.pNext))
	x.CommandBuffer = *(*CommandBuffer)(unsafe.Pointer(&x.refc21b3351.commandBuffer))
	x.DeviceMask = (uint32)(x.refc21b3351.deviceMask)
}

// allocSubmitInfo2Memory allocates memory for type C.VkSubmitInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubmitInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubmitInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubmitInfo2Value = unsafe.Sizeof([1]C.VkSubmitInfo2KHR{})

// unpackSSemaphoreSubmitInfo transforms a sliced Go data structure into plain C format.
func unpackSSemaphoreSubmitInfo(x []SemaphoreSubmitInfo) (unpacked *C.VkSemaphoreSubmitInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSemaphoreSubmitInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSemaphoreSubmitInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSemaphoreSubmitInfoKHR)(h.Data)
	return
}

// unpackSCommandBufferSubmitInfo transforms a sliced Go data structure into plain C format.
func unpackSCommandBufferSubmitInfo(x []CommandBufferSubmitInfo) (unpacked *C.VkCommandBufferSubmitInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCommandBufferSubmitInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCommandBufferSubmitInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCommandBufferSubmitInfoKHR)(h.Data)
	return
}

// packSSemaphoreSubmitInfo reads sliced Go data structure out from plain C format.
func packSSemaphoreSubmitInfo(v []SemaphoreSubmitInfo, ptr0 *C.VkSemaphoreSubmitInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSemaphoreSubmitInfoValue]C.VkSemaphoreSubmitInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSemaphoreSubmitInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSCommandBufferSubmitInfo reads sliced Go data structure out from plain C format.
func packSCommandBufferSubmitInfo(v []CommandBufferSubmitInfo, ptr0 *C.VkCommandBufferSubmitInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCommandBufferSubmitInfoValue]C.VkCommandBufferSubmitInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCommandBufferSubmitInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubmitInfo2) Ref() *C.VkSubmitInfo2KHR {
	if x == nil {
		return nil
	}
	return x.ref7b20f9a9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubmitInfo2) Free() {
	if x != nil && x.allocs7b20f9a9 != nil {
		x.allocs7b20f9a9.(*cgoAllocMap).Free()
		x.ref7b20f9a9 = nil
	}
}

// NewSubmitInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubmitInfo2Ref(ref unsafe.Pointer) *SubmitInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(SubmitInfo2)
	obj.ref7b20f9a9 = (*C.VkSubmitInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubmitInfo2) PassRef() (*C.VkSubmitInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7b20f9a9 != nil {
		return x.ref7b20f9a9, nil
	}
	mem7b20f9a9 := allocSubmitInfo2Memory(1)
	ref7b20f9a9 := (*C.VkSubmitInfo2KHR)(mem7b20f9a9)
	allocs7b20f9a9 := new(cgoAllocMap)
	allocs7b20f9a9.Add(mem7b20f9a9)

	var csType_allocs *cgoAllocMap
	ref7b20f9a9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7b20f9a9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7b20f9a9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7b20f9a9.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref7b20f9a9.flags, cflags_allocs = (C.VkSubmitFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs7b20f9a9.Borrow(cflags_allocs)

	var cwaitSemaphoreInfoCount_allocs *cgoAllocMap
	ref7b20f9a9.waitSemaphoreInfoCount, cwaitSemaphoreInfoCount_allocs = (C.uint32_t)(x.WaitSemaphoreInfoCount), cgoAllocsUnknown
	allocs7b20f9a9.Borrow(cwaitSemaphoreInfoCount_allocs)

	var cpWaitSemaphoreInfos_allocs *cgoAllocMap
	ref7b20f9a9.pWaitSemaphoreInfos, cpWaitSemaphoreInfos_allocs = unpackSSemaphoreSubmitInfo(x.PWaitSemaphoreInfos)
	allocs7b20f9a9.Borrow(cpWaitSemaphoreInfos_allocs)

	var ccommandBufferInfoCount_allocs *cgoAllocMap
	ref7b20f9a9.commandBufferInfoCount, ccommandBufferInfoCount_allocs = (C.uint32_t)(x.CommandBufferInfoCount), cgoAllocsUnknown
	allocs7b20f9a9.Borrow(ccommandBufferInfoCount_allocs)

	var cpCommandBufferInfos_allocs *cgoAllocMap
	ref7b20f9a9.pCommandBufferInfos, cpCommandBufferInfos_allocs = unpackSCommandBufferSubmitInfo(x.PCommandBufferInfos)
	allocs7b20f9a9.Borrow(cpCommandBufferInfos_allocs)

	var csignalSemaphoreInfoCount_allocs *cgoAllocMap
	ref7b20f9a9.signalSemaphoreInfoCount, csignalSemaphoreInfoCount_allocs = (C.uint32_t)(x.SignalSemaphoreInfoCount), cgoAllocsUnknown
	allocs7b20f9a9.Borrow(csignalSemaphoreInfoCount_allocs)

	var cpSignalSemaphoreInfos_allocs *cgoAllocMap
	ref7b20f9a9.pSignalSemaphoreInfos, cpSignalSemaphoreInfos_allocs = unpackSSemaphoreSubmitInfo(x.PSignalSemaphoreInfos)
	allocs7b20f9a9.Borrow(cpSignalSemaphoreInfos_allocs)

	x.ref7b20f9a9 = ref7b20f9a9
	x.allocs7b20f9a9 = allocs7b20f9a9
	return ref7b20f9a9, allocs7b20f9a9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubmitInfo2) PassValue() (C.VkSubmitInfo2KHR, *cgoAllocMap) {
	if x.ref7b20f9a9 != nil {
		return *x.ref7b20f9a9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubmitInfo2) Deref() {
	if x.ref7b20f9a9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7b20f9a9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7b20f9a9.pNext))
	x.Flags = (SubmitFlags)(x.ref7b20f9a9.flags)
	x.WaitSemaphoreInfoCount = (uint32)(x.ref7b20f9a9.waitSemaphoreInfoCount)
	packSSemaphoreSubmitInfo(x.PWaitSemaphoreInfos, x.ref7b20f9a9.pWaitSemaphoreInfos)
	x.CommandBufferInfoCount = (uint32)(x.ref7b20f9a9.commandBufferInfoCount)
	packSCommandBufferSubmitInfo(x.PCommandBufferInfos, x.ref7b20f9a9.pCommandBufferInfos)
	x.SignalSemaphoreInfoCount = (uint32)(x.ref7b20f9a9.signalSemaphoreInfoCount)
	packSSemaphoreSubmitInfo(x.PSignalSemaphoreInfos, x.ref7b20f9a9.pSignalSemaphoreInfos)
}

// allocPhysicalDeviceSynchronization2FeaturesMemory allocates memory for type C.VkPhysicalDeviceSynchronization2FeaturesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSynchronization2FeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSynchronization2FeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceSynchronization2FeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSynchronization2FeaturesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSynchronization2Features) Ref() *C.VkPhysicalDeviceSynchronization2FeaturesKHR {
	if x == nil {
		return nil
	}
	return x.ref5f42a84f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSynchronization2Features) Free() {
	if x != nil && x.allocs5f42a84f != nil {
		x.allocs5f42a84f.(*cgoAllocMap).Free()
		x.ref5f42a84f = nil
	}
}

// NewPhysicalDeviceSynchronization2FeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSynchronization2FeaturesRef(ref unsafe.Pointer) *PhysicalDeviceSynchronization2Features {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSynchronization2Features)
	obj.ref5f42a84f = (*C.VkPhysicalDeviceSynchronization2FeaturesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSynchronization2Features) PassRef() (*C.VkPhysicalDeviceSynchronization2FeaturesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5f42a84f != nil {
		return x.ref5f42a84f, nil
	}
	mem5f42a84f := allocPhysicalDeviceSynchronization2FeaturesMemory(1)
	ref5f42a84f := (*C.VkPhysicalDeviceSynchronization2FeaturesKHR)(mem5f42a84f)
	allocs5f42a84f := new(cgoAllocMap)
	allocs5f42a84f.Add(mem5f42a84f)

	var csType_allocs *cgoAllocMap
	ref5f42a84f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5f42a84f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5f42a84f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5f42a84f.Borrow(cpNext_allocs)

	var csynchronization2_allocs *cgoAllocMap
	ref5f42a84f.synchronization2, csynchronization2_allocs = (C.VkBool32)(x.Synchronization2), cgoAllocsUnknown
	allocs5f42a84f.Borrow(csynchronization2_allocs)

	x.ref5f42a84f = ref5f42a84f
	x.allocs5f42a84f = allocs5f42a84f
	return ref5f42a84f, allocs5f42a84f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSynchronization2Features) PassValue() (C.VkPhysicalDeviceSynchronization2FeaturesKHR, *cgoAllocMap) {
	if x.ref5f42a84f != nil {
		return *x.ref5f42a84f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSynchronization2Features) Deref() {
	if x.ref5f42a84f == nil {
		return
	}
	x.SType = (StructureType)(x.ref5f42a84f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5f42a84f.pNext))
	x.Synchronization2 = (Bool32)(x.ref5f42a84f.synchronization2)
}

// allocQueueFamilyCheckpointProperties2NVMemory allocates memory for type C.VkQueueFamilyCheckpointProperties2NV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueueFamilyCheckpointProperties2NVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueueFamilyCheckpointProperties2NVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfQueueFamilyCheckpointProperties2NVValue = unsafe.Sizeof([1]C.VkQueueFamilyCheckpointProperties2NV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueueFamilyCheckpointProperties2NV) Ref() *C.VkQueueFamilyCheckpointProperties2NV {
	if x == nil {
		return nil
	}
	return x.reffdc86afc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueueFamilyCheckpointProperties2NV) Free() {
	if x != nil && x.allocsfdc86afc != nil {
		x.allocsfdc86afc.(*cgoAllocMap).Free()
		x.reffdc86afc = nil
	}
}

// NewQueueFamilyCheckpointProperties2NVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueueFamilyCheckpointProperties2NVRef(ref unsafe.Pointer) *QueueFamilyCheckpointProperties2NV {
	if ref == nil {
		return nil
	}
	obj := new(QueueFamilyCheckpointProperties2NV)
	obj.reffdc86afc = (*C.VkQueueFamilyCheckpointProperties2NV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueueFamilyCheckpointProperties2NV) PassRef() (*C.VkQueueFamilyCheckpointProperties2NV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffdc86afc != nil {
		return x.reffdc86afc, nil
	}
	memfdc86afc := allocQueueFamilyCheckpointProperties2NVMemory(1)
	reffdc86afc := (*C.VkQueueFamilyCheckpointProperties2NV)(memfdc86afc)
	allocsfdc86afc := new(cgoAllocMap)
	allocsfdc86afc.Add(memfdc86afc)

	var csType_allocs *cgoAllocMap
	reffdc86afc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfdc86afc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffdc86afc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfdc86afc.Borrow(cpNext_allocs)

	var ccheckpointExecutionStageMask_allocs *cgoAllocMap
	reffdc86afc.checkpointExecutionStageMask, ccheckpointExecutionStageMask_allocs = (C.VkPipelineStageFlags2KHR)(x.CheckpointExecutionStageMask), cgoAllocsUnknown
	allocsfdc86afc.Borrow(ccheckpointExecutionStageMask_allocs)

	x.reffdc86afc = reffdc86afc
	x.allocsfdc86afc = allocsfdc86afc
	return reffdc86afc, allocsfdc86afc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueueFamilyCheckpointProperties2NV) PassValue() (C.VkQueueFamilyCheckpointProperties2NV, *cgoAllocMap) {
	if x.reffdc86afc != nil {
		return *x.reffdc86afc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueueFamilyCheckpointProperties2NV) Deref() {
	if x.reffdc86afc == nil {
		return
	}
	x.SType = (StructureType)(x.reffdc86afc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffdc86afc.pNext))
	x.CheckpointExecutionStageMask = (PipelineStageFlags2)(x.reffdc86afc.checkpointExecutionStageMask)
}

// allocCheckpointData2NVMemory allocates memory for type C.VkCheckpointData2NV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCheckpointData2NVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCheckpointData2NVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCheckpointData2NVValue = unsafe.Sizeof([1]C.VkCheckpointData2NV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CheckpointData2NV) Ref() *C.VkCheckpointData2NV {
	if x == nil {
		return nil
	}
	return x.ref6e25431b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CheckpointData2NV) Free() {
	if x != nil && x.allocs6e25431b != nil {
		x.allocs6e25431b.(*cgoAllocMap).Free()
		x.ref6e25431b = nil
	}
}

// NewCheckpointData2NVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCheckpointData2NVRef(ref unsafe.Pointer) *CheckpointData2NV {
	if ref == nil {
		return nil
	}
	obj := new(CheckpointData2NV)
	obj.ref6e25431b = (*C.VkCheckpointData2NV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CheckpointData2NV) PassRef() (*C.VkCheckpointData2NV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6e25431b != nil {
		return x.ref6e25431b, nil
	}
	mem6e25431b := allocCheckpointData2NVMemory(1)
	ref6e25431b := (*C.VkCheckpointData2NV)(mem6e25431b)
	allocs6e25431b := new(cgoAllocMap)
	allocs6e25431b.Add(mem6e25431b)

	var csType_allocs *cgoAllocMap
	ref6e25431b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6e25431b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6e25431b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6e25431b.Borrow(cpNext_allocs)

	var cstage_allocs *cgoAllocMap
	ref6e25431b.stage, cstage_allocs = (C.VkPipelineStageFlags2KHR)(x.Stage), cgoAllocsUnknown
	allocs6e25431b.Borrow(cstage_allocs)

	var cpCheckpointMarker_allocs *cgoAllocMap
	ref6e25431b.pCheckpointMarker, cpCheckpointMarker_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PCheckpointMarker)), cgoAllocsUnknown
	allocs6e25431b.Borrow(cpCheckpointMarker_allocs)

	x.ref6e25431b = ref6e25431b
	x.allocs6e25431b = allocs6e25431b
	return ref6e25431b, allocs6e25431b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CheckpointData2NV) PassValue() (C.VkCheckpointData2NV, *cgoAllocMap) {
	if x.ref6e25431b != nil {
		return *x.ref6e25431b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CheckpointData2NV) Deref() {
	if x.ref6e25431b == nil {
		return
	}
	x.SType = (StructureType)(x.ref6e25431b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6e25431b.pNext))
	x.Stage = (PipelineStageFlags2)(x.ref6e25431b.stage)
	x.PCheckpointMarker = (unsafe.Pointer)(unsafe.Pointer(x.ref6e25431b.pCheckpointMarker))
}

// allocPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesMemory allocates memory for type C.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) Ref() *C.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR {
	if x == nil {
		return nil
	}
	return x.ref7fb8b693
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) Free() {
	if x != nil && x.allocs7fb8b693 != nil {
		x.allocs7fb8b693.(*cgoAllocMap).Free()
		x.ref7fb8b693 = nil
	}
}

// NewPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures)
	obj.ref7fb8b693 = (*C.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) PassRef() (*C.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7fb8b693 != nil {
		return x.ref7fb8b693, nil
	}
	mem7fb8b693 := allocPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesMemory(1)
	ref7fb8b693 := (*C.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR)(mem7fb8b693)
	allocs7fb8b693 := new(cgoAllocMap)
	allocs7fb8b693.Add(mem7fb8b693)

	var csType_allocs *cgoAllocMap
	ref7fb8b693.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7fb8b693.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7fb8b693.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7fb8b693.Borrow(cpNext_allocs)

	var cshaderZeroInitializeWorkgroupMemory_allocs *cgoAllocMap
	ref7fb8b693.shaderZeroInitializeWorkgroupMemory, cshaderZeroInitializeWorkgroupMemory_allocs = (C.VkBool32)(x.ShaderZeroInitializeWorkgroupMemory), cgoAllocsUnknown
	allocs7fb8b693.Borrow(cshaderZeroInitializeWorkgroupMemory_allocs)

	x.ref7fb8b693 = ref7fb8b693
	x.allocs7fb8b693 = allocs7fb8b693
	return ref7fb8b693, allocs7fb8b693

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) PassValue() (C.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR, *cgoAllocMap) {
	if x.ref7fb8b693 != nil {
		return *x.ref7fb8b693, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) Deref() {
	if x.ref7fb8b693 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7fb8b693.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7fb8b693.pNext))
	x.ShaderZeroInitializeWorkgroupMemory = (Bool32)(x.ref7fb8b693.shaderZeroInitializeWorkgroupMemory)
}

// allocPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesMemory allocates memory for type C.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceWorkgroupMemoryExplicitLayoutFeatures) Ref() *C.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
	if x == nil {
		return nil
	}
	return x.ref288a691
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceWorkgroupMemoryExplicitLayoutFeatures) Free() {
	if x != nil && x.allocs288a691 != nil {
		x.allocs288a691.(*cgoAllocMap).Free()
		x.ref288a691 = nil
	}
}

// NewPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceWorkgroupMemoryExplicitLayoutFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceWorkgroupMemoryExplicitLayoutFeatures)
	obj.ref288a691 = (*C.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceWorkgroupMemoryExplicitLayoutFeatures) PassRef() (*C.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref288a691 != nil {
		return x.ref288a691, nil
	}
	mem288a691 := allocPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesMemory(1)
	ref288a691 := (*C.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR)(mem288a691)
	allocs288a691 := new(cgoAllocMap)
	allocs288a691.Add(mem288a691)

	var csType_allocs *cgoAllocMap
	ref288a691.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs288a691.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref288a691.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs288a691.Borrow(cpNext_allocs)

	var cworkgroupMemoryExplicitLayout_allocs *cgoAllocMap
	ref288a691.workgroupMemoryExplicitLayout, cworkgroupMemoryExplicitLayout_allocs = (C.VkBool32)(x.WorkgroupMemoryExplicitLayout), cgoAllocsUnknown
	allocs288a691.Borrow(cworkgroupMemoryExplicitLayout_allocs)

	var cworkgroupMemoryExplicitLayoutScalarBlockLayout_allocs *cgoAllocMap
	ref288a691.workgroupMemoryExplicitLayoutScalarBlockLayout, cworkgroupMemoryExplicitLayoutScalarBlockLayout_allocs = (C.VkBool32)(x.WorkgroupMemoryExplicitLayoutScalarBlockLayout), cgoAllocsUnknown
	allocs288a691.Borrow(cworkgroupMemoryExplicitLayoutScalarBlockLayout_allocs)

	var cworkgroupMemoryExplicitLayout8BitAccess_allocs *cgoAllocMap
	ref288a691.workgroupMemoryExplicitLayout8BitAccess, cworkgroupMemoryExplicitLayout8BitAccess_allocs = (C.VkBool32)(x.WorkgroupMemoryExplicitLayout8BitAccess), cgoAllocsUnknown
	allocs288a691.Borrow(cworkgroupMemoryExplicitLayout8BitAccess_allocs)

	var cworkgroupMemoryExplicitLayout16BitAccess_allocs *cgoAllocMap
	ref288a691.workgroupMemoryExplicitLayout16BitAccess, cworkgroupMemoryExplicitLayout16BitAccess_allocs = (C.VkBool32)(x.WorkgroupMemoryExplicitLayout16BitAccess), cgoAllocsUnknown
	allocs288a691.Borrow(cworkgroupMemoryExplicitLayout16BitAccess_allocs)

	x.ref288a691 = ref288a691
	x.allocs288a691 = allocs288a691
	return ref288a691, allocs288a691

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceWorkgroupMemoryExplicitLayoutFeatures) PassValue() (C.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, *cgoAllocMap) {
	if x.ref288a691 != nil {
		return *x.ref288a691, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceWorkgroupMemoryExplicitLayoutFeatures) Deref() {
	if x.ref288a691 == nil {
		return
	}
	x.SType = (StructureType)(x.ref288a691.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref288a691.pNext))
	x.WorkgroupMemoryExplicitLayout = (Bool32)(x.ref288a691.workgroupMemoryExplicitLayout)
	x.WorkgroupMemoryExplicitLayoutScalarBlockLayout = (Bool32)(x.ref288a691.workgroupMemoryExplicitLayoutScalarBlockLayout)
	x.WorkgroupMemoryExplicitLayout8BitAccess = (Bool32)(x.ref288a691.workgroupMemoryExplicitLayout8BitAccess)
	x.WorkgroupMemoryExplicitLayout16BitAccess = (Bool32)(x.ref288a691.workgroupMemoryExplicitLayout16BitAccess)
}

// allocBufferCopy2Memory allocates memory for type C.VkBufferCopy2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferCopy2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferCopy2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferCopy2Value = unsafe.Sizeof([1]C.VkBufferCopy2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferCopy2) Ref() *C.VkBufferCopy2KHR {
	if x == nil {
		return nil
	}
	return x.refc4049554
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferCopy2) Free() {
	if x != nil && x.allocsc4049554 != nil {
		x.allocsc4049554.(*cgoAllocMap).Free()
		x.refc4049554 = nil
	}
}

// NewBufferCopy2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferCopy2Ref(ref unsafe.Pointer) *BufferCopy2 {
	if ref == nil {
		return nil
	}
	obj := new(BufferCopy2)
	obj.refc4049554 = (*C.VkBufferCopy2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferCopy2) PassRef() (*C.VkBufferCopy2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc4049554 != nil {
		return x.refc4049554, nil
	}
	memc4049554 := allocBufferCopy2Memory(1)
	refc4049554 := (*C.VkBufferCopy2KHR)(memc4049554)
	allocsc4049554 := new(cgoAllocMap)
	allocsc4049554.Add(memc4049554)

	var csType_allocs *cgoAllocMap
	refc4049554.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc4049554.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc4049554.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc4049554.Borrow(cpNext_allocs)

	var csrcOffset_allocs *cgoAllocMap
	refc4049554.srcOffset, csrcOffset_allocs = (C.VkDeviceSize)(x.SrcOffset), cgoAllocsUnknown
	allocsc4049554.Borrow(csrcOffset_allocs)

	var cdstOffset_allocs *cgoAllocMap
	refc4049554.dstOffset, cdstOffset_allocs = (C.VkDeviceSize)(x.DstOffset), cgoAllocsUnknown
	allocsc4049554.Borrow(cdstOffset_allocs)

	var csize_allocs *cgoAllocMap
	refc4049554.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocsc4049554.Borrow(csize_allocs)

	x.refc4049554 = refc4049554
	x.allocsc4049554 = allocsc4049554
	return refc4049554, allocsc4049554

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferCopy2) PassValue() (C.VkBufferCopy2KHR, *cgoAllocMap) {
	if x.refc4049554 != nil {
		return *x.refc4049554, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferCopy2) Deref() {
	if x.refc4049554 == nil {
		return
	}
	x.SType = (StructureType)(x.refc4049554.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc4049554.pNext))
	x.SrcOffset = (DeviceSize)(x.refc4049554.srcOffset)
	x.DstOffset = (DeviceSize)(x.refc4049554.dstOffset)
	x.Size = (DeviceSize)(x.refc4049554.size)
}

// allocCopyBufferInfo2Memory allocates memory for type C.VkCopyBufferInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyBufferInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyBufferInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCopyBufferInfo2Value = unsafe.Sizeof([1]C.VkCopyBufferInfo2KHR{})

// unpackSBufferCopy2 transforms a sliced Go data structure into plain C format.
func unpackSBufferCopy2(x []BufferCopy2) (unpacked *C.VkBufferCopy2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocBufferCopy2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferCopy2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferCopy2KHR)(h.Data)
	return
}

// packSBufferCopy2 reads sliced Go data structure out from plain C format.
func packSBufferCopy2(v []BufferCopy2, ptr0 *C.VkBufferCopy2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferCopy2Value]C.VkBufferCopy2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferCopy2Ref(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CopyBufferInfo2) Ref() *C.VkCopyBufferInfo2KHR {
	if x == nil {
		return nil
	}
	return x.reff7b2b33c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CopyBufferInfo2) Free() {
	if x != nil && x.allocsf7b2b33c != nil {
		x.allocsf7b2b33c.(*cgoAllocMap).Free()
		x.reff7b2b33c = nil
	}
}

// NewCopyBufferInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCopyBufferInfo2Ref(ref unsafe.Pointer) *CopyBufferInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(CopyBufferInfo2)
	obj.reff7b2b33c = (*C.VkCopyBufferInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CopyBufferInfo2) PassRef() (*C.VkCopyBufferInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff7b2b33c != nil {
		return x.reff7b2b33c, nil
	}
	memf7b2b33c := allocCopyBufferInfo2Memory(1)
	reff7b2b33c := (*C.VkCopyBufferInfo2KHR)(memf7b2b33c)
	allocsf7b2b33c := new(cgoAllocMap)
	allocsf7b2b33c.Add(memf7b2b33c)

	var csType_allocs *cgoAllocMap
	reff7b2b33c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf7b2b33c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff7b2b33c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf7b2b33c.Borrow(cpNext_allocs)

	var csrcBuffer_allocs *cgoAllocMap
	reff7b2b33c.srcBuffer, csrcBuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.SrcBuffer)), cgoAllocsUnknown
	allocsf7b2b33c.Borrow(csrcBuffer_allocs)

	var cdstBuffer_allocs *cgoAllocMap
	reff7b2b33c.dstBuffer, cdstBuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.DstBuffer)), cgoAllocsUnknown
	allocsf7b2b33c.Borrow(cdstBuffer_allocs)

	var cregionCount_allocs *cgoAllocMap
	reff7b2b33c.regionCount, cregionCount_allocs = (C.uint32_t)(x.RegionCount), cgoAllocsUnknown
	allocsf7b2b33c.Borrow(cregionCount_allocs)

	var cpRegions_allocs *cgoAllocMap
	reff7b2b33c.pRegions, cpRegions_allocs = unpackSBufferCopy2(x.PRegions)
	allocsf7b2b33c.Borrow(cpRegions_allocs)

	x.reff7b2b33c = reff7b2b33c
	x.allocsf7b2b33c = allocsf7b2b33c
	return reff7b2b33c, allocsf7b2b33c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CopyBufferInfo2) PassValue() (C.VkCopyBufferInfo2KHR, *cgoAllocMap) {
	if x.reff7b2b33c != nil {
		return *x.reff7b2b33c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CopyBufferInfo2) Deref() {
	if x.reff7b2b33c == nil {
		return
	}
	x.SType = (StructureType)(x.reff7b2b33c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff7b2b33c.pNext))
	x.SrcBuffer = *(*Buffer)(unsafe.Pointer(&x.reff7b2b33c.srcBuffer))
	x.DstBuffer = *(*Buffer)(unsafe.Pointer(&x.reff7b2b33c.dstBuffer))
	x.RegionCount = (uint32)(x.reff7b2b33c.regionCount)
	packSBufferCopy2(x.PRegions, x.reff7b2b33c.pRegions)
}

// allocImageCopy2Memory allocates memory for type C.VkImageCopy2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCopy2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCopy2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageCopy2Value = unsafe.Sizeof([1]C.VkImageCopy2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageCopy2) Ref() *C.VkImageCopy2KHR {
	if x == nil {
		return nil
	}
	return x.ref3e0132ff
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageCopy2) Free() {
	if x != nil && x.allocs3e0132ff != nil {
		x.allocs3e0132ff.(*cgoAllocMap).Free()
		x.ref3e0132ff = nil
	}
}

// NewImageCopy2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageCopy2Ref(ref unsafe.Pointer) *ImageCopy2 {
	if ref == nil {
		return nil
	}
	obj := new(ImageCopy2)
	obj.ref3e0132ff = (*C.VkImageCopy2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageCopy2) PassRef() (*C.VkImageCopy2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3e0132ff != nil {
		return x.ref3e0132ff, nil
	}
	mem3e0132ff := allocImageCopy2Memory(1)
	ref3e0132ff := (*C.VkImageCopy2KHR)(mem3e0132ff)
	allocs3e0132ff := new(cgoAllocMap)
	allocs3e0132ff.Add(mem3e0132ff)

	var csType_allocs *cgoAllocMap
	ref3e0132ff.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3e0132ff.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3e0132ff.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3e0132ff.Borrow(cpNext_allocs)

	var csrcSubresource_allocs *cgoAllocMap
	ref3e0132ff.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs3e0132ff.Borrow(csrcSubresource_allocs)

	var csrcOffset_allocs *cgoAllocMap
	ref3e0132ff.srcOffset, csrcOffset_allocs = x.SrcOffset.PassValue()
	allocs3e0132ff.Borrow(csrcOffset_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref3e0132ff.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs3e0132ff.Borrow(cdstSubresource_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref3e0132ff.dstOffset, cdstOffset_allocs = x.DstOffset.PassValue()
	allocs3e0132ff.Borrow(cdstOffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref3e0132ff.extent, cextent_allocs = x.Extent.PassValue()
	allocs3e0132ff.Borrow(cextent_allocs)

	x.ref3e0132ff = ref3e0132ff
	x.allocs3e0132ff = allocs3e0132ff
	return ref3e0132ff, allocs3e0132ff

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageCopy2) PassValue() (C.VkImageCopy2KHR, *cgoAllocMap) {
	if x.ref3e0132ff != nil {
		return *x.ref3e0132ff, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageCopy2) Deref() {
	if x.ref3e0132ff == nil {
		return
	}
	x.SType = (StructureType)(x.ref3e0132ff.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3e0132ff.pNext))
	x.SrcSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref3e0132ff.srcSubresource))
	x.SrcOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref3e0132ff.srcOffset))
	x.DstSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref3e0132ff.dstSubresource))
	x.DstOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref3e0132ff.dstOffset))
	x.Extent = *NewExtent3DRef(unsafe.Pointer(&x.ref3e0132ff.extent))
}

// allocCopyImageInfo2Memory allocates memory for type C.VkCopyImageInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyImageInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyImageInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCopyImageInfo2Value = unsafe.Sizeof([1]C.VkCopyImageInfo2KHR{})

// unpackSImageCopy2 transforms a sliced Go data structure into plain C format.
func unpackSImageCopy2(x []ImageCopy2) (unpacked *C.VkImageCopy2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocImageCopy2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageCopy2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageCopy2KHR)(h.Data)
	return
}

// packSImageCopy2 reads sliced Go data structure out from plain C format.
func packSImageCopy2(v []ImageCopy2, ptr0 *C.VkImageCopy2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageCopy2Value]C.VkImageCopy2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageCopy2Ref(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CopyImageInfo2) Ref() *C.VkCopyImageInfo2KHR {
	if x == nil {
		return nil
	}
	return x.ref735ccdc0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CopyImageInfo2) Free() {
	if x != nil && x.allocs735ccdc0 != nil {
		x.allocs735ccdc0.(*cgoAllocMap).Free()
		x.ref735ccdc0 = nil
	}
}

// NewCopyImageInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCopyImageInfo2Ref(ref unsafe.Pointer) *CopyImageInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(CopyImageInfo2)
	obj.ref735ccdc0 = (*C.VkCopyImageInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CopyImageInfo2) PassRef() (*C.VkCopyImageInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref735ccdc0 != nil {
		return x.ref735ccdc0, nil
	}
	mem735ccdc0 := allocCopyImageInfo2Memory(1)
	ref735ccdc0 := (*C.VkCopyImageInfo2KHR)(mem735ccdc0)
	allocs735ccdc0 := new(cgoAllocMap)
	allocs735ccdc0.Add(mem735ccdc0)

	var csType_allocs *cgoAllocMap
	ref735ccdc0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs735ccdc0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref735ccdc0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs735ccdc0.Borrow(cpNext_allocs)

	var csrcImage_allocs *cgoAllocMap
	ref735ccdc0.srcImage, csrcImage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.SrcImage)), cgoAllocsUnknown
	allocs735ccdc0.Borrow(csrcImage_allocs)

	var csrcImageLayout_allocs *cgoAllocMap
	ref735ccdc0.srcImageLayout, csrcImageLayout_allocs = (C.VkImageLayout)(x.SrcImageLayout), cgoAllocsUnknown
	allocs735ccdc0.Borrow(csrcImageLayout_allocs)

	var cdstImage_allocs *cgoAllocMap
	ref735ccdc0.dstImage, cdstImage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.DstImage)), cgoAllocsUnknown
	allocs735ccdc0.Borrow(cdstImage_allocs)

	var cdstImageLayout_allocs *cgoAllocMap
	ref735ccdc0.dstImageLayout, cdstImageLayout_allocs = (C.VkImageLayout)(x.DstImageLayout), cgoAllocsUnknown
	allocs735ccdc0.Borrow(cdstImageLayout_allocs)

	var cregionCount_allocs *cgoAllocMap
	ref735ccdc0.regionCount, cregionCount_allocs = (C.uint32_t)(x.RegionCount), cgoAllocsUnknown
	allocs735ccdc0.Borrow(cregionCount_allocs)

	var cpRegions_allocs *cgoAllocMap
	ref735ccdc0.pRegions, cpRegions_allocs = unpackSImageCopy2(x.PRegions)
	allocs735ccdc0.Borrow(cpRegions_allocs)

	x.ref735ccdc0 = ref735ccdc0
	x.allocs735ccdc0 = allocs735ccdc0
	return ref735ccdc0, allocs735ccdc0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CopyImageInfo2) PassValue() (C.VkCopyImageInfo2KHR, *cgoAllocMap) {
	if x.ref735ccdc0 != nil {
		return *x.ref735ccdc0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CopyImageInfo2) Deref() {
	if x.ref735ccdc0 == nil {
		return
	}
	x.SType = (StructureType)(x.ref735ccdc0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref735ccdc0.pNext))
	x.SrcImage = *(*Image)(unsafe.Pointer(&x.ref735ccdc0.srcImage))
	x.SrcImageLayout = (ImageLayout)(x.ref735ccdc0.srcImageLayout)
	x.DstImage = *(*Image)(unsafe.Pointer(&x.ref735ccdc0.dstImage))
	x.DstImageLayout = (ImageLayout)(x.ref735ccdc0.dstImageLayout)
	x.RegionCount = (uint32)(x.ref735ccdc0.regionCount)
	packSImageCopy2(x.PRegions, x.ref735ccdc0.pRegions)
}

// allocBufferImageCopy2Memory allocates memory for type C.VkBufferImageCopy2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferImageCopy2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferImageCopy2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferImageCopy2Value = unsafe.Sizeof([1]C.VkBufferImageCopy2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferImageCopy2) Ref() *C.VkBufferImageCopy2KHR {
	if x == nil {
		return nil
	}
	return x.ref4389d6ba
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferImageCopy2) Free() {
	if x != nil && x.allocs4389d6ba != nil {
		x.allocs4389d6ba.(*cgoAllocMap).Free()
		x.ref4389d6ba = nil
	}
}

// NewBufferImageCopy2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferImageCopy2Ref(ref unsafe.Pointer) *BufferImageCopy2 {
	if ref == nil {
		return nil
	}
	obj := new(BufferImageCopy2)
	obj.ref4389d6ba = (*C.VkBufferImageCopy2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferImageCopy2) PassRef() (*C.VkBufferImageCopy2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4389d6ba != nil {
		return x.ref4389d6ba, nil
	}
	mem4389d6ba := allocBufferImageCopy2Memory(1)
	ref4389d6ba := (*C.VkBufferImageCopy2KHR)(mem4389d6ba)
	allocs4389d6ba := new(cgoAllocMap)
	allocs4389d6ba.Add(mem4389d6ba)

	var csType_allocs *cgoAllocMap
	ref4389d6ba.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4389d6ba.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4389d6ba.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4389d6ba.Borrow(cpNext_allocs)

	var cbufferOffset_allocs *cgoAllocMap
	ref4389d6ba.bufferOffset, cbufferOffset_allocs = (C.VkDeviceSize)(x.BufferOffset), cgoAllocsUnknown
	allocs4389d6ba.Borrow(cbufferOffset_allocs)

	var cbufferRowLength_allocs *cgoAllocMap
	ref4389d6ba.bufferRowLength, cbufferRowLength_allocs = (C.uint32_t)(x.BufferRowLength), cgoAllocsUnknown
	allocs4389d6ba.Borrow(cbufferRowLength_allocs)

	var cbufferImageHeight_allocs *cgoAllocMap
	ref4389d6ba.bufferImageHeight, cbufferImageHeight_allocs = (C.uint32_t)(x.BufferImageHeight), cgoAllocsUnknown
	allocs4389d6ba.Borrow(cbufferImageHeight_allocs)

	var cimageSubresource_allocs *cgoAllocMap
	ref4389d6ba.imageSubresource, cimageSubresource_allocs = x.ImageSubresource.PassValue()
	allocs4389d6ba.Borrow(cimageSubresource_allocs)

	var cimageOffset_allocs *cgoAllocMap
	ref4389d6ba.imageOffset, cimageOffset_allocs = x.ImageOffset.PassValue()
	allocs4389d6ba.Borrow(cimageOffset_allocs)

	var cimageExtent_allocs *cgoAllocMap
	ref4389d6ba.imageExtent, cimageExtent_allocs = x.ImageExtent.PassValue()
	allocs4389d6ba.Borrow(cimageExtent_allocs)

	x.ref4389d6ba = ref4389d6ba
	x.allocs4389d6ba = allocs4389d6ba
	return ref4389d6ba, allocs4389d6ba

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferImageCopy2) PassValue() (C.VkBufferImageCopy2KHR, *cgoAllocMap) {
	if x.ref4389d6ba != nil {
		return *x.ref4389d6ba, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferImageCopy2) Deref() {
	if x.ref4389d6ba == nil {
		return
	}
	x.SType = (StructureType)(x.ref4389d6ba.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4389d6ba.pNext))
	x.BufferOffset = (DeviceSize)(x.ref4389d6ba.bufferOffset)
	x.BufferRowLength = (uint32)(x.ref4389d6ba.bufferRowLength)
	x.BufferImageHeight = (uint32)(x.ref4389d6ba.bufferImageHeight)
	x.ImageSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref4389d6ba.imageSubresource))
	x.ImageOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref4389d6ba.imageOffset))
	x.ImageExtent = *NewExtent3DRef(unsafe.Pointer(&x.ref4389d6ba.imageExtent))
}

// allocCopyBufferToImageInfo2Memory allocates memory for type C.VkCopyBufferToImageInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyBufferToImageInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyBufferToImageInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCopyBufferToImageInfo2Value = unsafe.Sizeof([1]C.VkCopyBufferToImageInfo2KHR{})

// unpackSBufferImageCopy2 transforms a sliced Go data structure into plain C format.
func unpackSBufferImageCopy2(x []BufferImageCopy2) (unpacked *C.VkBufferImageCopy2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocBufferImageCopy2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferImageCopy2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferImageCopy2KHR)(h.Data)
	return
}

// packSBufferImageCopy2 reads sliced Go data structure out from plain C format.
func packSBufferImageCopy2(v []BufferImageCopy2, ptr0 *C.VkBufferImageCopy2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferImageCopy2Value]C.VkBufferImageCopy2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferImageCopy2Ref(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CopyBufferToImageInfo2) Ref() *C.VkCopyBufferToImageInfo2KHR {
	if x == nil {
		return nil
	}
	return x.ref212d84cc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CopyBufferToImageInfo2) Free() {
	if x != nil && x.allocs212d84cc != nil {
		x.allocs212d84cc.(*cgoAllocMap).Free()
		x.ref212d84cc = nil
	}
}

// NewCopyBufferToImageInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCopyBufferToImageInfo2Ref(ref unsafe.Pointer) *CopyBufferToImageInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(CopyBufferToImageInfo2)
	obj.ref212d84cc = (*C.VkCopyBufferToImageInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CopyBufferToImageInfo2) PassRef() (*C.VkCopyBufferToImageInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref212d84cc != nil {
		return x.ref212d84cc, nil
	}
	mem212d84cc := allocCopyBufferToImageInfo2Memory(1)
	ref212d84cc := (*C.VkCopyBufferToImageInfo2KHR)(mem212d84cc)
	allocs212d84cc := new(cgoAllocMap)
	allocs212d84cc.Add(mem212d84cc)

	var csType_allocs *cgoAllocMap
	ref212d84cc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs212d84cc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref212d84cc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs212d84cc.Borrow(cpNext_allocs)

	var csrcBuffer_allocs *cgoAllocMap
	ref212d84cc.srcBuffer, csrcBuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.SrcBuffer)), cgoAllocsUnknown
	allocs212d84cc.Borrow(csrcBuffer_allocs)

	var cdstImage_allocs *cgoAllocMap
	ref212d84cc.dstImage, cdstImage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.DstImage)), cgoAllocsUnknown
	allocs212d84cc.Borrow(cdstImage_allocs)

	var cdstImageLayout_allocs *cgoAllocMap
	ref212d84cc.dstImageLayout, cdstImageLayout_allocs = (C.VkImageLayout)(x.DstImageLayout), cgoAllocsUnknown
	allocs212d84cc.Borrow(cdstImageLayout_allocs)

	var cregionCount_allocs *cgoAllocMap
	ref212d84cc.regionCount, cregionCount_allocs = (C.uint32_t)(x.RegionCount), cgoAllocsUnknown
	allocs212d84cc.Borrow(cregionCount_allocs)

	var cpRegions_allocs *cgoAllocMap
	ref212d84cc.pRegions, cpRegions_allocs = unpackSBufferImageCopy2(x.PRegions)
	allocs212d84cc.Borrow(cpRegions_allocs)

	x.ref212d84cc = ref212d84cc
	x.allocs212d84cc = allocs212d84cc
	return ref212d84cc, allocs212d84cc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CopyBufferToImageInfo2) PassValue() (C.VkCopyBufferToImageInfo2KHR, *cgoAllocMap) {
	if x.ref212d84cc != nil {
		return *x.ref212d84cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CopyBufferToImageInfo2) Deref() {
	if x.ref212d84cc == nil {
		return
	}
	x.SType = (StructureType)(x.ref212d84cc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref212d84cc.pNext))
	x.SrcBuffer = *(*Buffer)(unsafe.Pointer(&x.ref212d84cc.srcBuffer))
	x.DstImage = *(*Image)(unsafe.Pointer(&x.ref212d84cc.dstImage))
	x.DstImageLayout = (ImageLayout)(x.ref212d84cc.dstImageLayout)
	x.RegionCount = (uint32)(x.ref212d84cc.regionCount)
	packSBufferImageCopy2(x.PRegions, x.ref212d84cc.pRegions)
}

// allocCopyImageToBufferInfo2Memory allocates memory for type C.VkCopyImageToBufferInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyImageToBufferInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyImageToBufferInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCopyImageToBufferInfo2Value = unsafe.Sizeof([1]C.VkCopyImageToBufferInfo2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CopyImageToBufferInfo2) Ref() *C.VkCopyImageToBufferInfo2KHR {
	if x == nil {
		return nil
	}
	return x.ref82ed488d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CopyImageToBufferInfo2) Free() {
	if x != nil && x.allocs82ed488d != nil {
		x.allocs82ed488d.(*cgoAllocMap).Free()
		x.ref82ed488d = nil
	}
}

// NewCopyImageToBufferInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCopyImageToBufferInfo2Ref(ref unsafe.Pointer) *CopyImageToBufferInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(CopyImageToBufferInfo2)
	obj.ref82ed488d = (*C.VkCopyImageToBufferInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CopyImageToBufferInfo2) PassRef() (*C.VkCopyImageToBufferInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref82ed488d != nil {
		return x.ref82ed488d, nil
	}
	mem82ed488d := allocCopyImageToBufferInfo2Memory(1)
	ref82ed488d := (*C.VkCopyImageToBufferInfo2KHR)(mem82ed488d)
	allocs82ed488d := new(cgoAllocMap)
	allocs82ed488d.Add(mem82ed488d)

	var csType_allocs *cgoAllocMap
	ref82ed488d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs82ed488d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref82ed488d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs82ed488d.Borrow(cpNext_allocs)

	var csrcImage_allocs *cgoAllocMap
	ref82ed488d.srcImage, csrcImage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.SrcImage)), cgoAllocsUnknown
	allocs82ed488d.Borrow(csrcImage_allocs)

	var csrcImageLayout_allocs *cgoAllocMap
	ref82ed488d.srcImageLayout, csrcImageLayout_allocs = (C.VkImageLayout)(x.SrcImageLayout), cgoAllocsUnknown
	allocs82ed488d.Borrow(csrcImageLayout_allocs)

	var cdstBuffer_allocs *cgoAllocMap
	ref82ed488d.dstBuffer, cdstBuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.DstBuffer)), cgoAllocsUnknown
	allocs82ed488d.Borrow(cdstBuffer_allocs)

	var cregionCount_allocs *cgoAllocMap
	ref82ed488d.regionCount, cregionCount_allocs = (C.uint32_t)(x.RegionCount), cgoAllocsUnknown
	allocs82ed488d.Borrow(cregionCount_allocs)

	var cpRegions_allocs *cgoAllocMap
	ref82ed488d.pRegions, cpRegions_allocs = unpackSBufferImageCopy2(x.PRegions)
	allocs82ed488d.Borrow(cpRegions_allocs)

	x.ref82ed488d = ref82ed488d
	x.allocs82ed488d = allocs82ed488d
	return ref82ed488d, allocs82ed488d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CopyImageToBufferInfo2) PassValue() (C.VkCopyImageToBufferInfo2KHR, *cgoAllocMap) {
	if x.ref82ed488d != nil {
		return *x.ref82ed488d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CopyImageToBufferInfo2) Deref() {
	if x.ref82ed488d == nil {
		return
	}
	x.SType = (StructureType)(x.ref82ed488d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref82ed488d.pNext))
	x.SrcImage = *(*Image)(unsafe.Pointer(&x.ref82ed488d.srcImage))
	x.SrcImageLayout = (ImageLayout)(x.ref82ed488d.srcImageLayout)
	x.DstBuffer = *(*Buffer)(unsafe.Pointer(&x.ref82ed488d.dstBuffer))
	x.RegionCount = (uint32)(x.ref82ed488d.regionCount)
	packSBufferImageCopy2(x.PRegions, x.ref82ed488d.pRegions)
}

// allocImageBlit2Memory allocates memory for type C.VkImageBlit2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageBlit2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageBlit2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageBlit2Value = unsafe.Sizeof([1]C.VkImageBlit2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageBlit2) Ref() *C.VkImageBlit2KHR {
	if x == nil {
		return nil
	}
	return x.ref1f0abf1e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageBlit2) Free() {
	if x != nil && x.allocs1f0abf1e != nil {
		x.allocs1f0abf1e.(*cgoAllocMap).Free()
		x.ref1f0abf1e = nil
	}
}

// NewImageBlit2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageBlit2Ref(ref unsafe.Pointer) *ImageBlit2 {
	if ref == nil {
		return nil
	}
	obj := new(ImageBlit2)
	obj.ref1f0abf1e = (*C.VkImageBlit2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageBlit2) PassRef() (*C.VkImageBlit2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1f0abf1e != nil {
		return x.ref1f0abf1e, nil
	}
	mem1f0abf1e := allocImageBlit2Memory(1)
	ref1f0abf1e := (*C.VkImageBlit2KHR)(mem1f0abf1e)
	allocs1f0abf1e := new(cgoAllocMap)
	allocs1f0abf1e.Add(mem1f0abf1e)

	var csType_allocs *cgoAllocMap
	ref1f0abf1e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1f0abf1e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1f0abf1e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1f0abf1e.Borrow(cpNext_allocs)

	var csrcSubresource_allocs *cgoAllocMap
	ref1f0abf1e.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs1f0abf1e.Borrow(csrcSubresource_allocs)

	var csrcOffsets_allocs *cgoAllocMap
	ref1f0abf1e.srcOffsets, csrcOffsets_allocs = unpackA2Offset3D(x.SrcOffsets)
	allocs1f0abf1e.Borrow(csrcOffsets_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref1f0abf1e.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs1f0abf1e.Borrow(cdstSubresource_allocs)

	var cdstOffsets_allocs *cgoAllocMap
	ref1f0abf1e.dstOffsets, cdstOffsets_allocs = unpackA2Offset3D(x.DstOffsets)
	allocs1f0abf1e.Borrow(cdstOffsets_allocs)

	x.ref1f0abf1e = ref1f0abf1e
	x.allocs1f0abf1e = allocs1f0abf1e
	return ref1f0abf1e, allocs1f0abf1e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageBlit2) PassValue() (C.VkImageBlit2KHR, *cgoAllocMap) {
	if x.ref1f0abf1e != nil {
		return *x.ref1f0abf1e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageBlit2) Deref() {
	if x.ref1f0abf1e == nil {
		return
	}
	x.SType = (StructureType)(x.ref1f0abf1e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1f0abf1e.pNext))
	x.SrcSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref1f0abf1e.srcSubresource))
	packA2Offset3D(&x.SrcOffsets, (*[2]C.VkOffset3D)(unsafe.Pointer(&x.ref1f0abf1e.srcOffsets)))
	x.DstSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref1f0abf1e.dstSubresource))
	packA2Offset3D(&x.DstOffsets, (*[2]C.VkOffset3D)(unsafe.Pointer(&x.ref1f0abf1e.dstOffsets)))
}

// allocBlitImageInfo2Memory allocates memory for type C.VkBlitImageInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBlitImageInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBlitImageInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBlitImageInfo2Value = unsafe.Sizeof([1]C.VkBlitImageInfo2KHR{})

// unpackSImageBlit2 transforms a sliced Go data structure into plain C format.
func unpackSImageBlit2(x []ImageBlit2) (unpacked *C.VkImageBlit2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocImageBlit2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageBlit2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageBlit2KHR)(h.Data)
	return
}

// packSImageBlit2 reads sliced Go data structure out from plain C format.
func packSImageBlit2(v []ImageBlit2, ptr0 *C.VkImageBlit2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageBlit2Value]C.VkImageBlit2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageBlit2Ref(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BlitImageInfo2) Ref() *C.VkBlitImageInfo2KHR {
	if x == nil {
		return nil
	}
	return x.ref58d84a0a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BlitImageInfo2) Free() {
	if x != nil && x.allocs58d84a0a != nil {
		x.allocs58d84a0a.(*cgoAllocMap).Free()
		x.ref58d84a0a = nil
	}
}

// NewBlitImageInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBlitImageInfo2Ref(ref unsafe.Pointer) *BlitImageInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(BlitImageInfo2)
	obj.ref58d84a0a = (*C.VkBlitImageInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BlitImageInfo2) PassRef() (*C.VkBlitImageInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref58d84a0a != nil {
		return x.ref58d84a0a, nil
	}
	mem58d84a0a := allocBlitImageInfo2Memory(1)
	ref58d84a0a := (*C.VkBlitImageInfo2KHR)(mem58d84a0a)
	allocs58d84a0a := new(cgoAllocMap)
	allocs58d84a0a.Add(mem58d84a0a)

	var csType_allocs *cgoAllocMap
	ref58d84a0a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs58d84a0a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref58d84a0a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs58d84a0a.Borrow(cpNext_allocs)

	var csrcImage_allocs *cgoAllocMap
	ref58d84a0a.srcImage, csrcImage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.SrcImage)), cgoAllocsUnknown
	allocs58d84a0a.Borrow(csrcImage_allocs)

	var csrcImageLayout_allocs *cgoAllocMap
	ref58d84a0a.srcImageLayout, csrcImageLayout_allocs = (C.VkImageLayout)(x.SrcImageLayout), cgoAllocsUnknown
	allocs58d84a0a.Borrow(csrcImageLayout_allocs)

	var cdstImage_allocs *cgoAllocMap
	ref58d84a0a.dstImage, cdstImage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.DstImage)), cgoAllocsUnknown
	allocs58d84a0a.Borrow(cdstImage_allocs)

	var cdstImageLayout_allocs *cgoAllocMap
	ref58d84a0a.dstImageLayout, cdstImageLayout_allocs = (C.VkImageLayout)(x.DstImageLayout), cgoAllocsUnknown
	allocs58d84a0a.Borrow(cdstImageLayout_allocs)

	var cregionCount_allocs *cgoAllocMap
	ref58d84a0a.regionCount, cregionCount_allocs = (C.uint32_t)(x.RegionCount), cgoAllocsUnknown
	allocs58d84a0a.Borrow(cregionCount_allocs)

	var cpRegions_allocs *cgoAllocMap
	ref58d84a0a.pRegions, cpRegions_allocs = unpackSImageBlit2(x.PRegions)
	allocs58d84a0a.Borrow(cpRegions_allocs)

	var cfilter_allocs *cgoAllocMap
	ref58d84a0a.filter, cfilter_allocs = (C.VkFilter)(x.Filter), cgoAllocsUnknown
	allocs58d84a0a.Borrow(cfilter_allocs)

	x.ref58d84a0a = ref58d84a0a
	x.allocs58d84a0a = allocs58d84a0a
	return ref58d84a0a, allocs58d84a0a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BlitImageInfo2) PassValue() (C.VkBlitImageInfo2KHR, *cgoAllocMap) {
	if x.ref58d84a0a != nil {
		return *x.ref58d84a0a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BlitImageInfo2) Deref() {
	if x.ref58d84a0a == nil {
		return
	}
	x.SType = (StructureType)(x.ref58d84a0a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref58d84a0a.pNext))
	x.SrcImage = *(*Image)(unsafe.Pointer(&x.ref58d84a0a.srcImage))
	x.SrcImageLayout = (ImageLayout)(x.ref58d84a0a.srcImageLayout)
	x.DstImage = *(*Image)(unsafe.Pointer(&x.ref58d84a0a.dstImage))
	x.DstImageLayout = (ImageLayout)(x.ref58d84a0a.dstImageLayout)
	x.RegionCount = (uint32)(x.ref58d84a0a.regionCount)
	packSImageBlit2(x.PRegions, x.ref58d84a0a.pRegions)
	x.Filter = (Filter)(x.ref58d84a0a.filter)
}

// allocImageResolve2Memory allocates memory for type C.VkImageResolve2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageResolve2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageResolve2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageResolve2Value = unsafe.Sizeof([1]C.VkImageResolve2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageResolve2) Ref() *C.VkImageResolve2KHR {
	if x == nil {
		return nil
	}
	return x.ref28de0b56
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageResolve2) Free() {
	if x != nil && x.allocs28de0b56 != nil {
		x.allocs28de0b56.(*cgoAllocMap).Free()
		x.ref28de0b56 = nil
	}
}

// NewImageResolve2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageResolve2Ref(ref unsafe.Pointer) *ImageResolve2 {
	if ref == nil {
		return nil
	}
	obj := new(ImageResolve2)
	obj.ref28de0b56 = (*C.VkImageResolve2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageResolve2) PassRef() (*C.VkImageResolve2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref28de0b56 != nil {
		return x.ref28de0b56, nil
	}
	mem28de0b56 := allocImageResolve2Memory(1)
	ref28de0b56 := (*C.VkImageResolve2KHR)(mem28de0b56)
	allocs28de0b56 := new(cgoAllocMap)
	allocs28de0b56.Add(mem28de0b56)

	var csType_allocs *cgoAllocMap
	ref28de0b56.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs28de0b56.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref28de0b56.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs28de0b56.Borrow(cpNext_allocs)

	var csrcSubresource_allocs *cgoAllocMap
	ref28de0b56.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs28de0b56.Borrow(csrcSubresource_allocs)

	var csrcOffset_allocs *cgoAllocMap
	ref28de0b56.srcOffset, csrcOffset_allocs = x.SrcOffset.PassValue()
	allocs28de0b56.Borrow(csrcOffset_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref28de0b56.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs28de0b56.Borrow(cdstSubresource_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref28de0b56.dstOffset, cdstOffset_allocs = x.DstOffset.PassValue()
	allocs28de0b56.Borrow(cdstOffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref28de0b56.extent, cextent_allocs = x.Extent.PassValue()
	allocs28de0b56.Borrow(cextent_allocs)

	x.ref28de0b56 = ref28de0b56
	x.allocs28de0b56 = allocs28de0b56
	return ref28de0b56, allocs28de0b56

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageResolve2) PassValue() (C.VkImageResolve2KHR, *cgoAllocMap) {
	if x.ref28de0b56 != nil {
		return *x.ref28de0b56, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageResolve2) Deref() {
	if x.ref28de0b56 == nil {
		return
	}
	x.SType = (StructureType)(x.ref28de0b56.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref28de0b56.pNext))
	x.SrcSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref28de0b56.srcSubresource))
	x.SrcOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref28de0b56.srcOffset))
	x.DstSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref28de0b56.dstSubresource))
	x.DstOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref28de0b56.dstOffset))
	x.Extent = *NewExtent3DRef(unsafe.Pointer(&x.ref28de0b56.extent))
}

// allocResolveImageInfo2Memory allocates memory for type C.VkResolveImageInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResolveImageInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResolveImageInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResolveImageInfo2Value = unsafe.Sizeof([1]C.VkResolveImageInfo2KHR{})

// unpackSImageResolve2 transforms a sliced Go data structure into plain C format.
func unpackSImageResolve2(x []ImageResolve2) (unpacked *C.VkImageResolve2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocImageResolve2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageResolve2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageResolve2KHR)(h.Data)
	return
}

// packSImageResolve2 reads sliced Go data structure out from plain C format.
func packSImageResolve2(v []ImageResolve2, ptr0 *C.VkImageResolve2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageResolve2Value]C.VkImageResolve2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageResolve2Ref(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResolveImageInfo2) Ref() *C.VkResolveImageInfo2KHR {
	if x == nil {
		return nil
	}
	return x.ref61acb603
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResolveImageInfo2) Free() {
	if x != nil && x.allocs61acb603 != nil {
		x.allocs61acb603.(*cgoAllocMap).Free()
		x.ref61acb603 = nil
	}
}

// NewResolveImageInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResolveImageInfo2Ref(ref unsafe.Pointer) *ResolveImageInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(ResolveImageInfo2)
	obj.ref61acb603 = (*C.VkResolveImageInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResolveImageInfo2) PassRef() (*C.VkResolveImageInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref61acb603 != nil {
		return x.ref61acb603, nil
	}
	mem61acb603 := allocResolveImageInfo2Memory(1)
	ref61acb603 := (*C.VkResolveImageInfo2KHR)(mem61acb603)
	allocs61acb603 := new(cgoAllocMap)
	allocs61acb603.Add(mem61acb603)

	var csType_allocs *cgoAllocMap
	ref61acb603.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs61acb603.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref61acb603.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs61acb603.Borrow(cpNext_allocs)

	var csrcImage_allocs *cgoAllocMap
	ref61acb603.srcImage, csrcImage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.SrcImage)), cgoAllocsUnknown
	allocs61acb603.Borrow(csrcImage_allocs)

	var csrcImageLayout_allocs *cgoAllocMap
	ref61acb603.srcImageLayout, csrcImageLayout_allocs = (C.VkImageLayout)(x.SrcImageLayout), cgoAllocsUnknown
	allocs61acb603.Borrow(csrcImageLayout_allocs)

	var cdstImage_allocs *cgoAllocMap
	ref61acb603.dstImage, cdstImage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.DstImage)), cgoAllocsUnknown
	allocs61acb603.Borrow(cdstImage_allocs)

	var cdstImageLayout_allocs *cgoAllocMap
	ref61acb603.dstImageLayout, cdstImageLayout_allocs = (C.VkImageLayout)(x.DstImageLayout), cgoAllocsUnknown
	allocs61acb603.Borrow(cdstImageLayout_allocs)

	var cregionCount_allocs *cgoAllocMap
	ref61acb603.regionCount, cregionCount_allocs = (C.uint32_t)(x.RegionCount), cgoAllocsUnknown
	allocs61acb603.Borrow(cregionCount_allocs)

	var cpRegions_allocs *cgoAllocMap
	ref61acb603.pRegions, cpRegions_allocs = unpackSImageResolve2(x.PRegions)
	allocs61acb603.Borrow(cpRegions_allocs)

	x.ref61acb603 = ref61acb603
	x.allocs61acb603 = allocs61acb603
	return ref61acb603, allocs61acb603

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResolveImageInfo2) PassValue() (C.VkResolveImageInfo2KHR, *cgoAllocMap) {
	if x.ref61acb603 != nil {
		return *x.ref61acb603, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResolveImageInfo2) Deref() {
	if x.ref61acb603 == nil {
		return
	}
	x.SType = (StructureType)(x.ref61acb603.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref61acb603.pNext))
	x.SrcImage = *(*Image)(unsafe.Pointer(&x.ref61acb603.srcImage))
	x.SrcImageLayout = (ImageLayout)(x.ref61acb603.srcImageLayout)
	x.DstImage = *(*Image)(unsafe.Pointer(&x.ref61acb603.dstImage))
	x.DstImageLayout = (ImageLayout)(x.ref61acb603.dstImageLayout)
	x.RegionCount = (uint32)(x.ref61acb603.regionCount)
	packSImageResolve2(x.PRegions, x.ref61acb603.pRegions)
}

func (x DebugReportCallbackFunc) PassRef() (ref *C.PFN_vkDebugReportCallbackEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if debugReportCallbackFuncC918AAC4Func == nil {
		debugReportCallbackFuncC918AAC4Func = x
	}
	return (*C.PFN_vkDebugReportCallbackEXT)(C.PFN_vkDebugReportCallbackEXT_c918aac4), nil
}

func (x DebugReportCallbackFunc) PassValue() (ref C.PFN_vkDebugReportCallbackEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if debugReportCallbackFuncC918AAC4Func == nil {
		debugReportCallbackFuncC918AAC4Func = x
	}
	return (C.PFN_vkDebugReportCallbackEXT)(C.PFN_vkDebugReportCallbackEXT_c918aac4), nil
}

func NewDebugReportCallbackFuncRef(ref unsafe.Pointer) *DebugReportCallbackFunc {
	return (*DebugReportCallbackFunc)(ref)
}

//export debugReportCallbackFuncC918AAC4
func debugReportCallbackFuncC918AAC4(cflags C.VkDebugReportFlagsEXT, cobjectType C.VkDebugReportObjectTypeEXT, cobject C.uint64_t, clocation C.size_t, cmessageCode C.int32_t, cpLayerPrefix *C.char, cpMessage *C.char, cpUserData unsafe.Pointer) C.VkBool32 {
	if debugReportCallbackFuncC918AAC4Func != nil {
		flagsc918aac4 := (DebugReportFlags)(cflags)
		objectTypec918aac4 := (DebugReportObjectType)(cobjectType)
		objectc918aac4 := (uint32)(cobject)
		locationc918aac4 := (uint32)(clocation)
		messageCodec918aac4 := (int32)(cmessageCode)
		pLayerPrefixc918aac4 := packPCharString(cpLayerPrefix)
		pMessagec918aac4 := packPCharString(cpMessage)
		pUserDatac918aac4 := (unsafe.Pointer)(unsafe.Pointer(cpUserData))
		retc918aac4 := debugReportCallbackFuncC918AAC4Func(flagsc918aac4, objectTypec918aac4, objectc918aac4, locationc918aac4, messageCodec918aac4, pLayerPrefixc918aac4, pMessagec918aac4, pUserDatac918aac4)
		ret, _ := (C.VkBool32)(retc918aac4), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var debugReportCallbackFuncC918AAC4Func DebugReportCallbackFunc

// allocDebugReportCallbackCreateInfoMemory allocates memory for type C.VkDebugReportCallbackCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugReportCallbackCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugReportCallbackCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDebugReportCallbackCreateInfoValue = unsafe.Sizeof([1]C.VkDebugReportCallbackCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugReportCallbackCreateInfo) Ref() *C.VkDebugReportCallbackCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refc8238563
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugReportCallbackCreateInfo) Free() {
	if x != nil && x.allocsc8238563 != nil {
		x.allocsc8238563.(*cgoAllocMap).Free()
		x.refc8238563 = nil
	}
}

// NewDebugReportCallbackCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugReportCallbackCreateInfoRef(ref unsafe.Pointer) *DebugReportCallbackCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DebugReportCallbackCreateInfo)
	obj.refc8238563 = (*C.VkDebugReportCallbackCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugReportCallbackCreateInfo) PassRef() (*C.VkDebugReportCallbackCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc8238563 != nil {
		return x.refc8238563, nil
	}
	memc8238563 := allocDebugReportCallbackCreateInfoMemory(1)
	refc8238563 := (*C.VkDebugReportCallbackCreateInfoEXT)(memc8238563)
	allocsc8238563 := new(cgoAllocMap)
	allocsc8238563.Add(memc8238563)

	var csType_allocs *cgoAllocMap
	refc8238563.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc8238563.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc8238563.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc8238563.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc8238563.flags, cflags_allocs = (C.VkDebugReportFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocsc8238563.Borrow(cflags_allocs)

	var cpfnCallback_allocs *cgoAllocMap
	refc8238563.pfnCallback, cpfnCallback_allocs = x.PfnCallback.PassValue()
	allocsc8238563.Borrow(cpfnCallback_allocs)

	var cpUserData_allocs *cgoAllocMap
	refc8238563.pUserData, cpUserData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PUserData)), cgoAllocsUnknown
	allocsc8238563.Borrow(cpUserData_allocs)

	x.refc8238563 = refc8238563
	x.allocsc8238563 = allocsc8238563
	return refc8238563, allocsc8238563

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugReportCallbackCreateInfo) PassValue() (C.VkDebugReportCallbackCreateInfoEXT, *cgoAllocMap) {
	if x.refc8238563 != nil {
		return *x.refc8238563, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugReportCallbackCreateInfo) Deref() {
	if x.refc8238563 == nil {
		return
	}
	x.SType = (StructureType)(x.refc8238563.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc8238563.pNext))
	x.Flags = (DebugReportFlags)(x.refc8238563.flags)
	x.PfnCallback = *NewDebugReportCallbackFuncRef(unsafe.Pointer(&x.refc8238563.pfnCallback))
	x.PUserData = (unsafe.Pointer)(unsafe.Pointer(x.refc8238563.pUserData))
}

// allocPipelineRasterizationStateRasterizationOrderAMDMemory allocates memory for type C.VkPipelineRasterizationStateRasterizationOrderAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationStateRasterizationOrderAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationStateRasterizationOrderAMDValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineRasterizationStateRasterizationOrderAMDValue = unsafe.Sizeof([1]C.VkPipelineRasterizationStateRasterizationOrderAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRasterizationStateRasterizationOrderAMD) Ref() *C.VkPipelineRasterizationStateRasterizationOrderAMD {
	if x == nil {
		return nil
	}
	return x.ref5098cf82
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRasterizationStateRasterizationOrderAMD) Free() {
	if x != nil && x.allocs5098cf82 != nil {
		x.allocs5098cf82.(*cgoAllocMap).Free()
		x.ref5098cf82 = nil
	}
}

// NewPipelineRasterizationStateRasterizationOrderAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRasterizationStateRasterizationOrderAMDRef(ref unsafe.Pointer) *PipelineRasterizationStateRasterizationOrderAMD {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRasterizationStateRasterizationOrderAMD)
	obj.ref5098cf82 = (*C.VkPipelineRasterizationStateRasterizationOrderAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRasterizationStateRasterizationOrderAMD) PassRef() (*C.VkPipelineRasterizationStateRasterizationOrderAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5098cf82 != nil {
		return x.ref5098cf82, nil
	}
	mem5098cf82 := allocPipelineRasterizationStateRasterizationOrderAMDMemory(1)
	ref5098cf82 := (*C.VkPipelineRasterizationStateRasterizationOrderAMD)(mem5098cf82)
	allocs5098cf82 := new(cgoAllocMap)
	allocs5098cf82.Add(mem5098cf82)

	var csType_allocs *cgoAllocMap
	ref5098cf82.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5098cf82.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5098cf82.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5098cf82.Borrow(cpNext_allocs)

	var crasterizationOrder_allocs *cgoAllocMap
	ref5098cf82.rasterizationOrder, crasterizationOrder_allocs = (C.VkRasterizationOrderAMD)(x.RasterizationOrder), cgoAllocsUnknown
	allocs5098cf82.Borrow(crasterizationOrder_allocs)

	x.ref5098cf82 = ref5098cf82
	x.allocs5098cf82 = allocs5098cf82
	return ref5098cf82, allocs5098cf82

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRasterizationStateRasterizationOrderAMD) PassValue() (C.VkPipelineRasterizationStateRasterizationOrderAMD, *cgoAllocMap) {
	if x.ref5098cf82 != nil {
		return *x.ref5098cf82, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRasterizationStateRasterizationOrderAMD) Deref() {
	if x.ref5098cf82 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5098cf82.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5098cf82.pNext))
	x.RasterizationOrder = (RasterizationOrderAMD)(x.ref5098cf82.rasterizationOrder)
}

// allocDebugMarkerObjectNameInfoMemory allocates memory for type C.VkDebugMarkerObjectNameInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerObjectNameInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerObjectNameInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDebugMarkerObjectNameInfoValue = unsafe.Sizeof([1]C.VkDebugMarkerObjectNameInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugMarkerObjectNameInfo) Ref() *C.VkDebugMarkerObjectNameInfoEXT {
	if x == nil {
		return nil
	}
	return x.refe4983fab
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugMarkerObjectNameInfo) Free() {
	if x != nil && x.allocse4983fab != nil {
		x.allocse4983fab.(*cgoAllocMap).Free()
		x.refe4983fab = nil
	}
}

// NewDebugMarkerObjectNameInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugMarkerObjectNameInfoRef(ref unsafe.Pointer) *DebugMarkerObjectNameInfo {
	if ref == nil {
		return nil
	}
	obj := new(DebugMarkerObjectNameInfo)
	obj.refe4983fab = (*C.VkDebugMarkerObjectNameInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugMarkerObjectNameInfo) PassRef() (*C.VkDebugMarkerObjectNameInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe4983fab != nil {
		return x.refe4983fab, nil
	}
	meme4983fab := allocDebugMarkerObjectNameInfoMemory(1)
	refe4983fab := (*C.VkDebugMarkerObjectNameInfoEXT)(meme4983fab)
	allocse4983fab := new(cgoAllocMap)
	allocse4983fab.Add(meme4983fab)

	var csType_allocs *cgoAllocMap
	refe4983fab.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse4983fab.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe4983fab.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse4983fab.Borrow(cpNext_allocs)

	var cobjectType_allocs *cgoAllocMap
	refe4983fab.objectType, cobjectType_allocs = (C.VkDebugReportObjectTypeEXT)(x.ObjectType), cgoAllocsUnknown
	allocse4983fab.Borrow(cobjectType_allocs)

	var cobject_allocs *cgoAllocMap
	refe4983fab.object, cobject_allocs = (C.uint64_t)(x.Object), cgoAllocsUnknown
	allocse4983fab.Borrow(cobject_allocs)

	var cpObjectName_allocs *cgoAllocMap
	refe4983fab.pObjectName, cpObjectName_allocs = unpackPCharString(x.PObjectName)
	allocse4983fab.Borrow(cpObjectName_allocs)

	x.refe4983fab = refe4983fab
	x.allocse4983fab = allocse4983fab
	return refe4983fab, allocse4983fab

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugMarkerObjectNameInfo) PassValue() (C.VkDebugMarkerObjectNameInfoEXT, *cgoAllocMap) {
	if x.refe4983fab != nil {
		return *x.refe4983fab, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugMarkerObjectNameInfo) Deref() {
	if x.refe4983fab == nil {
		return
	}
	x.SType = (StructureType)(x.refe4983fab.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe4983fab.pNext))
	x.ObjectType = (DebugReportObjectType)(x.refe4983fab.objectType)
	x.Object = (uint32)(x.refe4983fab.object)
	x.PObjectName = packPCharString(x.refe4983fab.pObjectName)
}

// allocDebugMarkerObjectTagInfoMemory allocates memory for type C.VkDebugMarkerObjectTagInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerObjectTagInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerObjectTagInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDebugMarkerObjectTagInfoValue = unsafe.Sizeof([1]C.VkDebugMarkerObjectTagInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugMarkerObjectTagInfo) Ref() *C.VkDebugMarkerObjectTagInfoEXT {
	if x == nil {
		return nil
	}
	return x.refa41a5c3b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugMarkerObjectTagInfo) Free() {
	if x != nil && x.allocsa41a5c3b != nil {
		x.allocsa41a5c3b.(*cgoAllocMap).Free()
		x.refa41a5c3b = nil
	}
}

// NewDebugMarkerObjectTagInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugMarkerObjectTagInfoRef(ref unsafe.Pointer) *DebugMarkerObjectTagInfo {
	if ref == nil {
		return nil
	}
	obj := new(DebugMarkerObjectTagInfo)
	obj.refa41a5c3b = (*C.VkDebugMarkerObjectTagInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugMarkerObjectTagInfo) PassRef() (*C.VkDebugMarkerObjectTagInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa41a5c3b != nil {
		return x.refa41a5c3b, nil
	}
	mema41a5c3b := allocDebugMarkerObjectTagInfoMemory(1)
	refa41a5c3b := (*C.VkDebugMarkerObjectTagInfoEXT)(mema41a5c3b)
	allocsa41a5c3b := new(cgoAllocMap)
	allocsa41a5c3b.Add(mema41a5c3b)

	var csType_allocs *cgoAllocMap
	refa41a5c3b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa41a5c3b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cpNext_allocs)

	var cobjectType_allocs *cgoAllocMap
	refa41a5c3b.objectType, cobjectType_allocs = (C.VkDebugReportObjectTypeEXT)(x.ObjectType), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cobjectType_allocs)

	var cobject_allocs *cgoAllocMap
	refa41a5c3b.object, cobject_allocs = (C.uint64_t)(x.Object), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cobject_allocs)

	var ctagName_allocs *cgoAllocMap
	refa41a5c3b.tagName, ctagName_allocs = (C.uint64_t)(x.TagName), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(ctagName_allocs)

	var ctagSize_allocs *cgoAllocMap
	refa41a5c3b.tagSize, ctagSize_allocs = (C.size_t)(x.TagSize), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(ctagSize_allocs)

	var cpTag_allocs *cgoAllocMap
	refa41a5c3b.pTag, cpTag_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PTag)), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cpTag_allocs)

	x.refa41a5c3b = refa41a5c3b
	x.allocsa41a5c3b = allocsa41a5c3b
	return refa41a5c3b, allocsa41a5c3b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugMarkerObjectTagInfo) PassValue() (C.VkDebugMarkerObjectTagInfoEXT, *cgoAllocMap) {
	if x.refa41a5c3b != nil {
		return *x.refa41a5c3b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugMarkerObjectTagInfo) Deref() {
	if x.refa41a5c3b == nil {
		return
	}
	x.SType = (StructureType)(x.refa41a5c3b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa41a5c3b.pNext))
	x.ObjectType = (DebugReportObjectType)(x.refa41a5c3b.objectType)
	x.Object = (uint32)(x.refa41a5c3b.object)
	x.TagName = (uint32)(x.refa41a5c3b.tagName)
	x.TagSize = (uint32)(x.refa41a5c3b.tagSize)
	x.PTag = (unsafe.Pointer)(unsafe.Pointer(x.refa41a5c3b.pTag))
}

// allocDebugMarkerMarkerInfoMemory allocates memory for type C.VkDebugMarkerMarkerInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerMarkerInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerMarkerInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDebugMarkerMarkerInfoValue = unsafe.Sizeof([1]C.VkDebugMarkerMarkerInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugMarkerMarkerInfo) Ref() *C.VkDebugMarkerMarkerInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref234b91fd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugMarkerMarkerInfo) Free() {
	if x != nil && x.allocs234b91fd != nil {
		x.allocs234b91fd.(*cgoAllocMap).Free()
		x.ref234b91fd = nil
	}
}

// NewDebugMarkerMarkerInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugMarkerMarkerInfoRef(ref unsafe.Pointer) *DebugMarkerMarkerInfo {
	if ref == nil {
		return nil
	}
	obj := new(DebugMarkerMarkerInfo)
	obj.ref234b91fd = (*C.VkDebugMarkerMarkerInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugMarkerMarkerInfo) PassRef() (*C.VkDebugMarkerMarkerInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref234b91fd != nil {
		return x.ref234b91fd, nil
	}
	mem234b91fd := allocDebugMarkerMarkerInfoMemory(1)
	ref234b91fd := (*C.VkDebugMarkerMarkerInfoEXT)(mem234b91fd)
	allocs234b91fd := new(cgoAllocMap)
	allocs234b91fd.Add(mem234b91fd)

	var csType_allocs *cgoAllocMap
	ref234b91fd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs234b91fd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref234b91fd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs234b91fd.Borrow(cpNext_allocs)

	var cpMarkerName_allocs *cgoAllocMap
	ref234b91fd.pMarkerName, cpMarkerName_allocs = unpackPCharString(x.PMarkerName)
	allocs234b91fd.Borrow(cpMarkerName_allocs)

	var ccolor_allocs *cgoAllocMap
	ref234b91fd.color, ccolor_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Color)), cgoAllocsUnknown
	allocs234b91fd.Borrow(ccolor_allocs)

	x.ref234b91fd = ref234b91fd
	x.allocs234b91fd = allocs234b91fd
	return ref234b91fd, allocs234b91fd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugMarkerMarkerInfo) PassValue() (C.VkDebugMarkerMarkerInfoEXT, *cgoAllocMap) {
	if x.ref234b91fd != nil {
		return *x.ref234b91fd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugMarkerMarkerInfo) Deref() {
	if x.ref234b91fd == nil {
		return
	}
	x.SType = (StructureType)(x.ref234b91fd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref234b91fd.pNext))
	x.PMarkerName = packPCharString(x.ref234b91fd.pMarkerName)
	x.Color = *(*[4]float32)(unsafe.Pointer(&x.ref234b91fd.color))
}

// allocDedicatedAllocationImageCreateInfoNVMemory allocates memory for type C.VkDedicatedAllocationImageCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDedicatedAllocationImageCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDedicatedAllocationImageCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDedicatedAllocationImageCreateInfoNVValue = unsafe.Sizeof([1]C.VkDedicatedAllocationImageCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DedicatedAllocationImageCreateInfoNV) Ref() *C.VkDedicatedAllocationImageCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref685d878b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DedicatedAllocationImageCreateInfoNV) Free() {
	if x != nil && x.allocs685d878b != nil {
		x.allocs685d878b.(*cgoAllocMap).Free()
		x.ref685d878b = nil
	}
}

// NewDedicatedAllocationImageCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDedicatedAllocationImageCreateInfoNVRef(ref unsafe.Pointer) *DedicatedAllocationImageCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(DedicatedAllocationImageCreateInfoNV)
	obj.ref685d878b = (*C.VkDedicatedAllocationImageCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DedicatedAllocationImageCreateInfoNV) PassRef() (*C.VkDedicatedAllocationImageCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref685d878b != nil {
		return x.ref685d878b, nil
	}
	mem685d878b := allocDedicatedAllocationImageCreateInfoNVMemory(1)
	ref685d878b := (*C.VkDedicatedAllocationImageCreateInfoNV)(mem685d878b)
	allocs685d878b := new(cgoAllocMap)
	allocs685d878b.Add(mem685d878b)

	var csType_allocs *cgoAllocMap
	ref685d878b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs685d878b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref685d878b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs685d878b.Borrow(cpNext_allocs)

	var cdedicatedAllocation_allocs *cgoAllocMap
	ref685d878b.dedicatedAllocation, cdedicatedAllocation_allocs = (C.VkBool32)(x.DedicatedAllocation), cgoAllocsUnknown
	allocs685d878b.Borrow(cdedicatedAllocation_allocs)

	x.ref685d878b = ref685d878b
	x.allocs685d878b = allocs685d878b
	return ref685d878b, allocs685d878b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DedicatedAllocationImageCreateInfoNV) PassValue() (C.VkDedicatedAllocationImageCreateInfoNV, *cgoAllocMap) {
	if x.ref685d878b != nil {
		return *x.ref685d878b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DedicatedAllocationImageCreateInfoNV) Deref() {
	if x.ref685d878b == nil {
		return
	}
	x.SType = (StructureType)(x.ref685d878b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref685d878b.pNext))
	x.DedicatedAllocation = (Bool32)(x.ref685d878b.dedicatedAllocation)
}

// allocDedicatedAllocationBufferCreateInfoNVMemory allocates memory for type C.VkDedicatedAllocationBufferCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDedicatedAllocationBufferCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDedicatedAllocationBufferCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDedicatedAllocationBufferCreateInfoNVValue = unsafe.Sizeof([1]C.VkDedicatedAllocationBufferCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DedicatedAllocationBufferCreateInfoNV) Ref() *C.VkDedicatedAllocationBufferCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refbc745a8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DedicatedAllocationBufferCreateInfoNV) Free() {
	if x != nil && x.allocsbc745a8 != nil {
		x.allocsbc745a8.(*cgoAllocMap).Free()
		x.refbc745a8 = nil
	}
}

// NewDedicatedAllocationBufferCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDedicatedAllocationBufferCreateInfoNVRef(ref unsafe.Pointer) *DedicatedAllocationBufferCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(DedicatedAllocationBufferCreateInfoNV)
	obj.refbc745a8 = (*C.VkDedicatedAllocationBufferCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DedicatedAllocationBufferCreateInfoNV) PassRef() (*C.VkDedicatedAllocationBufferCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbc745a8 != nil {
		return x.refbc745a8, nil
	}
	membc745a8 := allocDedicatedAllocationBufferCreateInfoNVMemory(1)
	refbc745a8 := (*C.VkDedicatedAllocationBufferCreateInfoNV)(membc745a8)
	allocsbc745a8 := new(cgoAllocMap)
	allocsbc745a8.Add(membc745a8)

	var csType_allocs *cgoAllocMap
	refbc745a8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbc745a8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbc745a8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbc745a8.Borrow(cpNext_allocs)

	var cdedicatedAllocation_allocs *cgoAllocMap
	refbc745a8.dedicatedAllocation, cdedicatedAllocation_allocs = (C.VkBool32)(x.DedicatedAllocation), cgoAllocsUnknown
	allocsbc745a8.Borrow(cdedicatedAllocation_allocs)

	x.refbc745a8 = refbc745a8
	x.allocsbc745a8 = allocsbc745a8
	return refbc745a8, allocsbc745a8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DedicatedAllocationBufferCreateInfoNV) PassValue() (C.VkDedicatedAllocationBufferCreateInfoNV, *cgoAllocMap) {
	if x.refbc745a8 != nil {
		return *x.refbc745a8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DedicatedAllocationBufferCreateInfoNV) Deref() {
	if x.refbc745a8 == nil {
		return
	}
	x.SType = (StructureType)(x.refbc745a8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbc745a8.pNext))
	x.DedicatedAllocation = (Bool32)(x.refbc745a8.dedicatedAllocation)
}

// allocDedicatedAllocationMemoryAllocateInfoNVMemory allocates memory for type C.VkDedicatedAllocationMemoryAllocateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDedicatedAllocationMemoryAllocateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDedicatedAllocationMemoryAllocateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDedicatedAllocationMemoryAllocateInfoNVValue = unsafe.Sizeof([1]C.VkDedicatedAllocationMemoryAllocateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DedicatedAllocationMemoryAllocateInfoNV) Ref() *C.VkDedicatedAllocationMemoryAllocateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref9a72b107
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DedicatedAllocationMemoryAllocateInfoNV) Free() {
	if x != nil && x.allocs9a72b107 != nil {
		x.allocs9a72b107.(*cgoAllocMap).Free()
		x.ref9a72b107 = nil
	}
}

// NewDedicatedAllocationMemoryAllocateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDedicatedAllocationMemoryAllocateInfoNVRef(ref unsafe.Pointer) *DedicatedAllocationMemoryAllocateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(DedicatedAllocationMemoryAllocateInfoNV)
	obj.ref9a72b107 = (*C.VkDedicatedAllocationMemoryAllocateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DedicatedAllocationMemoryAllocateInfoNV) PassRef() (*C.VkDedicatedAllocationMemoryAllocateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9a72b107 != nil {
		return x.ref9a72b107, nil
	}
	mem9a72b107 := allocDedicatedAllocationMemoryAllocateInfoNVMemory(1)
	ref9a72b107 := (*C.VkDedicatedAllocationMemoryAllocateInfoNV)(mem9a72b107)
	allocs9a72b107 := new(cgoAllocMap)
	allocs9a72b107.Add(mem9a72b107)

	var csType_allocs *cgoAllocMap
	ref9a72b107.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9a72b107.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9a72b107.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9a72b107.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	ref9a72b107.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs9a72b107.Borrow(cimage_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref9a72b107.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs9a72b107.Borrow(cbuffer_allocs)

	x.ref9a72b107 = ref9a72b107
	x.allocs9a72b107 = allocs9a72b107
	return ref9a72b107, allocs9a72b107

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DedicatedAllocationMemoryAllocateInfoNV) PassValue() (C.VkDedicatedAllocationMemoryAllocateInfoNV, *cgoAllocMap) {
	if x.ref9a72b107 != nil {
		return *x.ref9a72b107, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DedicatedAllocationMemoryAllocateInfoNV) Deref() {
	if x.ref9a72b107 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9a72b107.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9a72b107.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref9a72b107.image))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref9a72b107.buffer))
}

// allocPhysicalDeviceTransformFeedbackFeaturesMemory allocates memory for type C.VkPhysicalDeviceTransformFeedbackFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceTransformFeedbackFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceTransformFeedbackFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceTransformFeedbackFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceTransformFeedbackFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceTransformFeedbackFeatures) Ref() *C.VkPhysicalDeviceTransformFeedbackFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref64b2a913
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceTransformFeedbackFeatures) Free() {
	if x != nil && x.allocs64b2a913 != nil {
		x.allocs64b2a913.(*cgoAllocMap).Free()
		x.ref64b2a913 = nil
	}
}

// NewPhysicalDeviceTransformFeedbackFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceTransformFeedbackFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceTransformFeedbackFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceTransformFeedbackFeatures)
	obj.ref64b2a913 = (*C.VkPhysicalDeviceTransformFeedbackFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceTransformFeedbackFeatures) PassRef() (*C.VkPhysicalDeviceTransformFeedbackFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref64b2a913 != nil {
		return x.ref64b2a913, nil
	}
	mem64b2a913 := allocPhysicalDeviceTransformFeedbackFeaturesMemory(1)
	ref64b2a913 := (*C.VkPhysicalDeviceTransformFeedbackFeaturesEXT)(mem64b2a913)
	allocs64b2a913 := new(cgoAllocMap)
	allocs64b2a913.Add(mem64b2a913)

	var csType_allocs *cgoAllocMap
	ref64b2a913.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs64b2a913.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref64b2a913.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs64b2a913.Borrow(cpNext_allocs)

	var ctransformFeedback_allocs *cgoAllocMap
	ref64b2a913.transformFeedback, ctransformFeedback_allocs = (C.VkBool32)(x.TransformFeedback), cgoAllocsUnknown
	allocs64b2a913.Borrow(ctransformFeedback_allocs)

	var cgeometryStreams_allocs *cgoAllocMap
	ref64b2a913.geometryStreams, cgeometryStreams_allocs = (C.VkBool32)(x.GeometryStreams), cgoAllocsUnknown
	allocs64b2a913.Borrow(cgeometryStreams_allocs)

	x.ref64b2a913 = ref64b2a913
	x.allocs64b2a913 = allocs64b2a913
	return ref64b2a913, allocs64b2a913

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceTransformFeedbackFeatures) PassValue() (C.VkPhysicalDeviceTransformFeedbackFeaturesEXT, *cgoAllocMap) {
	if x.ref64b2a913 != nil {
		return *x.ref64b2a913, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceTransformFeedbackFeatures) Deref() {
	if x.ref64b2a913 == nil {
		return
	}
	x.SType = (StructureType)(x.ref64b2a913.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref64b2a913.pNext))
	x.TransformFeedback = (Bool32)(x.ref64b2a913.transformFeedback)
	x.GeometryStreams = (Bool32)(x.ref64b2a913.geometryStreams)
}

// allocPhysicalDeviceTransformFeedbackPropertiesMemory allocates memory for type C.VkPhysicalDeviceTransformFeedbackPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceTransformFeedbackPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceTransformFeedbackPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceTransformFeedbackPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceTransformFeedbackPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceTransformFeedbackProperties) Ref() *C.VkPhysicalDeviceTransformFeedbackPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refc295a2a0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceTransformFeedbackProperties) Free() {
	if x != nil && x.allocsc295a2a0 != nil {
		x.allocsc295a2a0.(*cgoAllocMap).Free()
		x.refc295a2a0 = nil
	}
}

// NewPhysicalDeviceTransformFeedbackPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceTransformFeedbackPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceTransformFeedbackProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceTransformFeedbackProperties)
	obj.refc295a2a0 = (*C.VkPhysicalDeviceTransformFeedbackPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceTransformFeedbackProperties) PassRef() (*C.VkPhysicalDeviceTransformFeedbackPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc295a2a0 != nil {
		return x.refc295a2a0, nil
	}
	memc295a2a0 := allocPhysicalDeviceTransformFeedbackPropertiesMemory(1)
	refc295a2a0 := (*C.VkPhysicalDeviceTransformFeedbackPropertiesEXT)(memc295a2a0)
	allocsc295a2a0 := new(cgoAllocMap)
	allocsc295a2a0.Add(memc295a2a0)

	var csType_allocs *cgoAllocMap
	refc295a2a0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc295a2a0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc295a2a0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc295a2a0.Borrow(cpNext_allocs)

	var cmaxTransformFeedbackStreams_allocs *cgoAllocMap
	refc295a2a0.maxTransformFeedbackStreams, cmaxTransformFeedbackStreams_allocs = (C.uint32_t)(x.MaxTransformFeedbackStreams), cgoAllocsUnknown
	allocsc295a2a0.Borrow(cmaxTransformFeedbackStreams_allocs)

	var cmaxTransformFeedbackBuffers_allocs *cgoAllocMap
	refc295a2a0.maxTransformFeedbackBuffers, cmaxTransformFeedbackBuffers_allocs = (C.uint32_t)(x.MaxTransformFeedbackBuffers), cgoAllocsUnknown
	allocsc295a2a0.Borrow(cmaxTransformFeedbackBuffers_allocs)

	var cmaxTransformFeedbackBufferSize_allocs *cgoAllocMap
	refc295a2a0.maxTransformFeedbackBufferSize, cmaxTransformFeedbackBufferSize_allocs = (C.VkDeviceSize)(x.MaxTransformFeedbackBufferSize), cgoAllocsUnknown
	allocsc295a2a0.Borrow(cmaxTransformFeedbackBufferSize_allocs)

	var cmaxTransformFeedbackStreamDataSize_allocs *cgoAllocMap
	refc295a2a0.maxTransformFeedbackStreamDataSize, cmaxTransformFeedbackStreamDataSize_allocs = (C.uint32_t)(x.MaxTransformFeedbackStreamDataSize), cgoAllocsUnknown
	allocsc295a2a0.Borrow(cmaxTransformFeedbackStreamDataSize_allocs)

	var cmaxTransformFeedbackBufferDataSize_allocs *cgoAllocMap
	refc295a2a0.maxTransformFeedbackBufferDataSize, cmaxTransformFeedbackBufferDataSize_allocs = (C.uint32_t)(x.MaxTransformFeedbackBufferDataSize), cgoAllocsUnknown
	allocsc295a2a0.Borrow(cmaxTransformFeedbackBufferDataSize_allocs)

	var cmaxTransformFeedbackBufferDataStride_allocs *cgoAllocMap
	refc295a2a0.maxTransformFeedbackBufferDataStride, cmaxTransformFeedbackBufferDataStride_allocs = (C.uint32_t)(x.MaxTransformFeedbackBufferDataStride), cgoAllocsUnknown
	allocsc295a2a0.Borrow(cmaxTransformFeedbackBufferDataStride_allocs)

	var ctransformFeedbackQueries_allocs *cgoAllocMap
	refc295a2a0.transformFeedbackQueries, ctransformFeedbackQueries_allocs = (C.VkBool32)(x.TransformFeedbackQueries), cgoAllocsUnknown
	allocsc295a2a0.Borrow(ctransformFeedbackQueries_allocs)

	var ctransformFeedbackStreamsLinesTriangles_allocs *cgoAllocMap
	refc295a2a0.transformFeedbackStreamsLinesTriangles, ctransformFeedbackStreamsLinesTriangles_allocs = (C.VkBool32)(x.TransformFeedbackStreamsLinesTriangles), cgoAllocsUnknown
	allocsc295a2a0.Borrow(ctransformFeedbackStreamsLinesTriangles_allocs)

	var ctransformFeedbackRasterizationStreamSelect_allocs *cgoAllocMap
	refc295a2a0.transformFeedbackRasterizationStreamSelect, ctransformFeedbackRasterizationStreamSelect_allocs = (C.VkBool32)(x.TransformFeedbackRasterizationStreamSelect), cgoAllocsUnknown
	allocsc295a2a0.Borrow(ctransformFeedbackRasterizationStreamSelect_allocs)

	var ctransformFeedbackDraw_allocs *cgoAllocMap
	refc295a2a0.transformFeedbackDraw, ctransformFeedbackDraw_allocs = (C.VkBool32)(x.TransformFeedbackDraw), cgoAllocsUnknown
	allocsc295a2a0.Borrow(ctransformFeedbackDraw_allocs)

	x.refc295a2a0 = refc295a2a0
	x.allocsc295a2a0 = allocsc295a2a0
	return refc295a2a0, allocsc295a2a0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceTransformFeedbackProperties) PassValue() (C.VkPhysicalDeviceTransformFeedbackPropertiesEXT, *cgoAllocMap) {
	if x.refc295a2a0 != nil {
		return *x.refc295a2a0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceTransformFeedbackProperties) Deref() {
	if x.refc295a2a0 == nil {
		return
	}
	x.SType = (StructureType)(x.refc295a2a0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc295a2a0.pNext))
	x.MaxTransformFeedbackStreams = (uint32)(x.refc295a2a0.maxTransformFeedbackStreams)
	x.MaxTransformFeedbackBuffers = (uint32)(x.refc295a2a0.maxTransformFeedbackBuffers)
	x.MaxTransformFeedbackBufferSize = (DeviceSize)(x.refc295a2a0.maxTransformFeedbackBufferSize)
	x.MaxTransformFeedbackStreamDataSize = (uint32)(x.refc295a2a0.maxTransformFeedbackStreamDataSize)
	x.MaxTransformFeedbackBufferDataSize = (uint32)(x.refc295a2a0.maxTransformFeedbackBufferDataSize)
	x.MaxTransformFeedbackBufferDataStride = (uint32)(x.refc295a2a0.maxTransformFeedbackBufferDataStride)
	x.TransformFeedbackQueries = (Bool32)(x.refc295a2a0.transformFeedbackQueries)
	x.TransformFeedbackStreamsLinesTriangles = (Bool32)(x.refc295a2a0.transformFeedbackStreamsLinesTriangles)
	x.TransformFeedbackRasterizationStreamSelect = (Bool32)(x.refc295a2a0.transformFeedbackRasterizationStreamSelect)
	x.TransformFeedbackDraw = (Bool32)(x.refc295a2a0.transformFeedbackDraw)
}

// allocPipelineRasterizationStateStreamCreateInfoMemory allocates memory for type C.VkPipelineRasterizationStateStreamCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationStateStreamCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationStateStreamCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineRasterizationStateStreamCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineRasterizationStateStreamCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRasterizationStateStreamCreateInfo) Ref() *C.VkPipelineRasterizationStateStreamCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refed6e1fb9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRasterizationStateStreamCreateInfo) Free() {
	if x != nil && x.allocsed6e1fb9 != nil {
		x.allocsed6e1fb9.(*cgoAllocMap).Free()
		x.refed6e1fb9 = nil
	}
}

// NewPipelineRasterizationStateStreamCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRasterizationStateStreamCreateInfoRef(ref unsafe.Pointer) *PipelineRasterizationStateStreamCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRasterizationStateStreamCreateInfo)
	obj.refed6e1fb9 = (*C.VkPipelineRasterizationStateStreamCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRasterizationStateStreamCreateInfo) PassRef() (*C.VkPipelineRasterizationStateStreamCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refed6e1fb9 != nil {
		return x.refed6e1fb9, nil
	}
	memed6e1fb9 := allocPipelineRasterizationStateStreamCreateInfoMemory(1)
	refed6e1fb9 := (*C.VkPipelineRasterizationStateStreamCreateInfoEXT)(memed6e1fb9)
	allocsed6e1fb9 := new(cgoAllocMap)
	allocsed6e1fb9.Add(memed6e1fb9)

	var csType_allocs *cgoAllocMap
	refed6e1fb9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsed6e1fb9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refed6e1fb9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsed6e1fb9.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refed6e1fb9.flags, cflags_allocs = (C.VkPipelineRasterizationStateStreamCreateFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocsed6e1fb9.Borrow(cflags_allocs)

	var crasterizationStream_allocs *cgoAllocMap
	refed6e1fb9.rasterizationStream, crasterizationStream_allocs = (C.uint32_t)(x.RasterizationStream), cgoAllocsUnknown
	allocsed6e1fb9.Borrow(crasterizationStream_allocs)

	x.refed6e1fb9 = refed6e1fb9
	x.allocsed6e1fb9 = allocsed6e1fb9
	return refed6e1fb9, allocsed6e1fb9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRasterizationStateStreamCreateInfo) PassValue() (C.VkPipelineRasterizationStateStreamCreateInfoEXT, *cgoAllocMap) {
	if x.refed6e1fb9 != nil {
		return *x.refed6e1fb9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRasterizationStateStreamCreateInfo) Deref() {
	if x.refed6e1fb9 == nil {
		return
	}
	x.SType = (StructureType)(x.refed6e1fb9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refed6e1fb9.pNext))
	x.Flags = (PipelineRasterizationStateStreamCreateFlags)(x.refed6e1fb9.flags)
	x.RasterizationStream = (uint32)(x.refed6e1fb9.rasterizationStream)
}

// allocImageViewHandleInfoNVXMemory allocates memory for type C.VkImageViewHandleInfoNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewHandleInfoNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewHandleInfoNVXValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageViewHandleInfoNVXValue = unsafe.Sizeof([1]C.VkImageViewHandleInfoNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageViewHandleInfoNVX) Ref() *C.VkImageViewHandleInfoNVX {
	if x == nil {
		return nil
	}
	return x.refc283b384
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageViewHandleInfoNVX) Free() {
	if x != nil && x.allocsc283b384 != nil {
		x.allocsc283b384.(*cgoAllocMap).Free()
		x.refc283b384 = nil
	}
}

// NewImageViewHandleInfoNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageViewHandleInfoNVXRef(ref unsafe.Pointer) *ImageViewHandleInfoNVX {
	if ref == nil {
		return nil
	}
	obj := new(ImageViewHandleInfoNVX)
	obj.refc283b384 = (*C.VkImageViewHandleInfoNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageViewHandleInfoNVX) PassRef() (*C.VkImageViewHandleInfoNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc283b384 != nil {
		return x.refc283b384, nil
	}
	memc283b384 := allocImageViewHandleInfoNVXMemory(1)
	refc283b384 := (*C.VkImageViewHandleInfoNVX)(memc283b384)
	allocsc283b384 := new(cgoAllocMap)
	allocsc283b384.Add(memc283b384)

	var csType_allocs *cgoAllocMap
	refc283b384.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc283b384.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc283b384.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc283b384.Borrow(cpNext_allocs)

	var cimageView_allocs *cgoAllocMap
	refc283b384.imageView, cimageView_allocs = *(*C.VkImageView)(unsafe.Pointer(&x.ImageView)), cgoAllocsUnknown
	allocsc283b384.Borrow(cimageView_allocs)

	var cdescriptorType_allocs *cgoAllocMap
	refc283b384.descriptorType, cdescriptorType_allocs = (C.VkDescriptorType)(x.DescriptorType), cgoAllocsUnknown
	allocsc283b384.Borrow(cdescriptorType_allocs)

	var csampler_allocs *cgoAllocMap
	refc283b384.sampler, csampler_allocs = *(*C.VkSampler)(unsafe.Pointer(&x.Sampler)), cgoAllocsUnknown
	allocsc283b384.Borrow(csampler_allocs)

	x.refc283b384 = refc283b384
	x.allocsc283b384 = allocsc283b384
	return refc283b384, allocsc283b384

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageViewHandleInfoNVX) PassValue() (C.VkImageViewHandleInfoNVX, *cgoAllocMap) {
	if x.refc283b384 != nil {
		return *x.refc283b384, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageViewHandleInfoNVX) Deref() {
	if x.refc283b384 == nil {
		return
	}
	x.SType = (StructureType)(x.refc283b384.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc283b384.pNext))
	x.ImageView = *(*ImageView)(unsafe.Pointer(&x.refc283b384.imageView))
	x.DescriptorType = (DescriptorType)(x.refc283b384.descriptorType)
	x.Sampler = *(*Sampler)(unsafe.Pointer(&x.refc283b384.sampler))
}

// allocImageViewAddressPropertiesNVXMemory allocates memory for type C.VkImageViewAddressPropertiesNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewAddressPropertiesNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewAddressPropertiesNVXValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageViewAddressPropertiesNVXValue = unsafe.Sizeof([1]C.VkImageViewAddressPropertiesNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageViewAddressPropertiesNVX) Ref() *C.VkImageViewAddressPropertiesNVX {
	if x == nil {
		return nil
	}
	return x.refe6dd1556
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageViewAddressPropertiesNVX) Free() {
	if x != nil && x.allocse6dd1556 != nil {
		x.allocse6dd1556.(*cgoAllocMap).Free()
		x.refe6dd1556 = nil
	}
}

// NewImageViewAddressPropertiesNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageViewAddressPropertiesNVXRef(ref unsafe.Pointer) *ImageViewAddressPropertiesNVX {
	if ref == nil {
		return nil
	}
	obj := new(ImageViewAddressPropertiesNVX)
	obj.refe6dd1556 = (*C.VkImageViewAddressPropertiesNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageViewAddressPropertiesNVX) PassRef() (*C.VkImageViewAddressPropertiesNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe6dd1556 != nil {
		return x.refe6dd1556, nil
	}
	meme6dd1556 := allocImageViewAddressPropertiesNVXMemory(1)
	refe6dd1556 := (*C.VkImageViewAddressPropertiesNVX)(meme6dd1556)
	allocse6dd1556 := new(cgoAllocMap)
	allocse6dd1556.Add(meme6dd1556)

	var csType_allocs *cgoAllocMap
	refe6dd1556.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse6dd1556.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe6dd1556.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse6dd1556.Borrow(cpNext_allocs)

	var cdeviceAddress_allocs *cgoAllocMap
	refe6dd1556.deviceAddress, cdeviceAddress_allocs = (C.VkDeviceAddress)(x.DeviceAddress), cgoAllocsUnknown
	allocse6dd1556.Borrow(cdeviceAddress_allocs)

	var csize_allocs *cgoAllocMap
	refe6dd1556.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocse6dd1556.Borrow(csize_allocs)

	x.refe6dd1556 = refe6dd1556
	x.allocse6dd1556 = allocse6dd1556
	return refe6dd1556, allocse6dd1556

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageViewAddressPropertiesNVX) PassValue() (C.VkImageViewAddressPropertiesNVX, *cgoAllocMap) {
	if x.refe6dd1556 != nil {
		return *x.refe6dd1556, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageViewAddressPropertiesNVX) Deref() {
	if x.refe6dd1556 == nil {
		return
	}
	x.SType = (StructureType)(x.refe6dd1556.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe6dd1556.pNext))
	x.DeviceAddress = (DeviceAddress)(x.refe6dd1556.deviceAddress)
	x.Size = (DeviceSize)(x.refe6dd1556.size)
}

// allocTextureLODGatherFormatPropertiesAMDMemory allocates memory for type C.VkTextureLODGatherFormatPropertiesAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTextureLODGatherFormatPropertiesAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTextureLODGatherFormatPropertiesAMDValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTextureLODGatherFormatPropertiesAMDValue = unsafe.Sizeof([1]C.VkTextureLODGatherFormatPropertiesAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TextureLODGatherFormatPropertiesAMD) Ref() *C.VkTextureLODGatherFormatPropertiesAMD {
	if x == nil {
		return nil
	}
	return x.ref519ba3a9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TextureLODGatherFormatPropertiesAMD) Free() {
	if x != nil && x.allocs519ba3a9 != nil {
		x.allocs519ba3a9.(*cgoAllocMap).Free()
		x.ref519ba3a9 = nil
	}
}

// NewTextureLODGatherFormatPropertiesAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextureLODGatherFormatPropertiesAMDRef(ref unsafe.Pointer) *TextureLODGatherFormatPropertiesAMD {
	if ref == nil {
		return nil
	}
	obj := new(TextureLODGatherFormatPropertiesAMD)
	obj.ref519ba3a9 = (*C.VkTextureLODGatherFormatPropertiesAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TextureLODGatherFormatPropertiesAMD) PassRef() (*C.VkTextureLODGatherFormatPropertiesAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref519ba3a9 != nil {
		return x.ref519ba3a9, nil
	}
	mem519ba3a9 := allocTextureLODGatherFormatPropertiesAMDMemory(1)
	ref519ba3a9 := (*C.VkTextureLODGatherFormatPropertiesAMD)(mem519ba3a9)
	allocs519ba3a9 := new(cgoAllocMap)
	allocs519ba3a9.Add(mem519ba3a9)

	var csType_allocs *cgoAllocMap
	ref519ba3a9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs519ba3a9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref519ba3a9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs519ba3a9.Borrow(cpNext_allocs)

	var csupportsTextureGatherLODBiasAMD_allocs *cgoAllocMap
	ref519ba3a9.supportsTextureGatherLODBiasAMD, csupportsTextureGatherLODBiasAMD_allocs = (C.VkBool32)(x.SupportsTextureGatherLODBiasAMD), cgoAllocsUnknown
	allocs519ba3a9.Borrow(csupportsTextureGatherLODBiasAMD_allocs)

	x.ref519ba3a9 = ref519ba3a9
	x.allocs519ba3a9 = allocs519ba3a9
	return ref519ba3a9, allocs519ba3a9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TextureLODGatherFormatPropertiesAMD) PassValue() (C.VkTextureLODGatherFormatPropertiesAMD, *cgoAllocMap) {
	if x.ref519ba3a9 != nil {
		return *x.ref519ba3a9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TextureLODGatherFormatPropertiesAMD) Deref() {
	if x.ref519ba3a9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref519ba3a9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref519ba3a9.pNext))
	x.SupportsTextureGatherLODBiasAMD = (Bool32)(x.ref519ba3a9.supportsTextureGatherLODBiasAMD)
}

// allocShaderResourceUsageAMDMemory allocates memory for type C.VkShaderResourceUsageAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderResourceUsageAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderResourceUsageAMDValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfShaderResourceUsageAMDValue = unsafe.Sizeof([1]C.VkShaderResourceUsageAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShaderResourceUsageAMD) Ref() *C.VkShaderResourceUsageAMD {
	if x == nil {
		return nil
	}
	return x.ref8a688131
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShaderResourceUsageAMD) Free() {
	if x != nil && x.allocs8a688131 != nil {
		x.allocs8a688131.(*cgoAllocMap).Free()
		x.ref8a688131 = nil
	}
}

// NewShaderResourceUsageAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderResourceUsageAMDRef(ref unsafe.Pointer) *ShaderResourceUsageAMD {
	if ref == nil {
		return nil
	}
	obj := new(ShaderResourceUsageAMD)
	obj.ref8a688131 = (*C.VkShaderResourceUsageAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShaderResourceUsageAMD) PassRef() (*C.VkShaderResourceUsageAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8a688131 != nil {
		return x.ref8a688131, nil
	}
	mem8a688131 := allocShaderResourceUsageAMDMemory(1)
	ref8a688131 := (*C.VkShaderResourceUsageAMD)(mem8a688131)
	allocs8a688131 := new(cgoAllocMap)
	allocs8a688131.Add(mem8a688131)

	var cnumUsedVgprs_allocs *cgoAllocMap
	ref8a688131.numUsedVgprs, cnumUsedVgprs_allocs = (C.uint32_t)(x.NumUsedVgprs), cgoAllocsUnknown
	allocs8a688131.Borrow(cnumUsedVgprs_allocs)

	var cnumUsedSgprs_allocs *cgoAllocMap
	ref8a688131.numUsedSgprs, cnumUsedSgprs_allocs = (C.uint32_t)(x.NumUsedSgprs), cgoAllocsUnknown
	allocs8a688131.Borrow(cnumUsedSgprs_allocs)

	var cldsSizePerLocalWorkGroup_allocs *cgoAllocMap
	ref8a688131.ldsSizePerLocalWorkGroup, cldsSizePerLocalWorkGroup_allocs = (C.uint32_t)(x.LdsSizePerLocalWorkGroup), cgoAllocsUnknown
	allocs8a688131.Borrow(cldsSizePerLocalWorkGroup_allocs)

	var cldsUsageSizeInBytes_allocs *cgoAllocMap
	ref8a688131.ldsUsageSizeInBytes, cldsUsageSizeInBytes_allocs = (C.size_t)(x.LdsUsageSizeInBytes), cgoAllocsUnknown
	allocs8a688131.Borrow(cldsUsageSizeInBytes_allocs)

	var cscratchMemUsageInBytes_allocs *cgoAllocMap
	ref8a688131.scratchMemUsageInBytes, cscratchMemUsageInBytes_allocs = (C.size_t)(x.ScratchMemUsageInBytes), cgoAllocsUnknown
	allocs8a688131.Borrow(cscratchMemUsageInBytes_allocs)

	x.ref8a688131 = ref8a688131
	x.allocs8a688131 = allocs8a688131
	return ref8a688131, allocs8a688131

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShaderResourceUsageAMD) PassValue() (C.VkShaderResourceUsageAMD, *cgoAllocMap) {
	if x.ref8a688131 != nil {
		return *x.ref8a688131, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShaderResourceUsageAMD) Deref() {
	if x.ref8a688131 == nil {
		return
	}
	x.NumUsedVgprs = (uint32)(x.ref8a688131.numUsedVgprs)
	x.NumUsedSgprs = (uint32)(x.ref8a688131.numUsedSgprs)
	x.LdsSizePerLocalWorkGroup = (uint32)(x.ref8a688131.ldsSizePerLocalWorkGroup)
	x.LdsUsageSizeInBytes = (uint32)(x.ref8a688131.ldsUsageSizeInBytes)
	x.ScratchMemUsageInBytes = (uint32)(x.ref8a688131.scratchMemUsageInBytes)
}

// allocShaderStatisticsInfoAMDMemory allocates memory for type C.VkShaderStatisticsInfoAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderStatisticsInfoAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderStatisticsInfoAMDValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfShaderStatisticsInfoAMDValue = unsafe.Sizeof([1]C.VkShaderStatisticsInfoAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShaderStatisticsInfoAMD) Ref() *C.VkShaderStatisticsInfoAMD {
	if x == nil {
		return nil
	}
	return x.ref896a52bf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShaderStatisticsInfoAMD) Free() {
	if x != nil && x.allocs896a52bf != nil {
		x.allocs896a52bf.(*cgoAllocMap).Free()
		x.ref896a52bf = nil
	}
}

// NewShaderStatisticsInfoAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderStatisticsInfoAMDRef(ref unsafe.Pointer) *ShaderStatisticsInfoAMD {
	if ref == nil {
		return nil
	}
	obj := new(ShaderStatisticsInfoAMD)
	obj.ref896a52bf = (*C.VkShaderStatisticsInfoAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShaderStatisticsInfoAMD) PassRef() (*C.VkShaderStatisticsInfoAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref896a52bf != nil {
		return x.ref896a52bf, nil
	}
	mem896a52bf := allocShaderStatisticsInfoAMDMemory(1)
	ref896a52bf := (*C.VkShaderStatisticsInfoAMD)(mem896a52bf)
	allocs896a52bf := new(cgoAllocMap)
	allocs896a52bf.Add(mem896a52bf)

	var cshaderStageMask_allocs *cgoAllocMap
	ref896a52bf.shaderStageMask, cshaderStageMask_allocs = (C.VkShaderStageFlags)(x.ShaderStageMask), cgoAllocsUnknown
	allocs896a52bf.Borrow(cshaderStageMask_allocs)

	var cresourceUsage_allocs *cgoAllocMap
	ref896a52bf.resourceUsage, cresourceUsage_allocs = x.ResourceUsage.PassValue()
	allocs896a52bf.Borrow(cresourceUsage_allocs)

	var cnumPhysicalVgprs_allocs *cgoAllocMap
	ref896a52bf.numPhysicalVgprs, cnumPhysicalVgprs_allocs = (C.uint32_t)(x.NumPhysicalVgprs), cgoAllocsUnknown
	allocs896a52bf.Borrow(cnumPhysicalVgprs_allocs)

	var cnumPhysicalSgprs_allocs *cgoAllocMap
	ref896a52bf.numPhysicalSgprs, cnumPhysicalSgprs_allocs = (C.uint32_t)(x.NumPhysicalSgprs), cgoAllocsUnknown
	allocs896a52bf.Borrow(cnumPhysicalSgprs_allocs)

	var cnumAvailableVgprs_allocs *cgoAllocMap
	ref896a52bf.numAvailableVgprs, cnumAvailableVgprs_allocs = (C.uint32_t)(x.NumAvailableVgprs), cgoAllocsUnknown
	allocs896a52bf.Borrow(cnumAvailableVgprs_allocs)

	var cnumAvailableSgprs_allocs *cgoAllocMap
	ref896a52bf.numAvailableSgprs, cnumAvailableSgprs_allocs = (C.uint32_t)(x.NumAvailableSgprs), cgoAllocsUnknown
	allocs896a52bf.Borrow(cnumAvailableSgprs_allocs)

	var ccomputeWorkGroupSize_allocs *cgoAllocMap
	ref896a52bf.computeWorkGroupSize, ccomputeWorkGroupSize_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.ComputeWorkGroupSize)), cgoAllocsUnknown
	allocs896a52bf.Borrow(ccomputeWorkGroupSize_allocs)

	x.ref896a52bf = ref896a52bf
	x.allocs896a52bf = allocs896a52bf
	return ref896a52bf, allocs896a52bf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShaderStatisticsInfoAMD) PassValue() (C.VkShaderStatisticsInfoAMD, *cgoAllocMap) {
	if x.ref896a52bf != nil {
		return *x.ref896a52bf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShaderStatisticsInfoAMD) Deref() {
	if x.ref896a52bf == nil {
		return
	}
	x.ShaderStageMask = (ShaderStageFlags)(x.ref896a52bf.shaderStageMask)
	x.ResourceUsage = *NewShaderResourceUsageAMDRef(unsafe.Pointer(&x.ref896a52bf.resourceUsage))
	x.NumPhysicalVgprs = (uint32)(x.ref896a52bf.numPhysicalVgprs)
	x.NumPhysicalSgprs = (uint32)(x.ref896a52bf.numPhysicalSgprs)
	x.NumAvailableVgprs = (uint32)(x.ref896a52bf.numAvailableVgprs)
	x.NumAvailableSgprs = (uint32)(x.ref896a52bf.numAvailableSgprs)
	x.ComputeWorkGroupSize = *(*[3]uint32)(unsafe.Pointer(&x.ref896a52bf.computeWorkGroupSize))
}

// allocPhysicalDeviceCornerSampledImageFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceCornerSampledImageFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceCornerSampledImageFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceCornerSampledImageFeaturesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceCornerSampledImageFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceCornerSampledImageFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceCornerSampledImageFeaturesNV) Ref() *C.VkPhysicalDeviceCornerSampledImageFeaturesNV {
	if x == nil {
		return nil
	}
	return x.refdf4a62d1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceCornerSampledImageFeaturesNV) Free() {
	if x != nil && x.allocsdf4a62d1 != nil {
		x.allocsdf4a62d1.(*cgoAllocMap).Free()
		x.refdf4a62d1 = nil
	}
}

// NewPhysicalDeviceCornerSampledImageFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceCornerSampledImageFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceCornerSampledImageFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceCornerSampledImageFeaturesNV)
	obj.refdf4a62d1 = (*C.VkPhysicalDeviceCornerSampledImageFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceCornerSampledImageFeaturesNV) PassRef() (*C.VkPhysicalDeviceCornerSampledImageFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdf4a62d1 != nil {
		return x.refdf4a62d1, nil
	}
	memdf4a62d1 := allocPhysicalDeviceCornerSampledImageFeaturesNVMemory(1)
	refdf4a62d1 := (*C.VkPhysicalDeviceCornerSampledImageFeaturesNV)(memdf4a62d1)
	allocsdf4a62d1 := new(cgoAllocMap)
	allocsdf4a62d1.Add(memdf4a62d1)

	var csType_allocs *cgoAllocMap
	refdf4a62d1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdf4a62d1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdf4a62d1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdf4a62d1.Borrow(cpNext_allocs)

	var ccornerSampledImage_allocs *cgoAllocMap
	refdf4a62d1.cornerSampledImage, ccornerSampledImage_allocs = (C.VkBool32)(x.CornerSampledImage), cgoAllocsUnknown
	allocsdf4a62d1.Borrow(ccornerSampledImage_allocs)

	x.refdf4a62d1 = refdf4a62d1
	x.allocsdf4a62d1 = allocsdf4a62d1
	return refdf4a62d1, allocsdf4a62d1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceCornerSampledImageFeaturesNV) PassValue() (C.VkPhysicalDeviceCornerSampledImageFeaturesNV, *cgoAllocMap) {
	if x.refdf4a62d1 != nil {
		return *x.refdf4a62d1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceCornerSampledImageFeaturesNV) Deref() {
	if x.refdf4a62d1 == nil {
		return
	}
	x.SType = (StructureType)(x.refdf4a62d1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdf4a62d1.pNext))
	x.CornerSampledImage = (Bool32)(x.refdf4a62d1.cornerSampledImage)
}

// allocExternalImageFormatPropertiesNVMemory allocates memory for type C.VkExternalImageFormatPropertiesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalImageFormatPropertiesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalImageFormatPropertiesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExternalImageFormatPropertiesNVValue = unsafe.Sizeof([1]C.VkExternalImageFormatPropertiesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalImageFormatPropertiesNV) Ref() *C.VkExternalImageFormatPropertiesNV {
	if x == nil {
		return nil
	}
	return x.refa8900ce5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalImageFormatPropertiesNV) Free() {
	if x != nil && x.allocsa8900ce5 != nil {
		x.allocsa8900ce5.(*cgoAllocMap).Free()
		x.refa8900ce5 = nil
	}
}

// NewExternalImageFormatPropertiesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalImageFormatPropertiesNVRef(ref unsafe.Pointer) *ExternalImageFormatPropertiesNV {
	if ref == nil {
		return nil
	}
	obj := new(ExternalImageFormatPropertiesNV)
	obj.refa8900ce5 = (*C.VkExternalImageFormatPropertiesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalImageFormatPropertiesNV) PassRef() (*C.VkExternalImageFormatPropertiesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa8900ce5 != nil {
		return x.refa8900ce5, nil
	}
	mema8900ce5 := allocExternalImageFormatPropertiesNVMemory(1)
	refa8900ce5 := (*C.VkExternalImageFormatPropertiesNV)(mema8900ce5)
	allocsa8900ce5 := new(cgoAllocMap)
	allocsa8900ce5.Add(mema8900ce5)

	var cimageFormatProperties_allocs *cgoAllocMap
	refa8900ce5.imageFormatProperties, cimageFormatProperties_allocs = x.ImageFormatProperties.PassValue()
	allocsa8900ce5.Borrow(cimageFormatProperties_allocs)

	var cexternalMemoryFeatures_allocs *cgoAllocMap
	refa8900ce5.externalMemoryFeatures, cexternalMemoryFeatures_allocs = (C.VkExternalMemoryFeatureFlagsNV)(x.ExternalMemoryFeatures), cgoAllocsUnknown
	allocsa8900ce5.Borrow(cexternalMemoryFeatures_allocs)

	var cexportFromImportedHandleTypes_allocs *cgoAllocMap
	refa8900ce5.exportFromImportedHandleTypes, cexportFromImportedHandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlagsNV)(x.ExportFromImportedHandleTypes), cgoAllocsUnknown
	allocsa8900ce5.Borrow(cexportFromImportedHandleTypes_allocs)

	var ccompatibleHandleTypes_allocs *cgoAllocMap
	refa8900ce5.compatibleHandleTypes, ccompatibleHandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlagsNV)(x.CompatibleHandleTypes), cgoAllocsUnknown
	allocsa8900ce5.Borrow(ccompatibleHandleTypes_allocs)

	x.refa8900ce5 = refa8900ce5
	x.allocsa8900ce5 = allocsa8900ce5
	return refa8900ce5, allocsa8900ce5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalImageFormatPropertiesNV) PassValue() (C.VkExternalImageFormatPropertiesNV, *cgoAllocMap) {
	if x.refa8900ce5 != nil {
		return *x.refa8900ce5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalImageFormatPropertiesNV) Deref() {
	if x.refa8900ce5 == nil {
		return
	}
	x.ImageFormatProperties = *NewImageFormatPropertiesRef(unsafe.Pointer(&x.refa8900ce5.imageFormatProperties))
	x.ExternalMemoryFeatures = (ExternalMemoryFeatureFlagsNV)(x.refa8900ce5.externalMemoryFeatures)
	x.ExportFromImportedHandleTypes = (ExternalMemoryHandleTypeFlagsNV)(x.refa8900ce5.exportFromImportedHandleTypes)
	x.CompatibleHandleTypes = (ExternalMemoryHandleTypeFlagsNV)(x.refa8900ce5.compatibleHandleTypes)
}

// allocExternalMemoryImageCreateInfoNVMemory allocates memory for type C.VkExternalMemoryImageCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalMemoryImageCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalMemoryImageCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExternalMemoryImageCreateInfoNVValue = unsafe.Sizeof([1]C.VkExternalMemoryImageCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalMemoryImageCreateInfoNV) Ref() *C.VkExternalMemoryImageCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref9a7fb6c8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalMemoryImageCreateInfoNV) Free() {
	if x != nil && x.allocs9a7fb6c8 != nil {
		x.allocs9a7fb6c8.(*cgoAllocMap).Free()
		x.ref9a7fb6c8 = nil
	}
}

// NewExternalMemoryImageCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalMemoryImageCreateInfoNVRef(ref unsafe.Pointer) *ExternalMemoryImageCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(ExternalMemoryImageCreateInfoNV)
	obj.ref9a7fb6c8 = (*C.VkExternalMemoryImageCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalMemoryImageCreateInfoNV) PassRef() (*C.VkExternalMemoryImageCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9a7fb6c8 != nil {
		return x.ref9a7fb6c8, nil
	}
	mem9a7fb6c8 := allocExternalMemoryImageCreateInfoNVMemory(1)
	ref9a7fb6c8 := (*C.VkExternalMemoryImageCreateInfoNV)(mem9a7fb6c8)
	allocs9a7fb6c8 := new(cgoAllocMap)
	allocs9a7fb6c8.Add(mem9a7fb6c8)

	var csType_allocs *cgoAllocMap
	ref9a7fb6c8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9a7fb6c8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9a7fb6c8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9a7fb6c8.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	ref9a7fb6c8.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlagsNV)(x.HandleTypes), cgoAllocsUnknown
	allocs9a7fb6c8.Borrow(chandleTypes_allocs)

	x.ref9a7fb6c8 = ref9a7fb6c8
	x.allocs9a7fb6c8 = allocs9a7fb6c8
	return ref9a7fb6c8, allocs9a7fb6c8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalMemoryImageCreateInfoNV) PassValue() (C.VkExternalMemoryImageCreateInfoNV, *cgoAllocMap) {
	if x.ref9a7fb6c8 != nil {
		return *x.ref9a7fb6c8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalMemoryImageCreateInfoNV) Deref() {
	if x.ref9a7fb6c8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9a7fb6c8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9a7fb6c8.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlagsNV)(x.ref9a7fb6c8.handleTypes)
}

// allocExportMemoryAllocateInfoNVMemory allocates memory for type C.VkExportMemoryAllocateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExportMemoryAllocateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExportMemoryAllocateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExportMemoryAllocateInfoNVValue = unsafe.Sizeof([1]C.VkExportMemoryAllocateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExportMemoryAllocateInfoNV) Ref() *C.VkExportMemoryAllocateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref5066f33
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExportMemoryAllocateInfoNV) Free() {
	if x != nil && x.allocs5066f33 != nil {
		x.allocs5066f33.(*cgoAllocMap).Free()
		x.ref5066f33 = nil
	}
}

// NewExportMemoryAllocateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExportMemoryAllocateInfoNVRef(ref unsafe.Pointer) *ExportMemoryAllocateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(ExportMemoryAllocateInfoNV)
	obj.ref5066f33 = (*C.VkExportMemoryAllocateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExportMemoryAllocateInfoNV) PassRef() (*C.VkExportMemoryAllocateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5066f33 != nil {
		return x.ref5066f33, nil
	}
	mem5066f33 := allocExportMemoryAllocateInfoNVMemory(1)
	ref5066f33 := (*C.VkExportMemoryAllocateInfoNV)(mem5066f33)
	allocs5066f33 := new(cgoAllocMap)
	allocs5066f33.Add(mem5066f33)

	var csType_allocs *cgoAllocMap
	ref5066f33.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5066f33.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5066f33.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5066f33.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	ref5066f33.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlagsNV)(x.HandleTypes), cgoAllocsUnknown
	allocs5066f33.Borrow(chandleTypes_allocs)

	x.ref5066f33 = ref5066f33
	x.allocs5066f33 = allocs5066f33
	return ref5066f33, allocs5066f33

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExportMemoryAllocateInfoNV) PassValue() (C.VkExportMemoryAllocateInfoNV, *cgoAllocMap) {
	if x.ref5066f33 != nil {
		return *x.ref5066f33, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExportMemoryAllocateInfoNV) Deref() {
	if x.ref5066f33 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5066f33.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5066f33.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlagsNV)(x.ref5066f33.handleTypes)
}

// allocValidationFlagsMemory allocates memory for type C.VkValidationFlagsEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValidationFlagsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValidationFlagsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfValidationFlagsValue = unsafe.Sizeof([1]C.VkValidationFlagsEXT{})

// copyPValidationCheckBytes copies the data from Go slice as *C.VkValidationCheckEXT.
func copyPValidationCheckBytes(slice *sliceHeader) (*C.VkValidationCheckEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfValidationCheckValue) * slice.Len,
		Cap:  int(sizeOfValidationCheckValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkValidationCheckEXT)(mem0), allocs
}

// allocValidationCheckMemory allocates memory for type C.VkValidationCheckEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValidationCheckMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValidationCheckValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfValidationCheckValue = unsafe.Sizeof([1]C.VkValidationCheckEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ValidationFlags) Ref() *C.VkValidationFlagsEXT {
	if x == nil {
		return nil
	}
	return x.refffe080ad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ValidationFlags) Free() {
	if x != nil && x.allocsffe080ad != nil {
		x.allocsffe080ad.(*cgoAllocMap).Free()
		x.refffe080ad = nil
	}
}

// NewValidationFlagsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewValidationFlagsRef(ref unsafe.Pointer) *ValidationFlags {
	if ref == nil {
		return nil
	}
	obj := new(ValidationFlags)
	obj.refffe080ad = (*C.VkValidationFlagsEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ValidationFlags) PassRef() (*C.VkValidationFlagsEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refffe080ad != nil {
		return x.refffe080ad, nil
	}
	memffe080ad := allocValidationFlagsMemory(1)
	refffe080ad := (*C.VkValidationFlagsEXT)(memffe080ad)
	allocsffe080ad := new(cgoAllocMap)
	allocsffe080ad.Add(memffe080ad)

	var csType_allocs *cgoAllocMap
	refffe080ad.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsffe080ad.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refffe080ad.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsffe080ad.Borrow(cpNext_allocs)

	var cdisabledValidationCheckCount_allocs *cgoAllocMap
	refffe080ad.disabledValidationCheckCount, cdisabledValidationCheckCount_allocs = (C.uint32_t)(x.DisabledValidationCheckCount), cgoAllocsUnknown
	allocsffe080ad.Borrow(cdisabledValidationCheckCount_allocs)

	var cpDisabledValidationChecks_allocs *cgoAllocMap
	refffe080ad.pDisabledValidationChecks, cpDisabledValidationChecks_allocs = copyPValidationCheckBytes((*sliceHeader)(unsafe.Pointer(&x.PDisabledValidationChecks)))
	allocsffe080ad.Borrow(cpDisabledValidationChecks_allocs)

	x.refffe080ad = refffe080ad
	x.allocsffe080ad = allocsffe080ad
	return refffe080ad, allocsffe080ad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ValidationFlags) PassValue() (C.VkValidationFlagsEXT, *cgoAllocMap) {
	if x.refffe080ad != nil {
		return *x.refffe080ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ValidationFlags) Deref() {
	if x.refffe080ad == nil {
		return
	}
	x.SType = (StructureType)(x.refffe080ad.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refffe080ad.pNext))
	x.DisabledValidationCheckCount = (uint32)(x.refffe080ad.disabledValidationCheckCount)
	hxf9aab83 := (*sliceHeader)(unsafe.Pointer(&x.PDisabledValidationChecks))
	hxf9aab83.Data = unsafe.Pointer(x.refffe080ad.pDisabledValidationChecks)
	hxf9aab83.Cap = 0x7fffffff
	// hxf9aab83.Len = ?

}

// allocPhysicalDeviceTextureCompressionASTCHDRFeaturesMemory allocates memory for type C.VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceTextureCompressionASTCHDRFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceTextureCompressionASTCHDRFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceTextureCompressionASTCHDRFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceTextureCompressionASTCHDRFeatures) Ref() *C.VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refdea20078
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceTextureCompressionASTCHDRFeatures) Free() {
	if x != nil && x.allocsdea20078 != nil {
		x.allocsdea20078.(*cgoAllocMap).Free()
		x.refdea20078 = nil
	}
}

// NewPhysicalDeviceTextureCompressionASTCHDRFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceTextureCompressionASTCHDRFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceTextureCompressionASTCHDRFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceTextureCompressionASTCHDRFeatures)
	obj.refdea20078 = (*C.VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceTextureCompressionASTCHDRFeatures) PassRef() (*C.VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdea20078 != nil {
		return x.refdea20078, nil
	}
	memdea20078 := allocPhysicalDeviceTextureCompressionASTCHDRFeaturesMemory(1)
	refdea20078 := (*C.VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT)(memdea20078)
	allocsdea20078 := new(cgoAllocMap)
	allocsdea20078.Add(memdea20078)

	var csType_allocs *cgoAllocMap
	refdea20078.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdea20078.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdea20078.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdea20078.Borrow(cpNext_allocs)

	var ctextureCompressionASTC_HDR_allocs *cgoAllocMap
	refdea20078.textureCompressionASTC_HDR, ctextureCompressionASTC_HDR_allocs = (C.VkBool32)(x.TextureCompressionASTC_HDR), cgoAllocsUnknown
	allocsdea20078.Borrow(ctextureCompressionASTC_HDR_allocs)

	x.refdea20078 = refdea20078
	x.allocsdea20078 = allocsdea20078
	return refdea20078, allocsdea20078

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) PassValue() (C.VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT, *cgoAllocMap) {
	if x.refdea20078 != nil {
		return *x.refdea20078, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceTextureCompressionASTCHDRFeatures) Deref() {
	if x.refdea20078 == nil {
		return
	}
	x.SType = (StructureType)(x.refdea20078.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdea20078.pNext))
	x.TextureCompressionASTC_HDR = (Bool32)(x.refdea20078.textureCompressionASTC_HDR)
}

// allocImageViewASTCDecodeModeMemory allocates memory for type C.VkImageViewASTCDecodeModeEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewASTCDecodeModeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewASTCDecodeModeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageViewASTCDecodeModeValue = unsafe.Sizeof([1]C.VkImageViewASTCDecodeModeEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageViewASTCDecodeMode) Ref() *C.VkImageViewASTCDecodeModeEXT {
	if x == nil {
		return nil
	}
	return x.ref3a973fc0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageViewASTCDecodeMode) Free() {
	if x != nil && x.allocs3a973fc0 != nil {
		x.allocs3a973fc0.(*cgoAllocMap).Free()
		x.ref3a973fc0 = nil
	}
}

// NewImageViewASTCDecodeModeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageViewASTCDecodeModeRef(ref unsafe.Pointer) *ImageViewASTCDecodeMode {
	if ref == nil {
		return nil
	}
	obj := new(ImageViewASTCDecodeMode)
	obj.ref3a973fc0 = (*C.VkImageViewASTCDecodeModeEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageViewASTCDecodeMode) PassRef() (*C.VkImageViewASTCDecodeModeEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3a973fc0 != nil {
		return x.ref3a973fc0, nil
	}
	mem3a973fc0 := allocImageViewASTCDecodeModeMemory(1)
	ref3a973fc0 := (*C.VkImageViewASTCDecodeModeEXT)(mem3a973fc0)
	allocs3a973fc0 := new(cgoAllocMap)
	allocs3a973fc0.Add(mem3a973fc0)

	var csType_allocs *cgoAllocMap
	ref3a973fc0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3a973fc0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3a973fc0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3a973fc0.Borrow(cpNext_allocs)

	var cdecodeMode_allocs *cgoAllocMap
	ref3a973fc0.decodeMode, cdecodeMode_allocs = (C.VkFormat)(x.DecodeMode), cgoAllocsUnknown
	allocs3a973fc0.Borrow(cdecodeMode_allocs)

	x.ref3a973fc0 = ref3a973fc0
	x.allocs3a973fc0 = allocs3a973fc0
	return ref3a973fc0, allocs3a973fc0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageViewASTCDecodeMode) PassValue() (C.VkImageViewASTCDecodeModeEXT, *cgoAllocMap) {
	if x.ref3a973fc0 != nil {
		return *x.ref3a973fc0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageViewASTCDecodeMode) Deref() {
	if x.ref3a973fc0 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3a973fc0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3a973fc0.pNext))
	x.DecodeMode = (Format)(x.ref3a973fc0.decodeMode)
}

// allocPhysicalDeviceASTCDecodeFeaturesMemory allocates memory for type C.VkPhysicalDeviceASTCDecodeFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceASTCDecodeFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceASTCDecodeFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceASTCDecodeFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceASTCDecodeFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceASTCDecodeFeatures) Ref() *C.VkPhysicalDeviceASTCDecodeFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refd8af7d5a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceASTCDecodeFeatures) Free() {
	if x != nil && x.allocsd8af7d5a != nil {
		x.allocsd8af7d5a.(*cgoAllocMap).Free()
		x.refd8af7d5a = nil
	}
}

// NewPhysicalDeviceASTCDecodeFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceASTCDecodeFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceASTCDecodeFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceASTCDecodeFeatures)
	obj.refd8af7d5a = (*C.VkPhysicalDeviceASTCDecodeFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceASTCDecodeFeatures) PassRef() (*C.VkPhysicalDeviceASTCDecodeFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd8af7d5a != nil {
		return x.refd8af7d5a, nil
	}
	memd8af7d5a := allocPhysicalDeviceASTCDecodeFeaturesMemory(1)
	refd8af7d5a := (*C.VkPhysicalDeviceASTCDecodeFeaturesEXT)(memd8af7d5a)
	allocsd8af7d5a := new(cgoAllocMap)
	allocsd8af7d5a.Add(memd8af7d5a)

	var csType_allocs *cgoAllocMap
	refd8af7d5a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd8af7d5a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd8af7d5a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd8af7d5a.Borrow(cpNext_allocs)

	var cdecodeModeSharedExponent_allocs *cgoAllocMap
	refd8af7d5a.decodeModeSharedExponent, cdecodeModeSharedExponent_allocs = (C.VkBool32)(x.DecodeModeSharedExponent), cgoAllocsUnknown
	allocsd8af7d5a.Borrow(cdecodeModeSharedExponent_allocs)

	x.refd8af7d5a = refd8af7d5a
	x.allocsd8af7d5a = allocsd8af7d5a
	return refd8af7d5a, allocsd8af7d5a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceASTCDecodeFeatures) PassValue() (C.VkPhysicalDeviceASTCDecodeFeaturesEXT, *cgoAllocMap) {
	if x.refd8af7d5a != nil {
		return *x.refd8af7d5a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceASTCDecodeFeatures) Deref() {
	if x.refd8af7d5a == nil {
		return
	}
	x.SType = (StructureType)(x.refd8af7d5a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd8af7d5a.pNext))
	x.DecodeModeSharedExponent = (Bool32)(x.refd8af7d5a.decodeModeSharedExponent)
}

// allocConditionalRenderingBeginInfoMemory allocates memory for type C.VkConditionalRenderingBeginInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocConditionalRenderingBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfConditionalRenderingBeginInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfConditionalRenderingBeginInfoValue = unsafe.Sizeof([1]C.VkConditionalRenderingBeginInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConditionalRenderingBeginInfo) Ref() *C.VkConditionalRenderingBeginInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref82da87c9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConditionalRenderingBeginInfo) Free() {
	if x != nil && x.allocs82da87c9 != nil {
		x.allocs82da87c9.(*cgoAllocMap).Free()
		x.ref82da87c9 = nil
	}
}

// NewConditionalRenderingBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConditionalRenderingBeginInfoRef(ref unsafe.Pointer) *ConditionalRenderingBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(ConditionalRenderingBeginInfo)
	obj.ref82da87c9 = (*C.VkConditionalRenderingBeginInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConditionalRenderingBeginInfo) PassRef() (*C.VkConditionalRenderingBeginInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref82da87c9 != nil {
		return x.ref82da87c9, nil
	}
	mem82da87c9 := allocConditionalRenderingBeginInfoMemory(1)
	ref82da87c9 := (*C.VkConditionalRenderingBeginInfoEXT)(mem82da87c9)
	allocs82da87c9 := new(cgoAllocMap)
	allocs82da87c9.Add(mem82da87c9)

	var csType_allocs *cgoAllocMap
	ref82da87c9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs82da87c9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref82da87c9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs82da87c9.Borrow(cpNext_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref82da87c9.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs82da87c9.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	ref82da87c9.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs82da87c9.Borrow(coffset_allocs)

	var cflags_allocs *cgoAllocMap
	ref82da87c9.flags, cflags_allocs = (C.VkConditionalRenderingFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocs82da87c9.Borrow(cflags_allocs)

	x.ref82da87c9 = ref82da87c9
	x.allocs82da87c9 = allocs82da87c9
	return ref82da87c9, allocs82da87c9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConditionalRenderingBeginInfo) PassValue() (C.VkConditionalRenderingBeginInfoEXT, *cgoAllocMap) {
	if x.ref82da87c9 != nil {
		return *x.ref82da87c9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConditionalRenderingBeginInfo) Deref() {
	if x.ref82da87c9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref82da87c9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref82da87c9.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref82da87c9.buffer))
	x.Offset = (DeviceSize)(x.ref82da87c9.offset)
	x.Flags = (ConditionalRenderingFlags)(x.ref82da87c9.flags)
}

// allocPhysicalDeviceConditionalRenderingFeaturesMemory allocates memory for type C.VkPhysicalDeviceConditionalRenderingFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceConditionalRenderingFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceConditionalRenderingFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceConditionalRenderingFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceConditionalRenderingFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceConditionalRenderingFeatures) Ref() *C.VkPhysicalDeviceConditionalRenderingFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref89d2a224
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceConditionalRenderingFeatures) Free() {
	if x != nil && x.allocs89d2a224 != nil {
		x.allocs89d2a224.(*cgoAllocMap).Free()
		x.ref89d2a224 = nil
	}
}

// NewPhysicalDeviceConditionalRenderingFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceConditionalRenderingFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceConditionalRenderingFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceConditionalRenderingFeatures)
	obj.ref89d2a224 = (*C.VkPhysicalDeviceConditionalRenderingFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceConditionalRenderingFeatures) PassRef() (*C.VkPhysicalDeviceConditionalRenderingFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref89d2a224 != nil {
		return x.ref89d2a224, nil
	}
	mem89d2a224 := allocPhysicalDeviceConditionalRenderingFeaturesMemory(1)
	ref89d2a224 := (*C.VkPhysicalDeviceConditionalRenderingFeaturesEXT)(mem89d2a224)
	allocs89d2a224 := new(cgoAllocMap)
	allocs89d2a224.Add(mem89d2a224)

	var csType_allocs *cgoAllocMap
	ref89d2a224.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs89d2a224.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref89d2a224.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs89d2a224.Borrow(cpNext_allocs)

	var cconditionalRendering_allocs *cgoAllocMap
	ref89d2a224.conditionalRendering, cconditionalRendering_allocs = (C.VkBool32)(x.ConditionalRendering), cgoAllocsUnknown
	allocs89d2a224.Borrow(cconditionalRendering_allocs)

	var cinheritedConditionalRendering_allocs *cgoAllocMap
	ref89d2a224.inheritedConditionalRendering, cinheritedConditionalRendering_allocs = (C.VkBool32)(x.InheritedConditionalRendering), cgoAllocsUnknown
	allocs89d2a224.Borrow(cinheritedConditionalRendering_allocs)

	x.ref89d2a224 = ref89d2a224
	x.allocs89d2a224 = allocs89d2a224
	return ref89d2a224, allocs89d2a224

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceConditionalRenderingFeatures) PassValue() (C.VkPhysicalDeviceConditionalRenderingFeaturesEXT, *cgoAllocMap) {
	if x.ref89d2a224 != nil {
		return *x.ref89d2a224, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceConditionalRenderingFeatures) Deref() {
	if x.ref89d2a224 == nil {
		return
	}
	x.SType = (StructureType)(x.ref89d2a224.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref89d2a224.pNext))
	x.ConditionalRendering = (Bool32)(x.ref89d2a224.conditionalRendering)
	x.InheritedConditionalRendering = (Bool32)(x.ref89d2a224.inheritedConditionalRendering)
}

// allocCommandBufferInheritanceConditionalRenderingInfoMemory allocates memory for type C.VkCommandBufferInheritanceConditionalRenderingInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferInheritanceConditionalRenderingInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferInheritanceConditionalRenderingInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCommandBufferInheritanceConditionalRenderingInfoValue = unsafe.Sizeof([1]C.VkCommandBufferInheritanceConditionalRenderingInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferInheritanceConditionalRenderingInfo) Ref() *C.VkCommandBufferInheritanceConditionalRenderingInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref7155f49c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferInheritanceConditionalRenderingInfo) Free() {
	if x != nil && x.allocs7155f49c != nil {
		x.allocs7155f49c.(*cgoAllocMap).Free()
		x.ref7155f49c = nil
	}
}

// NewCommandBufferInheritanceConditionalRenderingInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferInheritanceConditionalRenderingInfoRef(ref unsafe.Pointer) *CommandBufferInheritanceConditionalRenderingInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferInheritanceConditionalRenderingInfo)
	obj.ref7155f49c = (*C.VkCommandBufferInheritanceConditionalRenderingInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferInheritanceConditionalRenderingInfo) PassRef() (*C.VkCommandBufferInheritanceConditionalRenderingInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7155f49c != nil {
		return x.ref7155f49c, nil
	}
	mem7155f49c := allocCommandBufferInheritanceConditionalRenderingInfoMemory(1)
	ref7155f49c := (*C.VkCommandBufferInheritanceConditionalRenderingInfoEXT)(mem7155f49c)
	allocs7155f49c := new(cgoAllocMap)
	allocs7155f49c.Add(mem7155f49c)

	var csType_allocs *cgoAllocMap
	ref7155f49c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7155f49c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7155f49c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7155f49c.Borrow(cpNext_allocs)

	var cconditionalRenderingEnable_allocs *cgoAllocMap
	ref7155f49c.conditionalRenderingEnable, cconditionalRenderingEnable_allocs = (C.VkBool32)(x.ConditionalRenderingEnable), cgoAllocsUnknown
	allocs7155f49c.Borrow(cconditionalRenderingEnable_allocs)

	x.ref7155f49c = ref7155f49c
	x.allocs7155f49c = allocs7155f49c
	return ref7155f49c, allocs7155f49c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferInheritanceConditionalRenderingInfo) PassValue() (C.VkCommandBufferInheritanceConditionalRenderingInfoEXT, *cgoAllocMap) {
	if x.ref7155f49c != nil {
		return *x.ref7155f49c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferInheritanceConditionalRenderingInfo) Deref() {
	if x.ref7155f49c == nil {
		return
	}
	x.SType = (StructureType)(x.ref7155f49c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7155f49c.pNext))
	x.ConditionalRenderingEnable = (Bool32)(x.ref7155f49c.conditionalRenderingEnable)
}

// allocViewportWScalingNVMemory allocates memory for type C.VkViewportWScalingNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocViewportWScalingNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfViewportWScalingNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfViewportWScalingNVValue = unsafe.Sizeof([1]C.VkViewportWScalingNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ViewportWScalingNV) Ref() *C.VkViewportWScalingNV {
	if x == nil {
		return nil
	}
	return x.ref7ea4590f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ViewportWScalingNV) Free() {
	if x != nil && x.allocs7ea4590f != nil {
		x.allocs7ea4590f.(*cgoAllocMap).Free()
		x.ref7ea4590f = nil
	}
}

// NewViewportWScalingNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewViewportWScalingNVRef(ref unsafe.Pointer) *ViewportWScalingNV {
	if ref == nil {
		return nil
	}
	obj := new(ViewportWScalingNV)
	obj.ref7ea4590f = (*C.VkViewportWScalingNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ViewportWScalingNV) PassRef() (*C.VkViewportWScalingNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7ea4590f != nil {
		return x.ref7ea4590f, nil
	}
	mem7ea4590f := allocViewportWScalingNVMemory(1)
	ref7ea4590f := (*C.VkViewportWScalingNV)(mem7ea4590f)
	allocs7ea4590f := new(cgoAllocMap)
	allocs7ea4590f.Add(mem7ea4590f)

	var cxcoeff_allocs *cgoAllocMap
	ref7ea4590f.xcoeff, cxcoeff_allocs = (C.float)(x.Xcoeff), cgoAllocsUnknown
	allocs7ea4590f.Borrow(cxcoeff_allocs)

	var cycoeff_allocs *cgoAllocMap
	ref7ea4590f.ycoeff, cycoeff_allocs = (C.float)(x.Ycoeff), cgoAllocsUnknown
	allocs7ea4590f.Borrow(cycoeff_allocs)

	x.ref7ea4590f = ref7ea4590f
	x.allocs7ea4590f = allocs7ea4590f
	return ref7ea4590f, allocs7ea4590f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ViewportWScalingNV) PassValue() (C.VkViewportWScalingNV, *cgoAllocMap) {
	if x.ref7ea4590f != nil {
		return *x.ref7ea4590f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ViewportWScalingNV) Deref() {
	if x.ref7ea4590f == nil {
		return
	}
	x.Xcoeff = (float32)(x.ref7ea4590f.xcoeff)
	x.Ycoeff = (float32)(x.ref7ea4590f.ycoeff)
}

// allocPipelineViewportWScalingStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportWScalingStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportWScalingStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportWScalingStateCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineViewportWScalingStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportWScalingStateCreateInfoNV{})

// unpackSViewportWScalingNV transforms a sliced Go data structure into plain C format.
func unpackSViewportWScalingNV(x []ViewportWScalingNV) (unpacked *C.VkViewportWScalingNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocViewportWScalingNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkViewportWScalingNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkViewportWScalingNV)(h.Data)
	return
}

// packSViewportWScalingNV reads sliced Go data structure out from plain C format.
func packSViewportWScalingNV(v []ViewportWScalingNV, ptr0 *C.VkViewportWScalingNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfViewportWScalingNVValue]C.VkViewportWScalingNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewViewportWScalingNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportWScalingStateCreateInfoNV) Ref() *C.VkPipelineViewportWScalingStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref3e532c0b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportWScalingStateCreateInfoNV) Free() {
	if x != nil && x.allocs3e532c0b != nil {
		x.allocs3e532c0b.(*cgoAllocMap).Free()
		x.ref3e532c0b = nil
	}
}

// NewPipelineViewportWScalingStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportWScalingStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportWScalingStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportWScalingStateCreateInfoNV)
	obj.ref3e532c0b = (*C.VkPipelineViewportWScalingStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportWScalingStateCreateInfoNV) PassRef() (*C.VkPipelineViewportWScalingStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3e532c0b != nil {
		return x.ref3e532c0b, nil
	}
	mem3e532c0b := allocPipelineViewportWScalingStateCreateInfoNVMemory(1)
	ref3e532c0b := (*C.VkPipelineViewportWScalingStateCreateInfoNV)(mem3e532c0b)
	allocs3e532c0b := new(cgoAllocMap)
	allocs3e532c0b.Add(mem3e532c0b)

	var csType_allocs *cgoAllocMap
	ref3e532c0b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3e532c0b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3e532c0b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3e532c0b.Borrow(cpNext_allocs)

	var cviewportWScalingEnable_allocs *cgoAllocMap
	ref3e532c0b.viewportWScalingEnable, cviewportWScalingEnable_allocs = (C.VkBool32)(x.ViewportWScalingEnable), cgoAllocsUnknown
	allocs3e532c0b.Borrow(cviewportWScalingEnable_allocs)

	var cviewportCount_allocs *cgoAllocMap
	ref3e532c0b.viewportCount, cviewportCount_allocs = (C.uint32_t)(x.ViewportCount), cgoAllocsUnknown
	allocs3e532c0b.Borrow(cviewportCount_allocs)

	var cpViewportWScalings_allocs *cgoAllocMap
	ref3e532c0b.pViewportWScalings, cpViewportWScalings_allocs = unpackSViewportWScalingNV(x.PViewportWScalings)
	allocs3e532c0b.Borrow(cpViewportWScalings_allocs)

	x.ref3e532c0b = ref3e532c0b
	x.allocs3e532c0b = allocs3e532c0b
	return ref3e532c0b, allocs3e532c0b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportWScalingStateCreateInfoNV) PassValue() (C.VkPipelineViewportWScalingStateCreateInfoNV, *cgoAllocMap) {
	if x.ref3e532c0b != nil {
		return *x.ref3e532c0b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportWScalingStateCreateInfoNV) Deref() {
	if x.ref3e532c0b == nil {
		return
	}
	x.SType = (StructureType)(x.ref3e532c0b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3e532c0b.pNext))
	x.ViewportWScalingEnable = (Bool32)(x.ref3e532c0b.viewportWScalingEnable)
	x.ViewportCount = (uint32)(x.ref3e532c0b.viewportCount)
	packSViewportWScalingNV(x.PViewportWScalings, x.ref3e532c0b.pViewportWScalings)
}

// allocDisplayPowerInfoMemory allocates memory for type C.VkDisplayPowerInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPowerInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPowerInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayPowerInfoValue = unsafe.Sizeof([1]C.VkDisplayPowerInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPowerInfo) Ref() *C.VkDisplayPowerInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref80fed52f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPowerInfo) Free() {
	if x != nil && x.allocs80fed52f != nil {
		x.allocs80fed52f.(*cgoAllocMap).Free()
		x.ref80fed52f = nil
	}
}

// NewDisplayPowerInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPowerInfoRef(ref unsafe.Pointer) *DisplayPowerInfo {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPowerInfo)
	obj.ref80fed52f = (*C.VkDisplayPowerInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPowerInfo) PassRef() (*C.VkDisplayPowerInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref80fed52f != nil {
		return x.ref80fed52f, nil
	}
	mem80fed52f := allocDisplayPowerInfoMemory(1)
	ref80fed52f := (*C.VkDisplayPowerInfoEXT)(mem80fed52f)
	allocs80fed52f := new(cgoAllocMap)
	allocs80fed52f.Add(mem80fed52f)

	var csType_allocs *cgoAllocMap
	ref80fed52f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs80fed52f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref80fed52f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs80fed52f.Borrow(cpNext_allocs)

	var cpowerState_allocs *cgoAllocMap
	ref80fed52f.powerState, cpowerState_allocs = (C.VkDisplayPowerStateEXT)(x.PowerState), cgoAllocsUnknown
	allocs80fed52f.Borrow(cpowerState_allocs)

	x.ref80fed52f = ref80fed52f
	x.allocs80fed52f = allocs80fed52f
	return ref80fed52f, allocs80fed52f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPowerInfo) PassValue() (C.VkDisplayPowerInfoEXT, *cgoAllocMap) {
	if x.ref80fed52f != nil {
		return *x.ref80fed52f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPowerInfo) Deref() {
	if x.ref80fed52f == nil {
		return
	}
	x.SType = (StructureType)(x.ref80fed52f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref80fed52f.pNext))
	x.PowerState = (DisplayPowerState)(x.ref80fed52f.powerState)
}

// allocDeviceEventInfoMemory allocates memory for type C.VkDeviceEventInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceEventInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceEventInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceEventInfoValue = unsafe.Sizeof([1]C.VkDeviceEventInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceEventInfo) Ref() *C.VkDeviceEventInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref394b3fcb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceEventInfo) Free() {
	if x != nil && x.allocs394b3fcb != nil {
		x.allocs394b3fcb.(*cgoAllocMap).Free()
		x.ref394b3fcb = nil
	}
}

// NewDeviceEventInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceEventInfoRef(ref unsafe.Pointer) *DeviceEventInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceEventInfo)
	obj.ref394b3fcb = (*C.VkDeviceEventInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceEventInfo) PassRef() (*C.VkDeviceEventInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref394b3fcb != nil {
		return x.ref394b3fcb, nil
	}
	mem394b3fcb := allocDeviceEventInfoMemory(1)
	ref394b3fcb := (*C.VkDeviceEventInfoEXT)(mem394b3fcb)
	allocs394b3fcb := new(cgoAllocMap)
	allocs394b3fcb.Add(mem394b3fcb)

	var csType_allocs *cgoAllocMap
	ref394b3fcb.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs394b3fcb.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref394b3fcb.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs394b3fcb.Borrow(cpNext_allocs)

	var cdeviceEvent_allocs *cgoAllocMap
	ref394b3fcb.deviceEvent, cdeviceEvent_allocs = (C.VkDeviceEventTypeEXT)(x.DeviceEvent), cgoAllocsUnknown
	allocs394b3fcb.Borrow(cdeviceEvent_allocs)

	x.ref394b3fcb = ref394b3fcb
	x.allocs394b3fcb = allocs394b3fcb
	return ref394b3fcb, allocs394b3fcb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceEventInfo) PassValue() (C.VkDeviceEventInfoEXT, *cgoAllocMap) {
	if x.ref394b3fcb != nil {
		return *x.ref394b3fcb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceEventInfo) Deref() {
	if x.ref394b3fcb == nil {
		return
	}
	x.SType = (StructureType)(x.ref394b3fcb.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref394b3fcb.pNext))
	x.DeviceEvent = (DeviceEventType)(x.ref394b3fcb.deviceEvent)
}

// allocDisplayEventInfoMemory allocates memory for type C.VkDisplayEventInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayEventInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayEventInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayEventInfoValue = unsafe.Sizeof([1]C.VkDisplayEventInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayEventInfo) Ref() *C.VkDisplayEventInfoEXT {
	if x == nil {
		return nil
	}
	return x.refa69f7302
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayEventInfo) Free() {
	if x != nil && x.allocsa69f7302 != nil {
		x.allocsa69f7302.(*cgoAllocMap).Free()
		x.refa69f7302 = nil
	}
}

// NewDisplayEventInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayEventInfoRef(ref unsafe.Pointer) *DisplayEventInfo {
	if ref == nil {
		return nil
	}
	obj := new(DisplayEventInfo)
	obj.refa69f7302 = (*C.VkDisplayEventInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayEventInfo) PassRef() (*C.VkDisplayEventInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa69f7302 != nil {
		return x.refa69f7302, nil
	}
	mema69f7302 := allocDisplayEventInfoMemory(1)
	refa69f7302 := (*C.VkDisplayEventInfoEXT)(mema69f7302)
	allocsa69f7302 := new(cgoAllocMap)
	allocsa69f7302.Add(mema69f7302)

	var csType_allocs *cgoAllocMap
	refa69f7302.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa69f7302.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa69f7302.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa69f7302.Borrow(cpNext_allocs)

	var cdisplayEvent_allocs *cgoAllocMap
	refa69f7302.displayEvent, cdisplayEvent_allocs = (C.VkDisplayEventTypeEXT)(x.DisplayEvent), cgoAllocsUnknown
	allocsa69f7302.Borrow(cdisplayEvent_allocs)

	x.refa69f7302 = refa69f7302
	x.allocsa69f7302 = allocsa69f7302
	return refa69f7302, allocsa69f7302

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayEventInfo) PassValue() (C.VkDisplayEventInfoEXT, *cgoAllocMap) {
	if x.refa69f7302 != nil {
		return *x.refa69f7302, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayEventInfo) Deref() {
	if x.refa69f7302 == nil {
		return
	}
	x.SType = (StructureType)(x.refa69f7302.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa69f7302.pNext))
	x.DisplayEvent = (DisplayEventType)(x.refa69f7302.displayEvent)
}

// allocSwapchainCounterCreateInfoMemory allocates memory for type C.VkSwapchainCounterCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSwapchainCounterCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSwapchainCounterCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSwapchainCounterCreateInfoValue = unsafe.Sizeof([1]C.VkSwapchainCounterCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SwapchainCounterCreateInfo) Ref() *C.VkSwapchainCounterCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref9f21eca6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SwapchainCounterCreateInfo) Free() {
	if x != nil && x.allocs9f21eca6 != nil {
		x.allocs9f21eca6.(*cgoAllocMap).Free()
		x.ref9f21eca6 = nil
	}
}

// NewSwapchainCounterCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSwapchainCounterCreateInfoRef(ref unsafe.Pointer) *SwapchainCounterCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SwapchainCounterCreateInfo)
	obj.ref9f21eca6 = (*C.VkSwapchainCounterCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SwapchainCounterCreateInfo) PassRef() (*C.VkSwapchainCounterCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9f21eca6 != nil {
		return x.ref9f21eca6, nil
	}
	mem9f21eca6 := allocSwapchainCounterCreateInfoMemory(1)
	ref9f21eca6 := (*C.VkSwapchainCounterCreateInfoEXT)(mem9f21eca6)
	allocs9f21eca6 := new(cgoAllocMap)
	allocs9f21eca6.Add(mem9f21eca6)

	var csType_allocs *cgoAllocMap
	ref9f21eca6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9f21eca6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9f21eca6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9f21eca6.Borrow(cpNext_allocs)

	var csurfaceCounters_allocs *cgoAllocMap
	ref9f21eca6.surfaceCounters, csurfaceCounters_allocs = (C.VkSurfaceCounterFlagsEXT)(x.SurfaceCounters), cgoAllocsUnknown
	allocs9f21eca6.Borrow(csurfaceCounters_allocs)

	x.ref9f21eca6 = ref9f21eca6
	x.allocs9f21eca6 = allocs9f21eca6
	return ref9f21eca6, allocs9f21eca6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SwapchainCounterCreateInfo) PassValue() (C.VkSwapchainCounterCreateInfoEXT, *cgoAllocMap) {
	if x.ref9f21eca6 != nil {
		return *x.ref9f21eca6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SwapchainCounterCreateInfo) Deref() {
	if x.ref9f21eca6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9f21eca6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9f21eca6.pNext))
	x.SurfaceCounters = (SurfaceCounterFlags)(x.ref9f21eca6.surfaceCounters)
}

// allocRefreshCycleDurationGOOGLEMemory allocates memory for type C.VkRefreshCycleDurationGOOGLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRefreshCycleDurationGOOGLEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRefreshCycleDurationGOOGLEValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRefreshCycleDurationGOOGLEValue = unsafe.Sizeof([1]C.VkRefreshCycleDurationGOOGLE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RefreshCycleDurationGOOGLE) Ref() *C.VkRefreshCycleDurationGOOGLE {
	if x == nil {
		return nil
	}
	return x.ref969cb55b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RefreshCycleDurationGOOGLE) Free() {
	if x != nil && x.allocs969cb55b != nil {
		x.allocs969cb55b.(*cgoAllocMap).Free()
		x.ref969cb55b = nil
	}
}

// NewRefreshCycleDurationGOOGLERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRefreshCycleDurationGOOGLERef(ref unsafe.Pointer) *RefreshCycleDurationGOOGLE {
	if ref == nil {
		return nil
	}
	obj := new(RefreshCycleDurationGOOGLE)
	obj.ref969cb55b = (*C.VkRefreshCycleDurationGOOGLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RefreshCycleDurationGOOGLE) PassRef() (*C.VkRefreshCycleDurationGOOGLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref969cb55b != nil {
		return x.ref969cb55b, nil
	}
	mem969cb55b := allocRefreshCycleDurationGOOGLEMemory(1)
	ref969cb55b := (*C.VkRefreshCycleDurationGOOGLE)(mem969cb55b)
	allocs969cb55b := new(cgoAllocMap)
	allocs969cb55b.Add(mem969cb55b)

	var crefreshDuration_allocs *cgoAllocMap
	ref969cb55b.refreshDuration, crefreshDuration_allocs = (C.uint64_t)(x.RefreshDuration), cgoAllocsUnknown
	allocs969cb55b.Borrow(crefreshDuration_allocs)

	x.ref969cb55b = ref969cb55b
	x.allocs969cb55b = allocs969cb55b
	return ref969cb55b, allocs969cb55b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RefreshCycleDurationGOOGLE) PassValue() (C.VkRefreshCycleDurationGOOGLE, *cgoAllocMap) {
	if x.ref969cb55b != nil {
		return *x.ref969cb55b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RefreshCycleDurationGOOGLE) Deref() {
	if x.ref969cb55b == nil {
		return
	}
	x.RefreshDuration = (uint32)(x.ref969cb55b.refreshDuration)
}

// allocPastPresentationTimingGOOGLEMemory allocates memory for type C.VkPastPresentationTimingGOOGLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPastPresentationTimingGOOGLEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPastPresentationTimingGOOGLEValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPastPresentationTimingGOOGLEValue = unsafe.Sizeof([1]C.VkPastPresentationTimingGOOGLE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PastPresentationTimingGOOGLE) Ref() *C.VkPastPresentationTimingGOOGLE {
	if x == nil {
		return nil
	}
	return x.refac8cf1d8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PastPresentationTimingGOOGLE) Free() {
	if x != nil && x.allocsac8cf1d8 != nil {
		x.allocsac8cf1d8.(*cgoAllocMap).Free()
		x.refac8cf1d8 = nil
	}
}

// NewPastPresentationTimingGOOGLERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPastPresentationTimingGOOGLERef(ref unsafe.Pointer) *PastPresentationTimingGOOGLE {
	if ref == nil {
		return nil
	}
	obj := new(PastPresentationTimingGOOGLE)
	obj.refac8cf1d8 = (*C.VkPastPresentationTimingGOOGLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PastPresentationTimingGOOGLE) PassRef() (*C.VkPastPresentationTimingGOOGLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refac8cf1d8 != nil {
		return x.refac8cf1d8, nil
	}
	memac8cf1d8 := allocPastPresentationTimingGOOGLEMemory(1)
	refac8cf1d8 := (*C.VkPastPresentationTimingGOOGLE)(memac8cf1d8)
	allocsac8cf1d8 := new(cgoAllocMap)
	allocsac8cf1d8.Add(memac8cf1d8)

	var cpresentID_allocs *cgoAllocMap
	refac8cf1d8.presentID, cpresentID_allocs = (C.uint32_t)(x.PresentID), cgoAllocsUnknown
	allocsac8cf1d8.Borrow(cpresentID_allocs)

	var cdesiredPresentTime_allocs *cgoAllocMap
	refac8cf1d8.desiredPresentTime, cdesiredPresentTime_allocs = (C.uint64_t)(x.DesiredPresentTime), cgoAllocsUnknown
	allocsac8cf1d8.Borrow(cdesiredPresentTime_allocs)

	var cactualPresentTime_allocs *cgoAllocMap
	refac8cf1d8.actualPresentTime, cactualPresentTime_allocs = (C.uint64_t)(x.ActualPresentTime), cgoAllocsUnknown
	allocsac8cf1d8.Borrow(cactualPresentTime_allocs)

	var cearliestPresentTime_allocs *cgoAllocMap
	refac8cf1d8.earliestPresentTime, cearliestPresentTime_allocs = (C.uint64_t)(x.EarliestPresentTime), cgoAllocsUnknown
	allocsac8cf1d8.Borrow(cearliestPresentTime_allocs)

	var cpresentMargin_allocs *cgoAllocMap
	refac8cf1d8.presentMargin, cpresentMargin_allocs = (C.uint64_t)(x.PresentMargin), cgoAllocsUnknown
	allocsac8cf1d8.Borrow(cpresentMargin_allocs)

	x.refac8cf1d8 = refac8cf1d8
	x.allocsac8cf1d8 = allocsac8cf1d8
	return refac8cf1d8, allocsac8cf1d8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PastPresentationTimingGOOGLE) PassValue() (C.VkPastPresentationTimingGOOGLE, *cgoAllocMap) {
	if x.refac8cf1d8 != nil {
		return *x.refac8cf1d8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PastPresentationTimingGOOGLE) Deref() {
	if x.refac8cf1d8 == nil {
		return
	}
	x.PresentID = (uint32)(x.refac8cf1d8.presentID)
	x.DesiredPresentTime = (uint32)(x.refac8cf1d8.desiredPresentTime)
	x.ActualPresentTime = (uint32)(x.refac8cf1d8.actualPresentTime)
	x.EarliestPresentTime = (uint32)(x.refac8cf1d8.earliestPresentTime)
	x.PresentMargin = (uint32)(x.refac8cf1d8.presentMargin)
}

// allocPresentTimeGOOGLEMemory allocates memory for type C.VkPresentTimeGOOGLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentTimeGOOGLEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentTimeGOOGLEValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPresentTimeGOOGLEValue = unsafe.Sizeof([1]C.VkPresentTimeGOOGLE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentTimeGOOGLE) Ref() *C.VkPresentTimeGOOGLE {
	if x == nil {
		return nil
	}
	return x.ref9cd90ade
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentTimeGOOGLE) Free() {
	if x != nil && x.allocs9cd90ade != nil {
		x.allocs9cd90ade.(*cgoAllocMap).Free()
		x.ref9cd90ade = nil
	}
}

// NewPresentTimeGOOGLERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentTimeGOOGLERef(ref unsafe.Pointer) *PresentTimeGOOGLE {
	if ref == nil {
		return nil
	}
	obj := new(PresentTimeGOOGLE)
	obj.ref9cd90ade = (*C.VkPresentTimeGOOGLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentTimeGOOGLE) PassRef() (*C.VkPresentTimeGOOGLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9cd90ade != nil {
		return x.ref9cd90ade, nil
	}
	mem9cd90ade := allocPresentTimeGOOGLEMemory(1)
	ref9cd90ade := (*C.VkPresentTimeGOOGLE)(mem9cd90ade)
	allocs9cd90ade := new(cgoAllocMap)
	allocs9cd90ade.Add(mem9cd90ade)

	var cpresentID_allocs *cgoAllocMap
	ref9cd90ade.presentID, cpresentID_allocs = (C.uint32_t)(x.PresentID), cgoAllocsUnknown
	allocs9cd90ade.Borrow(cpresentID_allocs)

	var cdesiredPresentTime_allocs *cgoAllocMap
	ref9cd90ade.desiredPresentTime, cdesiredPresentTime_allocs = (C.uint64_t)(x.DesiredPresentTime), cgoAllocsUnknown
	allocs9cd90ade.Borrow(cdesiredPresentTime_allocs)

	x.ref9cd90ade = ref9cd90ade
	x.allocs9cd90ade = allocs9cd90ade
	return ref9cd90ade, allocs9cd90ade

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentTimeGOOGLE) PassValue() (C.VkPresentTimeGOOGLE, *cgoAllocMap) {
	if x.ref9cd90ade != nil {
		return *x.ref9cd90ade, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentTimeGOOGLE) Deref() {
	if x.ref9cd90ade == nil {
		return
	}
	x.PresentID = (uint32)(x.ref9cd90ade.presentID)
	x.DesiredPresentTime = (uint32)(x.ref9cd90ade.desiredPresentTime)
}

// allocPresentTimesInfoGOOGLEMemory allocates memory for type C.VkPresentTimesInfoGOOGLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentTimesInfoGOOGLEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentTimesInfoGOOGLEValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPresentTimesInfoGOOGLEValue = unsafe.Sizeof([1]C.VkPresentTimesInfoGOOGLE{})

// unpackSPresentTimeGOOGLE transforms a sliced Go data structure into plain C format.
func unpackSPresentTimeGOOGLE(x []PresentTimeGOOGLE) (unpacked *C.VkPresentTimeGOOGLE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPresentTimeGOOGLEMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPresentTimeGOOGLE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPresentTimeGOOGLE)(h.Data)
	return
}

// packSPresentTimeGOOGLE reads sliced Go data structure out from plain C format.
func packSPresentTimeGOOGLE(v []PresentTimeGOOGLE, ptr0 *C.VkPresentTimeGOOGLE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPresentTimeGOOGLEValue]C.VkPresentTimeGOOGLE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPresentTimeGOOGLERef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentTimesInfoGOOGLE) Ref() *C.VkPresentTimesInfoGOOGLE {
	if x == nil {
		return nil
	}
	return x.ref70eb8ab3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentTimesInfoGOOGLE) Free() {
	if x != nil && x.allocs70eb8ab3 != nil {
		x.allocs70eb8ab3.(*cgoAllocMap).Free()
		x.ref70eb8ab3 = nil
	}
}

// NewPresentTimesInfoGOOGLERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentTimesInfoGOOGLERef(ref unsafe.Pointer) *PresentTimesInfoGOOGLE {
	if ref == nil {
		return nil
	}
	obj := new(PresentTimesInfoGOOGLE)
	obj.ref70eb8ab3 = (*C.VkPresentTimesInfoGOOGLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentTimesInfoGOOGLE) PassRef() (*C.VkPresentTimesInfoGOOGLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref70eb8ab3 != nil {
		return x.ref70eb8ab3, nil
	}
	mem70eb8ab3 := allocPresentTimesInfoGOOGLEMemory(1)
	ref70eb8ab3 := (*C.VkPresentTimesInfoGOOGLE)(mem70eb8ab3)
	allocs70eb8ab3 := new(cgoAllocMap)
	allocs70eb8ab3.Add(mem70eb8ab3)

	var csType_allocs *cgoAllocMap
	ref70eb8ab3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs70eb8ab3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref70eb8ab3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs70eb8ab3.Borrow(cpNext_allocs)

	var cswapchainCount_allocs *cgoAllocMap
	ref70eb8ab3.swapchainCount, cswapchainCount_allocs = (C.uint32_t)(x.SwapchainCount), cgoAllocsUnknown
	allocs70eb8ab3.Borrow(cswapchainCount_allocs)

	var cpTimes_allocs *cgoAllocMap
	ref70eb8ab3.pTimes, cpTimes_allocs = unpackSPresentTimeGOOGLE(x.PTimes)
	allocs70eb8ab3.Borrow(cpTimes_allocs)

	x.ref70eb8ab3 = ref70eb8ab3
	x.allocs70eb8ab3 = allocs70eb8ab3
	return ref70eb8ab3, allocs70eb8ab3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentTimesInfoGOOGLE) PassValue() (C.VkPresentTimesInfoGOOGLE, *cgoAllocMap) {
	if x.ref70eb8ab3 != nil {
		return *x.ref70eb8ab3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentTimesInfoGOOGLE) Deref() {
	if x.ref70eb8ab3 == nil {
		return
	}
	x.SType = (StructureType)(x.ref70eb8ab3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref70eb8ab3.pNext))
	x.SwapchainCount = (uint32)(x.ref70eb8ab3.swapchainCount)
	packSPresentTimeGOOGLE(x.PTimes, x.ref70eb8ab3.pTimes)
}

// allocPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXMemory allocates memory for type C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) Ref() *C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
	if x == nil {
		return nil
	}
	return x.refbaf399ad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) Free() {
	if x != nil && x.allocsbaf399ad != nil {
		x.allocsbaf399ad.(*cgoAllocMap).Free()
		x.refbaf399ad = nil
	}
}

// NewPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXRef(ref unsafe.Pointer) *PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX)
	obj.refbaf399ad = (*C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) PassRef() (*C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbaf399ad != nil {
		return x.refbaf399ad, nil
	}
	membaf399ad := allocPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXMemory(1)
	refbaf399ad := (*C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX)(membaf399ad)
	allocsbaf399ad := new(cgoAllocMap)
	allocsbaf399ad.Add(membaf399ad)

	var csType_allocs *cgoAllocMap
	refbaf399ad.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbaf399ad.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbaf399ad.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbaf399ad.Borrow(cpNext_allocs)

	var cperViewPositionAllComponents_allocs *cgoAllocMap
	refbaf399ad.perViewPositionAllComponents, cperViewPositionAllComponents_allocs = (C.VkBool32)(x.PerViewPositionAllComponents), cgoAllocsUnknown
	allocsbaf399ad.Borrow(cperViewPositionAllComponents_allocs)

	x.refbaf399ad = refbaf399ad
	x.allocsbaf399ad = allocsbaf399ad
	return refbaf399ad, allocsbaf399ad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) PassValue() (C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, *cgoAllocMap) {
	if x.refbaf399ad != nil {
		return *x.refbaf399ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) Deref() {
	if x.refbaf399ad == nil {
		return
	}
	x.SType = (StructureType)(x.refbaf399ad.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbaf399ad.pNext))
	x.PerViewPositionAllComponents = (Bool32)(x.refbaf399ad.perViewPositionAllComponents)
}

// allocViewportSwizzleNVMemory allocates memory for type C.VkViewportSwizzleNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocViewportSwizzleNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfViewportSwizzleNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfViewportSwizzleNVValue = unsafe.Sizeof([1]C.VkViewportSwizzleNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ViewportSwizzleNV) Ref() *C.VkViewportSwizzleNV {
	if x == nil {
		return nil
	}
	return x.ref74ff2887
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ViewportSwizzleNV) Free() {
	if x != nil && x.allocs74ff2887 != nil {
		x.allocs74ff2887.(*cgoAllocMap).Free()
		x.ref74ff2887 = nil
	}
}

// NewViewportSwizzleNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewViewportSwizzleNVRef(ref unsafe.Pointer) *ViewportSwizzleNV {
	if ref == nil {
		return nil
	}
	obj := new(ViewportSwizzleNV)
	obj.ref74ff2887 = (*C.VkViewportSwizzleNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ViewportSwizzleNV) PassRef() (*C.VkViewportSwizzleNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref74ff2887 != nil {
		return x.ref74ff2887, nil
	}
	mem74ff2887 := allocViewportSwizzleNVMemory(1)
	ref74ff2887 := (*C.VkViewportSwizzleNV)(mem74ff2887)
	allocs74ff2887 := new(cgoAllocMap)
	allocs74ff2887.Add(mem74ff2887)

	var cx_allocs *cgoAllocMap
	ref74ff2887.x, cx_allocs = (C.VkViewportCoordinateSwizzleNV)(x.X), cgoAllocsUnknown
	allocs74ff2887.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref74ff2887.y, cy_allocs = (C.VkViewportCoordinateSwizzleNV)(x.Y), cgoAllocsUnknown
	allocs74ff2887.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	ref74ff2887.z, cz_allocs = (C.VkViewportCoordinateSwizzleNV)(x.Z), cgoAllocsUnknown
	allocs74ff2887.Borrow(cz_allocs)

	var cw_allocs *cgoAllocMap
	ref74ff2887.w, cw_allocs = (C.VkViewportCoordinateSwizzleNV)(x.W), cgoAllocsUnknown
	allocs74ff2887.Borrow(cw_allocs)

	x.ref74ff2887 = ref74ff2887
	x.allocs74ff2887 = allocs74ff2887
	return ref74ff2887, allocs74ff2887

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ViewportSwizzleNV) PassValue() (C.VkViewportSwizzleNV, *cgoAllocMap) {
	if x.ref74ff2887 != nil {
		return *x.ref74ff2887, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ViewportSwizzleNV) Deref() {
	if x.ref74ff2887 == nil {
		return
	}
	x.X = (ViewportCoordinateSwizzleNV)(x.ref74ff2887.x)
	x.Y = (ViewportCoordinateSwizzleNV)(x.ref74ff2887.y)
	x.Z = (ViewportCoordinateSwizzleNV)(x.ref74ff2887.z)
	x.W = (ViewportCoordinateSwizzleNV)(x.ref74ff2887.w)
}

// allocPipelineViewportSwizzleStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportSwizzleStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportSwizzleStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportSwizzleStateCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineViewportSwizzleStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportSwizzleStateCreateInfoNV{})

// unpackSViewportSwizzleNV transforms a sliced Go data structure into plain C format.
func unpackSViewportSwizzleNV(x []ViewportSwizzleNV) (unpacked *C.VkViewportSwizzleNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocViewportSwizzleNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkViewportSwizzleNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkViewportSwizzleNV)(h.Data)
	return
}

// packSViewportSwizzleNV reads sliced Go data structure out from plain C format.
func packSViewportSwizzleNV(v []ViewportSwizzleNV, ptr0 *C.VkViewportSwizzleNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfViewportSwizzleNVValue]C.VkViewportSwizzleNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewViewportSwizzleNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportSwizzleStateCreateInfoNV) Ref() *C.VkPipelineViewportSwizzleStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref5e90f24
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportSwizzleStateCreateInfoNV) Free() {
	if x != nil && x.allocs5e90f24 != nil {
		x.allocs5e90f24.(*cgoAllocMap).Free()
		x.ref5e90f24 = nil
	}
}

// NewPipelineViewportSwizzleStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportSwizzleStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportSwizzleStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportSwizzleStateCreateInfoNV)
	obj.ref5e90f24 = (*C.VkPipelineViewportSwizzleStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportSwizzleStateCreateInfoNV) PassRef() (*C.VkPipelineViewportSwizzleStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e90f24 != nil {
		return x.ref5e90f24, nil
	}
	mem5e90f24 := allocPipelineViewportSwizzleStateCreateInfoNVMemory(1)
	ref5e90f24 := (*C.VkPipelineViewportSwizzleStateCreateInfoNV)(mem5e90f24)
	allocs5e90f24 := new(cgoAllocMap)
	allocs5e90f24.Add(mem5e90f24)

	var csType_allocs *cgoAllocMap
	ref5e90f24.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5e90f24.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5e90f24.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5e90f24.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref5e90f24.flags, cflags_allocs = (C.VkPipelineViewportSwizzleStateCreateFlagsNV)(x.Flags), cgoAllocsUnknown
	allocs5e90f24.Borrow(cflags_allocs)

	var cviewportCount_allocs *cgoAllocMap
	ref5e90f24.viewportCount, cviewportCount_allocs = (C.uint32_t)(x.ViewportCount), cgoAllocsUnknown
	allocs5e90f24.Borrow(cviewportCount_allocs)

	var cpViewportSwizzles_allocs *cgoAllocMap
	ref5e90f24.pViewportSwizzles, cpViewportSwizzles_allocs = unpackSViewportSwizzleNV(x.PViewportSwizzles)
	allocs5e90f24.Borrow(cpViewportSwizzles_allocs)

	x.ref5e90f24 = ref5e90f24
	x.allocs5e90f24 = allocs5e90f24
	return ref5e90f24, allocs5e90f24

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportSwizzleStateCreateInfoNV) PassValue() (C.VkPipelineViewportSwizzleStateCreateInfoNV, *cgoAllocMap) {
	if x.ref5e90f24 != nil {
		return *x.ref5e90f24, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportSwizzleStateCreateInfoNV) Deref() {
	if x.ref5e90f24 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5e90f24.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5e90f24.pNext))
	x.Flags = (PipelineViewportSwizzleStateCreateFlagsNV)(x.ref5e90f24.flags)
	x.ViewportCount = (uint32)(x.ref5e90f24.viewportCount)
	packSViewportSwizzleNV(x.PViewportSwizzles, x.ref5e90f24.pViewportSwizzles)
}

// allocPhysicalDeviceDiscardRectanglePropertiesMemory allocates memory for type C.VkPhysicalDeviceDiscardRectanglePropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDiscardRectanglePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDiscardRectanglePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceDiscardRectanglePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDiscardRectanglePropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDiscardRectangleProperties) Ref() *C.VkPhysicalDeviceDiscardRectanglePropertiesEXT {
	if x == nil {
		return nil
	}
	return x.reffe8591da
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDiscardRectangleProperties) Free() {
	if x != nil && x.allocsfe8591da != nil {
		x.allocsfe8591da.(*cgoAllocMap).Free()
		x.reffe8591da = nil
	}
}

// NewPhysicalDeviceDiscardRectanglePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDiscardRectanglePropertiesRef(ref unsafe.Pointer) *PhysicalDeviceDiscardRectangleProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDiscardRectangleProperties)
	obj.reffe8591da = (*C.VkPhysicalDeviceDiscardRectanglePropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDiscardRectangleProperties) PassRef() (*C.VkPhysicalDeviceDiscardRectanglePropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe8591da != nil {
		return x.reffe8591da, nil
	}
	memfe8591da := allocPhysicalDeviceDiscardRectanglePropertiesMemory(1)
	reffe8591da := (*C.VkPhysicalDeviceDiscardRectanglePropertiesEXT)(memfe8591da)
	allocsfe8591da := new(cgoAllocMap)
	allocsfe8591da.Add(memfe8591da)

	var csType_allocs *cgoAllocMap
	reffe8591da.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfe8591da.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffe8591da.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfe8591da.Borrow(cpNext_allocs)

	var cmaxDiscardRectangles_allocs *cgoAllocMap
	reffe8591da.maxDiscardRectangles, cmaxDiscardRectangles_allocs = (C.uint32_t)(x.MaxDiscardRectangles), cgoAllocsUnknown
	allocsfe8591da.Borrow(cmaxDiscardRectangles_allocs)

	x.reffe8591da = reffe8591da
	x.allocsfe8591da = allocsfe8591da
	return reffe8591da, allocsfe8591da

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDiscardRectangleProperties) PassValue() (C.VkPhysicalDeviceDiscardRectanglePropertiesEXT, *cgoAllocMap) {
	if x.reffe8591da != nil {
		return *x.reffe8591da, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDiscardRectangleProperties) Deref() {
	if x.reffe8591da == nil {
		return
	}
	x.SType = (StructureType)(x.reffe8591da.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe8591da.pNext))
	x.MaxDiscardRectangles = (uint32)(x.reffe8591da.maxDiscardRectangles)
}

// allocPipelineDiscardRectangleStateCreateInfoMemory allocates memory for type C.VkPipelineDiscardRectangleStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineDiscardRectangleStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineDiscardRectangleStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineDiscardRectangleStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineDiscardRectangleStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineDiscardRectangleStateCreateInfo) Ref() *C.VkPipelineDiscardRectangleStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refcdbb125e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineDiscardRectangleStateCreateInfo) Free() {
	if x != nil && x.allocscdbb125e != nil {
		x.allocscdbb125e.(*cgoAllocMap).Free()
		x.refcdbb125e = nil
	}
}

// NewPipelineDiscardRectangleStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineDiscardRectangleStateCreateInfoRef(ref unsafe.Pointer) *PipelineDiscardRectangleStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineDiscardRectangleStateCreateInfo)
	obj.refcdbb125e = (*C.VkPipelineDiscardRectangleStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineDiscardRectangleStateCreateInfo) PassRef() (*C.VkPipelineDiscardRectangleStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcdbb125e != nil {
		return x.refcdbb125e, nil
	}
	memcdbb125e := allocPipelineDiscardRectangleStateCreateInfoMemory(1)
	refcdbb125e := (*C.VkPipelineDiscardRectangleStateCreateInfoEXT)(memcdbb125e)
	allocscdbb125e := new(cgoAllocMap)
	allocscdbb125e.Add(memcdbb125e)

	var csType_allocs *cgoAllocMap
	refcdbb125e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscdbb125e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcdbb125e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscdbb125e.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refcdbb125e.flags, cflags_allocs = (C.VkPipelineDiscardRectangleStateCreateFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocscdbb125e.Borrow(cflags_allocs)

	var cdiscardRectangleMode_allocs *cgoAllocMap
	refcdbb125e.discardRectangleMode, cdiscardRectangleMode_allocs = (C.VkDiscardRectangleModeEXT)(x.DiscardRectangleMode), cgoAllocsUnknown
	allocscdbb125e.Borrow(cdiscardRectangleMode_allocs)

	var cdiscardRectangleCount_allocs *cgoAllocMap
	refcdbb125e.discardRectangleCount, cdiscardRectangleCount_allocs = (C.uint32_t)(x.DiscardRectangleCount), cgoAllocsUnknown
	allocscdbb125e.Borrow(cdiscardRectangleCount_allocs)

	var cpDiscardRectangles_allocs *cgoAllocMap
	refcdbb125e.pDiscardRectangles, cpDiscardRectangles_allocs = unpackSRect2D(x.PDiscardRectangles)
	allocscdbb125e.Borrow(cpDiscardRectangles_allocs)

	x.refcdbb125e = refcdbb125e
	x.allocscdbb125e = allocscdbb125e
	return refcdbb125e, allocscdbb125e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineDiscardRectangleStateCreateInfo) PassValue() (C.VkPipelineDiscardRectangleStateCreateInfoEXT, *cgoAllocMap) {
	if x.refcdbb125e != nil {
		return *x.refcdbb125e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineDiscardRectangleStateCreateInfo) Deref() {
	if x.refcdbb125e == nil {
		return
	}
	x.SType = (StructureType)(x.refcdbb125e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcdbb125e.pNext))
	x.Flags = (PipelineDiscardRectangleStateCreateFlags)(x.refcdbb125e.flags)
	x.DiscardRectangleMode = (DiscardRectangleMode)(x.refcdbb125e.discardRectangleMode)
	x.DiscardRectangleCount = (uint32)(x.refcdbb125e.discardRectangleCount)
	packSRect2D(x.PDiscardRectangles, x.refcdbb125e.pDiscardRectangles)
}

// allocPhysicalDeviceConservativeRasterizationPropertiesMemory allocates memory for type C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceConservativeRasterizationPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceConservativeRasterizationPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceConservativeRasterizationPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceConservativeRasterizationProperties) Ref() *C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref878f819c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceConservativeRasterizationProperties) Free() {
	if x != nil && x.allocs878f819c != nil {
		x.allocs878f819c.(*cgoAllocMap).Free()
		x.ref878f819c = nil
	}
}

// NewPhysicalDeviceConservativeRasterizationPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceConservativeRasterizationPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceConservativeRasterizationProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceConservativeRasterizationProperties)
	obj.ref878f819c = (*C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceConservativeRasterizationProperties) PassRef() (*C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref878f819c != nil {
		return x.ref878f819c, nil
	}
	mem878f819c := allocPhysicalDeviceConservativeRasterizationPropertiesMemory(1)
	ref878f819c := (*C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT)(mem878f819c)
	allocs878f819c := new(cgoAllocMap)
	allocs878f819c.Add(mem878f819c)

	var csType_allocs *cgoAllocMap
	ref878f819c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs878f819c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref878f819c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs878f819c.Borrow(cpNext_allocs)

	var cprimitiveOverestimationSize_allocs *cgoAllocMap
	ref878f819c.primitiveOverestimationSize, cprimitiveOverestimationSize_allocs = (C.float)(x.PrimitiveOverestimationSize), cgoAllocsUnknown
	allocs878f819c.Borrow(cprimitiveOverestimationSize_allocs)

	var cmaxExtraPrimitiveOverestimationSize_allocs *cgoAllocMap
	ref878f819c.maxExtraPrimitiveOverestimationSize, cmaxExtraPrimitiveOverestimationSize_allocs = (C.float)(x.MaxExtraPrimitiveOverestimationSize), cgoAllocsUnknown
	allocs878f819c.Borrow(cmaxExtraPrimitiveOverestimationSize_allocs)

	var cextraPrimitiveOverestimationSizeGranularity_allocs *cgoAllocMap
	ref878f819c.extraPrimitiveOverestimationSizeGranularity, cextraPrimitiveOverestimationSizeGranularity_allocs = (C.float)(x.ExtraPrimitiveOverestimationSizeGranularity), cgoAllocsUnknown
	allocs878f819c.Borrow(cextraPrimitiveOverestimationSizeGranularity_allocs)

	var cprimitiveUnderestimation_allocs *cgoAllocMap
	ref878f819c.primitiveUnderestimation, cprimitiveUnderestimation_allocs = (C.VkBool32)(x.PrimitiveUnderestimation), cgoAllocsUnknown
	allocs878f819c.Borrow(cprimitiveUnderestimation_allocs)

	var cconservativePointAndLineRasterization_allocs *cgoAllocMap
	ref878f819c.conservativePointAndLineRasterization, cconservativePointAndLineRasterization_allocs = (C.VkBool32)(x.ConservativePointAndLineRasterization), cgoAllocsUnknown
	allocs878f819c.Borrow(cconservativePointAndLineRasterization_allocs)

	var cdegenerateTrianglesRasterized_allocs *cgoAllocMap
	ref878f819c.degenerateTrianglesRasterized, cdegenerateTrianglesRasterized_allocs = (C.VkBool32)(x.DegenerateTrianglesRasterized), cgoAllocsUnknown
	allocs878f819c.Borrow(cdegenerateTrianglesRasterized_allocs)

	var cdegenerateLinesRasterized_allocs *cgoAllocMap
	ref878f819c.degenerateLinesRasterized, cdegenerateLinesRasterized_allocs = (C.VkBool32)(x.DegenerateLinesRasterized), cgoAllocsUnknown
	allocs878f819c.Borrow(cdegenerateLinesRasterized_allocs)

	var cfullyCoveredFragmentShaderInputVariable_allocs *cgoAllocMap
	ref878f819c.fullyCoveredFragmentShaderInputVariable, cfullyCoveredFragmentShaderInputVariable_allocs = (C.VkBool32)(x.FullyCoveredFragmentShaderInputVariable), cgoAllocsUnknown
	allocs878f819c.Borrow(cfullyCoveredFragmentShaderInputVariable_allocs)

	var cconservativeRasterizationPostDepthCoverage_allocs *cgoAllocMap
	ref878f819c.conservativeRasterizationPostDepthCoverage, cconservativeRasterizationPostDepthCoverage_allocs = (C.VkBool32)(x.ConservativeRasterizationPostDepthCoverage), cgoAllocsUnknown
	allocs878f819c.Borrow(cconservativeRasterizationPostDepthCoverage_allocs)

	x.ref878f819c = ref878f819c
	x.allocs878f819c = allocs878f819c
	return ref878f819c, allocs878f819c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceConservativeRasterizationProperties) PassValue() (C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT, *cgoAllocMap) {
	if x.ref878f819c != nil {
		return *x.ref878f819c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceConservativeRasterizationProperties) Deref() {
	if x.ref878f819c == nil {
		return
	}
	x.SType = (StructureType)(x.ref878f819c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref878f819c.pNext))
	x.PrimitiveOverestimationSize = (float32)(x.ref878f819c.primitiveOverestimationSize)
	x.MaxExtraPrimitiveOverestimationSize = (float32)(x.ref878f819c.maxExtraPrimitiveOverestimationSize)
	x.ExtraPrimitiveOverestimationSizeGranularity = (float32)(x.ref878f819c.extraPrimitiveOverestimationSizeGranularity)
	x.PrimitiveUnderestimation = (Bool32)(x.ref878f819c.primitiveUnderestimation)
	x.ConservativePointAndLineRasterization = (Bool32)(x.ref878f819c.conservativePointAndLineRasterization)
	x.DegenerateTrianglesRasterized = (Bool32)(x.ref878f819c.degenerateTrianglesRasterized)
	x.DegenerateLinesRasterized = (Bool32)(x.ref878f819c.degenerateLinesRasterized)
	x.FullyCoveredFragmentShaderInputVariable = (Bool32)(x.ref878f819c.fullyCoveredFragmentShaderInputVariable)
	x.ConservativeRasterizationPostDepthCoverage = (Bool32)(x.ref878f819c.conservativeRasterizationPostDepthCoverage)
}

// allocPipelineRasterizationConservativeStateCreateInfoMemory allocates memory for type C.VkPipelineRasterizationConservativeStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationConservativeStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationConservativeStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineRasterizationConservativeStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineRasterizationConservativeStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRasterizationConservativeStateCreateInfo) Ref() *C.VkPipelineRasterizationConservativeStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refe3cd0046
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRasterizationConservativeStateCreateInfo) Free() {
	if x != nil && x.allocse3cd0046 != nil {
		x.allocse3cd0046.(*cgoAllocMap).Free()
		x.refe3cd0046 = nil
	}
}

// NewPipelineRasterizationConservativeStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRasterizationConservativeStateCreateInfoRef(ref unsafe.Pointer) *PipelineRasterizationConservativeStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRasterizationConservativeStateCreateInfo)
	obj.refe3cd0046 = (*C.VkPipelineRasterizationConservativeStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRasterizationConservativeStateCreateInfo) PassRef() (*C.VkPipelineRasterizationConservativeStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe3cd0046 != nil {
		return x.refe3cd0046, nil
	}
	meme3cd0046 := allocPipelineRasterizationConservativeStateCreateInfoMemory(1)
	refe3cd0046 := (*C.VkPipelineRasterizationConservativeStateCreateInfoEXT)(meme3cd0046)
	allocse3cd0046 := new(cgoAllocMap)
	allocse3cd0046.Add(meme3cd0046)

	var csType_allocs *cgoAllocMap
	refe3cd0046.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse3cd0046.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe3cd0046.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse3cd0046.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refe3cd0046.flags, cflags_allocs = (C.VkPipelineRasterizationConservativeStateCreateFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocse3cd0046.Borrow(cflags_allocs)

	var cconservativeRasterizationMode_allocs *cgoAllocMap
	refe3cd0046.conservativeRasterizationMode, cconservativeRasterizationMode_allocs = (C.VkConservativeRasterizationModeEXT)(x.ConservativeRasterizationMode), cgoAllocsUnknown
	allocse3cd0046.Borrow(cconservativeRasterizationMode_allocs)

	var cextraPrimitiveOverestimationSize_allocs *cgoAllocMap
	refe3cd0046.extraPrimitiveOverestimationSize, cextraPrimitiveOverestimationSize_allocs = (C.float)(x.ExtraPrimitiveOverestimationSize), cgoAllocsUnknown
	allocse3cd0046.Borrow(cextraPrimitiveOverestimationSize_allocs)

	x.refe3cd0046 = refe3cd0046
	x.allocse3cd0046 = allocse3cd0046
	return refe3cd0046, allocse3cd0046

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRasterizationConservativeStateCreateInfo) PassValue() (C.VkPipelineRasterizationConservativeStateCreateInfoEXT, *cgoAllocMap) {
	if x.refe3cd0046 != nil {
		return *x.refe3cd0046, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRasterizationConservativeStateCreateInfo) Deref() {
	if x.refe3cd0046 == nil {
		return
	}
	x.SType = (StructureType)(x.refe3cd0046.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe3cd0046.pNext))
	x.Flags = (PipelineRasterizationConservativeStateCreateFlags)(x.refe3cd0046.flags)
	x.ConservativeRasterizationMode = (ConservativeRasterizationMode)(x.refe3cd0046.conservativeRasterizationMode)
	x.ExtraPrimitiveOverestimationSize = (float32)(x.refe3cd0046.extraPrimitiveOverestimationSize)
}

// allocPhysicalDeviceDepthClipEnableFeaturesMemory allocates memory for type C.VkPhysicalDeviceDepthClipEnableFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDepthClipEnableFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDepthClipEnableFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceDepthClipEnableFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDepthClipEnableFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDepthClipEnableFeatures) Ref() *C.VkPhysicalDeviceDepthClipEnableFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refe0daf69c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDepthClipEnableFeatures) Free() {
	if x != nil && x.allocse0daf69c != nil {
		x.allocse0daf69c.(*cgoAllocMap).Free()
		x.refe0daf69c = nil
	}
}

// NewPhysicalDeviceDepthClipEnableFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDepthClipEnableFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceDepthClipEnableFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDepthClipEnableFeatures)
	obj.refe0daf69c = (*C.VkPhysicalDeviceDepthClipEnableFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDepthClipEnableFeatures) PassRef() (*C.VkPhysicalDeviceDepthClipEnableFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe0daf69c != nil {
		return x.refe0daf69c, nil
	}
	meme0daf69c := allocPhysicalDeviceDepthClipEnableFeaturesMemory(1)
	refe0daf69c := (*C.VkPhysicalDeviceDepthClipEnableFeaturesEXT)(meme0daf69c)
	allocse0daf69c := new(cgoAllocMap)
	allocse0daf69c.Add(meme0daf69c)

	var csType_allocs *cgoAllocMap
	refe0daf69c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse0daf69c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe0daf69c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse0daf69c.Borrow(cpNext_allocs)

	var cdepthClipEnable_allocs *cgoAllocMap
	refe0daf69c.depthClipEnable, cdepthClipEnable_allocs = (C.VkBool32)(x.DepthClipEnable), cgoAllocsUnknown
	allocse0daf69c.Borrow(cdepthClipEnable_allocs)

	x.refe0daf69c = refe0daf69c
	x.allocse0daf69c = allocse0daf69c
	return refe0daf69c, allocse0daf69c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDepthClipEnableFeatures) PassValue() (C.VkPhysicalDeviceDepthClipEnableFeaturesEXT, *cgoAllocMap) {
	if x.refe0daf69c != nil {
		return *x.refe0daf69c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDepthClipEnableFeatures) Deref() {
	if x.refe0daf69c == nil {
		return
	}
	x.SType = (StructureType)(x.refe0daf69c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe0daf69c.pNext))
	x.DepthClipEnable = (Bool32)(x.refe0daf69c.depthClipEnable)
}

// allocPipelineRasterizationDepthClipStateCreateInfoMemory allocates memory for type C.VkPipelineRasterizationDepthClipStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationDepthClipStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationDepthClipStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineRasterizationDepthClipStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineRasterizationDepthClipStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRasterizationDepthClipStateCreateInfo) Ref() *C.VkPipelineRasterizationDepthClipStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref38a864b5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRasterizationDepthClipStateCreateInfo) Free() {
	if x != nil && x.allocs38a864b5 != nil {
		x.allocs38a864b5.(*cgoAllocMap).Free()
		x.ref38a864b5 = nil
	}
}

// NewPipelineRasterizationDepthClipStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRasterizationDepthClipStateCreateInfoRef(ref unsafe.Pointer) *PipelineRasterizationDepthClipStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRasterizationDepthClipStateCreateInfo)
	obj.ref38a864b5 = (*C.VkPipelineRasterizationDepthClipStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRasterizationDepthClipStateCreateInfo) PassRef() (*C.VkPipelineRasterizationDepthClipStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref38a864b5 != nil {
		return x.ref38a864b5, nil
	}
	mem38a864b5 := allocPipelineRasterizationDepthClipStateCreateInfoMemory(1)
	ref38a864b5 := (*C.VkPipelineRasterizationDepthClipStateCreateInfoEXT)(mem38a864b5)
	allocs38a864b5 := new(cgoAllocMap)
	allocs38a864b5.Add(mem38a864b5)

	var csType_allocs *cgoAllocMap
	ref38a864b5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs38a864b5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref38a864b5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs38a864b5.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref38a864b5.flags, cflags_allocs = (C.VkPipelineRasterizationDepthClipStateCreateFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocs38a864b5.Borrow(cflags_allocs)

	var cdepthClipEnable_allocs *cgoAllocMap
	ref38a864b5.depthClipEnable, cdepthClipEnable_allocs = (C.VkBool32)(x.DepthClipEnable), cgoAllocsUnknown
	allocs38a864b5.Borrow(cdepthClipEnable_allocs)

	x.ref38a864b5 = ref38a864b5
	x.allocs38a864b5 = allocs38a864b5
	return ref38a864b5, allocs38a864b5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRasterizationDepthClipStateCreateInfo) PassValue() (C.VkPipelineRasterizationDepthClipStateCreateInfoEXT, *cgoAllocMap) {
	if x.ref38a864b5 != nil {
		return *x.ref38a864b5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRasterizationDepthClipStateCreateInfo) Deref() {
	if x.ref38a864b5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref38a864b5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref38a864b5.pNext))
	x.Flags = (PipelineRasterizationDepthClipStateCreateFlags)(x.ref38a864b5.flags)
	x.DepthClipEnable = (Bool32)(x.ref38a864b5.depthClipEnable)
}

// allocXYColorMemory allocates memory for type C.VkXYColorEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXYColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXYColorValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfXYColorValue = unsafe.Sizeof([1]C.VkXYColorEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *XYColor) Ref() *C.VkXYColorEXT {
	if x == nil {
		return nil
	}
	return x.refb8efaa5c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *XYColor) Free() {
	if x != nil && x.allocsb8efaa5c != nil {
		x.allocsb8efaa5c.(*cgoAllocMap).Free()
		x.refb8efaa5c = nil
	}
}

// NewXYColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXYColorRef(ref unsafe.Pointer) *XYColor {
	if ref == nil {
		return nil
	}
	obj := new(XYColor)
	obj.refb8efaa5c = (*C.VkXYColorEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *XYColor) PassRef() (*C.VkXYColorEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8efaa5c != nil {
		return x.refb8efaa5c, nil
	}
	memb8efaa5c := allocXYColorMemory(1)
	refb8efaa5c := (*C.VkXYColorEXT)(memb8efaa5c)
	allocsb8efaa5c := new(cgoAllocMap)
	allocsb8efaa5c.Add(memb8efaa5c)

	var cx_allocs *cgoAllocMap
	refb8efaa5c.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocsb8efaa5c.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refb8efaa5c.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocsb8efaa5c.Borrow(cy_allocs)

	x.refb8efaa5c = refb8efaa5c
	x.allocsb8efaa5c = allocsb8efaa5c
	return refb8efaa5c, allocsb8efaa5c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x XYColor) PassValue() (C.VkXYColorEXT, *cgoAllocMap) {
	if x.refb8efaa5c != nil {
		return *x.refb8efaa5c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *XYColor) Deref() {
	if x.refb8efaa5c == nil {
		return
	}
	x.X = (float32)(x.refb8efaa5c.x)
	x.Y = (float32)(x.refb8efaa5c.y)
}

// allocHdrMetadataMemory allocates memory for type C.VkHdrMetadataEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocHdrMetadataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfHdrMetadataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfHdrMetadataValue = unsafe.Sizeof([1]C.VkHdrMetadataEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *HdrMetadata) Ref() *C.VkHdrMetadataEXT {
	if x == nil {
		return nil
	}
	return x.ref5fd28976
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *HdrMetadata) Free() {
	if x != nil && x.allocs5fd28976 != nil {
		x.allocs5fd28976.(*cgoAllocMap).Free()
		x.ref5fd28976 = nil
	}
}

// NewHdrMetadataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewHdrMetadataRef(ref unsafe.Pointer) *HdrMetadata {
	if ref == nil {
		return nil
	}
	obj := new(HdrMetadata)
	obj.ref5fd28976 = (*C.VkHdrMetadataEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *HdrMetadata) PassRef() (*C.VkHdrMetadataEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5fd28976 != nil {
		return x.ref5fd28976, nil
	}
	mem5fd28976 := allocHdrMetadataMemory(1)
	ref5fd28976 := (*C.VkHdrMetadataEXT)(mem5fd28976)
	allocs5fd28976 := new(cgoAllocMap)
	allocs5fd28976.Add(mem5fd28976)

	var csType_allocs *cgoAllocMap
	ref5fd28976.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5fd28976.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5fd28976.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5fd28976.Borrow(cpNext_allocs)

	var cdisplayPrimaryRed_allocs *cgoAllocMap
	ref5fd28976.displayPrimaryRed, cdisplayPrimaryRed_allocs = x.DisplayPrimaryRed.PassValue()
	allocs5fd28976.Borrow(cdisplayPrimaryRed_allocs)

	var cdisplayPrimaryGreen_allocs *cgoAllocMap
	ref5fd28976.displayPrimaryGreen, cdisplayPrimaryGreen_allocs = x.DisplayPrimaryGreen.PassValue()
	allocs5fd28976.Borrow(cdisplayPrimaryGreen_allocs)

	var cdisplayPrimaryBlue_allocs *cgoAllocMap
	ref5fd28976.displayPrimaryBlue, cdisplayPrimaryBlue_allocs = x.DisplayPrimaryBlue.PassValue()
	allocs5fd28976.Borrow(cdisplayPrimaryBlue_allocs)

	var cwhitePoint_allocs *cgoAllocMap
	ref5fd28976.whitePoint, cwhitePoint_allocs = x.WhitePoint.PassValue()
	allocs5fd28976.Borrow(cwhitePoint_allocs)

	var cmaxLuminance_allocs *cgoAllocMap
	ref5fd28976.maxLuminance, cmaxLuminance_allocs = (C.float)(x.MaxLuminance), cgoAllocsUnknown
	allocs5fd28976.Borrow(cmaxLuminance_allocs)

	var cminLuminance_allocs *cgoAllocMap
	ref5fd28976.minLuminance, cminLuminance_allocs = (C.float)(x.MinLuminance), cgoAllocsUnknown
	allocs5fd28976.Borrow(cminLuminance_allocs)

	var cmaxContentLightLevel_allocs *cgoAllocMap
	ref5fd28976.maxContentLightLevel, cmaxContentLightLevel_allocs = (C.float)(x.MaxContentLightLevel), cgoAllocsUnknown
	allocs5fd28976.Borrow(cmaxContentLightLevel_allocs)

	var cmaxFrameAverageLightLevel_allocs *cgoAllocMap
	ref5fd28976.maxFrameAverageLightLevel, cmaxFrameAverageLightLevel_allocs = (C.float)(x.MaxFrameAverageLightLevel), cgoAllocsUnknown
	allocs5fd28976.Borrow(cmaxFrameAverageLightLevel_allocs)

	x.ref5fd28976 = ref5fd28976
	x.allocs5fd28976 = allocs5fd28976
	return ref5fd28976, allocs5fd28976

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x HdrMetadata) PassValue() (C.VkHdrMetadataEXT, *cgoAllocMap) {
	if x.ref5fd28976 != nil {
		return *x.ref5fd28976, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *HdrMetadata) Deref() {
	if x.ref5fd28976 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5fd28976.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5fd28976.pNext))
	x.DisplayPrimaryRed = *NewXYColorRef(unsafe.Pointer(&x.ref5fd28976.displayPrimaryRed))
	x.DisplayPrimaryGreen = *NewXYColorRef(unsafe.Pointer(&x.ref5fd28976.displayPrimaryGreen))
	x.DisplayPrimaryBlue = *NewXYColorRef(unsafe.Pointer(&x.ref5fd28976.displayPrimaryBlue))
	x.WhitePoint = *NewXYColorRef(unsafe.Pointer(&x.ref5fd28976.whitePoint))
	x.MaxLuminance = (float32)(x.ref5fd28976.maxLuminance)
	x.MinLuminance = (float32)(x.ref5fd28976.minLuminance)
	x.MaxContentLightLevel = (float32)(x.ref5fd28976.maxContentLightLevel)
	x.MaxFrameAverageLightLevel = (float32)(x.ref5fd28976.maxFrameAverageLightLevel)
}

// allocDebugUtilsLabelMemory allocates memory for type C.VkDebugUtilsLabelEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugUtilsLabelMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugUtilsLabelValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDebugUtilsLabelValue = unsafe.Sizeof([1]C.VkDebugUtilsLabelEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugUtilsLabel) Ref() *C.VkDebugUtilsLabelEXT {
	if x == nil {
		return nil
	}
	return x.ref8faaf7b1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugUtilsLabel) Free() {
	if x != nil && x.allocs8faaf7b1 != nil {
		x.allocs8faaf7b1.(*cgoAllocMap).Free()
		x.ref8faaf7b1 = nil
	}
}

// NewDebugUtilsLabelRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugUtilsLabelRef(ref unsafe.Pointer) *DebugUtilsLabel {
	if ref == nil {
		return nil
	}
	obj := new(DebugUtilsLabel)
	obj.ref8faaf7b1 = (*C.VkDebugUtilsLabelEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugUtilsLabel) PassRef() (*C.VkDebugUtilsLabelEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8faaf7b1 != nil {
		return x.ref8faaf7b1, nil
	}
	mem8faaf7b1 := allocDebugUtilsLabelMemory(1)
	ref8faaf7b1 := (*C.VkDebugUtilsLabelEXT)(mem8faaf7b1)
	allocs8faaf7b1 := new(cgoAllocMap)
	allocs8faaf7b1.Add(mem8faaf7b1)

	var csType_allocs *cgoAllocMap
	ref8faaf7b1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8faaf7b1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8faaf7b1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8faaf7b1.Borrow(cpNext_allocs)

	var cpLabelName_allocs *cgoAllocMap
	ref8faaf7b1.pLabelName, cpLabelName_allocs = unpackPCharString(x.PLabelName)
	allocs8faaf7b1.Borrow(cpLabelName_allocs)

	var ccolor_allocs *cgoAllocMap
	ref8faaf7b1.color, ccolor_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Color)), cgoAllocsUnknown
	allocs8faaf7b1.Borrow(ccolor_allocs)

	x.ref8faaf7b1 = ref8faaf7b1
	x.allocs8faaf7b1 = allocs8faaf7b1
	return ref8faaf7b1, allocs8faaf7b1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugUtilsLabel) PassValue() (C.VkDebugUtilsLabelEXT, *cgoAllocMap) {
	if x.ref8faaf7b1 != nil {
		return *x.ref8faaf7b1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugUtilsLabel) Deref() {
	if x.ref8faaf7b1 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8faaf7b1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8faaf7b1.pNext))
	x.PLabelName = packPCharString(x.ref8faaf7b1.pLabelName)
	x.Color = *(*[4]float32)(unsafe.Pointer(&x.ref8faaf7b1.color))
}

// allocDebugUtilsObjectNameInfoMemory allocates memory for type C.VkDebugUtilsObjectNameInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugUtilsObjectNameInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugUtilsObjectNameInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDebugUtilsObjectNameInfoValue = unsafe.Sizeof([1]C.VkDebugUtilsObjectNameInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugUtilsObjectNameInfo) Ref() *C.VkDebugUtilsObjectNameInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref5e73c2db
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugUtilsObjectNameInfo) Free() {
	if x != nil && x.allocs5e73c2db != nil {
		x.allocs5e73c2db.(*cgoAllocMap).Free()
		x.ref5e73c2db = nil
	}
}

// NewDebugUtilsObjectNameInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugUtilsObjectNameInfoRef(ref unsafe.Pointer) *DebugUtilsObjectNameInfo {
	if ref == nil {
		return nil
	}
	obj := new(DebugUtilsObjectNameInfo)
	obj.ref5e73c2db = (*C.VkDebugUtilsObjectNameInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugUtilsObjectNameInfo) PassRef() (*C.VkDebugUtilsObjectNameInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e73c2db != nil {
		return x.ref5e73c2db, nil
	}
	mem5e73c2db := allocDebugUtilsObjectNameInfoMemory(1)
	ref5e73c2db := (*C.VkDebugUtilsObjectNameInfoEXT)(mem5e73c2db)
	allocs5e73c2db := new(cgoAllocMap)
	allocs5e73c2db.Add(mem5e73c2db)

	var csType_allocs *cgoAllocMap
	ref5e73c2db.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5e73c2db.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5e73c2db.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5e73c2db.Borrow(cpNext_allocs)

	var cobjectType_allocs *cgoAllocMap
	ref5e73c2db.objectType, cobjectType_allocs = (C.VkObjectType)(x.ObjectType), cgoAllocsUnknown
	allocs5e73c2db.Borrow(cobjectType_allocs)

	var cobjectHandle_allocs *cgoAllocMap
	ref5e73c2db.objectHandle, cobjectHandle_allocs = (C.uint64_t)(x.ObjectHandle), cgoAllocsUnknown
	allocs5e73c2db.Borrow(cobjectHandle_allocs)

	var cpObjectName_allocs *cgoAllocMap
	ref5e73c2db.pObjectName, cpObjectName_allocs = unpackPCharString(x.PObjectName)
	allocs5e73c2db.Borrow(cpObjectName_allocs)

	x.ref5e73c2db = ref5e73c2db
	x.allocs5e73c2db = allocs5e73c2db
	return ref5e73c2db, allocs5e73c2db

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugUtilsObjectNameInfo) PassValue() (C.VkDebugUtilsObjectNameInfoEXT, *cgoAllocMap) {
	if x.ref5e73c2db != nil {
		return *x.ref5e73c2db, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugUtilsObjectNameInfo) Deref() {
	if x.ref5e73c2db == nil {
		return
	}
	x.SType = (StructureType)(x.ref5e73c2db.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5e73c2db.pNext))
	x.ObjectType = (ObjectType)(x.ref5e73c2db.objectType)
	x.ObjectHandle = (uint32)(x.ref5e73c2db.objectHandle)
	x.PObjectName = packPCharString(x.ref5e73c2db.pObjectName)
}

// allocDebugUtilsObjectTagInfoMemory allocates memory for type C.VkDebugUtilsObjectTagInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugUtilsObjectTagInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugUtilsObjectTagInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDebugUtilsObjectTagInfoValue = unsafe.Sizeof([1]C.VkDebugUtilsObjectTagInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugUtilsObjectTagInfo) Ref() *C.VkDebugUtilsObjectTagInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref9fd129cf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugUtilsObjectTagInfo) Free() {
	if x != nil && x.allocs9fd129cf != nil {
		x.allocs9fd129cf.(*cgoAllocMap).Free()
		x.ref9fd129cf = nil
	}
}

// NewDebugUtilsObjectTagInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugUtilsObjectTagInfoRef(ref unsafe.Pointer) *DebugUtilsObjectTagInfo {
	if ref == nil {
		return nil
	}
	obj := new(DebugUtilsObjectTagInfo)
	obj.ref9fd129cf = (*C.VkDebugUtilsObjectTagInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugUtilsObjectTagInfo) PassRef() (*C.VkDebugUtilsObjectTagInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9fd129cf != nil {
		return x.ref9fd129cf, nil
	}
	mem9fd129cf := allocDebugUtilsObjectTagInfoMemory(1)
	ref9fd129cf := (*C.VkDebugUtilsObjectTagInfoEXT)(mem9fd129cf)
	allocs9fd129cf := new(cgoAllocMap)
	allocs9fd129cf.Add(mem9fd129cf)

	var csType_allocs *cgoAllocMap
	ref9fd129cf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9fd129cf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9fd129cf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9fd129cf.Borrow(cpNext_allocs)

	var cobjectType_allocs *cgoAllocMap
	ref9fd129cf.objectType, cobjectType_allocs = (C.VkObjectType)(x.ObjectType), cgoAllocsUnknown
	allocs9fd129cf.Borrow(cobjectType_allocs)

	var cobjectHandle_allocs *cgoAllocMap
	ref9fd129cf.objectHandle, cobjectHandle_allocs = (C.uint64_t)(x.ObjectHandle), cgoAllocsUnknown
	allocs9fd129cf.Borrow(cobjectHandle_allocs)

	var ctagName_allocs *cgoAllocMap
	ref9fd129cf.tagName, ctagName_allocs = (C.uint64_t)(x.TagName), cgoAllocsUnknown
	allocs9fd129cf.Borrow(ctagName_allocs)

	var ctagSize_allocs *cgoAllocMap
	ref9fd129cf.tagSize, ctagSize_allocs = (C.size_t)(x.TagSize), cgoAllocsUnknown
	allocs9fd129cf.Borrow(ctagSize_allocs)

	var cpTag_allocs *cgoAllocMap
	ref9fd129cf.pTag, cpTag_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PTag)), cgoAllocsUnknown
	allocs9fd129cf.Borrow(cpTag_allocs)

	x.ref9fd129cf = ref9fd129cf
	x.allocs9fd129cf = allocs9fd129cf
	return ref9fd129cf, allocs9fd129cf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugUtilsObjectTagInfo) PassValue() (C.VkDebugUtilsObjectTagInfoEXT, *cgoAllocMap) {
	if x.ref9fd129cf != nil {
		return *x.ref9fd129cf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugUtilsObjectTagInfo) Deref() {
	if x.ref9fd129cf == nil {
		return
	}
	x.SType = (StructureType)(x.ref9fd129cf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9fd129cf.pNext))
	x.ObjectType = (ObjectType)(x.ref9fd129cf.objectType)
	x.ObjectHandle = (uint32)(x.ref9fd129cf.objectHandle)
	x.TagName = (uint32)(x.ref9fd129cf.tagName)
	x.TagSize = (uint32)(x.ref9fd129cf.tagSize)
	x.PTag = (unsafe.Pointer)(unsafe.Pointer(x.ref9fd129cf.pTag))
}

// allocPhysicalDeviceInlineUniformBlockFeaturesMemory allocates memory for type C.VkPhysicalDeviceInlineUniformBlockFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceInlineUniformBlockFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceInlineUniformBlockFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceInlineUniformBlockFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceInlineUniformBlockFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceInlineUniformBlockFeatures) Ref() *C.VkPhysicalDeviceInlineUniformBlockFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref5054bc6c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceInlineUniformBlockFeatures) Free() {
	if x != nil && x.allocs5054bc6c != nil {
		x.allocs5054bc6c.(*cgoAllocMap).Free()
		x.ref5054bc6c = nil
	}
}

// NewPhysicalDeviceInlineUniformBlockFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceInlineUniformBlockFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceInlineUniformBlockFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceInlineUniformBlockFeatures)
	obj.ref5054bc6c = (*C.VkPhysicalDeviceInlineUniformBlockFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceInlineUniformBlockFeatures) PassRef() (*C.VkPhysicalDeviceInlineUniformBlockFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5054bc6c != nil {
		return x.ref5054bc6c, nil
	}
	mem5054bc6c := allocPhysicalDeviceInlineUniformBlockFeaturesMemory(1)
	ref5054bc6c := (*C.VkPhysicalDeviceInlineUniformBlockFeaturesEXT)(mem5054bc6c)
	allocs5054bc6c := new(cgoAllocMap)
	allocs5054bc6c.Add(mem5054bc6c)

	var csType_allocs *cgoAllocMap
	ref5054bc6c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5054bc6c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5054bc6c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5054bc6c.Borrow(cpNext_allocs)

	var cinlineUniformBlock_allocs *cgoAllocMap
	ref5054bc6c.inlineUniformBlock, cinlineUniformBlock_allocs = (C.VkBool32)(x.InlineUniformBlock), cgoAllocsUnknown
	allocs5054bc6c.Borrow(cinlineUniformBlock_allocs)

	var cdescriptorBindingInlineUniformBlockUpdateAfterBind_allocs *cgoAllocMap
	ref5054bc6c.descriptorBindingInlineUniformBlockUpdateAfterBind, cdescriptorBindingInlineUniformBlockUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingInlineUniformBlockUpdateAfterBind), cgoAllocsUnknown
	allocs5054bc6c.Borrow(cdescriptorBindingInlineUniformBlockUpdateAfterBind_allocs)

	x.ref5054bc6c = ref5054bc6c
	x.allocs5054bc6c = allocs5054bc6c
	return ref5054bc6c, allocs5054bc6c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceInlineUniformBlockFeatures) PassValue() (C.VkPhysicalDeviceInlineUniformBlockFeaturesEXT, *cgoAllocMap) {
	if x.ref5054bc6c != nil {
		return *x.ref5054bc6c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceInlineUniformBlockFeatures) Deref() {
	if x.ref5054bc6c == nil {
		return
	}
	x.SType = (StructureType)(x.ref5054bc6c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5054bc6c.pNext))
	x.InlineUniformBlock = (Bool32)(x.ref5054bc6c.inlineUniformBlock)
	x.DescriptorBindingInlineUniformBlockUpdateAfterBind = (Bool32)(x.ref5054bc6c.descriptorBindingInlineUniformBlockUpdateAfterBind)
}

// allocPhysicalDeviceInlineUniformBlockPropertiesMemory allocates memory for type C.VkPhysicalDeviceInlineUniformBlockPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceInlineUniformBlockPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceInlineUniformBlockPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceInlineUniformBlockPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceInlineUniformBlockPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceInlineUniformBlockProperties) Ref() *C.VkPhysicalDeviceInlineUniformBlockPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref7ef1794
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceInlineUniformBlockProperties) Free() {
	if x != nil && x.allocs7ef1794 != nil {
		x.allocs7ef1794.(*cgoAllocMap).Free()
		x.ref7ef1794 = nil
	}
}

// NewPhysicalDeviceInlineUniformBlockPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceInlineUniformBlockPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceInlineUniformBlockProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceInlineUniformBlockProperties)
	obj.ref7ef1794 = (*C.VkPhysicalDeviceInlineUniformBlockPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceInlineUniformBlockProperties) PassRef() (*C.VkPhysicalDeviceInlineUniformBlockPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7ef1794 != nil {
		return x.ref7ef1794, nil
	}
	mem7ef1794 := allocPhysicalDeviceInlineUniformBlockPropertiesMemory(1)
	ref7ef1794 := (*C.VkPhysicalDeviceInlineUniformBlockPropertiesEXT)(mem7ef1794)
	allocs7ef1794 := new(cgoAllocMap)
	allocs7ef1794.Add(mem7ef1794)

	var csType_allocs *cgoAllocMap
	ref7ef1794.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7ef1794.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7ef1794.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7ef1794.Borrow(cpNext_allocs)

	var cmaxInlineUniformBlockSize_allocs *cgoAllocMap
	ref7ef1794.maxInlineUniformBlockSize, cmaxInlineUniformBlockSize_allocs = (C.uint32_t)(x.MaxInlineUniformBlockSize), cgoAllocsUnknown
	allocs7ef1794.Borrow(cmaxInlineUniformBlockSize_allocs)

	var cmaxPerStageDescriptorInlineUniformBlocks_allocs *cgoAllocMap
	ref7ef1794.maxPerStageDescriptorInlineUniformBlocks, cmaxPerStageDescriptorInlineUniformBlocks_allocs = (C.uint32_t)(x.MaxPerStageDescriptorInlineUniformBlocks), cgoAllocsUnknown
	allocs7ef1794.Borrow(cmaxPerStageDescriptorInlineUniformBlocks_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_allocs *cgoAllocMap
	ref7ef1794.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks, cmaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks), cgoAllocsUnknown
	allocs7ef1794.Borrow(cmaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_allocs)

	var cmaxDescriptorSetInlineUniformBlocks_allocs *cgoAllocMap
	ref7ef1794.maxDescriptorSetInlineUniformBlocks, cmaxDescriptorSetInlineUniformBlocks_allocs = (C.uint32_t)(x.MaxDescriptorSetInlineUniformBlocks), cgoAllocsUnknown
	allocs7ef1794.Borrow(cmaxDescriptorSetInlineUniformBlocks_allocs)

	var cmaxDescriptorSetUpdateAfterBindInlineUniformBlocks_allocs *cgoAllocMap
	ref7ef1794.maxDescriptorSetUpdateAfterBindInlineUniformBlocks, cmaxDescriptorSetUpdateAfterBindInlineUniformBlocks_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindInlineUniformBlocks), cgoAllocsUnknown
	allocs7ef1794.Borrow(cmaxDescriptorSetUpdateAfterBindInlineUniformBlocks_allocs)

	x.ref7ef1794 = ref7ef1794
	x.allocs7ef1794 = allocs7ef1794
	return ref7ef1794, allocs7ef1794

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceInlineUniformBlockProperties) PassValue() (C.VkPhysicalDeviceInlineUniformBlockPropertiesEXT, *cgoAllocMap) {
	if x.ref7ef1794 != nil {
		return *x.ref7ef1794, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceInlineUniformBlockProperties) Deref() {
	if x.ref7ef1794 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7ef1794.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7ef1794.pNext))
	x.MaxInlineUniformBlockSize = (uint32)(x.ref7ef1794.maxInlineUniformBlockSize)
	x.MaxPerStageDescriptorInlineUniformBlocks = (uint32)(x.ref7ef1794.maxPerStageDescriptorInlineUniformBlocks)
	x.MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = (uint32)(x.ref7ef1794.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks)
	x.MaxDescriptorSetInlineUniformBlocks = (uint32)(x.ref7ef1794.maxDescriptorSetInlineUniformBlocks)
	x.MaxDescriptorSetUpdateAfterBindInlineUniformBlocks = (uint32)(x.ref7ef1794.maxDescriptorSetUpdateAfterBindInlineUniformBlocks)
}

// allocWriteDescriptorSetInlineUniformBlockMemory allocates memory for type C.VkWriteDescriptorSetInlineUniformBlockEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWriteDescriptorSetInlineUniformBlockMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWriteDescriptorSetInlineUniformBlockValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfWriteDescriptorSetInlineUniformBlockValue = unsafe.Sizeof([1]C.VkWriteDescriptorSetInlineUniformBlockEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *WriteDescriptorSetInlineUniformBlock) Ref() *C.VkWriteDescriptorSetInlineUniformBlockEXT {
	if x == nil {
		return nil
	}
	return x.ref18d00656
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *WriteDescriptorSetInlineUniformBlock) Free() {
	if x != nil && x.allocs18d00656 != nil {
		x.allocs18d00656.(*cgoAllocMap).Free()
		x.ref18d00656 = nil
	}
}

// NewWriteDescriptorSetInlineUniformBlockRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWriteDescriptorSetInlineUniformBlockRef(ref unsafe.Pointer) *WriteDescriptorSetInlineUniformBlock {
	if ref == nil {
		return nil
	}
	obj := new(WriteDescriptorSetInlineUniformBlock)
	obj.ref18d00656 = (*C.VkWriteDescriptorSetInlineUniformBlockEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *WriteDescriptorSetInlineUniformBlock) PassRef() (*C.VkWriteDescriptorSetInlineUniformBlockEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref18d00656 != nil {
		return x.ref18d00656, nil
	}
	mem18d00656 := allocWriteDescriptorSetInlineUniformBlockMemory(1)
	ref18d00656 := (*C.VkWriteDescriptorSetInlineUniformBlockEXT)(mem18d00656)
	allocs18d00656 := new(cgoAllocMap)
	allocs18d00656.Add(mem18d00656)

	var csType_allocs *cgoAllocMap
	ref18d00656.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs18d00656.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref18d00656.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs18d00656.Borrow(cpNext_allocs)

	var cdataSize_allocs *cgoAllocMap
	ref18d00656.dataSize, cdataSize_allocs = (C.uint32_t)(x.DataSize), cgoAllocsUnknown
	allocs18d00656.Borrow(cdataSize_allocs)

	var cpData_allocs *cgoAllocMap
	ref18d00656.pData, cpData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocs18d00656.Borrow(cpData_allocs)

	x.ref18d00656 = ref18d00656
	x.allocs18d00656 = allocs18d00656
	return ref18d00656, allocs18d00656

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x WriteDescriptorSetInlineUniformBlock) PassValue() (C.VkWriteDescriptorSetInlineUniformBlockEXT, *cgoAllocMap) {
	if x.ref18d00656 != nil {
		return *x.ref18d00656, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *WriteDescriptorSetInlineUniformBlock) Deref() {
	if x.ref18d00656 == nil {
		return
	}
	x.SType = (StructureType)(x.ref18d00656.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref18d00656.pNext))
	x.DataSize = (uint32)(x.ref18d00656.dataSize)
	x.PData = (unsafe.Pointer)(unsafe.Pointer(x.ref18d00656.pData))
}

// allocDescriptorPoolInlineUniformBlockCreateInfoMemory allocates memory for type C.VkDescriptorPoolInlineUniformBlockCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorPoolInlineUniformBlockCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorPoolInlineUniformBlockCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorPoolInlineUniformBlockCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorPoolInlineUniformBlockCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorPoolInlineUniformBlockCreateInfo) Ref() *C.VkDescriptorPoolInlineUniformBlockCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refbc7edaa3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorPoolInlineUniformBlockCreateInfo) Free() {
	if x != nil && x.allocsbc7edaa3 != nil {
		x.allocsbc7edaa3.(*cgoAllocMap).Free()
		x.refbc7edaa3 = nil
	}
}

// NewDescriptorPoolInlineUniformBlockCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorPoolInlineUniformBlockCreateInfoRef(ref unsafe.Pointer) *DescriptorPoolInlineUniformBlockCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorPoolInlineUniformBlockCreateInfo)
	obj.refbc7edaa3 = (*C.VkDescriptorPoolInlineUniformBlockCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorPoolInlineUniformBlockCreateInfo) PassRef() (*C.VkDescriptorPoolInlineUniformBlockCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbc7edaa3 != nil {
		return x.refbc7edaa3, nil
	}
	membc7edaa3 := allocDescriptorPoolInlineUniformBlockCreateInfoMemory(1)
	refbc7edaa3 := (*C.VkDescriptorPoolInlineUniformBlockCreateInfoEXT)(membc7edaa3)
	allocsbc7edaa3 := new(cgoAllocMap)
	allocsbc7edaa3.Add(membc7edaa3)

	var csType_allocs *cgoAllocMap
	refbc7edaa3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbc7edaa3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbc7edaa3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbc7edaa3.Borrow(cpNext_allocs)

	var cmaxInlineUniformBlockBindings_allocs *cgoAllocMap
	refbc7edaa3.maxInlineUniformBlockBindings, cmaxInlineUniformBlockBindings_allocs = (C.uint32_t)(x.MaxInlineUniformBlockBindings), cgoAllocsUnknown
	allocsbc7edaa3.Borrow(cmaxInlineUniformBlockBindings_allocs)

	x.refbc7edaa3 = refbc7edaa3
	x.allocsbc7edaa3 = allocsbc7edaa3
	return refbc7edaa3, allocsbc7edaa3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorPoolInlineUniformBlockCreateInfo) PassValue() (C.VkDescriptorPoolInlineUniformBlockCreateInfoEXT, *cgoAllocMap) {
	if x.refbc7edaa3 != nil {
		return *x.refbc7edaa3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorPoolInlineUniformBlockCreateInfo) Deref() {
	if x.refbc7edaa3 == nil {
		return
	}
	x.SType = (StructureType)(x.refbc7edaa3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbc7edaa3.pNext))
	x.MaxInlineUniformBlockBindings = (uint32)(x.refbc7edaa3.maxInlineUniformBlockBindings)
}

// allocSampleLocationMemory allocates memory for type C.VkSampleLocationEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSampleLocationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSampleLocationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSampleLocationValue = unsafe.Sizeof([1]C.VkSampleLocationEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SampleLocation) Ref() *C.VkSampleLocationEXT {
	if x == nil {
		return nil
	}
	return x.refe7a2e761
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SampleLocation) Free() {
	if x != nil && x.allocse7a2e761 != nil {
		x.allocse7a2e761.(*cgoAllocMap).Free()
		x.refe7a2e761 = nil
	}
}

// NewSampleLocationRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSampleLocationRef(ref unsafe.Pointer) *SampleLocation {
	if ref == nil {
		return nil
	}
	obj := new(SampleLocation)
	obj.refe7a2e761 = (*C.VkSampleLocationEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SampleLocation) PassRef() (*C.VkSampleLocationEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe7a2e761 != nil {
		return x.refe7a2e761, nil
	}
	meme7a2e761 := allocSampleLocationMemory(1)
	refe7a2e761 := (*C.VkSampleLocationEXT)(meme7a2e761)
	allocse7a2e761 := new(cgoAllocMap)
	allocse7a2e761.Add(meme7a2e761)

	var cx_allocs *cgoAllocMap
	refe7a2e761.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocse7a2e761.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refe7a2e761.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocse7a2e761.Borrow(cy_allocs)

	x.refe7a2e761 = refe7a2e761
	x.allocse7a2e761 = allocse7a2e761
	return refe7a2e761, allocse7a2e761

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SampleLocation) PassValue() (C.VkSampleLocationEXT, *cgoAllocMap) {
	if x.refe7a2e761 != nil {
		return *x.refe7a2e761, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SampleLocation) Deref() {
	if x.refe7a2e761 == nil {
		return
	}
	x.X = (float32)(x.refe7a2e761.x)
	x.Y = (float32)(x.refe7a2e761.y)
}

// allocSampleLocationsInfoMemory allocates memory for type C.VkSampleLocationsInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSampleLocationsInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSampleLocationsInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSampleLocationsInfoValue = unsafe.Sizeof([1]C.VkSampleLocationsInfoEXT{})

// unpackSSampleLocation transforms a sliced Go data structure into plain C format.
func unpackSSampleLocation(x []SampleLocation) (unpacked *C.VkSampleLocationEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSampleLocationMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSampleLocationEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSampleLocationEXT)(h.Data)
	return
}

// packSSampleLocation reads sliced Go data structure out from plain C format.
func packSSampleLocation(v []SampleLocation, ptr0 *C.VkSampleLocationEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSampleLocationValue]C.VkSampleLocationEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSampleLocationRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SampleLocationsInfo) Ref() *C.VkSampleLocationsInfoEXT {
	if x == nil {
		return nil
	}
	return x.refd8f3bd2d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SampleLocationsInfo) Free() {
	if x != nil && x.allocsd8f3bd2d != nil {
		x.allocsd8f3bd2d.(*cgoAllocMap).Free()
		x.refd8f3bd2d = nil
	}
}

// NewSampleLocationsInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSampleLocationsInfoRef(ref unsafe.Pointer) *SampleLocationsInfo {
	if ref == nil {
		return nil
	}
	obj := new(SampleLocationsInfo)
	obj.refd8f3bd2d = (*C.VkSampleLocationsInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SampleLocationsInfo) PassRef() (*C.VkSampleLocationsInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd8f3bd2d != nil {
		return x.refd8f3bd2d, nil
	}
	memd8f3bd2d := allocSampleLocationsInfoMemory(1)
	refd8f3bd2d := (*C.VkSampleLocationsInfoEXT)(memd8f3bd2d)
	allocsd8f3bd2d := new(cgoAllocMap)
	allocsd8f3bd2d.Add(memd8f3bd2d)

	var csType_allocs *cgoAllocMap
	refd8f3bd2d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd8f3bd2d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd8f3bd2d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd8f3bd2d.Borrow(cpNext_allocs)

	var csampleLocationsPerPixel_allocs *cgoAllocMap
	refd8f3bd2d.sampleLocationsPerPixel, csampleLocationsPerPixel_allocs = (C.VkSampleCountFlagBits)(x.SampleLocationsPerPixel), cgoAllocsUnknown
	allocsd8f3bd2d.Borrow(csampleLocationsPerPixel_allocs)

	var csampleLocationGridSize_allocs *cgoAllocMap
	refd8f3bd2d.sampleLocationGridSize, csampleLocationGridSize_allocs = x.SampleLocationGridSize.PassValue()
	allocsd8f3bd2d.Borrow(csampleLocationGridSize_allocs)

	var csampleLocationsCount_allocs *cgoAllocMap
	refd8f3bd2d.sampleLocationsCount, csampleLocationsCount_allocs = (C.uint32_t)(x.SampleLocationsCount), cgoAllocsUnknown
	allocsd8f3bd2d.Borrow(csampleLocationsCount_allocs)

	var cpSampleLocations_allocs *cgoAllocMap
	refd8f3bd2d.pSampleLocations, cpSampleLocations_allocs = unpackSSampleLocation(x.PSampleLocations)
	allocsd8f3bd2d.Borrow(cpSampleLocations_allocs)

	x.refd8f3bd2d = refd8f3bd2d
	x.allocsd8f3bd2d = allocsd8f3bd2d
	return refd8f3bd2d, allocsd8f3bd2d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SampleLocationsInfo) PassValue() (C.VkSampleLocationsInfoEXT, *cgoAllocMap) {
	if x.refd8f3bd2d != nil {
		return *x.refd8f3bd2d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SampleLocationsInfo) Deref() {
	if x.refd8f3bd2d == nil {
		return
	}
	x.SType = (StructureType)(x.refd8f3bd2d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd8f3bd2d.pNext))
	x.SampleLocationsPerPixel = (SampleCountFlagBits)(x.refd8f3bd2d.sampleLocationsPerPixel)
	x.SampleLocationGridSize = *NewExtent2DRef(unsafe.Pointer(&x.refd8f3bd2d.sampleLocationGridSize))
	x.SampleLocationsCount = (uint32)(x.refd8f3bd2d.sampleLocationsCount)
	packSSampleLocation(x.PSampleLocations, x.refd8f3bd2d.pSampleLocations)
}

// allocAttachmentSampleLocationsMemory allocates memory for type C.VkAttachmentSampleLocationsEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentSampleLocationsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentSampleLocationsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAttachmentSampleLocationsValue = unsafe.Sizeof([1]C.VkAttachmentSampleLocationsEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentSampleLocations) Ref() *C.VkAttachmentSampleLocationsEXT {
	if x == nil {
		return nil
	}
	return x.ref6a3dd41e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentSampleLocations) Free() {
	if x != nil && x.allocs6a3dd41e != nil {
		x.allocs6a3dd41e.(*cgoAllocMap).Free()
		x.ref6a3dd41e = nil
	}
}

// NewAttachmentSampleLocationsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentSampleLocationsRef(ref unsafe.Pointer) *AttachmentSampleLocations {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentSampleLocations)
	obj.ref6a3dd41e = (*C.VkAttachmentSampleLocationsEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentSampleLocations) PassRef() (*C.VkAttachmentSampleLocationsEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6a3dd41e != nil {
		return x.ref6a3dd41e, nil
	}
	mem6a3dd41e := allocAttachmentSampleLocationsMemory(1)
	ref6a3dd41e := (*C.VkAttachmentSampleLocationsEXT)(mem6a3dd41e)
	allocs6a3dd41e := new(cgoAllocMap)
	allocs6a3dd41e.Add(mem6a3dd41e)

	var cattachmentIndex_allocs *cgoAllocMap
	ref6a3dd41e.attachmentIndex, cattachmentIndex_allocs = (C.uint32_t)(x.AttachmentIndex), cgoAllocsUnknown
	allocs6a3dd41e.Borrow(cattachmentIndex_allocs)

	var csampleLocationsInfo_allocs *cgoAllocMap
	ref6a3dd41e.sampleLocationsInfo, csampleLocationsInfo_allocs = x.SampleLocationsInfo.PassValue()
	allocs6a3dd41e.Borrow(csampleLocationsInfo_allocs)

	x.ref6a3dd41e = ref6a3dd41e
	x.allocs6a3dd41e = allocs6a3dd41e
	return ref6a3dd41e, allocs6a3dd41e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentSampleLocations) PassValue() (C.VkAttachmentSampleLocationsEXT, *cgoAllocMap) {
	if x.ref6a3dd41e != nil {
		return *x.ref6a3dd41e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentSampleLocations) Deref() {
	if x.ref6a3dd41e == nil {
		return
	}
	x.AttachmentIndex = (uint32)(x.ref6a3dd41e.attachmentIndex)
	x.SampleLocationsInfo = *NewSampleLocationsInfoRef(unsafe.Pointer(&x.ref6a3dd41e.sampleLocationsInfo))
}

// allocSubpassSampleLocationsMemory allocates memory for type C.VkSubpassSampleLocationsEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassSampleLocationsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassSampleLocationsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubpassSampleLocationsValue = unsafe.Sizeof([1]C.VkSubpassSampleLocationsEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassSampleLocations) Ref() *C.VkSubpassSampleLocationsEXT {
	if x == nil {
		return nil
	}
	return x.ref1f612812
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassSampleLocations) Free() {
	if x != nil && x.allocs1f612812 != nil {
		x.allocs1f612812.(*cgoAllocMap).Free()
		x.ref1f612812 = nil
	}
}

// NewSubpassSampleLocationsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassSampleLocationsRef(ref unsafe.Pointer) *SubpassSampleLocations {
	if ref == nil {
		return nil
	}
	obj := new(SubpassSampleLocations)
	obj.ref1f612812 = (*C.VkSubpassSampleLocationsEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassSampleLocations) PassRef() (*C.VkSubpassSampleLocationsEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1f612812 != nil {
		return x.ref1f612812, nil
	}
	mem1f612812 := allocSubpassSampleLocationsMemory(1)
	ref1f612812 := (*C.VkSubpassSampleLocationsEXT)(mem1f612812)
	allocs1f612812 := new(cgoAllocMap)
	allocs1f612812.Add(mem1f612812)

	var csubpassIndex_allocs *cgoAllocMap
	ref1f612812.subpassIndex, csubpassIndex_allocs = (C.uint32_t)(x.SubpassIndex), cgoAllocsUnknown
	allocs1f612812.Borrow(csubpassIndex_allocs)

	var csampleLocationsInfo_allocs *cgoAllocMap
	ref1f612812.sampleLocationsInfo, csampleLocationsInfo_allocs = x.SampleLocationsInfo.PassValue()
	allocs1f612812.Borrow(csampleLocationsInfo_allocs)

	x.ref1f612812 = ref1f612812
	x.allocs1f612812 = allocs1f612812
	return ref1f612812, allocs1f612812

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassSampleLocations) PassValue() (C.VkSubpassSampleLocationsEXT, *cgoAllocMap) {
	if x.ref1f612812 != nil {
		return *x.ref1f612812, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassSampleLocations) Deref() {
	if x.ref1f612812 == nil {
		return
	}
	x.SubpassIndex = (uint32)(x.ref1f612812.subpassIndex)
	x.SampleLocationsInfo = *NewSampleLocationsInfoRef(unsafe.Pointer(&x.ref1f612812.sampleLocationsInfo))
}

// allocRenderPassSampleLocationsBeginInfoMemory allocates memory for type C.VkRenderPassSampleLocationsBeginInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassSampleLocationsBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassSampleLocationsBeginInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderPassSampleLocationsBeginInfoValue = unsafe.Sizeof([1]C.VkRenderPassSampleLocationsBeginInfoEXT{})

// unpackSAttachmentSampleLocations transforms a sliced Go data structure into plain C format.
func unpackSAttachmentSampleLocations(x []AttachmentSampleLocations) (unpacked *C.VkAttachmentSampleLocationsEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentSampleLocationsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentSampleLocationsEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentSampleLocationsEXT)(h.Data)
	return
}

// unpackSSubpassSampleLocations transforms a sliced Go data structure into plain C format.
func unpackSSubpassSampleLocations(x []SubpassSampleLocations) (unpacked *C.VkSubpassSampleLocationsEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassSampleLocationsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassSampleLocationsEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassSampleLocationsEXT)(h.Data)
	return
}

// packSAttachmentSampleLocations reads sliced Go data structure out from plain C format.
func packSAttachmentSampleLocations(v []AttachmentSampleLocations, ptr0 *C.VkAttachmentSampleLocationsEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentSampleLocationsValue]C.VkAttachmentSampleLocationsEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentSampleLocationsRef(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassSampleLocations reads sliced Go data structure out from plain C format.
func packSSubpassSampleLocations(v []SubpassSampleLocations, ptr0 *C.VkSubpassSampleLocationsEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassSampleLocationsValue]C.VkSubpassSampleLocationsEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassSampleLocationsRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassSampleLocationsBeginInfo) Ref() *C.VkRenderPassSampleLocationsBeginInfoEXT {
	if x == nil {
		return nil
	}
	return x.refb61b51d4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassSampleLocationsBeginInfo) Free() {
	if x != nil && x.allocsb61b51d4 != nil {
		x.allocsb61b51d4.(*cgoAllocMap).Free()
		x.refb61b51d4 = nil
	}
}

// NewRenderPassSampleLocationsBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassSampleLocationsBeginInfoRef(ref unsafe.Pointer) *RenderPassSampleLocationsBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassSampleLocationsBeginInfo)
	obj.refb61b51d4 = (*C.VkRenderPassSampleLocationsBeginInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassSampleLocationsBeginInfo) PassRef() (*C.VkRenderPassSampleLocationsBeginInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb61b51d4 != nil {
		return x.refb61b51d4, nil
	}
	memb61b51d4 := allocRenderPassSampleLocationsBeginInfoMemory(1)
	refb61b51d4 := (*C.VkRenderPassSampleLocationsBeginInfoEXT)(memb61b51d4)
	allocsb61b51d4 := new(cgoAllocMap)
	allocsb61b51d4.Add(memb61b51d4)

	var csType_allocs *cgoAllocMap
	refb61b51d4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb61b51d4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb61b51d4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb61b51d4.Borrow(cpNext_allocs)

	var cattachmentInitialSampleLocationsCount_allocs *cgoAllocMap
	refb61b51d4.attachmentInitialSampleLocationsCount, cattachmentInitialSampleLocationsCount_allocs = (C.uint32_t)(x.AttachmentInitialSampleLocationsCount), cgoAllocsUnknown
	allocsb61b51d4.Borrow(cattachmentInitialSampleLocationsCount_allocs)

	var cpAttachmentInitialSampleLocations_allocs *cgoAllocMap
	refb61b51d4.pAttachmentInitialSampleLocations, cpAttachmentInitialSampleLocations_allocs = unpackSAttachmentSampleLocations(x.PAttachmentInitialSampleLocations)
	allocsb61b51d4.Borrow(cpAttachmentInitialSampleLocations_allocs)

	var cpostSubpassSampleLocationsCount_allocs *cgoAllocMap
	refb61b51d4.postSubpassSampleLocationsCount, cpostSubpassSampleLocationsCount_allocs = (C.uint32_t)(x.PostSubpassSampleLocationsCount), cgoAllocsUnknown
	allocsb61b51d4.Borrow(cpostSubpassSampleLocationsCount_allocs)

	var cpPostSubpassSampleLocations_allocs *cgoAllocMap
	refb61b51d4.pPostSubpassSampleLocations, cpPostSubpassSampleLocations_allocs = unpackSSubpassSampleLocations(x.PPostSubpassSampleLocations)
	allocsb61b51d4.Borrow(cpPostSubpassSampleLocations_allocs)

	x.refb61b51d4 = refb61b51d4
	x.allocsb61b51d4 = allocsb61b51d4
	return refb61b51d4, allocsb61b51d4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassSampleLocationsBeginInfo) PassValue() (C.VkRenderPassSampleLocationsBeginInfoEXT, *cgoAllocMap) {
	if x.refb61b51d4 != nil {
		return *x.refb61b51d4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassSampleLocationsBeginInfo) Deref() {
	if x.refb61b51d4 == nil {
		return
	}
	x.SType = (StructureType)(x.refb61b51d4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb61b51d4.pNext))
	x.AttachmentInitialSampleLocationsCount = (uint32)(x.refb61b51d4.attachmentInitialSampleLocationsCount)
	packSAttachmentSampleLocations(x.PAttachmentInitialSampleLocations, x.refb61b51d4.pAttachmentInitialSampleLocations)
	x.PostSubpassSampleLocationsCount = (uint32)(x.refb61b51d4.postSubpassSampleLocationsCount)
	packSSubpassSampleLocations(x.PPostSubpassSampleLocations, x.refb61b51d4.pPostSubpassSampleLocations)
}

// allocPipelineSampleLocationsStateCreateInfoMemory allocates memory for type C.VkPipelineSampleLocationsStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineSampleLocationsStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineSampleLocationsStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineSampleLocationsStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineSampleLocationsStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineSampleLocationsStateCreateInfo) Ref() *C.VkPipelineSampleLocationsStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref93a2968f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineSampleLocationsStateCreateInfo) Free() {
	if x != nil && x.allocs93a2968f != nil {
		x.allocs93a2968f.(*cgoAllocMap).Free()
		x.ref93a2968f = nil
	}
}

// NewPipelineSampleLocationsStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineSampleLocationsStateCreateInfoRef(ref unsafe.Pointer) *PipelineSampleLocationsStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineSampleLocationsStateCreateInfo)
	obj.ref93a2968f = (*C.VkPipelineSampleLocationsStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineSampleLocationsStateCreateInfo) PassRef() (*C.VkPipelineSampleLocationsStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref93a2968f != nil {
		return x.ref93a2968f, nil
	}
	mem93a2968f := allocPipelineSampleLocationsStateCreateInfoMemory(1)
	ref93a2968f := (*C.VkPipelineSampleLocationsStateCreateInfoEXT)(mem93a2968f)
	allocs93a2968f := new(cgoAllocMap)
	allocs93a2968f.Add(mem93a2968f)

	var csType_allocs *cgoAllocMap
	ref93a2968f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs93a2968f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref93a2968f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs93a2968f.Borrow(cpNext_allocs)

	var csampleLocationsEnable_allocs *cgoAllocMap
	ref93a2968f.sampleLocationsEnable, csampleLocationsEnable_allocs = (C.VkBool32)(x.SampleLocationsEnable), cgoAllocsUnknown
	allocs93a2968f.Borrow(csampleLocationsEnable_allocs)

	var csampleLocationsInfo_allocs *cgoAllocMap
	ref93a2968f.sampleLocationsInfo, csampleLocationsInfo_allocs = x.SampleLocationsInfo.PassValue()
	allocs93a2968f.Borrow(csampleLocationsInfo_allocs)

	x.ref93a2968f = ref93a2968f
	x.allocs93a2968f = allocs93a2968f
	return ref93a2968f, allocs93a2968f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineSampleLocationsStateCreateInfo) PassValue() (C.VkPipelineSampleLocationsStateCreateInfoEXT, *cgoAllocMap) {
	if x.ref93a2968f != nil {
		return *x.ref93a2968f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineSampleLocationsStateCreateInfo) Deref() {
	if x.ref93a2968f == nil {
		return
	}
	x.SType = (StructureType)(x.ref93a2968f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref93a2968f.pNext))
	x.SampleLocationsEnable = (Bool32)(x.ref93a2968f.sampleLocationsEnable)
	x.SampleLocationsInfo = *NewSampleLocationsInfoRef(unsafe.Pointer(&x.ref93a2968f.sampleLocationsInfo))
}

// allocPhysicalDeviceSampleLocationsPropertiesMemory allocates memory for type C.VkPhysicalDeviceSampleLocationsPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSampleLocationsPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSampleLocationsPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceSampleLocationsPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSampleLocationsPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSampleLocationsProperties) Ref() *C.VkPhysicalDeviceSampleLocationsPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refaf801323
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSampleLocationsProperties) Free() {
	if x != nil && x.allocsaf801323 != nil {
		x.allocsaf801323.(*cgoAllocMap).Free()
		x.refaf801323 = nil
	}
}

// NewPhysicalDeviceSampleLocationsPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSampleLocationsPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceSampleLocationsProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSampleLocationsProperties)
	obj.refaf801323 = (*C.VkPhysicalDeviceSampleLocationsPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSampleLocationsProperties) PassRef() (*C.VkPhysicalDeviceSampleLocationsPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaf801323 != nil {
		return x.refaf801323, nil
	}
	memaf801323 := allocPhysicalDeviceSampleLocationsPropertiesMemory(1)
	refaf801323 := (*C.VkPhysicalDeviceSampleLocationsPropertiesEXT)(memaf801323)
	allocsaf801323 := new(cgoAllocMap)
	allocsaf801323.Add(memaf801323)

	var csType_allocs *cgoAllocMap
	refaf801323.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsaf801323.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refaf801323.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsaf801323.Borrow(cpNext_allocs)

	var csampleLocationSampleCounts_allocs *cgoAllocMap
	refaf801323.sampleLocationSampleCounts, csampleLocationSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampleLocationSampleCounts), cgoAllocsUnknown
	allocsaf801323.Borrow(csampleLocationSampleCounts_allocs)

	var cmaxSampleLocationGridSize_allocs *cgoAllocMap
	refaf801323.maxSampleLocationGridSize, cmaxSampleLocationGridSize_allocs = x.MaxSampleLocationGridSize.PassValue()
	allocsaf801323.Borrow(cmaxSampleLocationGridSize_allocs)

	var csampleLocationCoordinateRange_allocs *cgoAllocMap
	refaf801323.sampleLocationCoordinateRange, csampleLocationCoordinateRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.SampleLocationCoordinateRange)), cgoAllocsUnknown
	allocsaf801323.Borrow(csampleLocationCoordinateRange_allocs)

	var csampleLocationSubPixelBits_allocs *cgoAllocMap
	refaf801323.sampleLocationSubPixelBits, csampleLocationSubPixelBits_allocs = (C.uint32_t)(x.SampleLocationSubPixelBits), cgoAllocsUnknown
	allocsaf801323.Borrow(csampleLocationSubPixelBits_allocs)

	var cvariableSampleLocations_allocs *cgoAllocMap
	refaf801323.variableSampleLocations, cvariableSampleLocations_allocs = (C.VkBool32)(x.VariableSampleLocations), cgoAllocsUnknown
	allocsaf801323.Borrow(cvariableSampleLocations_allocs)

	x.refaf801323 = refaf801323
	x.allocsaf801323 = allocsaf801323
	return refaf801323, allocsaf801323

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSampleLocationsProperties) PassValue() (C.VkPhysicalDeviceSampleLocationsPropertiesEXT, *cgoAllocMap) {
	if x.refaf801323 != nil {
		return *x.refaf801323, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSampleLocationsProperties) Deref() {
	if x.refaf801323 == nil {
		return
	}
	x.SType = (StructureType)(x.refaf801323.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refaf801323.pNext))
	x.SampleLocationSampleCounts = (SampleCountFlags)(x.refaf801323.sampleLocationSampleCounts)
	x.MaxSampleLocationGridSize = *NewExtent2DRef(unsafe.Pointer(&x.refaf801323.maxSampleLocationGridSize))
	x.SampleLocationCoordinateRange = *(*[2]float32)(unsafe.Pointer(&x.refaf801323.sampleLocationCoordinateRange))
	x.SampleLocationSubPixelBits = (uint32)(x.refaf801323.sampleLocationSubPixelBits)
	x.VariableSampleLocations = (Bool32)(x.refaf801323.variableSampleLocations)
}

// allocMultisamplePropertiesMemory allocates memory for type C.VkMultisamplePropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMultisamplePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMultisamplePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMultisamplePropertiesValue = unsafe.Sizeof([1]C.VkMultisamplePropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MultisampleProperties) Ref() *C.VkMultisamplePropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref3e47f337
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MultisampleProperties) Free() {
	if x != nil && x.allocs3e47f337 != nil {
		x.allocs3e47f337.(*cgoAllocMap).Free()
		x.ref3e47f337 = nil
	}
}

// NewMultisamplePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMultisamplePropertiesRef(ref unsafe.Pointer) *MultisampleProperties {
	if ref == nil {
		return nil
	}
	obj := new(MultisampleProperties)
	obj.ref3e47f337 = (*C.VkMultisamplePropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MultisampleProperties) PassRef() (*C.VkMultisamplePropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3e47f337 != nil {
		return x.ref3e47f337, nil
	}
	mem3e47f337 := allocMultisamplePropertiesMemory(1)
	ref3e47f337 := (*C.VkMultisamplePropertiesEXT)(mem3e47f337)
	allocs3e47f337 := new(cgoAllocMap)
	allocs3e47f337.Add(mem3e47f337)

	var csType_allocs *cgoAllocMap
	ref3e47f337.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3e47f337.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3e47f337.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3e47f337.Borrow(cpNext_allocs)

	var cmaxSampleLocationGridSize_allocs *cgoAllocMap
	ref3e47f337.maxSampleLocationGridSize, cmaxSampleLocationGridSize_allocs = x.MaxSampleLocationGridSize.PassValue()
	allocs3e47f337.Borrow(cmaxSampleLocationGridSize_allocs)

	x.ref3e47f337 = ref3e47f337
	x.allocs3e47f337 = allocs3e47f337
	return ref3e47f337, allocs3e47f337

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MultisampleProperties) PassValue() (C.VkMultisamplePropertiesEXT, *cgoAllocMap) {
	if x.ref3e47f337 != nil {
		return *x.ref3e47f337, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MultisampleProperties) Deref() {
	if x.ref3e47f337 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3e47f337.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3e47f337.pNext))
	x.MaxSampleLocationGridSize = *NewExtent2DRef(unsafe.Pointer(&x.ref3e47f337.maxSampleLocationGridSize))
}

// allocPhysicalDeviceBlendOperationAdvancedFeaturesMemory allocates memory for type C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceBlendOperationAdvancedFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceBlendOperationAdvancedFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceBlendOperationAdvancedFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceBlendOperationAdvancedFeatures) Ref() *C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref8514bc93
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceBlendOperationAdvancedFeatures) Free() {
	if x != nil && x.allocs8514bc93 != nil {
		x.allocs8514bc93.(*cgoAllocMap).Free()
		x.ref8514bc93 = nil
	}
}

// NewPhysicalDeviceBlendOperationAdvancedFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceBlendOperationAdvancedFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceBlendOperationAdvancedFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceBlendOperationAdvancedFeatures)
	obj.ref8514bc93 = (*C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceBlendOperationAdvancedFeatures) PassRef() (*C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8514bc93 != nil {
		return x.ref8514bc93, nil
	}
	mem8514bc93 := allocPhysicalDeviceBlendOperationAdvancedFeaturesMemory(1)
	ref8514bc93 := (*C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT)(mem8514bc93)
	allocs8514bc93 := new(cgoAllocMap)
	allocs8514bc93.Add(mem8514bc93)

	var csType_allocs *cgoAllocMap
	ref8514bc93.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8514bc93.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8514bc93.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8514bc93.Borrow(cpNext_allocs)

	var cadvancedBlendCoherentOperations_allocs *cgoAllocMap
	ref8514bc93.advancedBlendCoherentOperations, cadvancedBlendCoherentOperations_allocs = (C.VkBool32)(x.AdvancedBlendCoherentOperations), cgoAllocsUnknown
	allocs8514bc93.Borrow(cadvancedBlendCoherentOperations_allocs)

	x.ref8514bc93 = ref8514bc93
	x.allocs8514bc93 = allocs8514bc93
	return ref8514bc93, allocs8514bc93

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceBlendOperationAdvancedFeatures) PassValue() (C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, *cgoAllocMap) {
	if x.ref8514bc93 != nil {
		return *x.ref8514bc93, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceBlendOperationAdvancedFeatures) Deref() {
	if x.ref8514bc93 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8514bc93.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8514bc93.pNext))
	x.AdvancedBlendCoherentOperations = (Bool32)(x.ref8514bc93.advancedBlendCoherentOperations)
}

// allocPhysicalDeviceBlendOperationAdvancedPropertiesMemory allocates memory for type C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceBlendOperationAdvancedPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceBlendOperationAdvancedPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceBlendOperationAdvancedPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceBlendOperationAdvancedProperties) Ref() *C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref94cb3fa6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceBlendOperationAdvancedProperties) Free() {
	if x != nil && x.allocs94cb3fa6 != nil {
		x.allocs94cb3fa6.(*cgoAllocMap).Free()
		x.ref94cb3fa6 = nil
	}
}

// NewPhysicalDeviceBlendOperationAdvancedPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceBlendOperationAdvancedPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceBlendOperationAdvancedProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceBlendOperationAdvancedProperties)
	obj.ref94cb3fa6 = (*C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceBlendOperationAdvancedProperties) PassRef() (*C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref94cb3fa6 != nil {
		return x.ref94cb3fa6, nil
	}
	mem94cb3fa6 := allocPhysicalDeviceBlendOperationAdvancedPropertiesMemory(1)
	ref94cb3fa6 := (*C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT)(mem94cb3fa6)
	allocs94cb3fa6 := new(cgoAllocMap)
	allocs94cb3fa6.Add(mem94cb3fa6)

	var csType_allocs *cgoAllocMap
	ref94cb3fa6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref94cb3fa6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cpNext_allocs)

	var cadvancedBlendMaxColorAttachments_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendMaxColorAttachments, cadvancedBlendMaxColorAttachments_allocs = (C.uint32_t)(x.AdvancedBlendMaxColorAttachments), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendMaxColorAttachments_allocs)

	var cadvancedBlendIndependentBlend_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendIndependentBlend, cadvancedBlendIndependentBlend_allocs = (C.VkBool32)(x.AdvancedBlendIndependentBlend), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendIndependentBlend_allocs)

	var cadvancedBlendNonPremultipliedSrcColor_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendNonPremultipliedSrcColor, cadvancedBlendNonPremultipliedSrcColor_allocs = (C.VkBool32)(x.AdvancedBlendNonPremultipliedSrcColor), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendNonPremultipliedSrcColor_allocs)

	var cadvancedBlendNonPremultipliedDstColor_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendNonPremultipliedDstColor, cadvancedBlendNonPremultipliedDstColor_allocs = (C.VkBool32)(x.AdvancedBlendNonPremultipliedDstColor), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendNonPremultipliedDstColor_allocs)

	var cadvancedBlendCorrelatedOverlap_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendCorrelatedOverlap, cadvancedBlendCorrelatedOverlap_allocs = (C.VkBool32)(x.AdvancedBlendCorrelatedOverlap), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendCorrelatedOverlap_allocs)

	var cadvancedBlendAllOperations_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendAllOperations, cadvancedBlendAllOperations_allocs = (C.VkBool32)(x.AdvancedBlendAllOperations), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendAllOperations_allocs)

	x.ref94cb3fa6 = ref94cb3fa6
	x.allocs94cb3fa6 = allocs94cb3fa6
	return ref94cb3fa6, allocs94cb3fa6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceBlendOperationAdvancedProperties) PassValue() (C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, *cgoAllocMap) {
	if x.ref94cb3fa6 != nil {
		return *x.ref94cb3fa6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceBlendOperationAdvancedProperties) Deref() {
	if x.ref94cb3fa6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref94cb3fa6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref94cb3fa6.pNext))
	x.AdvancedBlendMaxColorAttachments = (uint32)(x.ref94cb3fa6.advancedBlendMaxColorAttachments)
	x.AdvancedBlendIndependentBlend = (Bool32)(x.ref94cb3fa6.advancedBlendIndependentBlend)
	x.AdvancedBlendNonPremultipliedSrcColor = (Bool32)(x.ref94cb3fa6.advancedBlendNonPremultipliedSrcColor)
	x.AdvancedBlendNonPremultipliedDstColor = (Bool32)(x.ref94cb3fa6.advancedBlendNonPremultipliedDstColor)
	x.AdvancedBlendCorrelatedOverlap = (Bool32)(x.ref94cb3fa6.advancedBlendCorrelatedOverlap)
	x.AdvancedBlendAllOperations = (Bool32)(x.ref94cb3fa6.advancedBlendAllOperations)
}

// allocPipelineColorBlendAdvancedStateCreateInfoMemory allocates memory for type C.VkPipelineColorBlendAdvancedStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineColorBlendAdvancedStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineColorBlendAdvancedStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineColorBlendAdvancedStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineColorBlendAdvancedStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineColorBlendAdvancedStateCreateInfo) Ref() *C.VkPipelineColorBlendAdvancedStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refcd374989
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineColorBlendAdvancedStateCreateInfo) Free() {
	if x != nil && x.allocscd374989 != nil {
		x.allocscd374989.(*cgoAllocMap).Free()
		x.refcd374989 = nil
	}
}

// NewPipelineColorBlendAdvancedStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineColorBlendAdvancedStateCreateInfoRef(ref unsafe.Pointer) *PipelineColorBlendAdvancedStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineColorBlendAdvancedStateCreateInfo)
	obj.refcd374989 = (*C.VkPipelineColorBlendAdvancedStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineColorBlendAdvancedStateCreateInfo) PassRef() (*C.VkPipelineColorBlendAdvancedStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcd374989 != nil {
		return x.refcd374989, nil
	}
	memcd374989 := allocPipelineColorBlendAdvancedStateCreateInfoMemory(1)
	refcd374989 := (*C.VkPipelineColorBlendAdvancedStateCreateInfoEXT)(memcd374989)
	allocscd374989 := new(cgoAllocMap)
	allocscd374989.Add(memcd374989)

	var csType_allocs *cgoAllocMap
	refcd374989.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscd374989.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcd374989.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscd374989.Borrow(cpNext_allocs)

	var csrcPremultiplied_allocs *cgoAllocMap
	refcd374989.srcPremultiplied, csrcPremultiplied_allocs = (C.VkBool32)(x.SrcPremultiplied), cgoAllocsUnknown
	allocscd374989.Borrow(csrcPremultiplied_allocs)

	var cdstPremultiplied_allocs *cgoAllocMap
	refcd374989.dstPremultiplied, cdstPremultiplied_allocs = (C.VkBool32)(x.DstPremultiplied), cgoAllocsUnknown
	allocscd374989.Borrow(cdstPremultiplied_allocs)

	var cblendOverlap_allocs *cgoAllocMap
	refcd374989.blendOverlap, cblendOverlap_allocs = (C.VkBlendOverlapEXT)(x.BlendOverlap), cgoAllocsUnknown
	allocscd374989.Borrow(cblendOverlap_allocs)

	x.refcd374989 = refcd374989
	x.allocscd374989 = allocscd374989
	return refcd374989, allocscd374989

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineColorBlendAdvancedStateCreateInfo) PassValue() (C.VkPipelineColorBlendAdvancedStateCreateInfoEXT, *cgoAllocMap) {
	if x.refcd374989 != nil {
		return *x.refcd374989, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineColorBlendAdvancedStateCreateInfo) Deref() {
	if x.refcd374989 == nil {
		return
	}
	x.SType = (StructureType)(x.refcd374989.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcd374989.pNext))
	x.SrcPremultiplied = (Bool32)(x.refcd374989.srcPremultiplied)
	x.DstPremultiplied = (Bool32)(x.refcd374989.dstPremultiplied)
	x.BlendOverlap = (BlendOverlap)(x.refcd374989.blendOverlap)
}

// allocPipelineCoverageToColorStateCreateInfoNVMemory allocates memory for type C.VkPipelineCoverageToColorStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCoverageToColorStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCoverageToColorStateCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineCoverageToColorStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineCoverageToColorStateCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineCoverageToColorStateCreateInfoNV) Ref() *C.VkPipelineCoverageToColorStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refcc6b7b68
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineCoverageToColorStateCreateInfoNV) Free() {
	if x != nil && x.allocscc6b7b68 != nil {
		x.allocscc6b7b68.(*cgoAllocMap).Free()
		x.refcc6b7b68 = nil
	}
}

// NewPipelineCoverageToColorStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineCoverageToColorStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineCoverageToColorStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCoverageToColorStateCreateInfoNV)
	obj.refcc6b7b68 = (*C.VkPipelineCoverageToColorStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineCoverageToColorStateCreateInfoNV) PassRef() (*C.VkPipelineCoverageToColorStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcc6b7b68 != nil {
		return x.refcc6b7b68, nil
	}
	memcc6b7b68 := allocPipelineCoverageToColorStateCreateInfoNVMemory(1)
	refcc6b7b68 := (*C.VkPipelineCoverageToColorStateCreateInfoNV)(memcc6b7b68)
	allocscc6b7b68 := new(cgoAllocMap)
	allocscc6b7b68.Add(memcc6b7b68)

	var csType_allocs *cgoAllocMap
	refcc6b7b68.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscc6b7b68.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcc6b7b68.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscc6b7b68.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refcc6b7b68.flags, cflags_allocs = (C.VkPipelineCoverageToColorStateCreateFlagsNV)(x.Flags), cgoAllocsUnknown
	allocscc6b7b68.Borrow(cflags_allocs)

	var ccoverageToColorEnable_allocs *cgoAllocMap
	refcc6b7b68.coverageToColorEnable, ccoverageToColorEnable_allocs = (C.VkBool32)(x.CoverageToColorEnable), cgoAllocsUnknown
	allocscc6b7b68.Borrow(ccoverageToColorEnable_allocs)

	var ccoverageToColorLocation_allocs *cgoAllocMap
	refcc6b7b68.coverageToColorLocation, ccoverageToColorLocation_allocs = (C.uint32_t)(x.CoverageToColorLocation), cgoAllocsUnknown
	allocscc6b7b68.Borrow(ccoverageToColorLocation_allocs)

	x.refcc6b7b68 = refcc6b7b68
	x.allocscc6b7b68 = allocscc6b7b68
	return refcc6b7b68, allocscc6b7b68

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineCoverageToColorStateCreateInfoNV) PassValue() (C.VkPipelineCoverageToColorStateCreateInfoNV, *cgoAllocMap) {
	if x.refcc6b7b68 != nil {
		return *x.refcc6b7b68, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineCoverageToColorStateCreateInfoNV) Deref() {
	if x.refcc6b7b68 == nil {
		return
	}
	x.SType = (StructureType)(x.refcc6b7b68.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcc6b7b68.pNext))
	x.Flags = (PipelineCoverageToColorStateCreateFlagsNV)(x.refcc6b7b68.flags)
	x.CoverageToColorEnable = (Bool32)(x.refcc6b7b68.coverageToColorEnable)
	x.CoverageToColorLocation = (uint32)(x.refcc6b7b68.coverageToColorLocation)
}

// allocPipelineCoverageModulationStateCreateInfoNVMemory allocates memory for type C.VkPipelineCoverageModulationStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCoverageModulationStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCoverageModulationStateCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineCoverageModulationStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineCoverageModulationStateCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineCoverageModulationStateCreateInfoNV) Ref() *C.VkPipelineCoverageModulationStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refa081b0ea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineCoverageModulationStateCreateInfoNV) Free() {
	if x != nil && x.allocsa081b0ea != nil {
		x.allocsa081b0ea.(*cgoAllocMap).Free()
		x.refa081b0ea = nil
	}
}

// NewPipelineCoverageModulationStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineCoverageModulationStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineCoverageModulationStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCoverageModulationStateCreateInfoNV)
	obj.refa081b0ea = (*C.VkPipelineCoverageModulationStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineCoverageModulationStateCreateInfoNV) PassRef() (*C.VkPipelineCoverageModulationStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa081b0ea != nil {
		return x.refa081b0ea, nil
	}
	mema081b0ea := allocPipelineCoverageModulationStateCreateInfoNVMemory(1)
	refa081b0ea := (*C.VkPipelineCoverageModulationStateCreateInfoNV)(mema081b0ea)
	allocsa081b0ea := new(cgoAllocMap)
	allocsa081b0ea.Add(mema081b0ea)

	var csType_allocs *cgoAllocMap
	refa081b0ea.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa081b0ea.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa081b0ea.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa081b0ea.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refa081b0ea.flags, cflags_allocs = (C.VkPipelineCoverageModulationStateCreateFlagsNV)(x.Flags), cgoAllocsUnknown
	allocsa081b0ea.Borrow(cflags_allocs)

	var ccoverageModulationMode_allocs *cgoAllocMap
	refa081b0ea.coverageModulationMode, ccoverageModulationMode_allocs = (C.VkCoverageModulationModeNV)(x.CoverageModulationMode), cgoAllocsUnknown
	allocsa081b0ea.Borrow(ccoverageModulationMode_allocs)

	var ccoverageModulationTableEnable_allocs *cgoAllocMap
	refa081b0ea.coverageModulationTableEnable, ccoverageModulationTableEnable_allocs = (C.VkBool32)(x.CoverageModulationTableEnable), cgoAllocsUnknown
	allocsa081b0ea.Borrow(ccoverageModulationTableEnable_allocs)

	var ccoverageModulationTableCount_allocs *cgoAllocMap
	refa081b0ea.coverageModulationTableCount, ccoverageModulationTableCount_allocs = (C.uint32_t)(x.CoverageModulationTableCount), cgoAllocsUnknown
	allocsa081b0ea.Borrow(ccoverageModulationTableCount_allocs)

	var cpCoverageModulationTable_allocs *cgoAllocMap
	refa081b0ea.pCoverageModulationTable, cpCoverageModulationTable_allocs = copyPFloatBytes((*sliceHeader)(unsafe.Pointer(&x.PCoverageModulationTable)))
	allocsa081b0ea.Borrow(cpCoverageModulationTable_allocs)

	x.refa081b0ea = refa081b0ea
	x.allocsa081b0ea = allocsa081b0ea
	return refa081b0ea, allocsa081b0ea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineCoverageModulationStateCreateInfoNV) PassValue() (C.VkPipelineCoverageModulationStateCreateInfoNV, *cgoAllocMap) {
	if x.refa081b0ea != nil {
		return *x.refa081b0ea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineCoverageModulationStateCreateInfoNV) Deref() {
	if x.refa081b0ea == nil {
		return
	}
	x.SType = (StructureType)(x.refa081b0ea.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa081b0ea.pNext))
	x.Flags = (PipelineCoverageModulationStateCreateFlagsNV)(x.refa081b0ea.flags)
	x.CoverageModulationMode = (CoverageModulationModeNV)(x.refa081b0ea.coverageModulationMode)
	x.CoverageModulationTableEnable = (Bool32)(x.refa081b0ea.coverageModulationTableEnable)
	x.CoverageModulationTableCount = (uint32)(x.refa081b0ea.coverageModulationTableCount)
	hxf8b35a8 := (*sliceHeader)(unsafe.Pointer(&x.PCoverageModulationTable))
	hxf8b35a8.Data = unsafe.Pointer(x.refa081b0ea.pCoverageModulationTable)
	hxf8b35a8.Cap = 0x7fffffff
	// hxf8b35a8.Len = ?

}

// allocPhysicalDeviceShaderSMBuiltinsPropertiesNVMemory allocates memory for type C.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderSMBuiltinsPropertiesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderSMBuiltinsPropertiesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShaderSMBuiltinsPropertiesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderSMBuiltinsPropertiesNV) Ref() *C.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV {
	if x == nil {
		return nil
	}
	return x.refc083cf09
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderSMBuiltinsPropertiesNV) Free() {
	if x != nil && x.allocsc083cf09 != nil {
		x.allocsc083cf09.(*cgoAllocMap).Free()
		x.refc083cf09 = nil
	}
}

// NewPhysicalDeviceShaderSMBuiltinsPropertiesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderSMBuiltinsPropertiesNVRef(ref unsafe.Pointer) *PhysicalDeviceShaderSMBuiltinsPropertiesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderSMBuiltinsPropertiesNV)
	obj.refc083cf09 = (*C.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderSMBuiltinsPropertiesNV) PassRef() (*C.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc083cf09 != nil {
		return x.refc083cf09, nil
	}
	memc083cf09 := allocPhysicalDeviceShaderSMBuiltinsPropertiesNVMemory(1)
	refc083cf09 := (*C.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV)(memc083cf09)
	allocsc083cf09 := new(cgoAllocMap)
	allocsc083cf09.Add(memc083cf09)

	var csType_allocs *cgoAllocMap
	refc083cf09.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc083cf09.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc083cf09.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc083cf09.Borrow(cpNext_allocs)

	var cshaderSMCount_allocs *cgoAllocMap
	refc083cf09.shaderSMCount, cshaderSMCount_allocs = (C.uint32_t)(x.ShaderSMCount), cgoAllocsUnknown
	allocsc083cf09.Borrow(cshaderSMCount_allocs)

	var cshaderWarpsPerSM_allocs *cgoAllocMap
	refc083cf09.shaderWarpsPerSM, cshaderWarpsPerSM_allocs = (C.uint32_t)(x.ShaderWarpsPerSM), cgoAllocsUnknown
	allocsc083cf09.Borrow(cshaderWarpsPerSM_allocs)

	x.refc083cf09 = refc083cf09
	x.allocsc083cf09 = allocsc083cf09
	return refc083cf09, allocsc083cf09

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderSMBuiltinsPropertiesNV) PassValue() (C.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, *cgoAllocMap) {
	if x.refc083cf09 != nil {
		return *x.refc083cf09, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderSMBuiltinsPropertiesNV) Deref() {
	if x.refc083cf09 == nil {
		return
	}
	x.SType = (StructureType)(x.refc083cf09.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc083cf09.pNext))
	x.ShaderSMCount = (uint32)(x.refc083cf09.shaderSMCount)
	x.ShaderWarpsPerSM = (uint32)(x.refc083cf09.shaderWarpsPerSM)
}

// allocPhysicalDeviceShaderSMBuiltinsFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderSMBuiltinsFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderSMBuiltinsFeaturesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShaderSMBuiltinsFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderSMBuiltinsFeaturesNV) Ref() *C.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV {
	if x == nil {
		return nil
	}
	return x.ref1965c1d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderSMBuiltinsFeaturesNV) Free() {
	if x != nil && x.allocs1965c1d != nil {
		x.allocs1965c1d.(*cgoAllocMap).Free()
		x.ref1965c1d = nil
	}
}

// NewPhysicalDeviceShaderSMBuiltinsFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderSMBuiltinsFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceShaderSMBuiltinsFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderSMBuiltinsFeaturesNV)
	obj.ref1965c1d = (*C.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderSMBuiltinsFeaturesNV) PassRef() (*C.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1965c1d != nil {
		return x.ref1965c1d, nil
	}
	mem1965c1d := allocPhysicalDeviceShaderSMBuiltinsFeaturesNVMemory(1)
	ref1965c1d := (*C.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV)(mem1965c1d)
	allocs1965c1d := new(cgoAllocMap)
	allocs1965c1d.Add(mem1965c1d)

	var csType_allocs *cgoAllocMap
	ref1965c1d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1965c1d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1965c1d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1965c1d.Borrow(cpNext_allocs)

	var cshaderSMBuiltins_allocs *cgoAllocMap
	ref1965c1d.shaderSMBuiltins, cshaderSMBuiltins_allocs = (C.VkBool32)(x.ShaderSMBuiltins), cgoAllocsUnknown
	allocs1965c1d.Borrow(cshaderSMBuiltins_allocs)

	x.ref1965c1d = ref1965c1d
	x.allocs1965c1d = allocs1965c1d
	return ref1965c1d, allocs1965c1d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderSMBuiltinsFeaturesNV) PassValue() (C.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, *cgoAllocMap) {
	if x.ref1965c1d != nil {
		return *x.ref1965c1d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderSMBuiltinsFeaturesNV) Deref() {
	if x.ref1965c1d == nil {
		return
	}
	x.SType = (StructureType)(x.ref1965c1d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1965c1d.pNext))
	x.ShaderSMBuiltins = (Bool32)(x.ref1965c1d.shaderSMBuiltins)
}

// allocDrmFormatModifierPropertiesMemory allocates memory for type C.VkDrmFormatModifierPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrmFormatModifierPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrmFormatModifierPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDrmFormatModifierPropertiesValue = unsafe.Sizeof([1]C.VkDrmFormatModifierPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrmFormatModifierProperties) Ref() *C.VkDrmFormatModifierPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref7dcb7f85
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrmFormatModifierProperties) Free() {
	if x != nil && x.allocs7dcb7f85 != nil {
		x.allocs7dcb7f85.(*cgoAllocMap).Free()
		x.ref7dcb7f85 = nil
	}
}

// NewDrmFormatModifierPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrmFormatModifierPropertiesRef(ref unsafe.Pointer) *DrmFormatModifierProperties {
	if ref == nil {
		return nil
	}
	obj := new(DrmFormatModifierProperties)
	obj.ref7dcb7f85 = (*C.VkDrmFormatModifierPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrmFormatModifierProperties) PassRef() (*C.VkDrmFormatModifierPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7dcb7f85 != nil {
		return x.ref7dcb7f85, nil
	}
	mem7dcb7f85 := allocDrmFormatModifierPropertiesMemory(1)
	ref7dcb7f85 := (*C.VkDrmFormatModifierPropertiesEXT)(mem7dcb7f85)
	allocs7dcb7f85 := new(cgoAllocMap)
	allocs7dcb7f85.Add(mem7dcb7f85)

	var cdrmFormatModifier_allocs *cgoAllocMap
	ref7dcb7f85.drmFormatModifier, cdrmFormatModifier_allocs = (C.uint64_t)(x.DrmFormatModifier), cgoAllocsUnknown
	allocs7dcb7f85.Borrow(cdrmFormatModifier_allocs)

	var cdrmFormatModifierPlaneCount_allocs *cgoAllocMap
	ref7dcb7f85.drmFormatModifierPlaneCount, cdrmFormatModifierPlaneCount_allocs = (C.uint32_t)(x.DrmFormatModifierPlaneCount), cgoAllocsUnknown
	allocs7dcb7f85.Borrow(cdrmFormatModifierPlaneCount_allocs)

	var cdrmFormatModifierTilingFeatures_allocs *cgoAllocMap
	ref7dcb7f85.drmFormatModifierTilingFeatures, cdrmFormatModifierTilingFeatures_allocs = (C.VkFormatFeatureFlags)(x.DrmFormatModifierTilingFeatures), cgoAllocsUnknown
	allocs7dcb7f85.Borrow(cdrmFormatModifierTilingFeatures_allocs)

	x.ref7dcb7f85 = ref7dcb7f85
	x.allocs7dcb7f85 = allocs7dcb7f85
	return ref7dcb7f85, allocs7dcb7f85

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrmFormatModifierProperties) PassValue() (C.VkDrmFormatModifierPropertiesEXT, *cgoAllocMap) {
	if x.ref7dcb7f85 != nil {
		return *x.ref7dcb7f85, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrmFormatModifierProperties) Deref() {
	if x.ref7dcb7f85 == nil {
		return
	}
	x.DrmFormatModifier = (uint32)(x.ref7dcb7f85.drmFormatModifier)
	x.DrmFormatModifierPlaneCount = (uint32)(x.ref7dcb7f85.drmFormatModifierPlaneCount)
	x.DrmFormatModifierTilingFeatures = (FormatFeatureFlags)(x.ref7dcb7f85.drmFormatModifierTilingFeatures)
}

// allocDrmFormatModifierPropertiesListMemory allocates memory for type C.VkDrmFormatModifierPropertiesListEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrmFormatModifierPropertiesListMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrmFormatModifierPropertiesListValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDrmFormatModifierPropertiesListValue = unsafe.Sizeof([1]C.VkDrmFormatModifierPropertiesListEXT{})

// unpackSDrmFormatModifierProperties transforms a sliced Go data structure into plain C format.
func unpackSDrmFormatModifierProperties(x []DrmFormatModifierProperties) (unpacked *C.VkDrmFormatModifierPropertiesEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDrmFormatModifierPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDrmFormatModifierPropertiesEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDrmFormatModifierPropertiesEXT)(h.Data)
	return
}

// packSDrmFormatModifierProperties reads sliced Go data structure out from plain C format.
func packSDrmFormatModifierProperties(v []DrmFormatModifierProperties, ptr0 *C.VkDrmFormatModifierPropertiesEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDrmFormatModifierPropertiesValue]C.VkDrmFormatModifierPropertiesEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDrmFormatModifierPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrmFormatModifierPropertiesList) Ref() *C.VkDrmFormatModifierPropertiesListEXT {
	if x == nil {
		return nil
	}
	return x.ref7e3ede2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrmFormatModifierPropertiesList) Free() {
	if x != nil && x.allocs7e3ede2 != nil {
		x.allocs7e3ede2.(*cgoAllocMap).Free()
		x.ref7e3ede2 = nil
	}
}

// NewDrmFormatModifierPropertiesListRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrmFormatModifierPropertiesListRef(ref unsafe.Pointer) *DrmFormatModifierPropertiesList {
	if ref == nil {
		return nil
	}
	obj := new(DrmFormatModifierPropertiesList)
	obj.ref7e3ede2 = (*C.VkDrmFormatModifierPropertiesListEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrmFormatModifierPropertiesList) PassRef() (*C.VkDrmFormatModifierPropertiesListEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7e3ede2 != nil {
		return x.ref7e3ede2, nil
	}
	mem7e3ede2 := allocDrmFormatModifierPropertiesListMemory(1)
	ref7e3ede2 := (*C.VkDrmFormatModifierPropertiesListEXT)(mem7e3ede2)
	allocs7e3ede2 := new(cgoAllocMap)
	allocs7e3ede2.Add(mem7e3ede2)

	var csType_allocs *cgoAllocMap
	ref7e3ede2.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7e3ede2.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7e3ede2.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7e3ede2.Borrow(cpNext_allocs)

	var cdrmFormatModifierCount_allocs *cgoAllocMap
	ref7e3ede2.drmFormatModifierCount, cdrmFormatModifierCount_allocs = (C.uint32_t)(x.DrmFormatModifierCount), cgoAllocsUnknown
	allocs7e3ede2.Borrow(cdrmFormatModifierCount_allocs)

	var cpDrmFormatModifierProperties_allocs *cgoAllocMap
	ref7e3ede2.pDrmFormatModifierProperties, cpDrmFormatModifierProperties_allocs = unpackSDrmFormatModifierProperties(x.PDrmFormatModifierProperties)
	allocs7e3ede2.Borrow(cpDrmFormatModifierProperties_allocs)

	x.ref7e3ede2 = ref7e3ede2
	x.allocs7e3ede2 = allocs7e3ede2
	return ref7e3ede2, allocs7e3ede2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrmFormatModifierPropertiesList) PassValue() (C.VkDrmFormatModifierPropertiesListEXT, *cgoAllocMap) {
	if x.ref7e3ede2 != nil {
		return *x.ref7e3ede2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrmFormatModifierPropertiesList) Deref() {
	if x.ref7e3ede2 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7e3ede2.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7e3ede2.pNext))
	x.DrmFormatModifierCount = (uint32)(x.ref7e3ede2.drmFormatModifierCount)
	packSDrmFormatModifierProperties(x.PDrmFormatModifierProperties, x.ref7e3ede2.pDrmFormatModifierProperties)
}

// allocPhysicalDeviceImageDrmFormatModifierInfoMemory allocates memory for type C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceImageDrmFormatModifierInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceImageDrmFormatModifierInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceImageDrmFormatModifierInfoValue = unsafe.Sizeof([1]C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceImageDrmFormatModifierInfo) Ref() *C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
	if x == nil {
		return nil
	}
	return x.refd7abef44
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceImageDrmFormatModifierInfo) Free() {
	if x != nil && x.allocsd7abef44 != nil {
		x.allocsd7abef44.(*cgoAllocMap).Free()
		x.refd7abef44 = nil
	}
}

// NewPhysicalDeviceImageDrmFormatModifierInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceImageDrmFormatModifierInfoRef(ref unsafe.Pointer) *PhysicalDeviceImageDrmFormatModifierInfo {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceImageDrmFormatModifierInfo)
	obj.refd7abef44 = (*C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceImageDrmFormatModifierInfo) PassRef() (*C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd7abef44 != nil {
		return x.refd7abef44, nil
	}
	memd7abef44 := allocPhysicalDeviceImageDrmFormatModifierInfoMemory(1)
	refd7abef44 := (*C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT)(memd7abef44)
	allocsd7abef44 := new(cgoAllocMap)
	allocsd7abef44.Add(memd7abef44)

	var csType_allocs *cgoAllocMap
	refd7abef44.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd7abef44.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd7abef44.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd7abef44.Borrow(cpNext_allocs)

	var cdrmFormatModifier_allocs *cgoAllocMap
	refd7abef44.drmFormatModifier, cdrmFormatModifier_allocs = (C.uint64_t)(x.DrmFormatModifier), cgoAllocsUnknown
	allocsd7abef44.Borrow(cdrmFormatModifier_allocs)

	var csharingMode_allocs *cgoAllocMap
	refd7abef44.sharingMode, csharingMode_allocs = (C.VkSharingMode)(x.SharingMode), cgoAllocsUnknown
	allocsd7abef44.Borrow(csharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	refd7abef44.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsd7abef44.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	refd7abef44.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)))
	allocsd7abef44.Borrow(cpQueueFamilyIndices_allocs)

	x.refd7abef44 = refd7abef44
	x.allocsd7abef44 = allocsd7abef44
	return refd7abef44, allocsd7abef44

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceImageDrmFormatModifierInfo) PassValue() (C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT, *cgoAllocMap) {
	if x.refd7abef44 != nil {
		return *x.refd7abef44, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceImageDrmFormatModifierInfo) Deref() {
	if x.refd7abef44 == nil {
		return
	}
	x.SType = (StructureType)(x.refd7abef44.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd7abef44.pNext))
	x.DrmFormatModifier = (uint32)(x.refd7abef44.drmFormatModifier)
	x.SharingMode = (SharingMode)(x.refd7abef44.sharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.refd7abef44.queueFamilyIndexCount)
	hxf8959c2 := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf8959c2.Data = unsafe.Pointer(x.refd7abef44.pQueueFamilyIndices)
	hxf8959c2.Cap = 0x7fffffff
	// hxf8959c2.Len = ?

}

// allocImageDrmFormatModifierListCreateInfoMemory allocates memory for type C.VkImageDrmFormatModifierListCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageDrmFormatModifierListCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageDrmFormatModifierListCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageDrmFormatModifierListCreateInfoValue = unsafe.Sizeof([1]C.VkImageDrmFormatModifierListCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageDrmFormatModifierListCreateInfo) Ref() *C.VkImageDrmFormatModifierListCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref544538ab
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageDrmFormatModifierListCreateInfo) Free() {
	if x != nil && x.allocs544538ab != nil {
		x.allocs544538ab.(*cgoAllocMap).Free()
		x.ref544538ab = nil
	}
}

// NewImageDrmFormatModifierListCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageDrmFormatModifierListCreateInfoRef(ref unsafe.Pointer) *ImageDrmFormatModifierListCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageDrmFormatModifierListCreateInfo)
	obj.ref544538ab = (*C.VkImageDrmFormatModifierListCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageDrmFormatModifierListCreateInfo) PassRef() (*C.VkImageDrmFormatModifierListCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref544538ab != nil {
		return x.ref544538ab, nil
	}
	mem544538ab := allocImageDrmFormatModifierListCreateInfoMemory(1)
	ref544538ab := (*C.VkImageDrmFormatModifierListCreateInfoEXT)(mem544538ab)
	allocs544538ab := new(cgoAllocMap)
	allocs544538ab.Add(mem544538ab)

	var csType_allocs *cgoAllocMap
	ref544538ab.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs544538ab.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref544538ab.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs544538ab.Borrow(cpNext_allocs)

	var cdrmFormatModifierCount_allocs *cgoAllocMap
	ref544538ab.drmFormatModifierCount, cdrmFormatModifierCount_allocs = (C.uint32_t)(x.DrmFormatModifierCount), cgoAllocsUnknown
	allocs544538ab.Borrow(cdrmFormatModifierCount_allocs)

	var cpDrmFormatModifiers_allocs *cgoAllocMap
	ref544538ab.pDrmFormatModifiers, cpDrmFormatModifiers_allocs = copyPUint64_tBytes((*sliceHeader)(unsafe.Pointer(&x.PDrmFormatModifiers)))
	allocs544538ab.Borrow(cpDrmFormatModifiers_allocs)

	x.ref544538ab = ref544538ab
	x.allocs544538ab = allocs544538ab
	return ref544538ab, allocs544538ab

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageDrmFormatModifierListCreateInfo) PassValue() (C.VkImageDrmFormatModifierListCreateInfoEXT, *cgoAllocMap) {
	if x.ref544538ab != nil {
		return *x.ref544538ab, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageDrmFormatModifierListCreateInfo) Deref() {
	if x.ref544538ab == nil {
		return
	}
	x.SType = (StructureType)(x.ref544538ab.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref544538ab.pNext))
	x.DrmFormatModifierCount = (uint32)(x.ref544538ab.drmFormatModifierCount)
	hxfb029a7 := (*sliceHeader)(unsafe.Pointer(&x.PDrmFormatModifiers))
	hxfb029a7.Data = unsafe.Pointer(x.ref544538ab.pDrmFormatModifiers)
	hxfb029a7.Cap = 0x7fffffff
	// hxfb029a7.Len = ?

}

// allocImageDrmFormatModifierExplicitCreateInfoMemory allocates memory for type C.VkImageDrmFormatModifierExplicitCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageDrmFormatModifierExplicitCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageDrmFormatModifierExplicitCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageDrmFormatModifierExplicitCreateInfoValue = unsafe.Sizeof([1]C.VkImageDrmFormatModifierExplicitCreateInfoEXT{})

// unpackSSubresourceLayout transforms a sliced Go data structure into plain C format.
func unpackSSubresourceLayout(x []SubresourceLayout) (unpacked *C.VkSubresourceLayout, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSubresourceLayoutMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubresourceLayout)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubresourceLayout)(h.Data)
	return
}

// packSSubresourceLayout reads sliced Go data structure out from plain C format.
func packSSubresourceLayout(v []SubresourceLayout, ptr0 *C.VkSubresourceLayout) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubresourceLayoutValue]C.VkSubresourceLayout)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubresourceLayoutRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageDrmFormatModifierExplicitCreateInfo) Ref() *C.VkImageDrmFormatModifierExplicitCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref8fb45ca9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageDrmFormatModifierExplicitCreateInfo) Free() {
	if x != nil && x.allocs8fb45ca9 != nil {
		x.allocs8fb45ca9.(*cgoAllocMap).Free()
		x.ref8fb45ca9 = nil
	}
}

// NewImageDrmFormatModifierExplicitCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageDrmFormatModifierExplicitCreateInfoRef(ref unsafe.Pointer) *ImageDrmFormatModifierExplicitCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageDrmFormatModifierExplicitCreateInfo)
	obj.ref8fb45ca9 = (*C.VkImageDrmFormatModifierExplicitCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageDrmFormatModifierExplicitCreateInfo) PassRef() (*C.VkImageDrmFormatModifierExplicitCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8fb45ca9 != nil {
		return x.ref8fb45ca9, nil
	}
	mem8fb45ca9 := allocImageDrmFormatModifierExplicitCreateInfoMemory(1)
	ref8fb45ca9 := (*C.VkImageDrmFormatModifierExplicitCreateInfoEXT)(mem8fb45ca9)
	allocs8fb45ca9 := new(cgoAllocMap)
	allocs8fb45ca9.Add(mem8fb45ca9)

	var csType_allocs *cgoAllocMap
	ref8fb45ca9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8fb45ca9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8fb45ca9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8fb45ca9.Borrow(cpNext_allocs)

	var cdrmFormatModifier_allocs *cgoAllocMap
	ref8fb45ca9.drmFormatModifier, cdrmFormatModifier_allocs = (C.uint64_t)(x.DrmFormatModifier), cgoAllocsUnknown
	allocs8fb45ca9.Borrow(cdrmFormatModifier_allocs)

	var cdrmFormatModifierPlaneCount_allocs *cgoAllocMap
	ref8fb45ca9.drmFormatModifierPlaneCount, cdrmFormatModifierPlaneCount_allocs = (C.uint32_t)(x.DrmFormatModifierPlaneCount), cgoAllocsUnknown
	allocs8fb45ca9.Borrow(cdrmFormatModifierPlaneCount_allocs)

	var cpPlaneLayouts_allocs *cgoAllocMap
	ref8fb45ca9.pPlaneLayouts, cpPlaneLayouts_allocs = unpackSSubresourceLayout(x.PPlaneLayouts)
	allocs8fb45ca9.Borrow(cpPlaneLayouts_allocs)

	x.ref8fb45ca9 = ref8fb45ca9
	x.allocs8fb45ca9 = allocs8fb45ca9
	return ref8fb45ca9, allocs8fb45ca9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageDrmFormatModifierExplicitCreateInfo) PassValue() (C.VkImageDrmFormatModifierExplicitCreateInfoEXT, *cgoAllocMap) {
	if x.ref8fb45ca9 != nil {
		return *x.ref8fb45ca9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageDrmFormatModifierExplicitCreateInfo) Deref() {
	if x.ref8fb45ca9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8fb45ca9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8fb45ca9.pNext))
	x.DrmFormatModifier = (uint32)(x.ref8fb45ca9.drmFormatModifier)
	x.DrmFormatModifierPlaneCount = (uint32)(x.ref8fb45ca9.drmFormatModifierPlaneCount)
	packSSubresourceLayout(x.PPlaneLayouts, x.ref8fb45ca9.pPlaneLayouts)
}

// allocImageDrmFormatModifierPropertiesMemory allocates memory for type C.VkImageDrmFormatModifierPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageDrmFormatModifierPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageDrmFormatModifierPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageDrmFormatModifierPropertiesValue = unsafe.Sizeof([1]C.VkImageDrmFormatModifierPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageDrmFormatModifierProperties) Ref() *C.VkImageDrmFormatModifierPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref86a0f149
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageDrmFormatModifierProperties) Free() {
	if x != nil && x.allocs86a0f149 != nil {
		x.allocs86a0f149.(*cgoAllocMap).Free()
		x.ref86a0f149 = nil
	}
}

// NewImageDrmFormatModifierPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageDrmFormatModifierPropertiesRef(ref unsafe.Pointer) *ImageDrmFormatModifierProperties {
	if ref == nil {
		return nil
	}
	obj := new(ImageDrmFormatModifierProperties)
	obj.ref86a0f149 = (*C.VkImageDrmFormatModifierPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageDrmFormatModifierProperties) PassRef() (*C.VkImageDrmFormatModifierPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref86a0f149 != nil {
		return x.ref86a0f149, nil
	}
	mem86a0f149 := allocImageDrmFormatModifierPropertiesMemory(1)
	ref86a0f149 := (*C.VkImageDrmFormatModifierPropertiesEXT)(mem86a0f149)
	allocs86a0f149 := new(cgoAllocMap)
	allocs86a0f149.Add(mem86a0f149)

	var csType_allocs *cgoAllocMap
	ref86a0f149.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs86a0f149.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref86a0f149.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs86a0f149.Borrow(cpNext_allocs)

	var cdrmFormatModifier_allocs *cgoAllocMap
	ref86a0f149.drmFormatModifier, cdrmFormatModifier_allocs = (C.uint64_t)(x.DrmFormatModifier), cgoAllocsUnknown
	allocs86a0f149.Borrow(cdrmFormatModifier_allocs)

	x.ref86a0f149 = ref86a0f149
	x.allocs86a0f149 = allocs86a0f149
	return ref86a0f149, allocs86a0f149

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageDrmFormatModifierProperties) PassValue() (C.VkImageDrmFormatModifierPropertiesEXT, *cgoAllocMap) {
	if x.ref86a0f149 != nil {
		return *x.ref86a0f149, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageDrmFormatModifierProperties) Deref() {
	if x.ref86a0f149 == nil {
		return
	}
	x.SType = (StructureType)(x.ref86a0f149.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref86a0f149.pNext))
	x.DrmFormatModifier = (uint32)(x.ref86a0f149.drmFormatModifier)
}

// allocValidationCacheCreateInfoMemory allocates memory for type C.VkValidationCacheCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValidationCacheCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValidationCacheCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfValidationCacheCreateInfoValue = unsafe.Sizeof([1]C.VkValidationCacheCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ValidationCacheCreateInfo) Ref() *C.VkValidationCacheCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref3d8ac8aa
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ValidationCacheCreateInfo) Free() {
	if x != nil && x.allocs3d8ac8aa != nil {
		x.allocs3d8ac8aa.(*cgoAllocMap).Free()
		x.ref3d8ac8aa = nil
	}
}

// NewValidationCacheCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewValidationCacheCreateInfoRef(ref unsafe.Pointer) *ValidationCacheCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ValidationCacheCreateInfo)
	obj.ref3d8ac8aa = (*C.VkValidationCacheCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ValidationCacheCreateInfo) PassRef() (*C.VkValidationCacheCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3d8ac8aa != nil {
		return x.ref3d8ac8aa, nil
	}
	mem3d8ac8aa := allocValidationCacheCreateInfoMemory(1)
	ref3d8ac8aa := (*C.VkValidationCacheCreateInfoEXT)(mem3d8ac8aa)
	allocs3d8ac8aa := new(cgoAllocMap)
	allocs3d8ac8aa.Add(mem3d8ac8aa)

	var csType_allocs *cgoAllocMap
	ref3d8ac8aa.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3d8ac8aa.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3d8ac8aa.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3d8ac8aa.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref3d8ac8aa.flags, cflags_allocs = (C.VkValidationCacheCreateFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocs3d8ac8aa.Borrow(cflags_allocs)

	var cinitialDataSize_allocs *cgoAllocMap
	ref3d8ac8aa.initialDataSize, cinitialDataSize_allocs = (C.size_t)(x.InitialDataSize), cgoAllocsUnknown
	allocs3d8ac8aa.Borrow(cinitialDataSize_allocs)

	var cpInitialData_allocs *cgoAllocMap
	ref3d8ac8aa.pInitialData, cpInitialData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PInitialData)), cgoAllocsUnknown
	allocs3d8ac8aa.Borrow(cpInitialData_allocs)

	x.ref3d8ac8aa = ref3d8ac8aa
	x.allocs3d8ac8aa = allocs3d8ac8aa
	return ref3d8ac8aa, allocs3d8ac8aa

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ValidationCacheCreateInfo) PassValue() (C.VkValidationCacheCreateInfoEXT, *cgoAllocMap) {
	if x.ref3d8ac8aa != nil {
		return *x.ref3d8ac8aa, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ValidationCacheCreateInfo) Deref() {
	if x.ref3d8ac8aa == nil {
		return
	}
	x.SType = (StructureType)(x.ref3d8ac8aa.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3d8ac8aa.pNext))
	x.Flags = (ValidationCacheCreateFlags)(x.ref3d8ac8aa.flags)
	x.InitialDataSize = (uint32)(x.ref3d8ac8aa.initialDataSize)
	x.PInitialData = (unsafe.Pointer)(unsafe.Pointer(x.ref3d8ac8aa.pInitialData))
}

// allocShaderModuleValidationCacheCreateInfoMemory allocates memory for type C.VkShaderModuleValidationCacheCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderModuleValidationCacheCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderModuleValidationCacheCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfShaderModuleValidationCacheCreateInfoValue = unsafe.Sizeof([1]C.VkShaderModuleValidationCacheCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShaderModuleValidationCacheCreateInfo) Ref() *C.VkShaderModuleValidationCacheCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref37065f24
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShaderModuleValidationCacheCreateInfo) Free() {
	if x != nil && x.allocs37065f24 != nil {
		x.allocs37065f24.(*cgoAllocMap).Free()
		x.ref37065f24 = nil
	}
}

// NewShaderModuleValidationCacheCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderModuleValidationCacheCreateInfoRef(ref unsafe.Pointer) *ShaderModuleValidationCacheCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ShaderModuleValidationCacheCreateInfo)
	obj.ref37065f24 = (*C.VkShaderModuleValidationCacheCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShaderModuleValidationCacheCreateInfo) PassRef() (*C.VkShaderModuleValidationCacheCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref37065f24 != nil {
		return x.ref37065f24, nil
	}
	mem37065f24 := allocShaderModuleValidationCacheCreateInfoMemory(1)
	ref37065f24 := (*C.VkShaderModuleValidationCacheCreateInfoEXT)(mem37065f24)
	allocs37065f24 := new(cgoAllocMap)
	allocs37065f24.Add(mem37065f24)

	var csType_allocs *cgoAllocMap
	ref37065f24.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs37065f24.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref37065f24.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs37065f24.Borrow(cpNext_allocs)

	var cvalidationCache_allocs *cgoAllocMap
	ref37065f24.validationCache, cvalidationCache_allocs = *(*C.VkValidationCacheEXT)(unsafe.Pointer(&x.ValidationCache)), cgoAllocsUnknown
	allocs37065f24.Borrow(cvalidationCache_allocs)

	x.ref37065f24 = ref37065f24
	x.allocs37065f24 = allocs37065f24
	return ref37065f24, allocs37065f24

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShaderModuleValidationCacheCreateInfo) PassValue() (C.VkShaderModuleValidationCacheCreateInfoEXT, *cgoAllocMap) {
	if x.ref37065f24 != nil {
		return *x.ref37065f24, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShaderModuleValidationCacheCreateInfo) Deref() {
	if x.ref37065f24 == nil {
		return
	}
	x.SType = (StructureType)(x.ref37065f24.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref37065f24.pNext))
	x.ValidationCache = *(*ValidationCache)(unsafe.Pointer(&x.ref37065f24.validationCache))
}

// allocShadingRatePaletteNVMemory allocates memory for type C.VkShadingRatePaletteNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShadingRatePaletteNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShadingRatePaletteNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfShadingRatePaletteNVValue = unsafe.Sizeof([1]C.VkShadingRatePaletteNV{})

// copyPShadingRatePaletteEntryNVBytes copies the data from Go slice as *C.VkShadingRatePaletteEntryNV.
func copyPShadingRatePaletteEntryNVBytes(slice *sliceHeader) (*C.VkShadingRatePaletteEntryNV, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfShadingRatePaletteEntryNVValue) * slice.Len,
		Cap:  int(sizeOfShadingRatePaletteEntryNVValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkShadingRatePaletteEntryNV)(mem0), allocs
}

// allocShadingRatePaletteEntryNVMemory allocates memory for type C.VkShadingRatePaletteEntryNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShadingRatePaletteEntryNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShadingRatePaletteEntryNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfShadingRatePaletteEntryNVValue = unsafe.Sizeof([1]C.VkShadingRatePaletteEntryNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShadingRatePaletteNV) Ref() *C.VkShadingRatePaletteNV {
	if x == nil {
		return nil
	}
	return x.refa5c4ae3a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShadingRatePaletteNV) Free() {
	if x != nil && x.allocsa5c4ae3a != nil {
		x.allocsa5c4ae3a.(*cgoAllocMap).Free()
		x.refa5c4ae3a = nil
	}
}

// NewShadingRatePaletteNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShadingRatePaletteNVRef(ref unsafe.Pointer) *ShadingRatePaletteNV {
	if ref == nil {
		return nil
	}
	obj := new(ShadingRatePaletteNV)
	obj.refa5c4ae3a = (*C.VkShadingRatePaletteNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShadingRatePaletteNV) PassRef() (*C.VkShadingRatePaletteNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa5c4ae3a != nil {
		return x.refa5c4ae3a, nil
	}
	mema5c4ae3a := allocShadingRatePaletteNVMemory(1)
	refa5c4ae3a := (*C.VkShadingRatePaletteNV)(mema5c4ae3a)
	allocsa5c4ae3a := new(cgoAllocMap)
	allocsa5c4ae3a.Add(mema5c4ae3a)

	var cshadingRatePaletteEntryCount_allocs *cgoAllocMap
	refa5c4ae3a.shadingRatePaletteEntryCount, cshadingRatePaletteEntryCount_allocs = (C.uint32_t)(x.ShadingRatePaletteEntryCount), cgoAllocsUnknown
	allocsa5c4ae3a.Borrow(cshadingRatePaletteEntryCount_allocs)

	var cpShadingRatePaletteEntries_allocs *cgoAllocMap
	refa5c4ae3a.pShadingRatePaletteEntries, cpShadingRatePaletteEntries_allocs = copyPShadingRatePaletteEntryNVBytes((*sliceHeader)(unsafe.Pointer(&x.PShadingRatePaletteEntries)))
	allocsa5c4ae3a.Borrow(cpShadingRatePaletteEntries_allocs)

	x.refa5c4ae3a = refa5c4ae3a
	x.allocsa5c4ae3a = allocsa5c4ae3a
	return refa5c4ae3a, allocsa5c4ae3a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShadingRatePaletteNV) PassValue() (C.VkShadingRatePaletteNV, *cgoAllocMap) {
	if x.refa5c4ae3a != nil {
		return *x.refa5c4ae3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShadingRatePaletteNV) Deref() {
	if x.refa5c4ae3a == nil {
		return
	}
	x.ShadingRatePaletteEntryCount = (uint32)(x.refa5c4ae3a.shadingRatePaletteEntryCount)
	hxf7d15a2 := (*sliceHeader)(unsafe.Pointer(&x.PShadingRatePaletteEntries))
	hxf7d15a2.Data = unsafe.Pointer(x.refa5c4ae3a.pShadingRatePaletteEntries)
	hxf7d15a2.Cap = 0x7fffffff
	// hxf7d15a2.Len = ?

}

// allocPipelineViewportShadingRateImageStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportShadingRateImageStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportShadingRateImageStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportShadingRateImageStateCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineViewportShadingRateImageStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportShadingRateImageStateCreateInfoNV{})

// unpackSShadingRatePaletteNV transforms a sliced Go data structure into plain C format.
func unpackSShadingRatePaletteNV(x []ShadingRatePaletteNV) (unpacked *C.VkShadingRatePaletteNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocShadingRatePaletteNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkShadingRatePaletteNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkShadingRatePaletteNV)(h.Data)
	return
}

// packSShadingRatePaletteNV reads sliced Go data structure out from plain C format.
func packSShadingRatePaletteNV(v []ShadingRatePaletteNV, ptr0 *C.VkShadingRatePaletteNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfShadingRatePaletteNVValue]C.VkShadingRatePaletteNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewShadingRatePaletteNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportShadingRateImageStateCreateInfoNV) Ref() *C.VkPipelineViewportShadingRateImageStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref6f2ec732
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportShadingRateImageStateCreateInfoNV) Free() {
	if x != nil && x.allocs6f2ec732 != nil {
		x.allocs6f2ec732.(*cgoAllocMap).Free()
		x.ref6f2ec732 = nil
	}
}

// NewPipelineViewportShadingRateImageStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportShadingRateImageStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportShadingRateImageStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportShadingRateImageStateCreateInfoNV)
	obj.ref6f2ec732 = (*C.VkPipelineViewportShadingRateImageStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportShadingRateImageStateCreateInfoNV) PassRef() (*C.VkPipelineViewportShadingRateImageStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6f2ec732 != nil {
		return x.ref6f2ec732, nil
	}
	mem6f2ec732 := allocPipelineViewportShadingRateImageStateCreateInfoNVMemory(1)
	ref6f2ec732 := (*C.VkPipelineViewportShadingRateImageStateCreateInfoNV)(mem6f2ec732)
	allocs6f2ec732 := new(cgoAllocMap)
	allocs6f2ec732.Add(mem6f2ec732)

	var csType_allocs *cgoAllocMap
	ref6f2ec732.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6f2ec732.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6f2ec732.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6f2ec732.Borrow(cpNext_allocs)

	var cshadingRateImageEnable_allocs *cgoAllocMap
	ref6f2ec732.shadingRateImageEnable, cshadingRateImageEnable_allocs = (C.VkBool32)(x.ShadingRateImageEnable), cgoAllocsUnknown
	allocs6f2ec732.Borrow(cshadingRateImageEnable_allocs)

	var cviewportCount_allocs *cgoAllocMap
	ref6f2ec732.viewportCount, cviewportCount_allocs = (C.uint32_t)(x.ViewportCount), cgoAllocsUnknown
	allocs6f2ec732.Borrow(cviewportCount_allocs)

	var cpShadingRatePalettes_allocs *cgoAllocMap
	ref6f2ec732.pShadingRatePalettes, cpShadingRatePalettes_allocs = unpackSShadingRatePaletteNV(x.PShadingRatePalettes)
	allocs6f2ec732.Borrow(cpShadingRatePalettes_allocs)

	x.ref6f2ec732 = ref6f2ec732
	x.allocs6f2ec732 = allocs6f2ec732
	return ref6f2ec732, allocs6f2ec732

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportShadingRateImageStateCreateInfoNV) PassValue() (C.VkPipelineViewportShadingRateImageStateCreateInfoNV, *cgoAllocMap) {
	if x.ref6f2ec732 != nil {
		return *x.ref6f2ec732, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportShadingRateImageStateCreateInfoNV) Deref() {
	if x.ref6f2ec732 == nil {
		return
	}
	x.SType = (StructureType)(x.ref6f2ec732.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6f2ec732.pNext))
	x.ShadingRateImageEnable = (Bool32)(x.ref6f2ec732.shadingRateImageEnable)
	x.ViewportCount = (uint32)(x.ref6f2ec732.viewportCount)
	packSShadingRatePaletteNV(x.PShadingRatePalettes, x.ref6f2ec732.pShadingRatePalettes)
}

// allocPhysicalDeviceShadingRateImageFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceShadingRateImageFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShadingRateImageFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShadingRateImageFeaturesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShadingRateImageFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShadingRateImageFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShadingRateImageFeaturesNV) Ref() *C.VkPhysicalDeviceShadingRateImageFeaturesNV {
	if x == nil {
		return nil
	}
	return x.ref199a921b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShadingRateImageFeaturesNV) Free() {
	if x != nil && x.allocs199a921b != nil {
		x.allocs199a921b.(*cgoAllocMap).Free()
		x.ref199a921b = nil
	}
}

// NewPhysicalDeviceShadingRateImageFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShadingRateImageFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceShadingRateImageFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShadingRateImageFeaturesNV)
	obj.ref199a921b = (*C.VkPhysicalDeviceShadingRateImageFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShadingRateImageFeaturesNV) PassRef() (*C.VkPhysicalDeviceShadingRateImageFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref199a921b != nil {
		return x.ref199a921b, nil
	}
	mem199a921b := allocPhysicalDeviceShadingRateImageFeaturesNVMemory(1)
	ref199a921b := (*C.VkPhysicalDeviceShadingRateImageFeaturesNV)(mem199a921b)
	allocs199a921b := new(cgoAllocMap)
	allocs199a921b.Add(mem199a921b)

	var csType_allocs *cgoAllocMap
	ref199a921b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs199a921b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref199a921b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs199a921b.Borrow(cpNext_allocs)

	var cshadingRateImage_allocs *cgoAllocMap
	ref199a921b.shadingRateImage, cshadingRateImage_allocs = (C.VkBool32)(x.ShadingRateImage), cgoAllocsUnknown
	allocs199a921b.Borrow(cshadingRateImage_allocs)

	var cshadingRateCoarseSampleOrder_allocs *cgoAllocMap
	ref199a921b.shadingRateCoarseSampleOrder, cshadingRateCoarseSampleOrder_allocs = (C.VkBool32)(x.ShadingRateCoarseSampleOrder), cgoAllocsUnknown
	allocs199a921b.Borrow(cshadingRateCoarseSampleOrder_allocs)

	x.ref199a921b = ref199a921b
	x.allocs199a921b = allocs199a921b
	return ref199a921b, allocs199a921b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShadingRateImageFeaturesNV) PassValue() (C.VkPhysicalDeviceShadingRateImageFeaturesNV, *cgoAllocMap) {
	if x.ref199a921b != nil {
		return *x.ref199a921b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShadingRateImageFeaturesNV) Deref() {
	if x.ref199a921b == nil {
		return
	}
	x.SType = (StructureType)(x.ref199a921b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref199a921b.pNext))
	x.ShadingRateImage = (Bool32)(x.ref199a921b.shadingRateImage)
	x.ShadingRateCoarseSampleOrder = (Bool32)(x.ref199a921b.shadingRateCoarseSampleOrder)
}

// allocPhysicalDeviceShadingRateImagePropertiesNVMemory allocates memory for type C.VkPhysicalDeviceShadingRateImagePropertiesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShadingRateImagePropertiesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShadingRateImagePropertiesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShadingRateImagePropertiesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShadingRateImagePropertiesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShadingRateImagePropertiesNV) Ref() *C.VkPhysicalDeviceShadingRateImagePropertiesNV {
	if x == nil {
		return nil
	}
	return x.refea059f34
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShadingRateImagePropertiesNV) Free() {
	if x != nil && x.allocsea059f34 != nil {
		x.allocsea059f34.(*cgoAllocMap).Free()
		x.refea059f34 = nil
	}
}

// NewPhysicalDeviceShadingRateImagePropertiesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShadingRateImagePropertiesNVRef(ref unsafe.Pointer) *PhysicalDeviceShadingRateImagePropertiesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShadingRateImagePropertiesNV)
	obj.refea059f34 = (*C.VkPhysicalDeviceShadingRateImagePropertiesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShadingRateImagePropertiesNV) PassRef() (*C.VkPhysicalDeviceShadingRateImagePropertiesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refea059f34 != nil {
		return x.refea059f34, nil
	}
	memea059f34 := allocPhysicalDeviceShadingRateImagePropertiesNVMemory(1)
	refea059f34 := (*C.VkPhysicalDeviceShadingRateImagePropertiesNV)(memea059f34)
	allocsea059f34 := new(cgoAllocMap)
	allocsea059f34.Add(memea059f34)

	var csType_allocs *cgoAllocMap
	refea059f34.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsea059f34.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refea059f34.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsea059f34.Borrow(cpNext_allocs)

	var cshadingRateTexelSize_allocs *cgoAllocMap
	refea059f34.shadingRateTexelSize, cshadingRateTexelSize_allocs = x.ShadingRateTexelSize.PassValue()
	allocsea059f34.Borrow(cshadingRateTexelSize_allocs)

	var cshadingRatePaletteSize_allocs *cgoAllocMap
	refea059f34.shadingRatePaletteSize, cshadingRatePaletteSize_allocs = (C.uint32_t)(x.ShadingRatePaletteSize), cgoAllocsUnknown
	allocsea059f34.Borrow(cshadingRatePaletteSize_allocs)

	var cshadingRateMaxCoarseSamples_allocs *cgoAllocMap
	refea059f34.shadingRateMaxCoarseSamples, cshadingRateMaxCoarseSamples_allocs = (C.uint32_t)(x.ShadingRateMaxCoarseSamples), cgoAllocsUnknown
	allocsea059f34.Borrow(cshadingRateMaxCoarseSamples_allocs)

	x.refea059f34 = refea059f34
	x.allocsea059f34 = allocsea059f34
	return refea059f34, allocsea059f34

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShadingRateImagePropertiesNV) PassValue() (C.VkPhysicalDeviceShadingRateImagePropertiesNV, *cgoAllocMap) {
	if x.refea059f34 != nil {
		return *x.refea059f34, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShadingRateImagePropertiesNV) Deref() {
	if x.refea059f34 == nil {
		return
	}
	x.SType = (StructureType)(x.refea059f34.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refea059f34.pNext))
	x.ShadingRateTexelSize = *NewExtent2DRef(unsafe.Pointer(&x.refea059f34.shadingRateTexelSize))
	x.ShadingRatePaletteSize = (uint32)(x.refea059f34.shadingRatePaletteSize)
	x.ShadingRateMaxCoarseSamples = (uint32)(x.refea059f34.shadingRateMaxCoarseSamples)
}

// allocCoarseSampleLocationNVMemory allocates memory for type C.VkCoarseSampleLocationNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCoarseSampleLocationNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCoarseSampleLocationNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCoarseSampleLocationNVValue = unsafe.Sizeof([1]C.VkCoarseSampleLocationNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CoarseSampleLocationNV) Ref() *C.VkCoarseSampleLocationNV {
	if x == nil {
		return nil
	}
	return x.ref2f447beb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CoarseSampleLocationNV) Free() {
	if x != nil && x.allocs2f447beb != nil {
		x.allocs2f447beb.(*cgoAllocMap).Free()
		x.ref2f447beb = nil
	}
}

// NewCoarseSampleLocationNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCoarseSampleLocationNVRef(ref unsafe.Pointer) *CoarseSampleLocationNV {
	if ref == nil {
		return nil
	}
	obj := new(CoarseSampleLocationNV)
	obj.ref2f447beb = (*C.VkCoarseSampleLocationNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CoarseSampleLocationNV) PassRef() (*C.VkCoarseSampleLocationNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f447beb != nil {
		return x.ref2f447beb, nil
	}
	mem2f447beb := allocCoarseSampleLocationNVMemory(1)
	ref2f447beb := (*C.VkCoarseSampleLocationNV)(mem2f447beb)
	allocs2f447beb := new(cgoAllocMap)
	allocs2f447beb.Add(mem2f447beb)

	var cpixelX_allocs *cgoAllocMap
	ref2f447beb.pixelX, cpixelX_allocs = (C.uint32_t)(x.PixelX), cgoAllocsUnknown
	allocs2f447beb.Borrow(cpixelX_allocs)

	var cpixelY_allocs *cgoAllocMap
	ref2f447beb.pixelY, cpixelY_allocs = (C.uint32_t)(x.PixelY), cgoAllocsUnknown
	allocs2f447beb.Borrow(cpixelY_allocs)

	var csample_allocs *cgoAllocMap
	ref2f447beb.sample, csample_allocs = (C.uint32_t)(x.Sample), cgoAllocsUnknown
	allocs2f447beb.Borrow(csample_allocs)

	x.ref2f447beb = ref2f447beb
	x.allocs2f447beb = allocs2f447beb
	return ref2f447beb, allocs2f447beb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CoarseSampleLocationNV) PassValue() (C.VkCoarseSampleLocationNV, *cgoAllocMap) {
	if x.ref2f447beb != nil {
		return *x.ref2f447beb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CoarseSampleLocationNV) Deref() {
	if x.ref2f447beb == nil {
		return
	}
	x.PixelX = (uint32)(x.ref2f447beb.pixelX)
	x.PixelY = (uint32)(x.ref2f447beb.pixelY)
	x.Sample = (uint32)(x.ref2f447beb.sample)
}

// allocCoarseSampleOrderCustomNVMemory allocates memory for type C.VkCoarseSampleOrderCustomNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCoarseSampleOrderCustomNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCoarseSampleOrderCustomNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCoarseSampleOrderCustomNVValue = unsafe.Sizeof([1]C.VkCoarseSampleOrderCustomNV{})

// unpackSCoarseSampleLocationNV transforms a sliced Go data structure into plain C format.
func unpackSCoarseSampleLocationNV(x []CoarseSampleLocationNV) (unpacked *C.VkCoarseSampleLocationNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCoarseSampleLocationNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCoarseSampleLocationNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCoarseSampleLocationNV)(h.Data)
	return
}

// packSCoarseSampleLocationNV reads sliced Go data structure out from plain C format.
func packSCoarseSampleLocationNV(v []CoarseSampleLocationNV, ptr0 *C.VkCoarseSampleLocationNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCoarseSampleLocationNVValue]C.VkCoarseSampleLocationNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCoarseSampleLocationNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CoarseSampleOrderCustomNV) Ref() *C.VkCoarseSampleOrderCustomNV {
	if x == nil {
		return nil
	}
	return x.ref4524fa09
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CoarseSampleOrderCustomNV) Free() {
	if x != nil && x.allocs4524fa09 != nil {
		x.allocs4524fa09.(*cgoAllocMap).Free()
		x.ref4524fa09 = nil
	}
}

// NewCoarseSampleOrderCustomNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCoarseSampleOrderCustomNVRef(ref unsafe.Pointer) *CoarseSampleOrderCustomNV {
	if ref == nil {
		return nil
	}
	obj := new(CoarseSampleOrderCustomNV)
	obj.ref4524fa09 = (*C.VkCoarseSampleOrderCustomNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CoarseSampleOrderCustomNV) PassRef() (*C.VkCoarseSampleOrderCustomNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4524fa09 != nil {
		return x.ref4524fa09, nil
	}
	mem4524fa09 := allocCoarseSampleOrderCustomNVMemory(1)
	ref4524fa09 := (*C.VkCoarseSampleOrderCustomNV)(mem4524fa09)
	allocs4524fa09 := new(cgoAllocMap)
	allocs4524fa09.Add(mem4524fa09)

	var cshadingRate_allocs *cgoAllocMap
	ref4524fa09.shadingRate, cshadingRate_allocs = (C.VkShadingRatePaletteEntryNV)(x.ShadingRate), cgoAllocsUnknown
	allocs4524fa09.Borrow(cshadingRate_allocs)

	var csampleCount_allocs *cgoAllocMap
	ref4524fa09.sampleCount, csampleCount_allocs = (C.uint32_t)(x.SampleCount), cgoAllocsUnknown
	allocs4524fa09.Borrow(csampleCount_allocs)

	var csampleLocationCount_allocs *cgoAllocMap
	ref4524fa09.sampleLocationCount, csampleLocationCount_allocs = (C.uint32_t)(x.SampleLocationCount), cgoAllocsUnknown
	allocs4524fa09.Borrow(csampleLocationCount_allocs)

	var cpSampleLocations_allocs *cgoAllocMap
	ref4524fa09.pSampleLocations, cpSampleLocations_allocs = unpackSCoarseSampleLocationNV(x.PSampleLocations)
	allocs4524fa09.Borrow(cpSampleLocations_allocs)

	x.ref4524fa09 = ref4524fa09
	x.allocs4524fa09 = allocs4524fa09
	return ref4524fa09, allocs4524fa09

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CoarseSampleOrderCustomNV) PassValue() (C.VkCoarseSampleOrderCustomNV, *cgoAllocMap) {
	if x.ref4524fa09 != nil {
		return *x.ref4524fa09, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CoarseSampleOrderCustomNV) Deref() {
	if x.ref4524fa09 == nil {
		return
	}
	x.ShadingRate = (ShadingRatePaletteEntryNV)(x.ref4524fa09.shadingRate)
	x.SampleCount = (uint32)(x.ref4524fa09.sampleCount)
	x.SampleLocationCount = (uint32)(x.ref4524fa09.sampleLocationCount)
	packSCoarseSampleLocationNV(x.PSampleLocations, x.ref4524fa09.pSampleLocations)
}

// allocPipelineViewportCoarseSampleOrderStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportCoarseSampleOrderStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportCoarseSampleOrderStateCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineViewportCoarseSampleOrderStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV{})

// unpackSCoarseSampleOrderCustomNV transforms a sliced Go data structure into plain C format.
func unpackSCoarseSampleOrderCustomNV(x []CoarseSampleOrderCustomNV) (unpacked *C.VkCoarseSampleOrderCustomNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCoarseSampleOrderCustomNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCoarseSampleOrderCustomNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCoarseSampleOrderCustomNV)(h.Data)
	return
}

// packSCoarseSampleOrderCustomNV reads sliced Go data structure out from plain C format.
func packSCoarseSampleOrderCustomNV(v []CoarseSampleOrderCustomNV, ptr0 *C.VkCoarseSampleOrderCustomNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCoarseSampleOrderCustomNVValue]C.VkCoarseSampleOrderCustomNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCoarseSampleOrderCustomNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportCoarseSampleOrderStateCreateInfoNV) Ref() *C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref54de8ca6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportCoarseSampleOrderStateCreateInfoNV) Free() {
	if x != nil && x.allocs54de8ca6 != nil {
		x.allocs54de8ca6.(*cgoAllocMap).Free()
		x.ref54de8ca6 = nil
	}
}

// NewPipelineViewportCoarseSampleOrderStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportCoarseSampleOrderStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportCoarseSampleOrderStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportCoarseSampleOrderStateCreateInfoNV)
	obj.ref54de8ca6 = (*C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportCoarseSampleOrderStateCreateInfoNV) PassRef() (*C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref54de8ca6 != nil {
		return x.ref54de8ca6, nil
	}
	mem54de8ca6 := allocPipelineViewportCoarseSampleOrderStateCreateInfoNVMemory(1)
	ref54de8ca6 := (*C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV)(mem54de8ca6)
	allocs54de8ca6 := new(cgoAllocMap)
	allocs54de8ca6.Add(mem54de8ca6)

	var csType_allocs *cgoAllocMap
	ref54de8ca6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs54de8ca6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref54de8ca6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs54de8ca6.Borrow(cpNext_allocs)

	var csampleOrderType_allocs *cgoAllocMap
	ref54de8ca6.sampleOrderType, csampleOrderType_allocs = (C.VkCoarseSampleOrderTypeNV)(x.SampleOrderType), cgoAllocsUnknown
	allocs54de8ca6.Borrow(csampleOrderType_allocs)

	var ccustomSampleOrderCount_allocs *cgoAllocMap
	ref54de8ca6.customSampleOrderCount, ccustomSampleOrderCount_allocs = (C.uint32_t)(x.CustomSampleOrderCount), cgoAllocsUnknown
	allocs54de8ca6.Borrow(ccustomSampleOrderCount_allocs)

	var cpCustomSampleOrders_allocs *cgoAllocMap
	ref54de8ca6.pCustomSampleOrders, cpCustomSampleOrders_allocs = unpackSCoarseSampleOrderCustomNV(x.PCustomSampleOrders)
	allocs54de8ca6.Borrow(cpCustomSampleOrders_allocs)

	x.ref54de8ca6 = ref54de8ca6
	x.allocs54de8ca6 = allocs54de8ca6
	return ref54de8ca6, allocs54de8ca6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportCoarseSampleOrderStateCreateInfoNV) PassValue() (C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, *cgoAllocMap) {
	if x.ref54de8ca6 != nil {
		return *x.ref54de8ca6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportCoarseSampleOrderStateCreateInfoNV) Deref() {
	if x.ref54de8ca6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref54de8ca6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref54de8ca6.pNext))
	x.SampleOrderType = (CoarseSampleOrderTypeNV)(x.ref54de8ca6.sampleOrderType)
	x.CustomSampleOrderCount = (uint32)(x.ref54de8ca6.customSampleOrderCount)
	packSCoarseSampleOrderCustomNV(x.PCustomSampleOrders, x.ref54de8ca6.pCustomSampleOrders)
}

// allocRayTracingShaderGroupCreateInfoNVMemory allocates memory for type C.VkRayTracingShaderGroupCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayTracingShaderGroupCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayTracingShaderGroupCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRayTracingShaderGroupCreateInfoNVValue = unsafe.Sizeof([1]C.VkRayTracingShaderGroupCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RayTracingShaderGroupCreateInfoNV) Ref() *C.VkRayTracingShaderGroupCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refec94d00
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RayTracingShaderGroupCreateInfoNV) Free() {
	if x != nil && x.allocsec94d00 != nil {
		x.allocsec94d00.(*cgoAllocMap).Free()
		x.refec94d00 = nil
	}
}

// NewRayTracingShaderGroupCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRayTracingShaderGroupCreateInfoNVRef(ref unsafe.Pointer) *RayTracingShaderGroupCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(RayTracingShaderGroupCreateInfoNV)
	obj.refec94d00 = (*C.VkRayTracingShaderGroupCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RayTracingShaderGroupCreateInfoNV) PassRef() (*C.VkRayTracingShaderGroupCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refec94d00 != nil {
		return x.refec94d00, nil
	}
	memec94d00 := allocRayTracingShaderGroupCreateInfoNVMemory(1)
	refec94d00 := (*C.VkRayTracingShaderGroupCreateInfoNV)(memec94d00)
	allocsec94d00 := new(cgoAllocMap)
	allocsec94d00.Add(memec94d00)

	var csType_allocs *cgoAllocMap
	refec94d00.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsec94d00.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refec94d00.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsec94d00.Borrow(cpNext_allocs)

	var c_type_allocs *cgoAllocMap
	refec94d00._type, c_type_allocs = (C.VkRayTracingShaderGroupTypeKHR)(x.Type), cgoAllocsUnknown
	allocsec94d00.Borrow(c_type_allocs)

	var cgeneralShader_allocs *cgoAllocMap
	refec94d00.generalShader, cgeneralShader_allocs = (C.uint32_t)(x.GeneralShader), cgoAllocsUnknown
	allocsec94d00.Borrow(cgeneralShader_allocs)

	var cclosestHitShader_allocs *cgoAllocMap
	refec94d00.closestHitShader, cclosestHitShader_allocs = (C.uint32_t)(x.ClosestHitShader), cgoAllocsUnknown
	allocsec94d00.Borrow(cclosestHitShader_allocs)

	var canyHitShader_allocs *cgoAllocMap
	refec94d00.anyHitShader, canyHitShader_allocs = (C.uint32_t)(x.AnyHitShader), cgoAllocsUnknown
	allocsec94d00.Borrow(canyHitShader_allocs)

	var cintersectionShader_allocs *cgoAllocMap
	refec94d00.intersectionShader, cintersectionShader_allocs = (C.uint32_t)(x.IntersectionShader), cgoAllocsUnknown
	allocsec94d00.Borrow(cintersectionShader_allocs)

	x.refec94d00 = refec94d00
	x.allocsec94d00 = allocsec94d00
	return refec94d00, allocsec94d00

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RayTracingShaderGroupCreateInfoNV) PassValue() (C.VkRayTracingShaderGroupCreateInfoNV, *cgoAllocMap) {
	if x.refec94d00 != nil {
		return *x.refec94d00, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RayTracingShaderGroupCreateInfoNV) Deref() {
	if x.refec94d00 == nil {
		return
	}
	x.SType = (StructureType)(x.refec94d00.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refec94d00.pNext))
	x.Type = (RayTracingShaderGroupType)(x.refec94d00._type)
	x.GeneralShader = (uint32)(x.refec94d00.generalShader)
	x.ClosestHitShader = (uint32)(x.refec94d00.closestHitShader)
	x.AnyHitShader = (uint32)(x.refec94d00.anyHitShader)
	x.IntersectionShader = (uint32)(x.refec94d00.intersectionShader)
}

// allocRayTracingPipelineCreateInfoNVMemory allocates memory for type C.VkRayTracingPipelineCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayTracingPipelineCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayTracingPipelineCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRayTracingPipelineCreateInfoNVValue = unsafe.Sizeof([1]C.VkRayTracingPipelineCreateInfoNV{})

// unpackSRayTracingShaderGroupCreateInfoNV transforms a sliced Go data structure into plain C format.
func unpackSRayTracingShaderGroupCreateInfoNV(x []RayTracingShaderGroupCreateInfoNV) (unpacked *C.VkRayTracingShaderGroupCreateInfoNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRayTracingShaderGroupCreateInfoNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRayTracingShaderGroupCreateInfoNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRayTracingShaderGroupCreateInfoNV)(h.Data)
	return
}

// packSRayTracingShaderGroupCreateInfoNV reads sliced Go data structure out from plain C format.
func packSRayTracingShaderGroupCreateInfoNV(v []RayTracingShaderGroupCreateInfoNV, ptr0 *C.VkRayTracingShaderGroupCreateInfoNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRayTracingShaderGroupCreateInfoNVValue]C.VkRayTracingShaderGroupCreateInfoNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRayTracingShaderGroupCreateInfoNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RayTracingPipelineCreateInfoNV) Ref() *C.VkRayTracingPipelineCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref906754b4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RayTracingPipelineCreateInfoNV) Free() {
	if x != nil && x.allocs906754b4 != nil {
		x.allocs906754b4.(*cgoAllocMap).Free()
		x.ref906754b4 = nil
	}
}

// NewRayTracingPipelineCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRayTracingPipelineCreateInfoNVRef(ref unsafe.Pointer) *RayTracingPipelineCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(RayTracingPipelineCreateInfoNV)
	obj.ref906754b4 = (*C.VkRayTracingPipelineCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RayTracingPipelineCreateInfoNV) PassRef() (*C.VkRayTracingPipelineCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref906754b4 != nil {
		return x.ref906754b4, nil
	}
	mem906754b4 := allocRayTracingPipelineCreateInfoNVMemory(1)
	ref906754b4 := (*C.VkRayTracingPipelineCreateInfoNV)(mem906754b4)
	allocs906754b4 := new(cgoAllocMap)
	allocs906754b4.Add(mem906754b4)

	var csType_allocs *cgoAllocMap
	ref906754b4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs906754b4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref906754b4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs906754b4.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref906754b4.flags, cflags_allocs = (C.VkPipelineCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs906754b4.Borrow(cflags_allocs)

	var cstageCount_allocs *cgoAllocMap
	ref906754b4.stageCount, cstageCount_allocs = (C.uint32_t)(x.StageCount), cgoAllocsUnknown
	allocs906754b4.Borrow(cstageCount_allocs)

	var cpStages_allocs *cgoAllocMap
	ref906754b4.pStages, cpStages_allocs = unpackSPipelineShaderStageCreateInfo(x.PStages)
	allocs906754b4.Borrow(cpStages_allocs)

	var cgroupCount_allocs *cgoAllocMap
	ref906754b4.groupCount, cgroupCount_allocs = (C.uint32_t)(x.GroupCount), cgoAllocsUnknown
	allocs906754b4.Borrow(cgroupCount_allocs)

	var cpGroups_allocs *cgoAllocMap
	ref906754b4.pGroups, cpGroups_allocs = unpackSRayTracingShaderGroupCreateInfoNV(x.PGroups)
	allocs906754b4.Borrow(cpGroups_allocs)

	var cmaxRecursionDepth_allocs *cgoAllocMap
	ref906754b4.maxRecursionDepth, cmaxRecursionDepth_allocs = (C.uint32_t)(x.MaxRecursionDepth), cgoAllocsUnknown
	allocs906754b4.Borrow(cmaxRecursionDepth_allocs)

	var clayout_allocs *cgoAllocMap
	ref906754b4.layout, clayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.Layout)), cgoAllocsUnknown
	allocs906754b4.Borrow(clayout_allocs)

	var cbasePipelineHandle_allocs *cgoAllocMap
	ref906754b4.basePipelineHandle, cbasePipelineHandle_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.BasePipelineHandle)), cgoAllocsUnknown
	allocs906754b4.Borrow(cbasePipelineHandle_allocs)

	var cbasePipelineIndex_allocs *cgoAllocMap
	ref906754b4.basePipelineIndex, cbasePipelineIndex_allocs = (C.int32_t)(x.BasePipelineIndex), cgoAllocsUnknown
	allocs906754b4.Borrow(cbasePipelineIndex_allocs)

	x.ref906754b4 = ref906754b4
	x.allocs906754b4 = allocs906754b4
	return ref906754b4, allocs906754b4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RayTracingPipelineCreateInfoNV) PassValue() (C.VkRayTracingPipelineCreateInfoNV, *cgoAllocMap) {
	if x.ref906754b4 != nil {
		return *x.ref906754b4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RayTracingPipelineCreateInfoNV) Deref() {
	if x.ref906754b4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref906754b4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref906754b4.pNext))
	x.Flags = (PipelineCreateFlags)(x.ref906754b4.flags)
	x.StageCount = (uint32)(x.ref906754b4.stageCount)
	packSPipelineShaderStageCreateInfo(x.PStages, x.ref906754b4.pStages)
	x.GroupCount = (uint32)(x.ref906754b4.groupCount)
	packSRayTracingShaderGroupCreateInfoNV(x.PGroups, x.ref906754b4.pGroups)
	x.MaxRecursionDepth = (uint32)(x.ref906754b4.maxRecursionDepth)
	x.Layout = *(*PipelineLayout)(unsafe.Pointer(&x.ref906754b4.layout))
	x.BasePipelineHandle = *(*Pipeline)(unsafe.Pointer(&x.ref906754b4.basePipelineHandle))
	x.BasePipelineIndex = (int32)(x.ref906754b4.basePipelineIndex)
}

// allocGeometryTrianglesNVMemory allocates memory for type C.VkGeometryTrianglesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGeometryTrianglesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGeometryTrianglesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGeometryTrianglesNVValue = unsafe.Sizeof([1]C.VkGeometryTrianglesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GeometryTrianglesNV) Ref() *C.VkGeometryTrianglesNV {
	if x == nil {
		return nil
	}
	return x.ref874d9dc5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GeometryTrianglesNV) Free() {
	if x != nil && x.allocs874d9dc5 != nil {
		x.allocs874d9dc5.(*cgoAllocMap).Free()
		x.ref874d9dc5 = nil
	}
}

// NewGeometryTrianglesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGeometryTrianglesNVRef(ref unsafe.Pointer) *GeometryTrianglesNV {
	if ref == nil {
		return nil
	}
	obj := new(GeometryTrianglesNV)
	obj.ref874d9dc5 = (*C.VkGeometryTrianglesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GeometryTrianglesNV) PassRef() (*C.VkGeometryTrianglesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref874d9dc5 != nil {
		return x.ref874d9dc5, nil
	}
	mem874d9dc5 := allocGeometryTrianglesNVMemory(1)
	ref874d9dc5 := (*C.VkGeometryTrianglesNV)(mem874d9dc5)
	allocs874d9dc5 := new(cgoAllocMap)
	allocs874d9dc5.Add(mem874d9dc5)

	var csType_allocs *cgoAllocMap
	ref874d9dc5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs874d9dc5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref874d9dc5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs874d9dc5.Borrow(cpNext_allocs)

	var cvertexData_allocs *cgoAllocMap
	ref874d9dc5.vertexData, cvertexData_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.VertexData)), cgoAllocsUnknown
	allocs874d9dc5.Borrow(cvertexData_allocs)

	var cvertexOffset_allocs *cgoAllocMap
	ref874d9dc5.vertexOffset, cvertexOffset_allocs = (C.VkDeviceSize)(x.VertexOffset), cgoAllocsUnknown
	allocs874d9dc5.Borrow(cvertexOffset_allocs)

	var cvertexCount_allocs *cgoAllocMap
	ref874d9dc5.vertexCount, cvertexCount_allocs = (C.uint32_t)(x.VertexCount), cgoAllocsUnknown
	allocs874d9dc5.Borrow(cvertexCount_allocs)

	var cvertexStride_allocs *cgoAllocMap
	ref874d9dc5.vertexStride, cvertexStride_allocs = (C.VkDeviceSize)(x.VertexStride), cgoAllocsUnknown
	allocs874d9dc5.Borrow(cvertexStride_allocs)

	var cvertexFormat_allocs *cgoAllocMap
	ref874d9dc5.vertexFormat, cvertexFormat_allocs = (C.VkFormat)(x.VertexFormat), cgoAllocsUnknown
	allocs874d9dc5.Borrow(cvertexFormat_allocs)

	var cindexData_allocs *cgoAllocMap
	ref874d9dc5.indexData, cindexData_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.IndexData)), cgoAllocsUnknown
	allocs874d9dc5.Borrow(cindexData_allocs)

	var cindexOffset_allocs *cgoAllocMap
	ref874d9dc5.indexOffset, cindexOffset_allocs = (C.VkDeviceSize)(x.IndexOffset), cgoAllocsUnknown
	allocs874d9dc5.Borrow(cindexOffset_allocs)

	var cindexCount_allocs *cgoAllocMap
	ref874d9dc5.indexCount, cindexCount_allocs = (C.uint32_t)(x.IndexCount), cgoAllocsUnknown
	allocs874d9dc5.Borrow(cindexCount_allocs)

	var cindexType_allocs *cgoAllocMap
	ref874d9dc5.indexType, cindexType_allocs = (C.VkIndexType)(x.IndexType), cgoAllocsUnknown
	allocs874d9dc5.Borrow(cindexType_allocs)

	var ctransformData_allocs *cgoAllocMap
	ref874d9dc5.transformData, ctransformData_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.TransformData)), cgoAllocsUnknown
	allocs874d9dc5.Borrow(ctransformData_allocs)

	var ctransformOffset_allocs *cgoAllocMap
	ref874d9dc5.transformOffset, ctransformOffset_allocs = (C.VkDeviceSize)(x.TransformOffset), cgoAllocsUnknown
	allocs874d9dc5.Borrow(ctransformOffset_allocs)

	x.ref874d9dc5 = ref874d9dc5
	x.allocs874d9dc5 = allocs874d9dc5
	return ref874d9dc5, allocs874d9dc5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GeometryTrianglesNV) PassValue() (C.VkGeometryTrianglesNV, *cgoAllocMap) {
	if x.ref874d9dc5 != nil {
		return *x.ref874d9dc5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GeometryTrianglesNV) Deref() {
	if x.ref874d9dc5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref874d9dc5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref874d9dc5.pNext))
	x.VertexData = *(*Buffer)(unsafe.Pointer(&x.ref874d9dc5.vertexData))
	x.VertexOffset = (DeviceSize)(x.ref874d9dc5.vertexOffset)
	x.VertexCount = (uint32)(x.ref874d9dc5.vertexCount)
	x.VertexStride = (DeviceSize)(x.ref874d9dc5.vertexStride)
	x.VertexFormat = (Format)(x.ref874d9dc5.vertexFormat)
	x.IndexData = *(*Buffer)(unsafe.Pointer(&x.ref874d9dc5.indexData))
	x.IndexOffset = (DeviceSize)(x.ref874d9dc5.indexOffset)
	x.IndexCount = (uint32)(x.ref874d9dc5.indexCount)
	x.IndexType = (IndexType)(x.ref874d9dc5.indexType)
	x.TransformData = *(*Buffer)(unsafe.Pointer(&x.ref874d9dc5.transformData))
	x.TransformOffset = (DeviceSize)(x.ref874d9dc5.transformOffset)
}

// allocGeometryAABBNVMemory allocates memory for type C.VkGeometryAABBNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGeometryAABBNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGeometryAABBNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGeometryAABBNVValue = unsafe.Sizeof([1]C.VkGeometryAABBNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GeometryAABBNV) Ref() *C.VkGeometryAABBNV {
	if x == nil {
		return nil
	}
	return x.ref1ff5bc68
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GeometryAABBNV) Free() {
	if x != nil && x.allocs1ff5bc68 != nil {
		x.allocs1ff5bc68.(*cgoAllocMap).Free()
		x.ref1ff5bc68 = nil
	}
}

// NewGeometryAABBNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGeometryAABBNVRef(ref unsafe.Pointer) *GeometryAABBNV {
	if ref == nil {
		return nil
	}
	obj := new(GeometryAABBNV)
	obj.ref1ff5bc68 = (*C.VkGeometryAABBNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GeometryAABBNV) PassRef() (*C.VkGeometryAABBNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1ff5bc68 != nil {
		return x.ref1ff5bc68, nil
	}
	mem1ff5bc68 := allocGeometryAABBNVMemory(1)
	ref1ff5bc68 := (*C.VkGeometryAABBNV)(mem1ff5bc68)
	allocs1ff5bc68 := new(cgoAllocMap)
	allocs1ff5bc68.Add(mem1ff5bc68)

	var csType_allocs *cgoAllocMap
	ref1ff5bc68.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1ff5bc68.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1ff5bc68.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1ff5bc68.Borrow(cpNext_allocs)

	var caabbData_allocs *cgoAllocMap
	ref1ff5bc68.aabbData, caabbData_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.AabbData)), cgoAllocsUnknown
	allocs1ff5bc68.Borrow(caabbData_allocs)

	var cnumAABBs_allocs *cgoAllocMap
	ref1ff5bc68.numAABBs, cnumAABBs_allocs = (C.uint32_t)(x.NumAABBs), cgoAllocsUnknown
	allocs1ff5bc68.Borrow(cnumAABBs_allocs)

	var cstride_allocs *cgoAllocMap
	ref1ff5bc68.stride, cstride_allocs = (C.uint32_t)(x.Stride), cgoAllocsUnknown
	allocs1ff5bc68.Borrow(cstride_allocs)

	var coffset_allocs *cgoAllocMap
	ref1ff5bc68.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs1ff5bc68.Borrow(coffset_allocs)

	x.ref1ff5bc68 = ref1ff5bc68
	x.allocs1ff5bc68 = allocs1ff5bc68
	return ref1ff5bc68, allocs1ff5bc68

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GeometryAABBNV) PassValue() (C.VkGeometryAABBNV, *cgoAllocMap) {
	if x.ref1ff5bc68 != nil {
		return *x.ref1ff5bc68, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GeometryAABBNV) Deref() {
	if x.ref1ff5bc68 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1ff5bc68.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1ff5bc68.pNext))
	x.AabbData = *(*Buffer)(unsafe.Pointer(&x.ref1ff5bc68.aabbData))
	x.NumAABBs = (uint32)(x.ref1ff5bc68.numAABBs)
	x.Stride = (uint32)(x.ref1ff5bc68.stride)
	x.Offset = (DeviceSize)(x.ref1ff5bc68.offset)
}

// allocGeometryDataNVMemory allocates memory for type C.VkGeometryDataNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGeometryDataNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGeometryDataNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGeometryDataNVValue = unsafe.Sizeof([1]C.VkGeometryDataNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GeometryDataNV) Ref() *C.VkGeometryDataNV {
	if x == nil {
		return nil
	}
	return x.ref61b25d1b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GeometryDataNV) Free() {
	if x != nil && x.allocs61b25d1b != nil {
		x.allocs61b25d1b.(*cgoAllocMap).Free()
		x.ref61b25d1b = nil
	}
}

// NewGeometryDataNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGeometryDataNVRef(ref unsafe.Pointer) *GeometryDataNV {
	if ref == nil {
		return nil
	}
	obj := new(GeometryDataNV)
	obj.ref61b25d1b = (*C.VkGeometryDataNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GeometryDataNV) PassRef() (*C.VkGeometryDataNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref61b25d1b != nil {
		return x.ref61b25d1b, nil
	}
	mem61b25d1b := allocGeometryDataNVMemory(1)
	ref61b25d1b := (*C.VkGeometryDataNV)(mem61b25d1b)
	allocs61b25d1b := new(cgoAllocMap)
	allocs61b25d1b.Add(mem61b25d1b)

	var ctriangles_allocs *cgoAllocMap
	ref61b25d1b.triangles, ctriangles_allocs = x.Triangles.PassValue()
	allocs61b25d1b.Borrow(ctriangles_allocs)

	var caabbs_allocs *cgoAllocMap
	ref61b25d1b.aabbs, caabbs_allocs = x.Aabbs.PassValue()
	allocs61b25d1b.Borrow(caabbs_allocs)

	x.ref61b25d1b = ref61b25d1b
	x.allocs61b25d1b = allocs61b25d1b
	return ref61b25d1b, allocs61b25d1b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GeometryDataNV) PassValue() (C.VkGeometryDataNV, *cgoAllocMap) {
	if x.ref61b25d1b != nil {
		return *x.ref61b25d1b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GeometryDataNV) Deref() {
	if x.ref61b25d1b == nil {
		return
	}
	x.Triangles = *NewGeometryTrianglesNVRef(unsafe.Pointer(&x.ref61b25d1b.triangles))
	x.Aabbs = *NewGeometryAABBNVRef(unsafe.Pointer(&x.ref61b25d1b.aabbs))
}

// allocGeometryNVMemory allocates memory for type C.VkGeometryNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGeometryNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGeometryNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGeometryNVValue = unsafe.Sizeof([1]C.VkGeometryNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GeometryNV) Ref() *C.VkGeometryNV {
	if x == nil {
		return nil
	}
	return x.ref70d11a9b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GeometryNV) Free() {
	if x != nil && x.allocs70d11a9b != nil {
		x.allocs70d11a9b.(*cgoAllocMap).Free()
		x.ref70d11a9b = nil
	}
}

// NewGeometryNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGeometryNVRef(ref unsafe.Pointer) *GeometryNV {
	if ref == nil {
		return nil
	}
	obj := new(GeometryNV)
	obj.ref70d11a9b = (*C.VkGeometryNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GeometryNV) PassRef() (*C.VkGeometryNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref70d11a9b != nil {
		return x.ref70d11a9b, nil
	}
	mem70d11a9b := allocGeometryNVMemory(1)
	ref70d11a9b := (*C.VkGeometryNV)(mem70d11a9b)
	allocs70d11a9b := new(cgoAllocMap)
	allocs70d11a9b.Add(mem70d11a9b)

	var csType_allocs *cgoAllocMap
	ref70d11a9b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs70d11a9b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref70d11a9b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs70d11a9b.Borrow(cpNext_allocs)

	var cgeometryType_allocs *cgoAllocMap
	ref70d11a9b.geometryType, cgeometryType_allocs = (C.VkGeometryTypeKHR)(x.GeometryType), cgoAllocsUnknown
	allocs70d11a9b.Borrow(cgeometryType_allocs)

	var cgeometry_allocs *cgoAllocMap
	ref70d11a9b.geometry, cgeometry_allocs = x.Geometry.PassValue()
	allocs70d11a9b.Borrow(cgeometry_allocs)

	var cflags_allocs *cgoAllocMap
	ref70d11a9b.flags, cflags_allocs = (C.VkGeometryFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs70d11a9b.Borrow(cflags_allocs)

	x.ref70d11a9b = ref70d11a9b
	x.allocs70d11a9b = allocs70d11a9b
	return ref70d11a9b, allocs70d11a9b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GeometryNV) PassValue() (C.VkGeometryNV, *cgoAllocMap) {
	if x.ref70d11a9b != nil {
		return *x.ref70d11a9b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GeometryNV) Deref() {
	if x.ref70d11a9b == nil {
		return
	}
	x.SType = (StructureType)(x.ref70d11a9b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref70d11a9b.pNext))
	x.GeometryType = (GeometryType)(x.ref70d11a9b.geometryType)
	x.Geometry = *NewGeometryDataNVRef(unsafe.Pointer(&x.ref70d11a9b.geometry))
	x.Flags = (GeometryFlags)(x.ref70d11a9b.flags)
}

// allocAccelerationStructureInfoNVMemory allocates memory for type C.VkAccelerationStructureInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAccelerationStructureInfoNVValue = unsafe.Sizeof([1]C.VkAccelerationStructureInfoNV{})

// unpackSGeometryNV transforms a sliced Go data structure into plain C format.
func unpackSGeometryNV(x []GeometryNV) (unpacked *C.VkGeometryNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocGeometryNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkGeometryNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkGeometryNV)(h.Data)
	return
}

// packSGeometryNV reads sliced Go data structure out from plain C format.
func packSGeometryNV(v []GeometryNV, ptr0 *C.VkGeometryNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfGeometryNVValue]C.VkGeometryNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewGeometryNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureInfoNV) Ref() *C.VkAccelerationStructureInfoNV {
	if x == nil {
		return nil
	}
	return x.refe123d2c9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureInfoNV) Free() {
	if x != nil && x.allocse123d2c9 != nil {
		x.allocse123d2c9.(*cgoAllocMap).Free()
		x.refe123d2c9 = nil
	}
}

// NewAccelerationStructureInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureInfoNVRef(ref unsafe.Pointer) *AccelerationStructureInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureInfoNV)
	obj.refe123d2c9 = (*C.VkAccelerationStructureInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureInfoNV) PassRef() (*C.VkAccelerationStructureInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe123d2c9 != nil {
		return x.refe123d2c9, nil
	}
	meme123d2c9 := allocAccelerationStructureInfoNVMemory(1)
	refe123d2c9 := (*C.VkAccelerationStructureInfoNV)(meme123d2c9)
	allocse123d2c9 := new(cgoAllocMap)
	allocse123d2c9.Add(meme123d2c9)

	var csType_allocs *cgoAllocMap
	refe123d2c9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse123d2c9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe123d2c9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse123d2c9.Borrow(cpNext_allocs)

	var c_type_allocs *cgoAllocMap
	refe123d2c9._type, c_type_allocs = (C.VkAccelerationStructureTypeNV)(x.Type), cgoAllocsUnknown
	allocse123d2c9.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	refe123d2c9.flags, cflags_allocs = (C.VkBuildAccelerationStructureFlagsNV)(x.Flags), cgoAllocsUnknown
	allocse123d2c9.Borrow(cflags_allocs)

	var cinstanceCount_allocs *cgoAllocMap
	refe123d2c9.instanceCount, cinstanceCount_allocs = (C.uint32_t)(x.InstanceCount), cgoAllocsUnknown
	allocse123d2c9.Borrow(cinstanceCount_allocs)

	var cgeometryCount_allocs *cgoAllocMap
	refe123d2c9.geometryCount, cgeometryCount_allocs = (C.uint32_t)(x.GeometryCount), cgoAllocsUnknown
	allocse123d2c9.Borrow(cgeometryCount_allocs)

	var cpGeometries_allocs *cgoAllocMap
	refe123d2c9.pGeometries, cpGeometries_allocs = unpackSGeometryNV(x.PGeometries)
	allocse123d2c9.Borrow(cpGeometries_allocs)

	x.refe123d2c9 = refe123d2c9
	x.allocse123d2c9 = allocse123d2c9
	return refe123d2c9, allocse123d2c9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureInfoNV) PassValue() (C.VkAccelerationStructureInfoNV, *cgoAllocMap) {
	if x.refe123d2c9 != nil {
		return *x.refe123d2c9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureInfoNV) Deref() {
	if x.refe123d2c9 == nil {
		return
	}
	x.SType = (StructureType)(x.refe123d2c9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe123d2c9.pNext))
	x.Type = (AccelerationStructureTypeNV)(x.refe123d2c9._type)
	x.Flags = (BuildAccelerationStructureFlagsNV)(x.refe123d2c9.flags)
	x.InstanceCount = (uint32)(x.refe123d2c9.instanceCount)
	x.GeometryCount = (uint32)(x.refe123d2c9.geometryCount)
	packSGeometryNV(x.PGeometries, x.refe123d2c9.pGeometries)
}

// allocAccelerationStructureCreateInfoNVMemory allocates memory for type C.VkAccelerationStructureCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAccelerationStructureCreateInfoNVValue = unsafe.Sizeof([1]C.VkAccelerationStructureCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureCreateInfoNV) Ref() *C.VkAccelerationStructureCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref317e7627
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureCreateInfoNV) Free() {
	if x != nil && x.allocs317e7627 != nil {
		x.allocs317e7627.(*cgoAllocMap).Free()
		x.ref317e7627 = nil
	}
}

// NewAccelerationStructureCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureCreateInfoNVRef(ref unsafe.Pointer) *AccelerationStructureCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureCreateInfoNV)
	obj.ref317e7627 = (*C.VkAccelerationStructureCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureCreateInfoNV) PassRef() (*C.VkAccelerationStructureCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref317e7627 != nil {
		return x.ref317e7627, nil
	}
	mem317e7627 := allocAccelerationStructureCreateInfoNVMemory(1)
	ref317e7627 := (*C.VkAccelerationStructureCreateInfoNV)(mem317e7627)
	allocs317e7627 := new(cgoAllocMap)
	allocs317e7627.Add(mem317e7627)

	var csType_allocs *cgoAllocMap
	ref317e7627.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs317e7627.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref317e7627.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs317e7627.Borrow(cpNext_allocs)

	var ccompactedSize_allocs *cgoAllocMap
	ref317e7627.compactedSize, ccompactedSize_allocs = (C.VkDeviceSize)(x.CompactedSize), cgoAllocsUnknown
	allocs317e7627.Borrow(ccompactedSize_allocs)

	var cinfo_allocs *cgoAllocMap
	ref317e7627.info, cinfo_allocs = x.Info.PassValue()
	allocs317e7627.Borrow(cinfo_allocs)

	x.ref317e7627 = ref317e7627
	x.allocs317e7627 = allocs317e7627
	return ref317e7627, allocs317e7627

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureCreateInfoNV) PassValue() (C.VkAccelerationStructureCreateInfoNV, *cgoAllocMap) {
	if x.ref317e7627 != nil {
		return *x.ref317e7627, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureCreateInfoNV) Deref() {
	if x.ref317e7627 == nil {
		return
	}
	x.SType = (StructureType)(x.ref317e7627.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref317e7627.pNext))
	x.CompactedSize = (DeviceSize)(x.ref317e7627.compactedSize)
	x.Info = *NewAccelerationStructureInfoNVRef(unsafe.Pointer(&x.ref317e7627.info))
}

// allocBindAccelerationStructureMemoryInfoNVMemory allocates memory for type C.VkBindAccelerationStructureMemoryInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindAccelerationStructureMemoryInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindAccelerationStructureMemoryInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindAccelerationStructureMemoryInfoNVValue = unsafe.Sizeof([1]C.VkBindAccelerationStructureMemoryInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindAccelerationStructureMemoryInfoNV) Ref() *C.VkBindAccelerationStructureMemoryInfoNV {
	if x == nil {
		return nil
	}
	return x.ref47106908
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindAccelerationStructureMemoryInfoNV) Free() {
	if x != nil && x.allocs47106908 != nil {
		x.allocs47106908.(*cgoAllocMap).Free()
		x.ref47106908 = nil
	}
}

// NewBindAccelerationStructureMemoryInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindAccelerationStructureMemoryInfoNVRef(ref unsafe.Pointer) *BindAccelerationStructureMemoryInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(BindAccelerationStructureMemoryInfoNV)
	obj.ref47106908 = (*C.VkBindAccelerationStructureMemoryInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindAccelerationStructureMemoryInfoNV) PassRef() (*C.VkBindAccelerationStructureMemoryInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref47106908 != nil {
		return x.ref47106908, nil
	}
	mem47106908 := allocBindAccelerationStructureMemoryInfoNVMemory(1)
	ref47106908 := (*C.VkBindAccelerationStructureMemoryInfoNV)(mem47106908)
	allocs47106908 := new(cgoAllocMap)
	allocs47106908.Add(mem47106908)

	var csType_allocs *cgoAllocMap
	ref47106908.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs47106908.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref47106908.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs47106908.Borrow(cpNext_allocs)

	var caccelerationStructure_allocs *cgoAllocMap
	ref47106908.accelerationStructure, caccelerationStructure_allocs = *(*C.VkAccelerationStructureNV)(unsafe.Pointer(&x.AccelerationStructure)), cgoAllocsUnknown
	allocs47106908.Borrow(caccelerationStructure_allocs)

	var cmemory_allocs *cgoAllocMap
	ref47106908.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs47106908.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	ref47106908.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocs47106908.Borrow(cmemoryOffset_allocs)

	var cdeviceIndexCount_allocs *cgoAllocMap
	ref47106908.deviceIndexCount, cdeviceIndexCount_allocs = (C.uint32_t)(x.DeviceIndexCount), cgoAllocsUnknown
	allocs47106908.Borrow(cdeviceIndexCount_allocs)

	var cpDeviceIndices_allocs *cgoAllocMap
	ref47106908.pDeviceIndices, cpDeviceIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices)))
	allocs47106908.Borrow(cpDeviceIndices_allocs)

	x.ref47106908 = ref47106908
	x.allocs47106908 = allocs47106908
	return ref47106908, allocs47106908

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindAccelerationStructureMemoryInfoNV) PassValue() (C.VkBindAccelerationStructureMemoryInfoNV, *cgoAllocMap) {
	if x.ref47106908 != nil {
		return *x.ref47106908, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindAccelerationStructureMemoryInfoNV) Deref() {
	if x.ref47106908 == nil {
		return
	}
	x.SType = (StructureType)(x.ref47106908.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref47106908.pNext))
	x.AccelerationStructure = *(*AccelerationStructureNV)(unsafe.Pointer(&x.ref47106908.accelerationStructure))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref47106908.memory))
	x.MemoryOffset = (DeviceSize)(x.ref47106908.memoryOffset)
	x.DeviceIndexCount = (uint32)(x.ref47106908.deviceIndexCount)
	hxf8dbbe5 := (*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices))
	hxf8dbbe5.Data = unsafe.Pointer(x.ref47106908.pDeviceIndices)
	hxf8dbbe5.Cap = 0x7fffffff
	// hxf8dbbe5.Len = ?

}

// allocWriteDescriptorSetAccelerationStructureNVMemory allocates memory for type C.VkWriteDescriptorSetAccelerationStructureNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWriteDescriptorSetAccelerationStructureNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWriteDescriptorSetAccelerationStructureNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfWriteDescriptorSetAccelerationStructureNVValue = unsafe.Sizeof([1]C.VkWriteDescriptorSetAccelerationStructureNV{})

// copyPAccelerationStructureNVBytes copies the data from Go slice as *C.VkAccelerationStructureNV.
func copyPAccelerationStructureNVBytes(slice *sliceHeader) (*C.VkAccelerationStructureNV, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfAccelerationStructureNVValue) * slice.Len,
		Cap:  int(sizeOfAccelerationStructureNVValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkAccelerationStructureNV)(mem0), allocs
}

// allocAccelerationStructureNVMemory allocates memory for type C.VkAccelerationStructureNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAccelerationStructureNVValue = unsafe.Sizeof([1]C.VkAccelerationStructureNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *WriteDescriptorSetAccelerationStructureNV) Ref() *C.VkWriteDescriptorSetAccelerationStructureNV {
	if x == nil {
		return nil
	}
	return x.reff973db43
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *WriteDescriptorSetAccelerationStructureNV) Free() {
	if x != nil && x.allocsf973db43 != nil {
		x.allocsf973db43.(*cgoAllocMap).Free()
		x.reff973db43 = nil
	}
}

// NewWriteDescriptorSetAccelerationStructureNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWriteDescriptorSetAccelerationStructureNVRef(ref unsafe.Pointer) *WriteDescriptorSetAccelerationStructureNV {
	if ref == nil {
		return nil
	}
	obj := new(WriteDescriptorSetAccelerationStructureNV)
	obj.reff973db43 = (*C.VkWriteDescriptorSetAccelerationStructureNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *WriteDescriptorSetAccelerationStructureNV) PassRef() (*C.VkWriteDescriptorSetAccelerationStructureNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff973db43 != nil {
		return x.reff973db43, nil
	}
	memf973db43 := allocWriteDescriptorSetAccelerationStructureNVMemory(1)
	reff973db43 := (*C.VkWriteDescriptorSetAccelerationStructureNV)(memf973db43)
	allocsf973db43 := new(cgoAllocMap)
	allocsf973db43.Add(memf973db43)

	var csType_allocs *cgoAllocMap
	reff973db43.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf973db43.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff973db43.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf973db43.Borrow(cpNext_allocs)

	var caccelerationStructureCount_allocs *cgoAllocMap
	reff973db43.accelerationStructureCount, caccelerationStructureCount_allocs = (C.uint32_t)(x.AccelerationStructureCount), cgoAllocsUnknown
	allocsf973db43.Borrow(caccelerationStructureCount_allocs)

	var cpAccelerationStructures_allocs *cgoAllocMap
	reff973db43.pAccelerationStructures, cpAccelerationStructures_allocs = copyPAccelerationStructureNVBytes((*sliceHeader)(unsafe.Pointer(&x.PAccelerationStructures)))
	allocsf973db43.Borrow(cpAccelerationStructures_allocs)

	x.reff973db43 = reff973db43
	x.allocsf973db43 = allocsf973db43
	return reff973db43, allocsf973db43

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x WriteDescriptorSetAccelerationStructureNV) PassValue() (C.VkWriteDescriptorSetAccelerationStructureNV, *cgoAllocMap) {
	if x.reff973db43 != nil {
		return *x.reff973db43, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *WriteDescriptorSetAccelerationStructureNV) Deref() {
	if x.reff973db43 == nil {
		return
	}
	x.SType = (StructureType)(x.reff973db43.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff973db43.pNext))
	x.AccelerationStructureCount = (uint32)(x.reff973db43.accelerationStructureCount)
	hxf766ff8 := (*sliceHeader)(unsafe.Pointer(&x.PAccelerationStructures))
	hxf766ff8.Data = unsafe.Pointer(x.reff973db43.pAccelerationStructures)
	hxf766ff8.Cap = 0x7fffffff
	// hxf766ff8.Len = ?

}

// allocAccelerationStructureMemoryRequirementsInfoNVMemory allocates memory for type C.VkAccelerationStructureMemoryRequirementsInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureMemoryRequirementsInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureMemoryRequirementsInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAccelerationStructureMemoryRequirementsInfoNVValue = unsafe.Sizeof([1]C.VkAccelerationStructureMemoryRequirementsInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureMemoryRequirementsInfoNV) Ref() *C.VkAccelerationStructureMemoryRequirementsInfoNV {
	if x == nil {
		return nil
	}
	return x.ref9ff82d4a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureMemoryRequirementsInfoNV) Free() {
	if x != nil && x.allocs9ff82d4a != nil {
		x.allocs9ff82d4a.(*cgoAllocMap).Free()
		x.ref9ff82d4a = nil
	}
}

// NewAccelerationStructureMemoryRequirementsInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureMemoryRequirementsInfoNVRef(ref unsafe.Pointer) *AccelerationStructureMemoryRequirementsInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureMemoryRequirementsInfoNV)
	obj.ref9ff82d4a = (*C.VkAccelerationStructureMemoryRequirementsInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureMemoryRequirementsInfoNV) PassRef() (*C.VkAccelerationStructureMemoryRequirementsInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9ff82d4a != nil {
		return x.ref9ff82d4a, nil
	}
	mem9ff82d4a := allocAccelerationStructureMemoryRequirementsInfoNVMemory(1)
	ref9ff82d4a := (*C.VkAccelerationStructureMemoryRequirementsInfoNV)(mem9ff82d4a)
	allocs9ff82d4a := new(cgoAllocMap)
	allocs9ff82d4a.Add(mem9ff82d4a)

	var csType_allocs *cgoAllocMap
	ref9ff82d4a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9ff82d4a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9ff82d4a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9ff82d4a.Borrow(cpNext_allocs)

	var c_type_allocs *cgoAllocMap
	ref9ff82d4a._type, c_type_allocs = (C.VkAccelerationStructureMemoryRequirementsTypeNV)(x.Type), cgoAllocsUnknown
	allocs9ff82d4a.Borrow(c_type_allocs)

	var caccelerationStructure_allocs *cgoAllocMap
	ref9ff82d4a.accelerationStructure, caccelerationStructure_allocs = *(*C.VkAccelerationStructureNV)(unsafe.Pointer(&x.AccelerationStructure)), cgoAllocsUnknown
	allocs9ff82d4a.Borrow(caccelerationStructure_allocs)

	x.ref9ff82d4a = ref9ff82d4a
	x.allocs9ff82d4a = allocs9ff82d4a
	return ref9ff82d4a, allocs9ff82d4a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureMemoryRequirementsInfoNV) PassValue() (C.VkAccelerationStructureMemoryRequirementsInfoNV, *cgoAllocMap) {
	if x.ref9ff82d4a != nil {
		return *x.ref9ff82d4a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureMemoryRequirementsInfoNV) Deref() {
	if x.ref9ff82d4a == nil {
		return
	}
	x.SType = (StructureType)(x.ref9ff82d4a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9ff82d4a.pNext))
	x.Type = (AccelerationStructureMemoryRequirementsTypeNV)(x.ref9ff82d4a._type)
	x.AccelerationStructure = *(*AccelerationStructureNV)(unsafe.Pointer(&x.ref9ff82d4a.accelerationStructure))
}

// allocPhysicalDeviceRayTracingPropertiesNVMemory allocates memory for type C.VkPhysicalDeviceRayTracingPropertiesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceRayTracingPropertiesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceRayTracingPropertiesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceRayTracingPropertiesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceRayTracingPropertiesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceRayTracingPropertiesNV) Ref() *C.VkPhysicalDeviceRayTracingPropertiesNV {
	if x == nil {
		return nil
	}
	return x.ref8571940d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceRayTracingPropertiesNV) Free() {
	if x != nil && x.allocs8571940d != nil {
		x.allocs8571940d.(*cgoAllocMap).Free()
		x.ref8571940d = nil
	}
}

// NewPhysicalDeviceRayTracingPropertiesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceRayTracingPropertiesNVRef(ref unsafe.Pointer) *PhysicalDeviceRayTracingPropertiesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceRayTracingPropertiesNV)
	obj.ref8571940d = (*C.VkPhysicalDeviceRayTracingPropertiesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceRayTracingPropertiesNV) PassRef() (*C.VkPhysicalDeviceRayTracingPropertiesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8571940d != nil {
		return x.ref8571940d, nil
	}
	mem8571940d := allocPhysicalDeviceRayTracingPropertiesNVMemory(1)
	ref8571940d := (*C.VkPhysicalDeviceRayTracingPropertiesNV)(mem8571940d)
	allocs8571940d := new(cgoAllocMap)
	allocs8571940d.Add(mem8571940d)

	var csType_allocs *cgoAllocMap
	ref8571940d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8571940d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8571940d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8571940d.Borrow(cpNext_allocs)

	var cshaderGroupHandleSize_allocs *cgoAllocMap
	ref8571940d.shaderGroupHandleSize, cshaderGroupHandleSize_allocs = (C.uint32_t)(x.ShaderGroupHandleSize), cgoAllocsUnknown
	allocs8571940d.Borrow(cshaderGroupHandleSize_allocs)

	var cmaxRecursionDepth_allocs *cgoAllocMap
	ref8571940d.maxRecursionDepth, cmaxRecursionDepth_allocs = (C.uint32_t)(x.MaxRecursionDepth), cgoAllocsUnknown
	allocs8571940d.Borrow(cmaxRecursionDepth_allocs)

	var cmaxShaderGroupStride_allocs *cgoAllocMap
	ref8571940d.maxShaderGroupStride, cmaxShaderGroupStride_allocs = (C.uint32_t)(x.MaxShaderGroupStride), cgoAllocsUnknown
	allocs8571940d.Borrow(cmaxShaderGroupStride_allocs)

	var cshaderGroupBaseAlignment_allocs *cgoAllocMap
	ref8571940d.shaderGroupBaseAlignment, cshaderGroupBaseAlignment_allocs = (C.uint32_t)(x.ShaderGroupBaseAlignment), cgoAllocsUnknown
	allocs8571940d.Borrow(cshaderGroupBaseAlignment_allocs)

	var cmaxGeometryCount_allocs *cgoAllocMap
	ref8571940d.maxGeometryCount, cmaxGeometryCount_allocs = (C.uint64_t)(x.MaxGeometryCount), cgoAllocsUnknown
	allocs8571940d.Borrow(cmaxGeometryCount_allocs)

	var cmaxInstanceCount_allocs *cgoAllocMap
	ref8571940d.maxInstanceCount, cmaxInstanceCount_allocs = (C.uint64_t)(x.MaxInstanceCount), cgoAllocsUnknown
	allocs8571940d.Borrow(cmaxInstanceCount_allocs)

	var cmaxTriangleCount_allocs *cgoAllocMap
	ref8571940d.maxTriangleCount, cmaxTriangleCount_allocs = (C.uint64_t)(x.MaxTriangleCount), cgoAllocsUnknown
	allocs8571940d.Borrow(cmaxTriangleCount_allocs)

	var cmaxDescriptorSetAccelerationStructures_allocs *cgoAllocMap
	ref8571940d.maxDescriptorSetAccelerationStructures, cmaxDescriptorSetAccelerationStructures_allocs = (C.uint32_t)(x.MaxDescriptorSetAccelerationStructures), cgoAllocsUnknown
	allocs8571940d.Borrow(cmaxDescriptorSetAccelerationStructures_allocs)

	x.ref8571940d = ref8571940d
	x.allocs8571940d = allocs8571940d
	return ref8571940d, allocs8571940d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceRayTracingPropertiesNV) PassValue() (C.VkPhysicalDeviceRayTracingPropertiesNV, *cgoAllocMap) {
	if x.ref8571940d != nil {
		return *x.ref8571940d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceRayTracingPropertiesNV) Deref() {
	if x.ref8571940d == nil {
		return
	}
	x.SType = (StructureType)(x.ref8571940d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8571940d.pNext))
	x.ShaderGroupHandleSize = (uint32)(x.ref8571940d.shaderGroupHandleSize)
	x.MaxRecursionDepth = (uint32)(x.ref8571940d.maxRecursionDepth)
	x.MaxShaderGroupStride = (uint32)(x.ref8571940d.maxShaderGroupStride)
	x.ShaderGroupBaseAlignment = (uint32)(x.ref8571940d.shaderGroupBaseAlignment)
	x.MaxGeometryCount = (uint32)(x.ref8571940d.maxGeometryCount)
	x.MaxInstanceCount = (uint32)(x.ref8571940d.maxInstanceCount)
	x.MaxTriangleCount = (uint32)(x.ref8571940d.maxTriangleCount)
	x.MaxDescriptorSetAccelerationStructures = (uint32)(x.ref8571940d.maxDescriptorSetAccelerationStructures)
}

// allocTransformMatrixMemory allocates memory for type C.VkTransformMatrixKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTransformMatrixMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTransformMatrixValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTransformMatrixValue = unsafe.Sizeof([1]C.VkTransformMatrixKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TransformMatrix) Ref() *C.VkTransformMatrixKHR {
	if x == nil {
		return nil
	}
	return x.reffea2fa9b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TransformMatrix) Free() {
	if x != nil && x.allocsfea2fa9b != nil {
		x.allocsfea2fa9b.(*cgoAllocMap).Free()
		x.reffea2fa9b = nil
	}
}

// NewTransformMatrixRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTransformMatrixRef(ref unsafe.Pointer) *TransformMatrix {
	if ref == nil {
		return nil
	}
	obj := new(TransformMatrix)
	obj.reffea2fa9b = (*C.VkTransformMatrixKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TransformMatrix) PassRef() (*C.VkTransformMatrixKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffea2fa9b != nil {
		return x.reffea2fa9b, nil
	}
	memfea2fa9b := allocTransformMatrixMemory(1)
	reffea2fa9b := (*C.VkTransformMatrixKHR)(memfea2fa9b)
	allocsfea2fa9b := new(cgoAllocMap)
	allocsfea2fa9b.Add(memfea2fa9b)

	var cmatrix_allocs *cgoAllocMap
	reffea2fa9b.matrix, cmatrix_allocs = *(*[3][4]C.float)(unsafe.Pointer(&x.Matrix)), cgoAllocsUnknown
	allocsfea2fa9b.Borrow(cmatrix_allocs)

	x.reffea2fa9b = reffea2fa9b
	x.allocsfea2fa9b = allocsfea2fa9b
	return reffea2fa9b, allocsfea2fa9b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TransformMatrix) PassValue() (C.VkTransformMatrixKHR, *cgoAllocMap) {
	if x.reffea2fa9b != nil {
		return *x.reffea2fa9b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TransformMatrix) Deref() {
	if x.reffea2fa9b == nil {
		return
	}
	x.Matrix = *(*[3][4]float32)(unsafe.Pointer(&x.reffea2fa9b.matrix))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TransformMatrixNV) Ref() *C.VkTransformMatrixKHR {
	if x == nil {
		return nil
	}
	return x.reffea2fa9b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TransformMatrixNV) Free() {
	if x != nil && x.allocsfea2fa9b != nil {
		x.allocsfea2fa9b.(*cgoAllocMap).Free()
		x.reffea2fa9b = nil
	}
}

// NewTransformMatrixNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTransformMatrixNVRef(ref unsafe.Pointer) *TransformMatrixNV {
	if ref == nil {
		return nil
	}
	obj := new(TransformMatrixNV)
	obj.reffea2fa9b = (*C.VkTransformMatrixKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TransformMatrixNV) PassRef() (*C.VkTransformMatrixKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffea2fa9b != nil {
		return x.reffea2fa9b, nil
	}
	memfea2fa9b := allocTransformMatrixMemory(1)
	reffea2fa9b := (*C.VkTransformMatrixKHR)(memfea2fa9b)
	allocsfea2fa9b := new(cgoAllocMap)
	allocsfea2fa9b.Add(memfea2fa9b)

	var cmatrix_allocs *cgoAllocMap
	reffea2fa9b.matrix, cmatrix_allocs = *(*[3][4]C.float)(unsafe.Pointer(&x.Matrix)), cgoAllocsUnknown
	allocsfea2fa9b.Borrow(cmatrix_allocs)

	x.reffea2fa9b = reffea2fa9b
	x.allocsfea2fa9b = allocsfea2fa9b
	return reffea2fa9b, allocsfea2fa9b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TransformMatrixNV) PassValue() (C.VkTransformMatrixKHR, *cgoAllocMap) {
	if x.reffea2fa9b != nil {
		return *x.reffea2fa9b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TransformMatrixNV) Deref() {
	if x.reffea2fa9b == nil {
		return
	}
	x.Matrix = *(*[3][4]float32)(unsafe.Pointer(&x.reffea2fa9b.matrix))
}

// allocAabbPositionsMemory allocates memory for type C.VkAabbPositionsKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAabbPositionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAabbPositionsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAabbPositionsValue = unsafe.Sizeof([1]C.VkAabbPositionsKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AabbPositions) Ref() *C.VkAabbPositionsKHR {
	if x == nil {
		return nil
	}
	return x.ref148aba
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AabbPositions) Free() {
	if x != nil && x.allocs148aba != nil {
		x.allocs148aba.(*cgoAllocMap).Free()
		x.ref148aba = nil
	}
}

// NewAabbPositionsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAabbPositionsRef(ref unsafe.Pointer) *AabbPositions {
	if ref == nil {
		return nil
	}
	obj := new(AabbPositions)
	obj.ref148aba = (*C.VkAabbPositionsKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AabbPositions) PassRef() (*C.VkAabbPositionsKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref148aba != nil {
		return x.ref148aba, nil
	}
	mem148aba := allocAabbPositionsMemory(1)
	ref148aba := (*C.VkAabbPositionsKHR)(mem148aba)
	allocs148aba := new(cgoAllocMap)
	allocs148aba.Add(mem148aba)

	var cminX_allocs *cgoAllocMap
	ref148aba.minX, cminX_allocs = (C.float)(x.MinX), cgoAllocsUnknown
	allocs148aba.Borrow(cminX_allocs)

	var cminY_allocs *cgoAllocMap
	ref148aba.minY, cminY_allocs = (C.float)(x.MinY), cgoAllocsUnknown
	allocs148aba.Borrow(cminY_allocs)

	var cminZ_allocs *cgoAllocMap
	ref148aba.minZ, cminZ_allocs = (C.float)(x.MinZ), cgoAllocsUnknown
	allocs148aba.Borrow(cminZ_allocs)

	var cmaxX_allocs *cgoAllocMap
	ref148aba.maxX, cmaxX_allocs = (C.float)(x.MaxX), cgoAllocsUnknown
	allocs148aba.Borrow(cmaxX_allocs)

	var cmaxY_allocs *cgoAllocMap
	ref148aba.maxY, cmaxY_allocs = (C.float)(x.MaxY), cgoAllocsUnknown
	allocs148aba.Borrow(cmaxY_allocs)

	var cmaxZ_allocs *cgoAllocMap
	ref148aba.maxZ, cmaxZ_allocs = (C.float)(x.MaxZ), cgoAllocsUnknown
	allocs148aba.Borrow(cmaxZ_allocs)

	x.ref148aba = ref148aba
	x.allocs148aba = allocs148aba
	return ref148aba, allocs148aba

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AabbPositions) PassValue() (C.VkAabbPositionsKHR, *cgoAllocMap) {
	if x.ref148aba != nil {
		return *x.ref148aba, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AabbPositions) Deref() {
	if x.ref148aba == nil {
		return
	}
	x.MinX = (float32)(x.ref148aba.minX)
	x.MinY = (float32)(x.ref148aba.minY)
	x.MinZ = (float32)(x.ref148aba.minZ)
	x.MaxX = (float32)(x.ref148aba.maxX)
	x.MaxY = (float32)(x.ref148aba.maxY)
	x.MaxZ = (float32)(x.ref148aba.maxZ)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AabbPositionsNV) Ref() *C.VkAabbPositionsKHR {
	if x == nil {
		return nil
	}
	return x.ref148aba
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AabbPositionsNV) Free() {
	if x != nil && x.allocs148aba != nil {
		x.allocs148aba.(*cgoAllocMap).Free()
		x.ref148aba = nil
	}
}

// NewAabbPositionsNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAabbPositionsNVRef(ref unsafe.Pointer) *AabbPositionsNV {
	if ref == nil {
		return nil
	}
	obj := new(AabbPositionsNV)
	obj.ref148aba = (*C.VkAabbPositionsKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AabbPositionsNV) PassRef() (*C.VkAabbPositionsKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref148aba != nil {
		return x.ref148aba, nil
	}
	mem148aba := allocAabbPositionsMemory(1)
	ref148aba := (*C.VkAabbPositionsKHR)(mem148aba)
	allocs148aba := new(cgoAllocMap)
	allocs148aba.Add(mem148aba)

	var cminX_allocs *cgoAllocMap
	ref148aba.minX, cminX_allocs = (C.float)(x.MinX), cgoAllocsUnknown
	allocs148aba.Borrow(cminX_allocs)

	var cminY_allocs *cgoAllocMap
	ref148aba.minY, cminY_allocs = (C.float)(x.MinY), cgoAllocsUnknown
	allocs148aba.Borrow(cminY_allocs)

	var cminZ_allocs *cgoAllocMap
	ref148aba.minZ, cminZ_allocs = (C.float)(x.MinZ), cgoAllocsUnknown
	allocs148aba.Borrow(cminZ_allocs)

	var cmaxX_allocs *cgoAllocMap
	ref148aba.maxX, cmaxX_allocs = (C.float)(x.MaxX), cgoAllocsUnknown
	allocs148aba.Borrow(cmaxX_allocs)

	var cmaxY_allocs *cgoAllocMap
	ref148aba.maxY, cmaxY_allocs = (C.float)(x.MaxY), cgoAllocsUnknown
	allocs148aba.Borrow(cmaxY_allocs)

	var cmaxZ_allocs *cgoAllocMap
	ref148aba.maxZ, cmaxZ_allocs = (C.float)(x.MaxZ), cgoAllocsUnknown
	allocs148aba.Borrow(cmaxZ_allocs)

	x.ref148aba = ref148aba
	x.allocs148aba = allocs148aba
	return ref148aba, allocs148aba

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AabbPositionsNV) PassValue() (C.VkAabbPositionsKHR, *cgoAllocMap) {
	if x.ref148aba != nil {
		return *x.ref148aba, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AabbPositionsNV) Deref() {
	if x.ref148aba == nil {
		return
	}
	x.MinX = (float32)(x.ref148aba.minX)
	x.MinY = (float32)(x.ref148aba.minY)
	x.MinZ = (float32)(x.ref148aba.minZ)
	x.MaxX = (float32)(x.ref148aba.maxX)
	x.MaxY = (float32)(x.ref148aba.maxY)
	x.MaxZ = (float32)(x.ref148aba.maxZ)
}

// allocAccelerationStructureInstanceMemory allocates memory for type C.VkAccelerationStructureInstanceKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureInstanceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureInstanceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAccelerationStructureInstanceValue = unsafe.Sizeof([1]C.VkAccelerationStructureInstanceKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureInstance) Ref() *C.VkAccelerationStructureInstanceKHR {
	if x == nil {
		return nil
	}
	return x.refd62e4d1f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureInstance) Free() {
	if x != nil && x.allocsd62e4d1f != nil {
		x.allocsd62e4d1f.(*cgoAllocMap).Free()
		x.refd62e4d1f = nil
	}
}

// NewAccelerationStructureInstanceRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureInstanceRef(ref unsafe.Pointer) *AccelerationStructureInstance {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureInstance)
	obj.refd62e4d1f = (*C.VkAccelerationStructureInstanceKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureInstance) PassRef() (*C.VkAccelerationStructureInstanceKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd62e4d1f != nil {
		return x.refd62e4d1f, nil
	}
	memd62e4d1f := allocAccelerationStructureInstanceMemory(1)
	refd62e4d1f := (*C.VkAccelerationStructureInstanceKHR)(memd62e4d1f)
	allocsd62e4d1f := new(cgoAllocMap)
	allocsd62e4d1f.Add(memd62e4d1f)

	var ctransform_allocs *cgoAllocMap
	refd62e4d1f.transform, ctransform_allocs = x.Transform.PassValue()
	allocsd62e4d1f.Borrow(ctransform_allocs)

	// var cinstanceCustomIndex_allocs *cgoAllocMap
	// refd62e4d1f.instanceCustomIndex, cinstanceCustomIndex_allocs = (C.uint32_t)(x.InstanceCustomIndex), cgoAllocsUnknown
	// allocsd62e4d1f.Borrow(cinstanceCustomIndex_allocs)

	// var cmask_allocs *cgoAllocMap
	// refd62e4d1f.mask, cmask_allocs = (C.uint32_t)(x.Mask), cgoAllocsUnknown
	// allocsd62e4d1f.Borrow(cmask_allocs)

	// var cinstanceShaderBindingTableRecordOffset_allocs *cgoAllocMap
	// refd62e4d1f.instanceShaderBindingTableRecordOffset, cinstanceShaderBindingTableRecordOffset_allocs = (C.uint32_t)(x.InstanceShaderBindingTableRecordOffset), cgoAllocsUnknown
	// allocsd62e4d1f.Borrow(cinstanceShaderBindingTableRecordOffset_allocs)

	// var cflags_allocs *cgoAllocMap
	// refd62e4d1f.flags, cflags_allocs = (C.VkGeometryInstanceFlagsKHR)(x.Flags), cgoAllocsUnknown
	// allocsd62e4d1f.Borrow(cflags_allocs)

	// var caccelerationStructureReference_allocs *cgoAllocMap
	// refd62e4d1f.accelerationStructureReference, caccelerationStructureReference_allocs = (C.uint64_t)(x.AccelerationStructureReference), cgoAllocsUnknown
	// allocsd62e4d1f.Borrow(caccelerationStructureReference_allocs)

	// x.refd62e4d1f = refd62e4d1f
	// x.allocsd62e4d1f = allocsd62e4d1f
	// return refd62e4d1f, allocsd62e4d1f
	return nil, nil
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureInstance) PassValue() (C.VkAccelerationStructureInstanceKHR, *cgoAllocMap) {
	if x.refd62e4d1f != nil {
		return *x.refd62e4d1f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureInstance) Deref() {
	if x.refd62e4d1f == nil {
		return
	}
	x.Transform = *NewTransformMatrixRef(unsafe.Pointer(&x.refd62e4d1f.transform))
	// x.InstanceCustomIndex = (uint32)(x.refd62e4d1f.instanceCustomIndex)
	// x.Mask = (uint32)(x.refd62e4d1f.mask)
	// x.InstanceShaderBindingTableRecordOffset = (uint32)(x.refd62e4d1f.instanceShaderBindingTableRecordOffset)
	// x.Flags = (GeometryInstanceFlags)(x.refd62e4d1f.flags)
	// x.AccelerationStructureReference = (uint32)(x.refd62e4d1f.accelerationStructureReference)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureInstanceNV) Ref() *C.VkAccelerationStructureInstanceKHR {
	if x == nil {
		return nil
	}
	return x.refd62e4d1f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureInstanceNV) Free() {
	if x != nil && x.allocsd62e4d1f != nil {
		x.allocsd62e4d1f.(*cgoAllocMap).Free()
		x.refd62e4d1f = nil
	}
}

// NewAccelerationStructureInstanceNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureInstanceNVRef(ref unsafe.Pointer) *AccelerationStructureInstanceNV {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureInstanceNV)
	obj.refd62e4d1f = (*C.VkAccelerationStructureInstanceKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureInstanceNV) PassRef() (*C.VkAccelerationStructureInstanceKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd62e4d1f != nil {
		return x.refd62e4d1f, nil
	}
	memd62e4d1f := allocAccelerationStructureInstanceMemory(1)
	refd62e4d1f := (*C.VkAccelerationStructureInstanceKHR)(memd62e4d1f)
	allocsd62e4d1f := new(cgoAllocMap)
	allocsd62e4d1f.Add(memd62e4d1f)

	var ctransform_allocs *cgoAllocMap
	refd62e4d1f.transform, ctransform_allocs = x.Transform.PassValue()
	allocsd62e4d1f.Borrow(ctransform_allocs)

	// var cinstanceCustomIndex_allocs *cgoAllocMap
	// refd62e4d1f.instanceCustomIndex, cinstanceCustomIndex_allocs = (C.uint32_t)(x.InstanceCustomIndex), cgoAllocsUnknown
	// allocsd62e4d1f.Borrow(cinstanceCustomIndex_allocs)

	// var cmask_allocs *cgoAllocMap
	// refd62e4d1f.mask, cmask_allocs = (C.uint32_t)(x.Mask), cgoAllocsUnknown
	// allocsd62e4d1f.Borrow(cmask_allocs)

	// var cinstanceShaderBindingTableRecordOffset_allocs *cgoAllocMap
	// refd62e4d1f.instanceShaderBindingTableRecordOffset, cinstanceShaderBindingTableRecordOffset_allocs = (C.uint32_t)(x.InstanceShaderBindingTableRecordOffset), cgoAllocsUnknown
	// allocsd62e4d1f.Borrow(cinstanceShaderBindingTableRecordOffset_allocs)

	// var cflags_allocs *cgoAllocMap
	// refd62e4d1f.flags, cflags_allocs = (C.VkGeometryInstanceFlagsKHR)(x.Flags), cgoAllocsUnknown
	// allocsd62e4d1f.Borrow(cflags_allocs)

	// var caccelerationStructureReference_allocs *cgoAllocMap
	// refd62e4d1f.accelerationStructureReference, caccelerationStructureReference_allocs = (C.uint64_t)(x.AccelerationStructureReference), cgoAllocsUnknown
	// allocsd62e4d1f.Borrow(caccelerationStructureReference_allocs)

	// x.refd62e4d1f = refd62e4d1f
	// x.allocsd62e4d1f = allocsd62e4d1f
	// return refd62e4d1f, allocsd62e4d1f
	return nil, nil
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureInstanceNV) PassValue() (C.VkAccelerationStructureInstanceKHR, *cgoAllocMap) {
	if x.refd62e4d1f != nil {
		return *x.refd62e4d1f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureInstanceNV) Deref() {
	if x.refd62e4d1f == nil {
		return
	}
	x.Transform = *NewTransformMatrixRef(unsafe.Pointer(&x.refd62e4d1f.transform))
	// x.InstanceCustomIndex = (uint32)(x.refd62e4d1f.instanceCustomIndex)
	// x.Mask = (uint32)(x.refd62e4d1f.mask)
	// x.InstanceShaderBindingTableRecordOffset = (uint32)(x.refd62e4d1f.instanceShaderBindingTableRecordOffset)
	// x.Flags = (GeometryInstanceFlags)(x.refd62e4d1f.flags)
	// x.AccelerationStructureReference = (uint32)(x.refd62e4d1f.accelerationStructureReference)
}

// allocPhysicalDeviceRepresentativeFragmentTestFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceRepresentativeFragmentTestFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceRepresentativeFragmentTestFeaturesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceRepresentativeFragmentTestFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceRepresentativeFragmentTestFeaturesNV) Ref() *C.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
	if x == nil {
		return nil
	}
	return x.reff1f69e03
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceRepresentativeFragmentTestFeaturesNV) Free() {
	if x != nil && x.allocsf1f69e03 != nil {
		x.allocsf1f69e03.(*cgoAllocMap).Free()
		x.reff1f69e03 = nil
	}
}

// NewPhysicalDeviceRepresentativeFragmentTestFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceRepresentativeFragmentTestFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceRepresentativeFragmentTestFeaturesNV)
	obj.reff1f69e03 = (*C.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceRepresentativeFragmentTestFeaturesNV) PassRef() (*C.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff1f69e03 != nil {
		return x.reff1f69e03, nil
	}
	memf1f69e03 := allocPhysicalDeviceRepresentativeFragmentTestFeaturesNVMemory(1)
	reff1f69e03 := (*C.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV)(memf1f69e03)
	allocsf1f69e03 := new(cgoAllocMap)
	allocsf1f69e03.Add(memf1f69e03)

	var csType_allocs *cgoAllocMap
	reff1f69e03.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf1f69e03.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff1f69e03.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf1f69e03.Borrow(cpNext_allocs)

	var crepresentativeFragmentTest_allocs *cgoAllocMap
	reff1f69e03.representativeFragmentTest, crepresentativeFragmentTest_allocs = (C.VkBool32)(x.RepresentativeFragmentTest), cgoAllocsUnknown
	allocsf1f69e03.Borrow(crepresentativeFragmentTest_allocs)

	x.reff1f69e03 = reff1f69e03
	x.allocsf1f69e03 = allocsf1f69e03
	return reff1f69e03, allocsf1f69e03

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceRepresentativeFragmentTestFeaturesNV) PassValue() (C.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, *cgoAllocMap) {
	if x.reff1f69e03 != nil {
		return *x.reff1f69e03, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceRepresentativeFragmentTestFeaturesNV) Deref() {
	if x.reff1f69e03 == nil {
		return
	}
	x.SType = (StructureType)(x.reff1f69e03.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff1f69e03.pNext))
	x.RepresentativeFragmentTest = (Bool32)(x.reff1f69e03.representativeFragmentTest)
}

// allocPipelineRepresentativeFragmentTestStateCreateInfoNVMemory allocates memory for type C.VkPipelineRepresentativeFragmentTestStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRepresentativeFragmentTestStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRepresentativeFragmentTestStateCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineRepresentativeFragmentTestStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineRepresentativeFragmentTestStateCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRepresentativeFragmentTestStateCreateInfoNV) Ref() *C.VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref9c224e21
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRepresentativeFragmentTestStateCreateInfoNV) Free() {
	if x != nil && x.allocs9c224e21 != nil {
		x.allocs9c224e21.(*cgoAllocMap).Free()
		x.ref9c224e21 = nil
	}
}

// NewPipelineRepresentativeFragmentTestStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRepresentativeFragmentTestStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineRepresentativeFragmentTestStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRepresentativeFragmentTestStateCreateInfoNV)
	obj.ref9c224e21 = (*C.VkPipelineRepresentativeFragmentTestStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRepresentativeFragmentTestStateCreateInfoNV) PassRef() (*C.VkPipelineRepresentativeFragmentTestStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9c224e21 != nil {
		return x.ref9c224e21, nil
	}
	mem9c224e21 := allocPipelineRepresentativeFragmentTestStateCreateInfoNVMemory(1)
	ref9c224e21 := (*C.VkPipelineRepresentativeFragmentTestStateCreateInfoNV)(mem9c224e21)
	allocs9c224e21 := new(cgoAllocMap)
	allocs9c224e21.Add(mem9c224e21)

	var csType_allocs *cgoAllocMap
	ref9c224e21.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9c224e21.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9c224e21.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9c224e21.Borrow(cpNext_allocs)

	var crepresentativeFragmentTestEnable_allocs *cgoAllocMap
	ref9c224e21.representativeFragmentTestEnable, crepresentativeFragmentTestEnable_allocs = (C.VkBool32)(x.RepresentativeFragmentTestEnable), cgoAllocsUnknown
	allocs9c224e21.Borrow(crepresentativeFragmentTestEnable_allocs)

	x.ref9c224e21 = ref9c224e21
	x.allocs9c224e21 = allocs9c224e21
	return ref9c224e21, allocs9c224e21

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRepresentativeFragmentTestStateCreateInfoNV) PassValue() (C.VkPipelineRepresentativeFragmentTestStateCreateInfoNV, *cgoAllocMap) {
	if x.ref9c224e21 != nil {
		return *x.ref9c224e21, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRepresentativeFragmentTestStateCreateInfoNV) Deref() {
	if x.ref9c224e21 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9c224e21.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9c224e21.pNext))
	x.RepresentativeFragmentTestEnable = (Bool32)(x.ref9c224e21.representativeFragmentTestEnable)
}

// allocPhysicalDeviceImageViewImageFormatInfoMemory allocates memory for type C.VkPhysicalDeviceImageViewImageFormatInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceImageViewImageFormatInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceImageViewImageFormatInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceImageViewImageFormatInfoValue = unsafe.Sizeof([1]C.VkPhysicalDeviceImageViewImageFormatInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceImageViewImageFormatInfo) Ref() *C.VkPhysicalDeviceImageViewImageFormatInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref99e4ab46
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceImageViewImageFormatInfo) Free() {
	if x != nil && x.allocs99e4ab46 != nil {
		x.allocs99e4ab46.(*cgoAllocMap).Free()
		x.ref99e4ab46 = nil
	}
}

// NewPhysicalDeviceImageViewImageFormatInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceImageViewImageFormatInfoRef(ref unsafe.Pointer) *PhysicalDeviceImageViewImageFormatInfo {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceImageViewImageFormatInfo)
	obj.ref99e4ab46 = (*C.VkPhysicalDeviceImageViewImageFormatInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceImageViewImageFormatInfo) PassRef() (*C.VkPhysicalDeviceImageViewImageFormatInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref99e4ab46 != nil {
		return x.ref99e4ab46, nil
	}
	mem99e4ab46 := allocPhysicalDeviceImageViewImageFormatInfoMemory(1)
	ref99e4ab46 := (*C.VkPhysicalDeviceImageViewImageFormatInfoEXT)(mem99e4ab46)
	allocs99e4ab46 := new(cgoAllocMap)
	allocs99e4ab46.Add(mem99e4ab46)

	var csType_allocs *cgoAllocMap
	ref99e4ab46.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs99e4ab46.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref99e4ab46.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs99e4ab46.Borrow(cpNext_allocs)

	var cimageViewType_allocs *cgoAllocMap
	ref99e4ab46.imageViewType, cimageViewType_allocs = (C.VkImageViewType)(x.ImageViewType), cgoAllocsUnknown
	allocs99e4ab46.Borrow(cimageViewType_allocs)

	x.ref99e4ab46 = ref99e4ab46
	x.allocs99e4ab46 = allocs99e4ab46
	return ref99e4ab46, allocs99e4ab46

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceImageViewImageFormatInfo) PassValue() (C.VkPhysicalDeviceImageViewImageFormatInfoEXT, *cgoAllocMap) {
	if x.ref99e4ab46 != nil {
		return *x.ref99e4ab46, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceImageViewImageFormatInfo) Deref() {
	if x.ref99e4ab46 == nil {
		return
	}
	x.SType = (StructureType)(x.ref99e4ab46.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref99e4ab46.pNext))
	x.ImageViewType = (ImageViewType)(x.ref99e4ab46.imageViewType)
}

// allocFilterCubicImageViewImageFormatPropertiesMemory allocates memory for type C.VkFilterCubicImageViewImageFormatPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilterCubicImageViewImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilterCubicImageViewImageFormatPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilterCubicImageViewImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkFilterCubicImageViewImageFormatPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilterCubicImageViewImageFormatProperties) Ref() *C.VkFilterCubicImageViewImageFormatPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refcf60927c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilterCubicImageViewImageFormatProperties) Free() {
	if x != nil && x.allocscf60927c != nil {
		x.allocscf60927c.(*cgoAllocMap).Free()
		x.refcf60927c = nil
	}
}

// NewFilterCubicImageViewImageFormatPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilterCubicImageViewImageFormatPropertiesRef(ref unsafe.Pointer) *FilterCubicImageViewImageFormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(FilterCubicImageViewImageFormatProperties)
	obj.refcf60927c = (*C.VkFilterCubicImageViewImageFormatPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilterCubicImageViewImageFormatProperties) PassRef() (*C.VkFilterCubicImageViewImageFormatPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcf60927c != nil {
		return x.refcf60927c, nil
	}
	memcf60927c := allocFilterCubicImageViewImageFormatPropertiesMemory(1)
	refcf60927c := (*C.VkFilterCubicImageViewImageFormatPropertiesEXT)(memcf60927c)
	allocscf60927c := new(cgoAllocMap)
	allocscf60927c.Add(memcf60927c)

	var csType_allocs *cgoAllocMap
	refcf60927c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscf60927c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcf60927c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscf60927c.Borrow(cpNext_allocs)

	var cfilterCubic_allocs *cgoAllocMap
	refcf60927c.filterCubic, cfilterCubic_allocs = (C.VkBool32)(x.FilterCubic), cgoAllocsUnknown
	allocscf60927c.Borrow(cfilterCubic_allocs)

	var cfilterCubicMinmax_allocs *cgoAllocMap
	refcf60927c.filterCubicMinmax, cfilterCubicMinmax_allocs = (C.VkBool32)(x.FilterCubicMinmax), cgoAllocsUnknown
	allocscf60927c.Borrow(cfilterCubicMinmax_allocs)

	x.refcf60927c = refcf60927c
	x.allocscf60927c = allocscf60927c
	return refcf60927c, allocscf60927c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilterCubicImageViewImageFormatProperties) PassValue() (C.VkFilterCubicImageViewImageFormatPropertiesEXT, *cgoAllocMap) {
	if x.refcf60927c != nil {
		return *x.refcf60927c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilterCubicImageViewImageFormatProperties) Deref() {
	if x.refcf60927c == nil {
		return
	}
	x.SType = (StructureType)(x.refcf60927c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcf60927c.pNext))
	x.FilterCubic = (Bool32)(x.refcf60927c.filterCubic)
	x.FilterCubicMinmax = (Bool32)(x.refcf60927c.filterCubicMinmax)
}

// allocDeviceQueueGlobalPriorityCreateInfoMemory allocates memory for type C.VkDeviceQueueGlobalPriorityCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceQueueGlobalPriorityCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceQueueGlobalPriorityCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceQueueGlobalPriorityCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceQueueGlobalPriorityCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceQueueGlobalPriorityCreateInfo) Ref() *C.VkDeviceQueueGlobalPriorityCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref76356646
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceQueueGlobalPriorityCreateInfo) Free() {
	if x != nil && x.allocs76356646 != nil {
		x.allocs76356646.(*cgoAllocMap).Free()
		x.ref76356646 = nil
	}
}

// NewDeviceQueueGlobalPriorityCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceQueueGlobalPriorityCreateInfoRef(ref unsafe.Pointer) *DeviceQueueGlobalPriorityCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceQueueGlobalPriorityCreateInfo)
	obj.ref76356646 = (*C.VkDeviceQueueGlobalPriorityCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceQueueGlobalPriorityCreateInfo) PassRef() (*C.VkDeviceQueueGlobalPriorityCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref76356646 != nil {
		return x.ref76356646, nil
	}
	mem76356646 := allocDeviceQueueGlobalPriorityCreateInfoMemory(1)
	ref76356646 := (*C.VkDeviceQueueGlobalPriorityCreateInfoEXT)(mem76356646)
	allocs76356646 := new(cgoAllocMap)
	allocs76356646.Add(mem76356646)

	var csType_allocs *cgoAllocMap
	ref76356646.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs76356646.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref76356646.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs76356646.Borrow(cpNext_allocs)

	var cglobalPriority_allocs *cgoAllocMap
	ref76356646.globalPriority, cglobalPriority_allocs = (C.VkQueueGlobalPriorityEXT)(x.GlobalPriority), cgoAllocsUnknown
	allocs76356646.Borrow(cglobalPriority_allocs)

	x.ref76356646 = ref76356646
	x.allocs76356646 = allocs76356646
	return ref76356646, allocs76356646

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceQueueGlobalPriorityCreateInfo) PassValue() (C.VkDeviceQueueGlobalPriorityCreateInfoEXT, *cgoAllocMap) {
	if x.ref76356646 != nil {
		return *x.ref76356646, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceQueueGlobalPriorityCreateInfo) Deref() {
	if x.ref76356646 == nil {
		return
	}
	x.SType = (StructureType)(x.ref76356646.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref76356646.pNext))
	x.GlobalPriority = (QueueGlobalPriority)(x.ref76356646.globalPriority)
}

// allocImportMemoryHostPointerInfoMemory allocates memory for type C.VkImportMemoryHostPointerInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImportMemoryHostPointerInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImportMemoryHostPointerInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImportMemoryHostPointerInfoValue = unsafe.Sizeof([1]C.VkImportMemoryHostPointerInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImportMemoryHostPointerInfo) Ref() *C.VkImportMemoryHostPointerInfoEXT {
	if x == nil {
		return nil
	}
	return x.reffe09253e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImportMemoryHostPointerInfo) Free() {
	if x != nil && x.allocsfe09253e != nil {
		x.allocsfe09253e.(*cgoAllocMap).Free()
		x.reffe09253e = nil
	}
}

// NewImportMemoryHostPointerInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImportMemoryHostPointerInfoRef(ref unsafe.Pointer) *ImportMemoryHostPointerInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImportMemoryHostPointerInfo)
	obj.reffe09253e = (*C.VkImportMemoryHostPointerInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImportMemoryHostPointerInfo) PassRef() (*C.VkImportMemoryHostPointerInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe09253e != nil {
		return x.reffe09253e, nil
	}
	memfe09253e := allocImportMemoryHostPointerInfoMemory(1)
	reffe09253e := (*C.VkImportMemoryHostPointerInfoEXT)(memfe09253e)
	allocsfe09253e := new(cgoAllocMap)
	allocsfe09253e.Add(memfe09253e)

	var csType_allocs *cgoAllocMap
	reffe09253e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfe09253e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffe09253e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfe09253e.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	reffe09253e.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocsfe09253e.Borrow(chandleType_allocs)

	var cpHostPointer_allocs *cgoAllocMap
	reffe09253e.pHostPointer, cpHostPointer_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PHostPointer)), cgoAllocsUnknown
	allocsfe09253e.Borrow(cpHostPointer_allocs)

	x.reffe09253e = reffe09253e
	x.allocsfe09253e = allocsfe09253e
	return reffe09253e, allocsfe09253e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImportMemoryHostPointerInfo) PassValue() (C.VkImportMemoryHostPointerInfoEXT, *cgoAllocMap) {
	if x.reffe09253e != nil {
		return *x.reffe09253e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImportMemoryHostPointerInfo) Deref() {
	if x.reffe09253e == nil {
		return
	}
	x.SType = (StructureType)(x.reffe09253e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe09253e.pNext))
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.reffe09253e.handleType)
	x.PHostPointer = (unsafe.Pointer)(unsafe.Pointer(x.reffe09253e.pHostPointer))
}

// allocMemoryHostPointerPropertiesMemory allocates memory for type C.VkMemoryHostPointerPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryHostPointerPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryHostPointerPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryHostPointerPropertiesValue = unsafe.Sizeof([1]C.VkMemoryHostPointerPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryHostPointerProperties) Ref() *C.VkMemoryHostPointerPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refebf46a84
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryHostPointerProperties) Free() {
	if x != nil && x.allocsebf46a84 != nil {
		x.allocsebf46a84.(*cgoAllocMap).Free()
		x.refebf46a84 = nil
	}
}

// NewMemoryHostPointerPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryHostPointerPropertiesRef(ref unsafe.Pointer) *MemoryHostPointerProperties {
	if ref == nil {
		return nil
	}
	obj := new(MemoryHostPointerProperties)
	obj.refebf46a84 = (*C.VkMemoryHostPointerPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryHostPointerProperties) PassRef() (*C.VkMemoryHostPointerPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refebf46a84 != nil {
		return x.refebf46a84, nil
	}
	memebf46a84 := allocMemoryHostPointerPropertiesMemory(1)
	refebf46a84 := (*C.VkMemoryHostPointerPropertiesEXT)(memebf46a84)
	allocsebf46a84 := new(cgoAllocMap)
	allocsebf46a84.Add(memebf46a84)

	var csType_allocs *cgoAllocMap
	refebf46a84.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsebf46a84.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refebf46a84.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsebf46a84.Borrow(cpNext_allocs)

	var cmemoryTypeBits_allocs *cgoAllocMap
	refebf46a84.memoryTypeBits, cmemoryTypeBits_allocs = (C.uint32_t)(x.MemoryTypeBits), cgoAllocsUnknown
	allocsebf46a84.Borrow(cmemoryTypeBits_allocs)

	x.refebf46a84 = refebf46a84
	x.allocsebf46a84 = allocsebf46a84
	return refebf46a84, allocsebf46a84

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryHostPointerProperties) PassValue() (C.VkMemoryHostPointerPropertiesEXT, *cgoAllocMap) {
	if x.refebf46a84 != nil {
		return *x.refebf46a84, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryHostPointerProperties) Deref() {
	if x.refebf46a84 == nil {
		return
	}
	x.SType = (StructureType)(x.refebf46a84.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refebf46a84.pNext))
	x.MemoryTypeBits = (uint32)(x.refebf46a84.memoryTypeBits)
}

// allocPhysicalDeviceExternalMemoryHostPropertiesMemory allocates memory for type C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExternalMemoryHostPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExternalMemoryHostPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceExternalMemoryHostPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalMemoryHostProperties) Ref() *C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref7f697d15
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalMemoryHostProperties) Free() {
	if x != nil && x.allocs7f697d15 != nil {
		x.allocs7f697d15.(*cgoAllocMap).Free()
		x.ref7f697d15 = nil
	}
}

// NewPhysicalDeviceExternalMemoryHostPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalMemoryHostPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceExternalMemoryHostProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalMemoryHostProperties)
	obj.ref7f697d15 = (*C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalMemoryHostProperties) PassRef() (*C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7f697d15 != nil {
		return x.ref7f697d15, nil
	}
	mem7f697d15 := allocPhysicalDeviceExternalMemoryHostPropertiesMemory(1)
	ref7f697d15 := (*C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT)(mem7f697d15)
	allocs7f697d15 := new(cgoAllocMap)
	allocs7f697d15.Add(mem7f697d15)

	var csType_allocs *cgoAllocMap
	ref7f697d15.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7f697d15.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7f697d15.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7f697d15.Borrow(cpNext_allocs)

	var cminImportedHostPointerAlignment_allocs *cgoAllocMap
	ref7f697d15.minImportedHostPointerAlignment, cminImportedHostPointerAlignment_allocs = (C.VkDeviceSize)(x.MinImportedHostPointerAlignment), cgoAllocsUnknown
	allocs7f697d15.Borrow(cminImportedHostPointerAlignment_allocs)

	x.ref7f697d15 = ref7f697d15
	x.allocs7f697d15 = allocs7f697d15
	return ref7f697d15, allocs7f697d15

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalMemoryHostProperties) PassValue() (C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT, *cgoAllocMap) {
	if x.ref7f697d15 != nil {
		return *x.ref7f697d15, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalMemoryHostProperties) Deref() {
	if x.ref7f697d15 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7f697d15.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7f697d15.pNext))
	x.MinImportedHostPointerAlignment = (DeviceSize)(x.ref7f697d15.minImportedHostPointerAlignment)
}

// allocPipelineCompilerControlCreateInfoAMDMemory allocates memory for type C.VkPipelineCompilerControlCreateInfoAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCompilerControlCreateInfoAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCompilerControlCreateInfoAMDValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineCompilerControlCreateInfoAMDValue = unsafe.Sizeof([1]C.VkPipelineCompilerControlCreateInfoAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineCompilerControlCreateInfoAMD) Ref() *C.VkPipelineCompilerControlCreateInfoAMD {
	if x == nil {
		return nil
	}
	return x.ref46a09e46
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineCompilerControlCreateInfoAMD) Free() {
	if x != nil && x.allocs46a09e46 != nil {
		x.allocs46a09e46.(*cgoAllocMap).Free()
		x.ref46a09e46 = nil
	}
}

// NewPipelineCompilerControlCreateInfoAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineCompilerControlCreateInfoAMDRef(ref unsafe.Pointer) *PipelineCompilerControlCreateInfoAMD {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCompilerControlCreateInfoAMD)
	obj.ref46a09e46 = (*C.VkPipelineCompilerControlCreateInfoAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineCompilerControlCreateInfoAMD) PassRef() (*C.VkPipelineCompilerControlCreateInfoAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref46a09e46 != nil {
		return x.ref46a09e46, nil
	}
	mem46a09e46 := allocPipelineCompilerControlCreateInfoAMDMemory(1)
	ref46a09e46 := (*C.VkPipelineCompilerControlCreateInfoAMD)(mem46a09e46)
	allocs46a09e46 := new(cgoAllocMap)
	allocs46a09e46.Add(mem46a09e46)

	var csType_allocs *cgoAllocMap
	ref46a09e46.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs46a09e46.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref46a09e46.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs46a09e46.Borrow(cpNext_allocs)

	var ccompilerControlFlags_allocs *cgoAllocMap
	ref46a09e46.compilerControlFlags, ccompilerControlFlags_allocs = (C.VkPipelineCompilerControlFlagsAMD)(x.CompilerControlFlags), cgoAllocsUnknown
	allocs46a09e46.Borrow(ccompilerControlFlags_allocs)

	x.ref46a09e46 = ref46a09e46
	x.allocs46a09e46 = allocs46a09e46
	return ref46a09e46, allocs46a09e46

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineCompilerControlCreateInfoAMD) PassValue() (C.VkPipelineCompilerControlCreateInfoAMD, *cgoAllocMap) {
	if x.ref46a09e46 != nil {
		return *x.ref46a09e46, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineCompilerControlCreateInfoAMD) Deref() {
	if x.ref46a09e46 == nil {
		return
	}
	x.SType = (StructureType)(x.ref46a09e46.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref46a09e46.pNext))
	x.CompilerControlFlags = (PipelineCompilerControlFlagsAMD)(x.ref46a09e46.compilerControlFlags)
}

// allocCalibratedTimestampInfoMemory allocates memory for type C.VkCalibratedTimestampInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCalibratedTimestampInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCalibratedTimestampInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCalibratedTimestampInfoValue = unsafe.Sizeof([1]C.VkCalibratedTimestampInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CalibratedTimestampInfo) Ref() *C.VkCalibratedTimestampInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref5f061d2a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CalibratedTimestampInfo) Free() {
	if x != nil && x.allocs5f061d2a != nil {
		x.allocs5f061d2a.(*cgoAllocMap).Free()
		x.ref5f061d2a = nil
	}
}

// NewCalibratedTimestampInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCalibratedTimestampInfoRef(ref unsafe.Pointer) *CalibratedTimestampInfo {
	if ref == nil {
		return nil
	}
	obj := new(CalibratedTimestampInfo)
	obj.ref5f061d2a = (*C.VkCalibratedTimestampInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CalibratedTimestampInfo) PassRef() (*C.VkCalibratedTimestampInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5f061d2a != nil {
		return x.ref5f061d2a, nil
	}
	mem5f061d2a := allocCalibratedTimestampInfoMemory(1)
	ref5f061d2a := (*C.VkCalibratedTimestampInfoEXT)(mem5f061d2a)
	allocs5f061d2a := new(cgoAllocMap)
	allocs5f061d2a.Add(mem5f061d2a)

	var csType_allocs *cgoAllocMap
	ref5f061d2a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5f061d2a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5f061d2a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5f061d2a.Borrow(cpNext_allocs)

	var ctimeDomain_allocs *cgoAllocMap
	ref5f061d2a.timeDomain, ctimeDomain_allocs = (C.VkTimeDomainEXT)(x.TimeDomain), cgoAllocsUnknown
	allocs5f061d2a.Borrow(ctimeDomain_allocs)

	x.ref5f061d2a = ref5f061d2a
	x.allocs5f061d2a = allocs5f061d2a
	return ref5f061d2a, allocs5f061d2a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CalibratedTimestampInfo) PassValue() (C.VkCalibratedTimestampInfoEXT, *cgoAllocMap) {
	if x.ref5f061d2a != nil {
		return *x.ref5f061d2a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CalibratedTimestampInfo) Deref() {
	if x.ref5f061d2a == nil {
		return
	}
	x.SType = (StructureType)(x.ref5f061d2a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5f061d2a.pNext))
	x.TimeDomain = (TimeDomain)(x.ref5f061d2a.timeDomain)
}

// allocPhysicalDeviceShaderCorePropertiesAMDMemory allocates memory for type C.VkPhysicalDeviceShaderCorePropertiesAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderCorePropertiesAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderCorePropertiesAMDValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShaderCorePropertiesAMDValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderCorePropertiesAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderCorePropertiesAMD) Ref() *C.VkPhysicalDeviceShaderCorePropertiesAMD {
	if x == nil {
		return nil
	}
	return x.refde4b3b09
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderCorePropertiesAMD) Free() {
	if x != nil && x.allocsde4b3b09 != nil {
		x.allocsde4b3b09.(*cgoAllocMap).Free()
		x.refde4b3b09 = nil
	}
}

// NewPhysicalDeviceShaderCorePropertiesAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderCorePropertiesAMDRef(ref unsafe.Pointer) *PhysicalDeviceShaderCorePropertiesAMD {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderCorePropertiesAMD)
	obj.refde4b3b09 = (*C.VkPhysicalDeviceShaderCorePropertiesAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderCorePropertiesAMD) PassRef() (*C.VkPhysicalDeviceShaderCorePropertiesAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refde4b3b09 != nil {
		return x.refde4b3b09, nil
	}
	memde4b3b09 := allocPhysicalDeviceShaderCorePropertiesAMDMemory(1)
	refde4b3b09 := (*C.VkPhysicalDeviceShaderCorePropertiesAMD)(memde4b3b09)
	allocsde4b3b09 := new(cgoAllocMap)
	allocsde4b3b09.Add(memde4b3b09)

	var csType_allocs *cgoAllocMap
	refde4b3b09.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsde4b3b09.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refde4b3b09.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cpNext_allocs)

	var cshaderEngineCount_allocs *cgoAllocMap
	refde4b3b09.shaderEngineCount, cshaderEngineCount_allocs = (C.uint32_t)(x.ShaderEngineCount), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cshaderEngineCount_allocs)

	var cshaderArraysPerEngineCount_allocs *cgoAllocMap
	refde4b3b09.shaderArraysPerEngineCount, cshaderArraysPerEngineCount_allocs = (C.uint32_t)(x.ShaderArraysPerEngineCount), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cshaderArraysPerEngineCount_allocs)

	var ccomputeUnitsPerShaderArray_allocs *cgoAllocMap
	refde4b3b09.computeUnitsPerShaderArray, ccomputeUnitsPerShaderArray_allocs = (C.uint32_t)(x.ComputeUnitsPerShaderArray), cgoAllocsUnknown
	allocsde4b3b09.Borrow(ccomputeUnitsPerShaderArray_allocs)

	var csimdPerComputeUnit_allocs *cgoAllocMap
	refde4b3b09.simdPerComputeUnit, csimdPerComputeUnit_allocs = (C.uint32_t)(x.SimdPerComputeUnit), cgoAllocsUnknown
	allocsde4b3b09.Borrow(csimdPerComputeUnit_allocs)

	var cwavefrontsPerSimd_allocs *cgoAllocMap
	refde4b3b09.wavefrontsPerSimd, cwavefrontsPerSimd_allocs = (C.uint32_t)(x.WavefrontsPerSimd), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cwavefrontsPerSimd_allocs)

	var cwavefrontSize_allocs *cgoAllocMap
	refde4b3b09.wavefrontSize, cwavefrontSize_allocs = (C.uint32_t)(x.WavefrontSize), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cwavefrontSize_allocs)

	var csgprsPerSimd_allocs *cgoAllocMap
	refde4b3b09.sgprsPerSimd, csgprsPerSimd_allocs = (C.uint32_t)(x.SgprsPerSimd), cgoAllocsUnknown
	allocsde4b3b09.Borrow(csgprsPerSimd_allocs)

	var cminSgprAllocation_allocs *cgoAllocMap
	refde4b3b09.minSgprAllocation, cminSgprAllocation_allocs = (C.uint32_t)(x.MinSgprAllocation), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cminSgprAllocation_allocs)

	var cmaxSgprAllocation_allocs *cgoAllocMap
	refde4b3b09.maxSgprAllocation, cmaxSgprAllocation_allocs = (C.uint32_t)(x.MaxSgprAllocation), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cmaxSgprAllocation_allocs)

	var csgprAllocationGranularity_allocs *cgoAllocMap
	refde4b3b09.sgprAllocationGranularity, csgprAllocationGranularity_allocs = (C.uint32_t)(x.SgprAllocationGranularity), cgoAllocsUnknown
	allocsde4b3b09.Borrow(csgprAllocationGranularity_allocs)

	var cvgprsPerSimd_allocs *cgoAllocMap
	refde4b3b09.vgprsPerSimd, cvgprsPerSimd_allocs = (C.uint32_t)(x.VgprsPerSimd), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cvgprsPerSimd_allocs)

	var cminVgprAllocation_allocs *cgoAllocMap
	refde4b3b09.minVgprAllocation, cminVgprAllocation_allocs = (C.uint32_t)(x.MinVgprAllocation), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cminVgprAllocation_allocs)

	var cmaxVgprAllocation_allocs *cgoAllocMap
	refde4b3b09.maxVgprAllocation, cmaxVgprAllocation_allocs = (C.uint32_t)(x.MaxVgprAllocation), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cmaxVgprAllocation_allocs)

	var cvgprAllocationGranularity_allocs *cgoAllocMap
	refde4b3b09.vgprAllocationGranularity, cvgprAllocationGranularity_allocs = (C.uint32_t)(x.VgprAllocationGranularity), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cvgprAllocationGranularity_allocs)

	x.refde4b3b09 = refde4b3b09
	x.allocsde4b3b09 = allocsde4b3b09
	return refde4b3b09, allocsde4b3b09

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderCorePropertiesAMD) PassValue() (C.VkPhysicalDeviceShaderCorePropertiesAMD, *cgoAllocMap) {
	if x.refde4b3b09 != nil {
		return *x.refde4b3b09, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderCorePropertiesAMD) Deref() {
	if x.refde4b3b09 == nil {
		return
	}
	x.SType = (StructureType)(x.refde4b3b09.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refde4b3b09.pNext))
	x.ShaderEngineCount = (uint32)(x.refde4b3b09.shaderEngineCount)
	x.ShaderArraysPerEngineCount = (uint32)(x.refde4b3b09.shaderArraysPerEngineCount)
	x.ComputeUnitsPerShaderArray = (uint32)(x.refde4b3b09.computeUnitsPerShaderArray)
	x.SimdPerComputeUnit = (uint32)(x.refde4b3b09.simdPerComputeUnit)
	x.WavefrontsPerSimd = (uint32)(x.refde4b3b09.wavefrontsPerSimd)
	x.WavefrontSize = (uint32)(x.refde4b3b09.wavefrontSize)
	x.SgprsPerSimd = (uint32)(x.refde4b3b09.sgprsPerSimd)
	x.MinSgprAllocation = (uint32)(x.refde4b3b09.minSgprAllocation)
	x.MaxSgprAllocation = (uint32)(x.refde4b3b09.maxSgprAllocation)
	x.SgprAllocationGranularity = (uint32)(x.refde4b3b09.sgprAllocationGranularity)
	x.VgprsPerSimd = (uint32)(x.refde4b3b09.vgprsPerSimd)
	x.MinVgprAllocation = (uint32)(x.refde4b3b09.minVgprAllocation)
	x.MaxVgprAllocation = (uint32)(x.refde4b3b09.maxVgprAllocation)
	x.VgprAllocationGranularity = (uint32)(x.refde4b3b09.vgprAllocationGranularity)
}

// allocDeviceMemoryOverallocationCreateInfoAMDMemory allocates memory for type C.VkDeviceMemoryOverallocationCreateInfoAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceMemoryOverallocationCreateInfoAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceMemoryOverallocationCreateInfoAMDValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceMemoryOverallocationCreateInfoAMDValue = unsafe.Sizeof([1]C.VkDeviceMemoryOverallocationCreateInfoAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceMemoryOverallocationCreateInfoAMD) Ref() *C.VkDeviceMemoryOverallocationCreateInfoAMD {
	if x == nil {
		return nil
	}
	return x.ref5ccee475
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceMemoryOverallocationCreateInfoAMD) Free() {
	if x != nil && x.allocs5ccee475 != nil {
		x.allocs5ccee475.(*cgoAllocMap).Free()
		x.ref5ccee475 = nil
	}
}

// NewDeviceMemoryOverallocationCreateInfoAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceMemoryOverallocationCreateInfoAMDRef(ref unsafe.Pointer) *DeviceMemoryOverallocationCreateInfoAMD {
	if ref == nil {
		return nil
	}
	obj := new(DeviceMemoryOverallocationCreateInfoAMD)
	obj.ref5ccee475 = (*C.VkDeviceMemoryOverallocationCreateInfoAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceMemoryOverallocationCreateInfoAMD) PassRef() (*C.VkDeviceMemoryOverallocationCreateInfoAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ccee475 != nil {
		return x.ref5ccee475, nil
	}
	mem5ccee475 := allocDeviceMemoryOverallocationCreateInfoAMDMemory(1)
	ref5ccee475 := (*C.VkDeviceMemoryOverallocationCreateInfoAMD)(mem5ccee475)
	allocs5ccee475 := new(cgoAllocMap)
	allocs5ccee475.Add(mem5ccee475)

	var csType_allocs *cgoAllocMap
	ref5ccee475.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5ccee475.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5ccee475.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5ccee475.Borrow(cpNext_allocs)

	var coverallocationBehavior_allocs *cgoAllocMap
	ref5ccee475.overallocationBehavior, coverallocationBehavior_allocs = (C.VkMemoryOverallocationBehaviorAMD)(x.OverallocationBehavior), cgoAllocsUnknown
	allocs5ccee475.Borrow(coverallocationBehavior_allocs)

	x.ref5ccee475 = ref5ccee475
	x.allocs5ccee475 = allocs5ccee475
	return ref5ccee475, allocs5ccee475

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceMemoryOverallocationCreateInfoAMD) PassValue() (C.VkDeviceMemoryOverallocationCreateInfoAMD, *cgoAllocMap) {
	if x.ref5ccee475 != nil {
		return *x.ref5ccee475, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceMemoryOverallocationCreateInfoAMD) Deref() {
	if x.ref5ccee475 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5ccee475.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5ccee475.pNext))
	x.OverallocationBehavior = (MemoryOverallocationBehaviorAMD)(x.ref5ccee475.overallocationBehavior)
}

// allocPhysicalDeviceVertexAttributeDivisorPropertiesMemory allocates memory for type C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVertexAttributeDivisorPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVertexAttributeDivisorPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceVertexAttributeDivisorPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVertexAttributeDivisorProperties) Ref() *C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refbd6b5075
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVertexAttributeDivisorProperties) Free() {
	if x != nil && x.allocsbd6b5075 != nil {
		x.allocsbd6b5075.(*cgoAllocMap).Free()
		x.refbd6b5075 = nil
	}
}

// NewPhysicalDeviceVertexAttributeDivisorPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVertexAttributeDivisorPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceVertexAttributeDivisorProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVertexAttributeDivisorProperties)
	obj.refbd6b5075 = (*C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVertexAttributeDivisorProperties) PassRef() (*C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbd6b5075 != nil {
		return x.refbd6b5075, nil
	}
	membd6b5075 := allocPhysicalDeviceVertexAttributeDivisorPropertiesMemory(1)
	refbd6b5075 := (*C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT)(membd6b5075)
	allocsbd6b5075 := new(cgoAllocMap)
	allocsbd6b5075.Add(membd6b5075)

	var csType_allocs *cgoAllocMap
	refbd6b5075.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbd6b5075.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbd6b5075.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbd6b5075.Borrow(cpNext_allocs)

	var cmaxVertexAttribDivisor_allocs *cgoAllocMap
	refbd6b5075.maxVertexAttribDivisor, cmaxVertexAttribDivisor_allocs = (C.uint32_t)(x.MaxVertexAttribDivisor), cgoAllocsUnknown
	allocsbd6b5075.Borrow(cmaxVertexAttribDivisor_allocs)

	x.refbd6b5075 = refbd6b5075
	x.allocsbd6b5075 = allocsbd6b5075
	return refbd6b5075, allocsbd6b5075

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVertexAttributeDivisorProperties) PassValue() (C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, *cgoAllocMap) {
	if x.refbd6b5075 != nil {
		return *x.refbd6b5075, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVertexAttributeDivisorProperties) Deref() {
	if x.refbd6b5075 == nil {
		return
	}
	x.SType = (StructureType)(x.refbd6b5075.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbd6b5075.pNext))
	x.MaxVertexAttribDivisor = (uint32)(x.refbd6b5075.maxVertexAttribDivisor)
}

// allocVertexInputBindingDivisorDescriptionMemory allocates memory for type C.VkVertexInputBindingDivisorDescriptionEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputBindingDivisorDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputBindingDivisorDescriptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVertexInputBindingDivisorDescriptionValue = unsafe.Sizeof([1]C.VkVertexInputBindingDivisorDescriptionEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VertexInputBindingDivisorDescription) Ref() *C.VkVertexInputBindingDivisorDescriptionEXT {
	if x == nil {
		return nil
	}
	return x.refd64d4396
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VertexInputBindingDivisorDescription) Free() {
	if x != nil && x.allocsd64d4396 != nil {
		x.allocsd64d4396.(*cgoAllocMap).Free()
		x.refd64d4396 = nil
	}
}

// NewVertexInputBindingDivisorDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVertexInputBindingDivisorDescriptionRef(ref unsafe.Pointer) *VertexInputBindingDivisorDescription {
	if ref == nil {
		return nil
	}
	obj := new(VertexInputBindingDivisorDescription)
	obj.refd64d4396 = (*C.VkVertexInputBindingDivisorDescriptionEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VertexInputBindingDivisorDescription) PassRef() (*C.VkVertexInputBindingDivisorDescriptionEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd64d4396 != nil {
		return x.refd64d4396, nil
	}
	memd64d4396 := allocVertexInputBindingDivisorDescriptionMemory(1)
	refd64d4396 := (*C.VkVertexInputBindingDivisorDescriptionEXT)(memd64d4396)
	allocsd64d4396 := new(cgoAllocMap)
	allocsd64d4396.Add(memd64d4396)

	var cbinding_allocs *cgoAllocMap
	refd64d4396.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocsd64d4396.Borrow(cbinding_allocs)

	var cdivisor_allocs *cgoAllocMap
	refd64d4396.divisor, cdivisor_allocs = (C.uint32_t)(x.Divisor), cgoAllocsUnknown
	allocsd64d4396.Borrow(cdivisor_allocs)

	x.refd64d4396 = refd64d4396
	x.allocsd64d4396 = allocsd64d4396
	return refd64d4396, allocsd64d4396

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VertexInputBindingDivisorDescription) PassValue() (C.VkVertexInputBindingDivisorDescriptionEXT, *cgoAllocMap) {
	if x.refd64d4396 != nil {
		return *x.refd64d4396, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VertexInputBindingDivisorDescription) Deref() {
	if x.refd64d4396 == nil {
		return
	}
	x.Binding = (uint32)(x.refd64d4396.binding)
	x.Divisor = (uint32)(x.refd64d4396.divisor)
}

// allocPipelineVertexInputDivisorStateCreateInfoMemory allocates memory for type C.VkPipelineVertexInputDivisorStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineVertexInputDivisorStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineVertexInputDivisorStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineVertexInputDivisorStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineVertexInputDivisorStateCreateInfoEXT{})

// unpackSVertexInputBindingDivisorDescription transforms a sliced Go data structure into plain C format.
func unpackSVertexInputBindingDivisorDescription(x []VertexInputBindingDivisorDescription) (unpacked *C.VkVertexInputBindingDivisorDescriptionEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocVertexInputBindingDivisorDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkVertexInputBindingDivisorDescriptionEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkVertexInputBindingDivisorDescriptionEXT)(h.Data)
	return
}

// packSVertexInputBindingDivisorDescription reads sliced Go data structure out from plain C format.
func packSVertexInputBindingDivisorDescription(v []VertexInputBindingDivisorDescription, ptr0 *C.VkVertexInputBindingDivisorDescriptionEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVertexInputBindingDivisorDescriptionValue]C.VkVertexInputBindingDivisorDescriptionEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVertexInputBindingDivisorDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineVertexInputDivisorStateCreateInfo) Ref() *C.VkPipelineVertexInputDivisorStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref86096bfd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineVertexInputDivisorStateCreateInfo) Free() {
	if x != nil && x.allocs86096bfd != nil {
		x.allocs86096bfd.(*cgoAllocMap).Free()
		x.ref86096bfd = nil
	}
}

// NewPipelineVertexInputDivisorStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineVertexInputDivisorStateCreateInfoRef(ref unsafe.Pointer) *PipelineVertexInputDivisorStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineVertexInputDivisorStateCreateInfo)
	obj.ref86096bfd = (*C.VkPipelineVertexInputDivisorStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineVertexInputDivisorStateCreateInfo) PassRef() (*C.VkPipelineVertexInputDivisorStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref86096bfd != nil {
		return x.ref86096bfd, nil
	}
	mem86096bfd := allocPipelineVertexInputDivisorStateCreateInfoMemory(1)
	ref86096bfd := (*C.VkPipelineVertexInputDivisorStateCreateInfoEXT)(mem86096bfd)
	allocs86096bfd := new(cgoAllocMap)
	allocs86096bfd.Add(mem86096bfd)

	var csType_allocs *cgoAllocMap
	ref86096bfd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs86096bfd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref86096bfd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs86096bfd.Borrow(cpNext_allocs)

	var cvertexBindingDivisorCount_allocs *cgoAllocMap
	ref86096bfd.vertexBindingDivisorCount, cvertexBindingDivisorCount_allocs = (C.uint32_t)(x.VertexBindingDivisorCount), cgoAllocsUnknown
	allocs86096bfd.Borrow(cvertexBindingDivisorCount_allocs)

	var cpVertexBindingDivisors_allocs *cgoAllocMap
	ref86096bfd.pVertexBindingDivisors, cpVertexBindingDivisors_allocs = unpackSVertexInputBindingDivisorDescription(x.PVertexBindingDivisors)
	allocs86096bfd.Borrow(cpVertexBindingDivisors_allocs)

	x.ref86096bfd = ref86096bfd
	x.allocs86096bfd = allocs86096bfd
	return ref86096bfd, allocs86096bfd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineVertexInputDivisorStateCreateInfo) PassValue() (C.VkPipelineVertexInputDivisorStateCreateInfoEXT, *cgoAllocMap) {
	if x.ref86096bfd != nil {
		return *x.ref86096bfd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineVertexInputDivisorStateCreateInfo) Deref() {
	if x.ref86096bfd == nil {
		return
	}
	x.SType = (StructureType)(x.ref86096bfd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref86096bfd.pNext))
	x.VertexBindingDivisorCount = (uint32)(x.ref86096bfd.vertexBindingDivisorCount)
	packSVertexInputBindingDivisorDescription(x.PVertexBindingDivisors, x.ref86096bfd.pVertexBindingDivisors)
}

// allocPhysicalDeviceVertexAttributeDivisorFeaturesMemory allocates memory for type C.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVertexAttributeDivisorFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVertexAttributeDivisorFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceVertexAttributeDivisorFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVertexAttributeDivisorFeatures) Ref() *C.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refffe7619a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVertexAttributeDivisorFeatures) Free() {
	if x != nil && x.allocsffe7619a != nil {
		x.allocsffe7619a.(*cgoAllocMap).Free()
		x.refffe7619a = nil
	}
}

// NewPhysicalDeviceVertexAttributeDivisorFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVertexAttributeDivisorFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceVertexAttributeDivisorFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVertexAttributeDivisorFeatures)
	obj.refffe7619a = (*C.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVertexAttributeDivisorFeatures) PassRef() (*C.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refffe7619a != nil {
		return x.refffe7619a, nil
	}
	memffe7619a := allocPhysicalDeviceVertexAttributeDivisorFeaturesMemory(1)
	refffe7619a := (*C.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT)(memffe7619a)
	allocsffe7619a := new(cgoAllocMap)
	allocsffe7619a.Add(memffe7619a)

	var csType_allocs *cgoAllocMap
	refffe7619a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsffe7619a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refffe7619a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsffe7619a.Borrow(cpNext_allocs)

	var cvertexAttributeInstanceRateDivisor_allocs *cgoAllocMap
	refffe7619a.vertexAttributeInstanceRateDivisor, cvertexAttributeInstanceRateDivisor_allocs = (C.VkBool32)(x.VertexAttributeInstanceRateDivisor), cgoAllocsUnknown
	allocsffe7619a.Borrow(cvertexAttributeInstanceRateDivisor_allocs)

	var cvertexAttributeInstanceRateZeroDivisor_allocs *cgoAllocMap
	refffe7619a.vertexAttributeInstanceRateZeroDivisor, cvertexAttributeInstanceRateZeroDivisor_allocs = (C.VkBool32)(x.VertexAttributeInstanceRateZeroDivisor), cgoAllocsUnknown
	allocsffe7619a.Borrow(cvertexAttributeInstanceRateZeroDivisor_allocs)

	x.refffe7619a = refffe7619a
	x.allocsffe7619a = allocsffe7619a
	return refffe7619a, allocsffe7619a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVertexAttributeDivisorFeatures) PassValue() (C.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, *cgoAllocMap) {
	if x.refffe7619a != nil {
		return *x.refffe7619a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVertexAttributeDivisorFeatures) Deref() {
	if x.refffe7619a == nil {
		return
	}
	x.SType = (StructureType)(x.refffe7619a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refffe7619a.pNext))
	x.VertexAttributeInstanceRateDivisor = (Bool32)(x.refffe7619a.vertexAttributeInstanceRateDivisor)
	x.VertexAttributeInstanceRateZeroDivisor = (Bool32)(x.refffe7619a.vertexAttributeInstanceRateZeroDivisor)
}

// allocPipelineCreationFeedbackMemory allocates memory for type C.VkPipelineCreationFeedbackEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCreationFeedbackMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCreationFeedbackValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineCreationFeedbackValue = unsafe.Sizeof([1]C.VkPipelineCreationFeedbackEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineCreationFeedback) Ref() *C.VkPipelineCreationFeedbackEXT {
	if x == nil {
		return nil
	}
	return x.refbd987604
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineCreationFeedback) Free() {
	if x != nil && x.allocsbd987604 != nil {
		x.allocsbd987604.(*cgoAllocMap).Free()
		x.refbd987604 = nil
	}
}

// NewPipelineCreationFeedbackRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineCreationFeedbackRef(ref unsafe.Pointer) *PipelineCreationFeedback {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCreationFeedback)
	obj.refbd987604 = (*C.VkPipelineCreationFeedbackEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineCreationFeedback) PassRef() (*C.VkPipelineCreationFeedbackEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbd987604 != nil {
		return x.refbd987604, nil
	}
	membd987604 := allocPipelineCreationFeedbackMemory(1)
	refbd987604 := (*C.VkPipelineCreationFeedbackEXT)(membd987604)
	allocsbd987604 := new(cgoAllocMap)
	allocsbd987604.Add(membd987604)

	var cflags_allocs *cgoAllocMap
	refbd987604.flags, cflags_allocs = (C.VkPipelineCreationFeedbackFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocsbd987604.Borrow(cflags_allocs)

	var cduration_allocs *cgoAllocMap
	refbd987604.duration, cduration_allocs = (C.uint64_t)(x.Duration), cgoAllocsUnknown
	allocsbd987604.Borrow(cduration_allocs)

	x.refbd987604 = refbd987604
	x.allocsbd987604 = allocsbd987604
	return refbd987604, allocsbd987604

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineCreationFeedback) PassValue() (C.VkPipelineCreationFeedbackEXT, *cgoAllocMap) {
	if x.refbd987604 != nil {
		return *x.refbd987604, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineCreationFeedback) Deref() {
	if x.refbd987604 == nil {
		return
	}
	x.Flags = (PipelineCreationFeedbackFlags)(x.refbd987604.flags)
	x.Duration = (uint32)(x.refbd987604.duration)
}

// allocPipelineCreationFeedbackCreateInfoMemory allocates memory for type C.VkPipelineCreationFeedbackCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCreationFeedbackCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCreationFeedbackCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineCreationFeedbackCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineCreationFeedbackCreateInfoEXT{})

// unpackSPipelineCreationFeedback transforms a sliced Go data structure into plain C format.
func unpackSPipelineCreationFeedback(x []PipelineCreationFeedback) (unpacked *C.VkPipelineCreationFeedbackEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineCreationFeedbackMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineCreationFeedbackEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineCreationFeedbackEXT)(h.Data)
	return
}

// packSPipelineCreationFeedback reads sliced Go data structure out from plain C format.
func packSPipelineCreationFeedback(v []PipelineCreationFeedback, ptr0 *C.VkPipelineCreationFeedbackEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineCreationFeedbackValue]C.VkPipelineCreationFeedbackEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineCreationFeedbackRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineCreationFeedbackCreateInfo) Ref() *C.VkPipelineCreationFeedbackCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref9a16ee05
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineCreationFeedbackCreateInfo) Free() {
	if x != nil && x.allocs9a16ee05 != nil {
		x.allocs9a16ee05.(*cgoAllocMap).Free()
		x.ref9a16ee05 = nil
	}
}

// NewPipelineCreationFeedbackCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineCreationFeedbackCreateInfoRef(ref unsafe.Pointer) *PipelineCreationFeedbackCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCreationFeedbackCreateInfo)
	obj.ref9a16ee05 = (*C.VkPipelineCreationFeedbackCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineCreationFeedbackCreateInfo) PassRef() (*C.VkPipelineCreationFeedbackCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9a16ee05 != nil {
		return x.ref9a16ee05, nil
	}
	mem9a16ee05 := allocPipelineCreationFeedbackCreateInfoMemory(1)
	ref9a16ee05 := (*C.VkPipelineCreationFeedbackCreateInfoEXT)(mem9a16ee05)
	allocs9a16ee05 := new(cgoAllocMap)
	allocs9a16ee05.Add(mem9a16ee05)

	var csType_allocs *cgoAllocMap
	ref9a16ee05.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9a16ee05.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9a16ee05.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9a16ee05.Borrow(cpNext_allocs)

	var cpPipelineCreationFeedback_allocs *cgoAllocMap
	ref9a16ee05.pPipelineCreationFeedback, cpPipelineCreationFeedback_allocs = unpackSPipelineCreationFeedback(x.PPipelineCreationFeedback)
	allocs9a16ee05.Borrow(cpPipelineCreationFeedback_allocs)

	var cpipelineStageCreationFeedbackCount_allocs *cgoAllocMap
	ref9a16ee05.pipelineStageCreationFeedbackCount, cpipelineStageCreationFeedbackCount_allocs = (C.uint32_t)(x.PipelineStageCreationFeedbackCount), cgoAllocsUnknown
	allocs9a16ee05.Borrow(cpipelineStageCreationFeedbackCount_allocs)

	var cpPipelineStageCreationFeedbacks_allocs *cgoAllocMap
	ref9a16ee05.pPipelineStageCreationFeedbacks, cpPipelineStageCreationFeedbacks_allocs = unpackSPipelineCreationFeedback(x.PPipelineStageCreationFeedbacks)
	allocs9a16ee05.Borrow(cpPipelineStageCreationFeedbacks_allocs)

	x.ref9a16ee05 = ref9a16ee05
	x.allocs9a16ee05 = allocs9a16ee05
	return ref9a16ee05, allocs9a16ee05

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineCreationFeedbackCreateInfo) PassValue() (C.VkPipelineCreationFeedbackCreateInfoEXT, *cgoAllocMap) {
	if x.ref9a16ee05 != nil {
		return *x.ref9a16ee05, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineCreationFeedbackCreateInfo) Deref() {
	if x.ref9a16ee05 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9a16ee05.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9a16ee05.pNext))
	packSPipelineCreationFeedback(x.PPipelineCreationFeedback, x.ref9a16ee05.pPipelineCreationFeedback)
	x.PipelineStageCreationFeedbackCount = (uint32)(x.ref9a16ee05.pipelineStageCreationFeedbackCount)
	packSPipelineCreationFeedback(x.PPipelineStageCreationFeedbacks, x.ref9a16ee05.pPipelineStageCreationFeedbacks)
}

// allocPhysicalDeviceComputeShaderDerivativesFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceComputeShaderDerivativesFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceComputeShaderDerivativesFeaturesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceComputeShaderDerivativesFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceComputeShaderDerivativesFeaturesNV) Ref() *C.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV {
	if x == nil {
		return nil
	}
	return x.reff31d599c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceComputeShaderDerivativesFeaturesNV) Free() {
	if x != nil && x.allocsf31d599c != nil {
		x.allocsf31d599c.(*cgoAllocMap).Free()
		x.reff31d599c = nil
	}
}

// NewPhysicalDeviceComputeShaderDerivativesFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceComputeShaderDerivativesFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceComputeShaderDerivativesFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceComputeShaderDerivativesFeaturesNV)
	obj.reff31d599c = (*C.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceComputeShaderDerivativesFeaturesNV) PassRef() (*C.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff31d599c != nil {
		return x.reff31d599c, nil
	}
	memf31d599c := allocPhysicalDeviceComputeShaderDerivativesFeaturesNVMemory(1)
	reff31d599c := (*C.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV)(memf31d599c)
	allocsf31d599c := new(cgoAllocMap)
	allocsf31d599c.Add(memf31d599c)

	var csType_allocs *cgoAllocMap
	reff31d599c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf31d599c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff31d599c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf31d599c.Borrow(cpNext_allocs)

	var ccomputeDerivativeGroupQuads_allocs *cgoAllocMap
	reff31d599c.computeDerivativeGroupQuads, ccomputeDerivativeGroupQuads_allocs = (C.VkBool32)(x.ComputeDerivativeGroupQuads), cgoAllocsUnknown
	allocsf31d599c.Borrow(ccomputeDerivativeGroupQuads_allocs)

	var ccomputeDerivativeGroupLinear_allocs *cgoAllocMap
	reff31d599c.computeDerivativeGroupLinear, ccomputeDerivativeGroupLinear_allocs = (C.VkBool32)(x.ComputeDerivativeGroupLinear), cgoAllocsUnknown
	allocsf31d599c.Borrow(ccomputeDerivativeGroupLinear_allocs)

	x.reff31d599c = reff31d599c
	x.allocsf31d599c = allocsf31d599c
	return reff31d599c, allocsf31d599c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceComputeShaderDerivativesFeaturesNV) PassValue() (C.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, *cgoAllocMap) {
	if x.reff31d599c != nil {
		return *x.reff31d599c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceComputeShaderDerivativesFeaturesNV) Deref() {
	if x.reff31d599c == nil {
		return
	}
	x.SType = (StructureType)(x.reff31d599c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff31d599c.pNext))
	x.ComputeDerivativeGroupQuads = (Bool32)(x.reff31d599c.computeDerivativeGroupQuads)
	x.ComputeDerivativeGroupLinear = (Bool32)(x.reff31d599c.computeDerivativeGroupLinear)
}

// allocPhysicalDeviceMeshShaderFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceMeshShaderFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMeshShaderFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMeshShaderFeaturesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceMeshShaderFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMeshShaderFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMeshShaderFeaturesNV) Ref() *C.VkPhysicalDeviceMeshShaderFeaturesNV {
	if x == nil {
		return nil
	}
	return x.ref802b98a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMeshShaderFeaturesNV) Free() {
	if x != nil && x.allocs802b98a != nil {
		x.allocs802b98a.(*cgoAllocMap).Free()
		x.ref802b98a = nil
	}
}

// NewPhysicalDeviceMeshShaderFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMeshShaderFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceMeshShaderFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMeshShaderFeaturesNV)
	obj.ref802b98a = (*C.VkPhysicalDeviceMeshShaderFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMeshShaderFeaturesNV) PassRef() (*C.VkPhysicalDeviceMeshShaderFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref802b98a != nil {
		return x.ref802b98a, nil
	}
	mem802b98a := allocPhysicalDeviceMeshShaderFeaturesNVMemory(1)
	ref802b98a := (*C.VkPhysicalDeviceMeshShaderFeaturesNV)(mem802b98a)
	allocs802b98a := new(cgoAllocMap)
	allocs802b98a.Add(mem802b98a)

	var csType_allocs *cgoAllocMap
	ref802b98a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs802b98a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref802b98a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs802b98a.Borrow(cpNext_allocs)

	var ctaskShader_allocs *cgoAllocMap
	ref802b98a.taskShader, ctaskShader_allocs = (C.VkBool32)(x.TaskShader), cgoAllocsUnknown
	allocs802b98a.Borrow(ctaskShader_allocs)

	var cmeshShader_allocs *cgoAllocMap
	ref802b98a.meshShader, cmeshShader_allocs = (C.VkBool32)(x.MeshShader), cgoAllocsUnknown
	allocs802b98a.Borrow(cmeshShader_allocs)

	x.ref802b98a = ref802b98a
	x.allocs802b98a = allocs802b98a
	return ref802b98a, allocs802b98a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMeshShaderFeaturesNV) PassValue() (C.VkPhysicalDeviceMeshShaderFeaturesNV, *cgoAllocMap) {
	if x.ref802b98a != nil {
		return *x.ref802b98a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMeshShaderFeaturesNV) Deref() {
	if x.ref802b98a == nil {
		return
	}
	x.SType = (StructureType)(x.ref802b98a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref802b98a.pNext))
	x.TaskShader = (Bool32)(x.ref802b98a.taskShader)
	x.MeshShader = (Bool32)(x.ref802b98a.meshShader)
}

// allocPhysicalDeviceMeshShaderPropertiesNVMemory allocates memory for type C.VkPhysicalDeviceMeshShaderPropertiesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMeshShaderPropertiesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMeshShaderPropertiesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceMeshShaderPropertiesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMeshShaderPropertiesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMeshShaderPropertiesNV) Ref() *C.VkPhysicalDeviceMeshShaderPropertiesNV {
	if x == nil {
		return nil
	}
	return x.ref2ee3ccb7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMeshShaderPropertiesNV) Free() {
	if x != nil && x.allocs2ee3ccb7 != nil {
		x.allocs2ee3ccb7.(*cgoAllocMap).Free()
		x.ref2ee3ccb7 = nil
	}
}

// NewPhysicalDeviceMeshShaderPropertiesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMeshShaderPropertiesNVRef(ref unsafe.Pointer) *PhysicalDeviceMeshShaderPropertiesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMeshShaderPropertiesNV)
	obj.ref2ee3ccb7 = (*C.VkPhysicalDeviceMeshShaderPropertiesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMeshShaderPropertiesNV) PassRef() (*C.VkPhysicalDeviceMeshShaderPropertiesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2ee3ccb7 != nil {
		return x.ref2ee3ccb7, nil
	}
	mem2ee3ccb7 := allocPhysicalDeviceMeshShaderPropertiesNVMemory(1)
	ref2ee3ccb7 := (*C.VkPhysicalDeviceMeshShaderPropertiesNV)(mem2ee3ccb7)
	allocs2ee3ccb7 := new(cgoAllocMap)
	allocs2ee3ccb7.Add(mem2ee3ccb7)

	var csType_allocs *cgoAllocMap
	ref2ee3ccb7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2ee3ccb7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cpNext_allocs)

	var cmaxDrawMeshTasksCount_allocs *cgoAllocMap
	ref2ee3ccb7.maxDrawMeshTasksCount, cmaxDrawMeshTasksCount_allocs = (C.uint32_t)(x.MaxDrawMeshTasksCount), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxDrawMeshTasksCount_allocs)

	var cmaxTaskWorkGroupInvocations_allocs *cgoAllocMap
	ref2ee3ccb7.maxTaskWorkGroupInvocations, cmaxTaskWorkGroupInvocations_allocs = (C.uint32_t)(x.MaxTaskWorkGroupInvocations), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxTaskWorkGroupInvocations_allocs)

	var cmaxTaskWorkGroupSize_allocs *cgoAllocMap
	ref2ee3ccb7.maxTaskWorkGroupSize, cmaxTaskWorkGroupSize_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.MaxTaskWorkGroupSize)), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxTaskWorkGroupSize_allocs)

	var cmaxTaskTotalMemorySize_allocs *cgoAllocMap
	ref2ee3ccb7.maxTaskTotalMemorySize, cmaxTaskTotalMemorySize_allocs = (C.uint32_t)(x.MaxTaskTotalMemorySize), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxTaskTotalMemorySize_allocs)

	var cmaxTaskOutputCount_allocs *cgoAllocMap
	ref2ee3ccb7.maxTaskOutputCount, cmaxTaskOutputCount_allocs = (C.uint32_t)(x.MaxTaskOutputCount), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxTaskOutputCount_allocs)

	var cmaxMeshWorkGroupInvocations_allocs *cgoAllocMap
	ref2ee3ccb7.maxMeshWorkGroupInvocations, cmaxMeshWorkGroupInvocations_allocs = (C.uint32_t)(x.MaxMeshWorkGroupInvocations), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxMeshWorkGroupInvocations_allocs)

	var cmaxMeshWorkGroupSize_allocs *cgoAllocMap
	ref2ee3ccb7.maxMeshWorkGroupSize, cmaxMeshWorkGroupSize_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.MaxMeshWorkGroupSize)), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxMeshWorkGroupSize_allocs)

	var cmaxMeshTotalMemorySize_allocs *cgoAllocMap
	ref2ee3ccb7.maxMeshTotalMemorySize, cmaxMeshTotalMemorySize_allocs = (C.uint32_t)(x.MaxMeshTotalMemorySize), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxMeshTotalMemorySize_allocs)

	var cmaxMeshOutputVertices_allocs *cgoAllocMap
	ref2ee3ccb7.maxMeshOutputVertices, cmaxMeshOutputVertices_allocs = (C.uint32_t)(x.MaxMeshOutputVertices), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxMeshOutputVertices_allocs)

	var cmaxMeshOutputPrimitives_allocs *cgoAllocMap
	ref2ee3ccb7.maxMeshOutputPrimitives, cmaxMeshOutputPrimitives_allocs = (C.uint32_t)(x.MaxMeshOutputPrimitives), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxMeshOutputPrimitives_allocs)

	var cmaxMeshMultiviewViewCount_allocs *cgoAllocMap
	ref2ee3ccb7.maxMeshMultiviewViewCount, cmaxMeshMultiviewViewCount_allocs = (C.uint32_t)(x.MaxMeshMultiviewViewCount), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxMeshMultiviewViewCount_allocs)

	var cmeshOutputPerVertexGranularity_allocs *cgoAllocMap
	ref2ee3ccb7.meshOutputPerVertexGranularity, cmeshOutputPerVertexGranularity_allocs = (C.uint32_t)(x.MeshOutputPerVertexGranularity), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmeshOutputPerVertexGranularity_allocs)

	var cmeshOutputPerPrimitiveGranularity_allocs *cgoAllocMap
	ref2ee3ccb7.meshOutputPerPrimitiveGranularity, cmeshOutputPerPrimitiveGranularity_allocs = (C.uint32_t)(x.MeshOutputPerPrimitiveGranularity), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmeshOutputPerPrimitiveGranularity_allocs)

	x.ref2ee3ccb7 = ref2ee3ccb7
	x.allocs2ee3ccb7 = allocs2ee3ccb7
	return ref2ee3ccb7, allocs2ee3ccb7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMeshShaderPropertiesNV) PassValue() (C.VkPhysicalDeviceMeshShaderPropertiesNV, *cgoAllocMap) {
	if x.ref2ee3ccb7 != nil {
		return *x.ref2ee3ccb7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMeshShaderPropertiesNV) Deref() {
	if x.ref2ee3ccb7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2ee3ccb7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2ee3ccb7.pNext))
	x.MaxDrawMeshTasksCount = (uint32)(x.ref2ee3ccb7.maxDrawMeshTasksCount)
	x.MaxTaskWorkGroupInvocations = (uint32)(x.ref2ee3ccb7.maxTaskWorkGroupInvocations)
	x.MaxTaskWorkGroupSize = *(*[3]uint32)(unsafe.Pointer(&x.ref2ee3ccb7.maxTaskWorkGroupSize))
	x.MaxTaskTotalMemorySize = (uint32)(x.ref2ee3ccb7.maxTaskTotalMemorySize)
	x.MaxTaskOutputCount = (uint32)(x.ref2ee3ccb7.maxTaskOutputCount)
	x.MaxMeshWorkGroupInvocations = (uint32)(x.ref2ee3ccb7.maxMeshWorkGroupInvocations)
	x.MaxMeshWorkGroupSize = *(*[3]uint32)(unsafe.Pointer(&x.ref2ee3ccb7.maxMeshWorkGroupSize))
	x.MaxMeshTotalMemorySize = (uint32)(x.ref2ee3ccb7.maxMeshTotalMemorySize)
	x.MaxMeshOutputVertices = (uint32)(x.ref2ee3ccb7.maxMeshOutputVertices)
	x.MaxMeshOutputPrimitives = (uint32)(x.ref2ee3ccb7.maxMeshOutputPrimitives)
	x.MaxMeshMultiviewViewCount = (uint32)(x.ref2ee3ccb7.maxMeshMultiviewViewCount)
	x.MeshOutputPerVertexGranularity = (uint32)(x.ref2ee3ccb7.meshOutputPerVertexGranularity)
	x.MeshOutputPerPrimitiveGranularity = (uint32)(x.ref2ee3ccb7.meshOutputPerPrimitiveGranularity)
}

// allocDrawMeshTasksIndirectCommandNVMemory allocates memory for type C.VkDrawMeshTasksIndirectCommandNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrawMeshTasksIndirectCommandNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrawMeshTasksIndirectCommandNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDrawMeshTasksIndirectCommandNVValue = unsafe.Sizeof([1]C.VkDrawMeshTasksIndirectCommandNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrawMeshTasksIndirectCommandNV) Ref() *C.VkDrawMeshTasksIndirectCommandNV {
	if x == nil {
		return nil
	}
	return x.refda6c46ea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrawMeshTasksIndirectCommandNV) Free() {
	if x != nil && x.allocsda6c46ea != nil {
		x.allocsda6c46ea.(*cgoAllocMap).Free()
		x.refda6c46ea = nil
	}
}

// NewDrawMeshTasksIndirectCommandNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrawMeshTasksIndirectCommandNVRef(ref unsafe.Pointer) *DrawMeshTasksIndirectCommandNV {
	if ref == nil {
		return nil
	}
	obj := new(DrawMeshTasksIndirectCommandNV)
	obj.refda6c46ea = (*C.VkDrawMeshTasksIndirectCommandNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrawMeshTasksIndirectCommandNV) PassRef() (*C.VkDrawMeshTasksIndirectCommandNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refda6c46ea != nil {
		return x.refda6c46ea, nil
	}
	memda6c46ea := allocDrawMeshTasksIndirectCommandNVMemory(1)
	refda6c46ea := (*C.VkDrawMeshTasksIndirectCommandNV)(memda6c46ea)
	allocsda6c46ea := new(cgoAllocMap)
	allocsda6c46ea.Add(memda6c46ea)

	var ctaskCount_allocs *cgoAllocMap
	refda6c46ea.taskCount, ctaskCount_allocs = (C.uint32_t)(x.TaskCount), cgoAllocsUnknown
	allocsda6c46ea.Borrow(ctaskCount_allocs)

	var cfirstTask_allocs *cgoAllocMap
	refda6c46ea.firstTask, cfirstTask_allocs = (C.uint32_t)(x.FirstTask), cgoAllocsUnknown
	allocsda6c46ea.Borrow(cfirstTask_allocs)

	x.refda6c46ea = refda6c46ea
	x.allocsda6c46ea = allocsda6c46ea
	return refda6c46ea, allocsda6c46ea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrawMeshTasksIndirectCommandNV) PassValue() (C.VkDrawMeshTasksIndirectCommandNV, *cgoAllocMap) {
	if x.refda6c46ea != nil {
		return *x.refda6c46ea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrawMeshTasksIndirectCommandNV) Deref() {
	if x.refda6c46ea == nil {
		return
	}
	x.TaskCount = (uint32)(x.refda6c46ea.taskCount)
	x.FirstTask = (uint32)(x.refda6c46ea.firstTask)
}

// allocPhysicalDeviceFragmentShaderBarycentricFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFragmentShaderBarycentricFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFragmentShaderBarycentricFeaturesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceFragmentShaderBarycentricFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFragmentShaderBarycentricFeaturesNV) Ref() *C.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV {
	if x == nil {
		return nil
	}
	return x.ref191b97c6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFragmentShaderBarycentricFeaturesNV) Free() {
	if x != nil && x.allocs191b97c6 != nil {
		x.allocs191b97c6.(*cgoAllocMap).Free()
		x.ref191b97c6 = nil
	}
}

// NewPhysicalDeviceFragmentShaderBarycentricFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFragmentShaderBarycentricFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceFragmentShaderBarycentricFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFragmentShaderBarycentricFeaturesNV)
	obj.ref191b97c6 = (*C.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFragmentShaderBarycentricFeaturesNV) PassRef() (*C.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref191b97c6 != nil {
		return x.ref191b97c6, nil
	}
	mem191b97c6 := allocPhysicalDeviceFragmentShaderBarycentricFeaturesNVMemory(1)
	ref191b97c6 := (*C.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV)(mem191b97c6)
	allocs191b97c6 := new(cgoAllocMap)
	allocs191b97c6.Add(mem191b97c6)

	var csType_allocs *cgoAllocMap
	ref191b97c6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs191b97c6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref191b97c6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs191b97c6.Borrow(cpNext_allocs)

	var cfragmentShaderBarycentric_allocs *cgoAllocMap
	ref191b97c6.fragmentShaderBarycentric, cfragmentShaderBarycentric_allocs = (C.VkBool32)(x.FragmentShaderBarycentric), cgoAllocsUnknown
	allocs191b97c6.Borrow(cfragmentShaderBarycentric_allocs)

	x.ref191b97c6 = ref191b97c6
	x.allocs191b97c6 = allocs191b97c6
	return ref191b97c6, allocs191b97c6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFragmentShaderBarycentricFeaturesNV) PassValue() (C.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, *cgoAllocMap) {
	if x.ref191b97c6 != nil {
		return *x.ref191b97c6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFragmentShaderBarycentricFeaturesNV) Deref() {
	if x.ref191b97c6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref191b97c6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref191b97c6.pNext))
	x.FragmentShaderBarycentric = (Bool32)(x.ref191b97c6.fragmentShaderBarycentric)
}

// allocPhysicalDeviceShaderImageFootprintFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceShaderImageFootprintFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderImageFootprintFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderImageFootprintFeaturesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShaderImageFootprintFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderImageFootprintFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderImageFootprintFeaturesNV) Ref() *C.VkPhysicalDeviceShaderImageFootprintFeaturesNV {
	if x == nil {
		return nil
	}
	return x.ref9d61e1b2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderImageFootprintFeaturesNV) Free() {
	if x != nil && x.allocs9d61e1b2 != nil {
		x.allocs9d61e1b2.(*cgoAllocMap).Free()
		x.ref9d61e1b2 = nil
	}
}

// NewPhysicalDeviceShaderImageFootprintFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderImageFootprintFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceShaderImageFootprintFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderImageFootprintFeaturesNV)
	obj.ref9d61e1b2 = (*C.VkPhysicalDeviceShaderImageFootprintFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderImageFootprintFeaturesNV) PassRef() (*C.VkPhysicalDeviceShaderImageFootprintFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9d61e1b2 != nil {
		return x.ref9d61e1b2, nil
	}
	mem9d61e1b2 := allocPhysicalDeviceShaderImageFootprintFeaturesNVMemory(1)
	ref9d61e1b2 := (*C.VkPhysicalDeviceShaderImageFootprintFeaturesNV)(mem9d61e1b2)
	allocs9d61e1b2 := new(cgoAllocMap)
	allocs9d61e1b2.Add(mem9d61e1b2)

	var csType_allocs *cgoAllocMap
	ref9d61e1b2.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9d61e1b2.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9d61e1b2.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9d61e1b2.Borrow(cpNext_allocs)

	var cimageFootprint_allocs *cgoAllocMap
	ref9d61e1b2.imageFootprint, cimageFootprint_allocs = (C.VkBool32)(x.ImageFootprint), cgoAllocsUnknown
	allocs9d61e1b2.Borrow(cimageFootprint_allocs)

	x.ref9d61e1b2 = ref9d61e1b2
	x.allocs9d61e1b2 = allocs9d61e1b2
	return ref9d61e1b2, allocs9d61e1b2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderImageFootprintFeaturesNV) PassValue() (C.VkPhysicalDeviceShaderImageFootprintFeaturesNV, *cgoAllocMap) {
	if x.ref9d61e1b2 != nil {
		return *x.ref9d61e1b2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderImageFootprintFeaturesNV) Deref() {
	if x.ref9d61e1b2 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9d61e1b2.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9d61e1b2.pNext))
	x.ImageFootprint = (Bool32)(x.ref9d61e1b2.imageFootprint)
}

// allocPipelineViewportExclusiveScissorStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportExclusiveScissorStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportExclusiveScissorStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportExclusiveScissorStateCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineViewportExclusiveScissorStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportExclusiveScissorStateCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportExclusiveScissorStateCreateInfoNV) Ref() *C.VkPipelineViewportExclusiveScissorStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refa8715ba6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportExclusiveScissorStateCreateInfoNV) Free() {
	if x != nil && x.allocsa8715ba6 != nil {
		x.allocsa8715ba6.(*cgoAllocMap).Free()
		x.refa8715ba6 = nil
	}
}

// NewPipelineViewportExclusiveScissorStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportExclusiveScissorStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportExclusiveScissorStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportExclusiveScissorStateCreateInfoNV)
	obj.refa8715ba6 = (*C.VkPipelineViewportExclusiveScissorStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportExclusiveScissorStateCreateInfoNV) PassRef() (*C.VkPipelineViewportExclusiveScissorStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa8715ba6 != nil {
		return x.refa8715ba6, nil
	}
	mema8715ba6 := allocPipelineViewportExclusiveScissorStateCreateInfoNVMemory(1)
	refa8715ba6 := (*C.VkPipelineViewportExclusiveScissorStateCreateInfoNV)(mema8715ba6)
	allocsa8715ba6 := new(cgoAllocMap)
	allocsa8715ba6.Add(mema8715ba6)

	var csType_allocs *cgoAllocMap
	refa8715ba6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa8715ba6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa8715ba6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa8715ba6.Borrow(cpNext_allocs)

	var cexclusiveScissorCount_allocs *cgoAllocMap
	refa8715ba6.exclusiveScissorCount, cexclusiveScissorCount_allocs = (C.uint32_t)(x.ExclusiveScissorCount), cgoAllocsUnknown
	allocsa8715ba6.Borrow(cexclusiveScissorCount_allocs)

	var cpExclusiveScissors_allocs *cgoAllocMap
	refa8715ba6.pExclusiveScissors, cpExclusiveScissors_allocs = unpackSRect2D(x.PExclusiveScissors)
	allocsa8715ba6.Borrow(cpExclusiveScissors_allocs)

	x.refa8715ba6 = refa8715ba6
	x.allocsa8715ba6 = allocsa8715ba6
	return refa8715ba6, allocsa8715ba6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportExclusiveScissorStateCreateInfoNV) PassValue() (C.VkPipelineViewportExclusiveScissorStateCreateInfoNV, *cgoAllocMap) {
	if x.refa8715ba6 != nil {
		return *x.refa8715ba6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportExclusiveScissorStateCreateInfoNV) Deref() {
	if x.refa8715ba6 == nil {
		return
	}
	x.SType = (StructureType)(x.refa8715ba6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa8715ba6.pNext))
	x.ExclusiveScissorCount = (uint32)(x.refa8715ba6.exclusiveScissorCount)
	packSRect2D(x.PExclusiveScissors, x.refa8715ba6.pExclusiveScissors)
}

// allocPhysicalDeviceExclusiveScissorFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceExclusiveScissorFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExclusiveScissorFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExclusiveScissorFeaturesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceExclusiveScissorFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExclusiveScissorFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExclusiveScissorFeaturesNV) Ref() *C.VkPhysicalDeviceExclusiveScissorFeaturesNV {
	if x == nil {
		return nil
	}
	return x.ref52c9fcfc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExclusiveScissorFeaturesNV) Free() {
	if x != nil && x.allocs52c9fcfc != nil {
		x.allocs52c9fcfc.(*cgoAllocMap).Free()
		x.ref52c9fcfc = nil
	}
}

// NewPhysicalDeviceExclusiveScissorFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExclusiveScissorFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceExclusiveScissorFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExclusiveScissorFeaturesNV)
	obj.ref52c9fcfc = (*C.VkPhysicalDeviceExclusiveScissorFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExclusiveScissorFeaturesNV) PassRef() (*C.VkPhysicalDeviceExclusiveScissorFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref52c9fcfc != nil {
		return x.ref52c9fcfc, nil
	}
	mem52c9fcfc := allocPhysicalDeviceExclusiveScissorFeaturesNVMemory(1)
	ref52c9fcfc := (*C.VkPhysicalDeviceExclusiveScissorFeaturesNV)(mem52c9fcfc)
	allocs52c9fcfc := new(cgoAllocMap)
	allocs52c9fcfc.Add(mem52c9fcfc)

	var csType_allocs *cgoAllocMap
	ref52c9fcfc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs52c9fcfc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref52c9fcfc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs52c9fcfc.Borrow(cpNext_allocs)

	var cexclusiveScissor_allocs *cgoAllocMap
	ref52c9fcfc.exclusiveScissor, cexclusiveScissor_allocs = (C.VkBool32)(x.ExclusiveScissor), cgoAllocsUnknown
	allocs52c9fcfc.Borrow(cexclusiveScissor_allocs)

	x.ref52c9fcfc = ref52c9fcfc
	x.allocs52c9fcfc = allocs52c9fcfc
	return ref52c9fcfc, allocs52c9fcfc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExclusiveScissorFeaturesNV) PassValue() (C.VkPhysicalDeviceExclusiveScissorFeaturesNV, *cgoAllocMap) {
	if x.ref52c9fcfc != nil {
		return *x.ref52c9fcfc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExclusiveScissorFeaturesNV) Deref() {
	if x.ref52c9fcfc == nil {
		return
	}
	x.SType = (StructureType)(x.ref52c9fcfc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref52c9fcfc.pNext))
	x.ExclusiveScissor = (Bool32)(x.ref52c9fcfc.exclusiveScissor)
}

// allocQueueFamilyCheckpointPropertiesNVMemory allocates memory for type C.VkQueueFamilyCheckpointPropertiesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueueFamilyCheckpointPropertiesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueueFamilyCheckpointPropertiesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfQueueFamilyCheckpointPropertiesNVValue = unsafe.Sizeof([1]C.VkQueueFamilyCheckpointPropertiesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueueFamilyCheckpointPropertiesNV) Ref() *C.VkQueueFamilyCheckpointPropertiesNV {
	if x == nil {
		return nil
	}
	return x.ref351f58c6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueueFamilyCheckpointPropertiesNV) Free() {
	if x != nil && x.allocs351f58c6 != nil {
		x.allocs351f58c6.(*cgoAllocMap).Free()
		x.ref351f58c6 = nil
	}
}

// NewQueueFamilyCheckpointPropertiesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueueFamilyCheckpointPropertiesNVRef(ref unsafe.Pointer) *QueueFamilyCheckpointPropertiesNV {
	if ref == nil {
		return nil
	}
	obj := new(QueueFamilyCheckpointPropertiesNV)
	obj.ref351f58c6 = (*C.VkQueueFamilyCheckpointPropertiesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueueFamilyCheckpointPropertiesNV) PassRef() (*C.VkQueueFamilyCheckpointPropertiesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref351f58c6 != nil {
		return x.ref351f58c6, nil
	}
	mem351f58c6 := allocQueueFamilyCheckpointPropertiesNVMemory(1)
	ref351f58c6 := (*C.VkQueueFamilyCheckpointPropertiesNV)(mem351f58c6)
	allocs351f58c6 := new(cgoAllocMap)
	allocs351f58c6.Add(mem351f58c6)

	var csType_allocs *cgoAllocMap
	ref351f58c6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs351f58c6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref351f58c6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs351f58c6.Borrow(cpNext_allocs)

	var ccheckpointExecutionStageMask_allocs *cgoAllocMap
	ref351f58c6.checkpointExecutionStageMask, ccheckpointExecutionStageMask_allocs = (C.VkPipelineStageFlags)(x.CheckpointExecutionStageMask), cgoAllocsUnknown
	allocs351f58c6.Borrow(ccheckpointExecutionStageMask_allocs)

	x.ref351f58c6 = ref351f58c6
	x.allocs351f58c6 = allocs351f58c6
	return ref351f58c6, allocs351f58c6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueueFamilyCheckpointPropertiesNV) PassValue() (C.VkQueueFamilyCheckpointPropertiesNV, *cgoAllocMap) {
	if x.ref351f58c6 != nil {
		return *x.ref351f58c6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueueFamilyCheckpointPropertiesNV) Deref() {
	if x.ref351f58c6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref351f58c6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref351f58c6.pNext))
	x.CheckpointExecutionStageMask = (PipelineStageFlags)(x.ref351f58c6.checkpointExecutionStageMask)
}

// allocCheckpointDataNVMemory allocates memory for type C.VkCheckpointDataNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCheckpointDataNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCheckpointDataNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCheckpointDataNVValue = unsafe.Sizeof([1]C.VkCheckpointDataNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CheckpointDataNV) Ref() *C.VkCheckpointDataNV {
	if x == nil {
		return nil
	}
	return x.refd1c9224b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CheckpointDataNV) Free() {
	if x != nil && x.allocsd1c9224b != nil {
		x.allocsd1c9224b.(*cgoAllocMap).Free()
		x.refd1c9224b = nil
	}
}

// NewCheckpointDataNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCheckpointDataNVRef(ref unsafe.Pointer) *CheckpointDataNV {
	if ref == nil {
		return nil
	}
	obj := new(CheckpointDataNV)
	obj.refd1c9224b = (*C.VkCheckpointDataNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CheckpointDataNV) PassRef() (*C.VkCheckpointDataNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd1c9224b != nil {
		return x.refd1c9224b, nil
	}
	memd1c9224b := allocCheckpointDataNVMemory(1)
	refd1c9224b := (*C.VkCheckpointDataNV)(memd1c9224b)
	allocsd1c9224b := new(cgoAllocMap)
	allocsd1c9224b.Add(memd1c9224b)

	var csType_allocs *cgoAllocMap
	refd1c9224b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd1c9224b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd1c9224b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd1c9224b.Borrow(cpNext_allocs)

	var cstage_allocs *cgoAllocMap
	refd1c9224b.stage, cstage_allocs = (C.VkPipelineStageFlagBits)(x.Stage), cgoAllocsUnknown
	allocsd1c9224b.Borrow(cstage_allocs)

	var cpCheckpointMarker_allocs *cgoAllocMap
	refd1c9224b.pCheckpointMarker, cpCheckpointMarker_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PCheckpointMarker)), cgoAllocsUnknown
	allocsd1c9224b.Borrow(cpCheckpointMarker_allocs)

	x.refd1c9224b = refd1c9224b
	x.allocsd1c9224b = allocsd1c9224b
	return refd1c9224b, allocsd1c9224b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CheckpointDataNV) PassValue() (C.VkCheckpointDataNV, *cgoAllocMap) {
	if x.refd1c9224b != nil {
		return *x.refd1c9224b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CheckpointDataNV) Deref() {
	if x.refd1c9224b == nil {
		return
	}
	x.SType = (StructureType)(x.refd1c9224b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd1c9224b.pNext))
	x.Stage = (PipelineStageFlagBits)(x.refd1c9224b.stage)
	x.PCheckpointMarker = (unsafe.Pointer)(unsafe.Pointer(x.refd1c9224b.pCheckpointMarker))
}

// allocPhysicalDeviceShaderIntegerFunctions2FeaturesINTELMemory allocates memory for type C.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderIntegerFunctions2FeaturesINTELMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderIntegerFunctions2FeaturesINTELValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShaderIntegerFunctions2FeaturesINTELValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL) Ref() *C.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
	if x == nil {
		return nil
	}
	return x.refff2cd6c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL) Free() {
	if x != nil && x.allocsff2cd6c != nil {
		x.allocsff2cd6c.(*cgoAllocMap).Free()
		x.refff2cd6c = nil
	}
}

// NewPhysicalDeviceShaderIntegerFunctions2FeaturesINTELRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderIntegerFunctions2FeaturesINTELRef(ref unsafe.Pointer) *PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL)
	obj.refff2cd6c = (*C.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL) PassRef() (*C.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff2cd6c != nil {
		return x.refff2cd6c, nil
	}
	memff2cd6c := allocPhysicalDeviceShaderIntegerFunctions2FeaturesINTELMemory(1)
	refff2cd6c := (*C.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL)(memff2cd6c)
	allocsff2cd6c := new(cgoAllocMap)
	allocsff2cd6c.Add(memff2cd6c)

	var csType_allocs *cgoAllocMap
	refff2cd6c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsff2cd6c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refff2cd6c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsff2cd6c.Borrow(cpNext_allocs)

	var cshaderIntegerFunctions2_allocs *cgoAllocMap
	refff2cd6c.shaderIntegerFunctions2, cshaderIntegerFunctions2_allocs = (C.VkBool32)(x.ShaderIntegerFunctions2), cgoAllocsUnknown
	allocsff2cd6c.Borrow(cshaderIntegerFunctions2_allocs)

	x.refff2cd6c = refff2cd6c
	x.allocsff2cd6c = allocsff2cd6c
	return refff2cd6c, allocsff2cd6c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL) PassValue() (C.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, *cgoAllocMap) {
	if x.refff2cd6c != nil {
		return *x.refff2cd6c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL) Deref() {
	if x.refff2cd6c == nil {
		return
	}
	x.SType = (StructureType)(x.refff2cd6c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refff2cd6c.pNext))
	x.ShaderIntegerFunctions2 = (Bool32)(x.refff2cd6c.shaderIntegerFunctions2)
}

// allocPerformanceValueINTELMemory allocates memory for type C.VkPerformanceValueINTEL in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPerformanceValueINTELMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPerformanceValueINTELValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPerformanceValueINTELValue = unsafe.Sizeof([1]C.VkPerformanceValueINTEL{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PerformanceValueINTEL) Ref() *C.VkPerformanceValueINTEL {
	if x == nil {
		return nil
	}
	return x.refe6a134ae
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PerformanceValueINTEL) Free() {
	if x != nil && x.allocse6a134ae != nil {
		x.allocse6a134ae.(*cgoAllocMap).Free()
		x.refe6a134ae = nil
	}
}

// NewPerformanceValueINTELRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPerformanceValueINTELRef(ref unsafe.Pointer) *PerformanceValueINTEL {
	if ref == nil {
		return nil
	}
	obj := new(PerformanceValueINTEL)
	obj.refe6a134ae = (*C.VkPerformanceValueINTEL)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PerformanceValueINTEL) PassRef() (*C.VkPerformanceValueINTEL, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe6a134ae != nil {
		return x.refe6a134ae, nil
	}
	meme6a134ae := allocPerformanceValueINTELMemory(1)
	refe6a134ae := (*C.VkPerformanceValueINTEL)(meme6a134ae)
	allocse6a134ae := new(cgoAllocMap)
	allocse6a134ae.Add(meme6a134ae)

	var c_type_allocs *cgoAllocMap
	refe6a134ae._type, c_type_allocs = (C.VkPerformanceValueTypeINTEL)(x.Type), cgoAllocsUnknown
	allocse6a134ae.Borrow(c_type_allocs)

	var cdata_allocs *cgoAllocMap
	refe6a134ae.data, cdata_allocs = *(*C.VkPerformanceValueDataINTEL)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocse6a134ae.Borrow(cdata_allocs)

	x.refe6a134ae = refe6a134ae
	x.allocse6a134ae = allocse6a134ae
	return refe6a134ae, allocse6a134ae

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PerformanceValueINTEL) PassValue() (C.VkPerformanceValueINTEL, *cgoAllocMap) {
	if x.refe6a134ae != nil {
		return *x.refe6a134ae, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PerformanceValueINTEL) Deref() {
	if x.refe6a134ae == nil {
		return
	}
	x.Type = (PerformanceValueTypeINTEL)(x.refe6a134ae._type)
	x.Data = *(*PerformanceValueDataINTEL)(unsafe.Pointer(&x.refe6a134ae.data))
}

// allocInitializePerformanceApiInfoINTELMemory allocates memory for type C.VkInitializePerformanceApiInfoINTEL in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInitializePerformanceApiInfoINTELMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInitializePerformanceApiInfoINTELValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInitializePerformanceApiInfoINTELValue = unsafe.Sizeof([1]C.VkInitializePerformanceApiInfoINTEL{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *InitializePerformanceApiInfoINTEL) Ref() *C.VkInitializePerformanceApiInfoINTEL {
	if x == nil {
		return nil
	}
	return x.refb72b1cf3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *InitializePerformanceApiInfoINTEL) Free() {
	if x != nil && x.allocsb72b1cf3 != nil {
		x.allocsb72b1cf3.(*cgoAllocMap).Free()
		x.refb72b1cf3 = nil
	}
}

// NewInitializePerformanceApiInfoINTELRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewInitializePerformanceApiInfoINTELRef(ref unsafe.Pointer) *InitializePerformanceApiInfoINTEL {
	if ref == nil {
		return nil
	}
	obj := new(InitializePerformanceApiInfoINTEL)
	obj.refb72b1cf3 = (*C.VkInitializePerformanceApiInfoINTEL)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *InitializePerformanceApiInfoINTEL) PassRef() (*C.VkInitializePerformanceApiInfoINTEL, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb72b1cf3 != nil {
		return x.refb72b1cf3, nil
	}
	memb72b1cf3 := allocInitializePerformanceApiInfoINTELMemory(1)
	refb72b1cf3 := (*C.VkInitializePerformanceApiInfoINTEL)(memb72b1cf3)
	allocsb72b1cf3 := new(cgoAllocMap)
	allocsb72b1cf3.Add(memb72b1cf3)

	var csType_allocs *cgoAllocMap
	refb72b1cf3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb72b1cf3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb72b1cf3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb72b1cf3.Borrow(cpNext_allocs)

	var cpUserData_allocs *cgoAllocMap
	refb72b1cf3.pUserData, cpUserData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PUserData)), cgoAllocsUnknown
	allocsb72b1cf3.Borrow(cpUserData_allocs)

	x.refb72b1cf3 = refb72b1cf3
	x.allocsb72b1cf3 = allocsb72b1cf3
	return refb72b1cf3, allocsb72b1cf3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x InitializePerformanceApiInfoINTEL) PassValue() (C.VkInitializePerformanceApiInfoINTEL, *cgoAllocMap) {
	if x.refb72b1cf3 != nil {
		return *x.refb72b1cf3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *InitializePerformanceApiInfoINTEL) Deref() {
	if x.refb72b1cf3 == nil {
		return
	}
	x.SType = (StructureType)(x.refb72b1cf3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb72b1cf3.pNext))
	x.PUserData = (unsafe.Pointer)(unsafe.Pointer(x.refb72b1cf3.pUserData))
}

// allocQueryPoolPerformanceQueryCreateInfoINTELMemory allocates memory for type C.VkQueryPoolPerformanceQueryCreateInfoINTEL in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueryPoolPerformanceQueryCreateInfoINTELMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueryPoolPerformanceQueryCreateInfoINTELValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfQueryPoolPerformanceQueryCreateInfoINTELValue = unsafe.Sizeof([1]C.VkQueryPoolPerformanceQueryCreateInfoINTEL{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueryPoolPerformanceQueryCreateInfoINTEL) Ref() *C.VkQueryPoolPerformanceQueryCreateInfoINTEL {
	if x == nil {
		return nil
	}
	return x.refb8883992
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueryPoolPerformanceQueryCreateInfoINTEL) Free() {
	if x != nil && x.allocsb8883992 != nil {
		x.allocsb8883992.(*cgoAllocMap).Free()
		x.refb8883992 = nil
	}
}

// NewQueryPoolPerformanceQueryCreateInfoINTELRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueryPoolPerformanceQueryCreateInfoINTELRef(ref unsafe.Pointer) *QueryPoolPerformanceQueryCreateInfoINTEL {
	if ref == nil {
		return nil
	}
	obj := new(QueryPoolPerformanceQueryCreateInfoINTEL)
	obj.refb8883992 = (*C.VkQueryPoolPerformanceQueryCreateInfoINTEL)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueryPoolPerformanceQueryCreateInfoINTEL) PassRef() (*C.VkQueryPoolPerformanceQueryCreateInfoINTEL, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8883992 != nil {
		return x.refb8883992, nil
	}
	memb8883992 := allocQueryPoolPerformanceQueryCreateInfoINTELMemory(1)
	refb8883992 := (*C.VkQueryPoolPerformanceQueryCreateInfoINTEL)(memb8883992)
	allocsb8883992 := new(cgoAllocMap)
	allocsb8883992.Add(memb8883992)

	var csType_allocs *cgoAllocMap
	refb8883992.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb8883992.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb8883992.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb8883992.Borrow(cpNext_allocs)

	var cperformanceCountersSampling_allocs *cgoAllocMap
	refb8883992.performanceCountersSampling, cperformanceCountersSampling_allocs = (C.VkQueryPoolSamplingModeINTEL)(x.PerformanceCountersSampling), cgoAllocsUnknown
	allocsb8883992.Borrow(cperformanceCountersSampling_allocs)

	x.refb8883992 = refb8883992
	x.allocsb8883992 = allocsb8883992
	return refb8883992, allocsb8883992

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueryPoolPerformanceQueryCreateInfoINTEL) PassValue() (C.VkQueryPoolPerformanceQueryCreateInfoINTEL, *cgoAllocMap) {
	if x.refb8883992 != nil {
		return *x.refb8883992, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueryPoolPerformanceQueryCreateInfoINTEL) Deref() {
	if x.refb8883992 == nil {
		return
	}
	x.SType = (StructureType)(x.refb8883992.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb8883992.pNext))
	x.PerformanceCountersSampling = (QueryPoolSamplingModeINTEL)(x.refb8883992.performanceCountersSampling)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueryPoolCreateInfoINTEL) Ref() *C.VkQueryPoolPerformanceQueryCreateInfoINTEL {
	if x == nil {
		return nil
	}
	return x.refb8883992
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueryPoolCreateInfoINTEL) Free() {
	if x != nil && x.allocsb8883992 != nil {
		x.allocsb8883992.(*cgoAllocMap).Free()
		x.refb8883992 = nil
	}
}

// NewQueryPoolCreateInfoINTELRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueryPoolCreateInfoINTELRef(ref unsafe.Pointer) *QueryPoolCreateInfoINTEL {
	if ref == nil {
		return nil
	}
	obj := new(QueryPoolCreateInfoINTEL)
	obj.refb8883992 = (*C.VkQueryPoolPerformanceQueryCreateInfoINTEL)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueryPoolCreateInfoINTEL) PassRef() (*C.VkQueryPoolPerformanceQueryCreateInfoINTEL, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8883992 != nil {
		return x.refb8883992, nil
	}
	memb8883992 := allocQueryPoolPerformanceQueryCreateInfoINTELMemory(1)
	refb8883992 := (*C.VkQueryPoolPerformanceQueryCreateInfoINTEL)(memb8883992)
	allocsb8883992 := new(cgoAllocMap)
	allocsb8883992.Add(memb8883992)

	var csType_allocs *cgoAllocMap
	refb8883992.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb8883992.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb8883992.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb8883992.Borrow(cpNext_allocs)

	var cperformanceCountersSampling_allocs *cgoAllocMap
	refb8883992.performanceCountersSampling, cperformanceCountersSampling_allocs = (C.VkQueryPoolSamplingModeINTEL)(x.PerformanceCountersSampling), cgoAllocsUnknown
	allocsb8883992.Borrow(cperformanceCountersSampling_allocs)

	x.refb8883992 = refb8883992
	x.allocsb8883992 = allocsb8883992
	return refb8883992, allocsb8883992

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueryPoolCreateInfoINTEL) PassValue() (C.VkQueryPoolPerformanceQueryCreateInfoINTEL, *cgoAllocMap) {
	if x.refb8883992 != nil {
		return *x.refb8883992, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueryPoolCreateInfoINTEL) Deref() {
	if x.refb8883992 == nil {
		return
	}
	x.SType = (StructureType)(x.refb8883992.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb8883992.pNext))
	x.PerformanceCountersSampling = (QueryPoolSamplingModeINTEL)(x.refb8883992.performanceCountersSampling)
}

// allocPerformanceMarkerInfoINTELMemory allocates memory for type C.VkPerformanceMarkerInfoINTEL in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPerformanceMarkerInfoINTELMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPerformanceMarkerInfoINTELValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPerformanceMarkerInfoINTELValue = unsafe.Sizeof([1]C.VkPerformanceMarkerInfoINTEL{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PerformanceMarkerInfoINTEL) Ref() *C.VkPerformanceMarkerInfoINTEL {
	if x == nil {
		return nil
	}
	return x.refbf575d93
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PerformanceMarkerInfoINTEL) Free() {
	if x != nil && x.allocsbf575d93 != nil {
		x.allocsbf575d93.(*cgoAllocMap).Free()
		x.refbf575d93 = nil
	}
}

// NewPerformanceMarkerInfoINTELRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPerformanceMarkerInfoINTELRef(ref unsafe.Pointer) *PerformanceMarkerInfoINTEL {
	if ref == nil {
		return nil
	}
	obj := new(PerformanceMarkerInfoINTEL)
	obj.refbf575d93 = (*C.VkPerformanceMarkerInfoINTEL)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PerformanceMarkerInfoINTEL) PassRef() (*C.VkPerformanceMarkerInfoINTEL, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbf575d93 != nil {
		return x.refbf575d93, nil
	}
	membf575d93 := allocPerformanceMarkerInfoINTELMemory(1)
	refbf575d93 := (*C.VkPerformanceMarkerInfoINTEL)(membf575d93)
	allocsbf575d93 := new(cgoAllocMap)
	allocsbf575d93.Add(membf575d93)

	var csType_allocs *cgoAllocMap
	refbf575d93.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbf575d93.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbf575d93.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbf575d93.Borrow(cpNext_allocs)

	var cmarker_allocs *cgoAllocMap
	refbf575d93.marker, cmarker_allocs = (C.uint64_t)(x.Marker), cgoAllocsUnknown
	allocsbf575d93.Borrow(cmarker_allocs)

	x.refbf575d93 = refbf575d93
	x.allocsbf575d93 = allocsbf575d93
	return refbf575d93, allocsbf575d93

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PerformanceMarkerInfoINTEL) PassValue() (C.VkPerformanceMarkerInfoINTEL, *cgoAllocMap) {
	if x.refbf575d93 != nil {
		return *x.refbf575d93, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PerformanceMarkerInfoINTEL) Deref() {
	if x.refbf575d93 == nil {
		return
	}
	x.SType = (StructureType)(x.refbf575d93.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbf575d93.pNext))
	x.Marker = (uint32)(x.refbf575d93.marker)
}

// allocPerformanceStreamMarkerInfoINTELMemory allocates memory for type C.VkPerformanceStreamMarkerInfoINTEL in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPerformanceStreamMarkerInfoINTELMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPerformanceStreamMarkerInfoINTELValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPerformanceStreamMarkerInfoINTELValue = unsafe.Sizeof([1]C.VkPerformanceStreamMarkerInfoINTEL{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PerformanceStreamMarkerInfoINTEL) Ref() *C.VkPerformanceStreamMarkerInfoINTEL {
	if x == nil {
		return nil
	}
	return x.refaaf8355c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PerformanceStreamMarkerInfoINTEL) Free() {
	if x != nil && x.allocsaaf8355c != nil {
		x.allocsaaf8355c.(*cgoAllocMap).Free()
		x.refaaf8355c = nil
	}
}

// NewPerformanceStreamMarkerInfoINTELRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPerformanceStreamMarkerInfoINTELRef(ref unsafe.Pointer) *PerformanceStreamMarkerInfoINTEL {
	if ref == nil {
		return nil
	}
	obj := new(PerformanceStreamMarkerInfoINTEL)
	obj.refaaf8355c = (*C.VkPerformanceStreamMarkerInfoINTEL)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PerformanceStreamMarkerInfoINTEL) PassRef() (*C.VkPerformanceStreamMarkerInfoINTEL, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaaf8355c != nil {
		return x.refaaf8355c, nil
	}
	memaaf8355c := allocPerformanceStreamMarkerInfoINTELMemory(1)
	refaaf8355c := (*C.VkPerformanceStreamMarkerInfoINTEL)(memaaf8355c)
	allocsaaf8355c := new(cgoAllocMap)
	allocsaaf8355c.Add(memaaf8355c)

	var csType_allocs *cgoAllocMap
	refaaf8355c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsaaf8355c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refaaf8355c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsaaf8355c.Borrow(cpNext_allocs)

	var cmarker_allocs *cgoAllocMap
	refaaf8355c.marker, cmarker_allocs = (C.uint32_t)(x.Marker), cgoAllocsUnknown
	allocsaaf8355c.Borrow(cmarker_allocs)

	x.refaaf8355c = refaaf8355c
	x.allocsaaf8355c = allocsaaf8355c
	return refaaf8355c, allocsaaf8355c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PerformanceStreamMarkerInfoINTEL) PassValue() (C.VkPerformanceStreamMarkerInfoINTEL, *cgoAllocMap) {
	if x.refaaf8355c != nil {
		return *x.refaaf8355c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PerformanceStreamMarkerInfoINTEL) Deref() {
	if x.refaaf8355c == nil {
		return
	}
	x.SType = (StructureType)(x.refaaf8355c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refaaf8355c.pNext))
	x.Marker = (uint32)(x.refaaf8355c.marker)
}

// allocPerformanceOverrideInfoINTELMemory allocates memory for type C.VkPerformanceOverrideInfoINTEL in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPerformanceOverrideInfoINTELMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPerformanceOverrideInfoINTELValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPerformanceOverrideInfoINTELValue = unsafe.Sizeof([1]C.VkPerformanceOverrideInfoINTEL{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PerformanceOverrideInfoINTEL) Ref() *C.VkPerformanceOverrideInfoINTEL {
	if x == nil {
		return nil
	}
	return x.ref1cdbce31
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PerformanceOverrideInfoINTEL) Free() {
	if x != nil && x.allocs1cdbce31 != nil {
		x.allocs1cdbce31.(*cgoAllocMap).Free()
		x.ref1cdbce31 = nil
	}
}

// NewPerformanceOverrideInfoINTELRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPerformanceOverrideInfoINTELRef(ref unsafe.Pointer) *PerformanceOverrideInfoINTEL {
	if ref == nil {
		return nil
	}
	obj := new(PerformanceOverrideInfoINTEL)
	obj.ref1cdbce31 = (*C.VkPerformanceOverrideInfoINTEL)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PerformanceOverrideInfoINTEL) PassRef() (*C.VkPerformanceOverrideInfoINTEL, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1cdbce31 != nil {
		return x.ref1cdbce31, nil
	}
	mem1cdbce31 := allocPerformanceOverrideInfoINTELMemory(1)
	ref1cdbce31 := (*C.VkPerformanceOverrideInfoINTEL)(mem1cdbce31)
	allocs1cdbce31 := new(cgoAllocMap)
	allocs1cdbce31.Add(mem1cdbce31)

	var csType_allocs *cgoAllocMap
	ref1cdbce31.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1cdbce31.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1cdbce31.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1cdbce31.Borrow(cpNext_allocs)

	var c_type_allocs *cgoAllocMap
	ref1cdbce31._type, c_type_allocs = (C.VkPerformanceOverrideTypeINTEL)(x.Type), cgoAllocsUnknown
	allocs1cdbce31.Borrow(c_type_allocs)

	var cenable_allocs *cgoAllocMap
	ref1cdbce31.enable, cenable_allocs = (C.VkBool32)(x.Enable), cgoAllocsUnknown
	allocs1cdbce31.Borrow(cenable_allocs)

	var cparameter_allocs *cgoAllocMap
	ref1cdbce31.parameter, cparameter_allocs = (C.uint64_t)(x.Parameter), cgoAllocsUnknown
	allocs1cdbce31.Borrow(cparameter_allocs)

	x.ref1cdbce31 = ref1cdbce31
	x.allocs1cdbce31 = allocs1cdbce31
	return ref1cdbce31, allocs1cdbce31

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PerformanceOverrideInfoINTEL) PassValue() (C.VkPerformanceOverrideInfoINTEL, *cgoAllocMap) {
	if x.ref1cdbce31 != nil {
		return *x.ref1cdbce31, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PerformanceOverrideInfoINTEL) Deref() {
	if x.ref1cdbce31 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1cdbce31.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1cdbce31.pNext))
	x.Type = (PerformanceOverrideTypeINTEL)(x.ref1cdbce31._type)
	x.Enable = (Bool32)(x.ref1cdbce31.enable)
	x.Parameter = (uint32)(x.ref1cdbce31.parameter)
}

// allocPerformanceConfigurationAcquireInfoINTELMemory allocates memory for type C.VkPerformanceConfigurationAcquireInfoINTEL in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPerformanceConfigurationAcquireInfoINTELMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPerformanceConfigurationAcquireInfoINTELValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPerformanceConfigurationAcquireInfoINTELValue = unsafe.Sizeof([1]C.VkPerformanceConfigurationAcquireInfoINTEL{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PerformanceConfigurationAcquireInfoINTEL) Ref() *C.VkPerformanceConfigurationAcquireInfoINTEL {
	if x == nil {
		return nil
	}
	return x.ref16c1d105
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PerformanceConfigurationAcquireInfoINTEL) Free() {
	if x != nil && x.allocs16c1d105 != nil {
		x.allocs16c1d105.(*cgoAllocMap).Free()
		x.ref16c1d105 = nil
	}
}

// NewPerformanceConfigurationAcquireInfoINTELRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPerformanceConfigurationAcquireInfoINTELRef(ref unsafe.Pointer) *PerformanceConfigurationAcquireInfoINTEL {
	if ref == nil {
		return nil
	}
	obj := new(PerformanceConfigurationAcquireInfoINTEL)
	obj.ref16c1d105 = (*C.VkPerformanceConfigurationAcquireInfoINTEL)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PerformanceConfigurationAcquireInfoINTEL) PassRef() (*C.VkPerformanceConfigurationAcquireInfoINTEL, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref16c1d105 != nil {
		return x.ref16c1d105, nil
	}
	mem16c1d105 := allocPerformanceConfigurationAcquireInfoINTELMemory(1)
	ref16c1d105 := (*C.VkPerformanceConfigurationAcquireInfoINTEL)(mem16c1d105)
	allocs16c1d105 := new(cgoAllocMap)
	allocs16c1d105.Add(mem16c1d105)

	var csType_allocs *cgoAllocMap
	ref16c1d105.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs16c1d105.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref16c1d105.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs16c1d105.Borrow(cpNext_allocs)

	var c_type_allocs *cgoAllocMap
	ref16c1d105._type, c_type_allocs = (C.VkPerformanceConfigurationTypeINTEL)(x.Type), cgoAllocsUnknown
	allocs16c1d105.Borrow(c_type_allocs)

	x.ref16c1d105 = ref16c1d105
	x.allocs16c1d105 = allocs16c1d105
	return ref16c1d105, allocs16c1d105

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PerformanceConfigurationAcquireInfoINTEL) PassValue() (C.VkPerformanceConfigurationAcquireInfoINTEL, *cgoAllocMap) {
	if x.ref16c1d105 != nil {
		return *x.ref16c1d105, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PerformanceConfigurationAcquireInfoINTEL) Deref() {
	if x.ref16c1d105 == nil {
		return
	}
	x.SType = (StructureType)(x.ref16c1d105.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref16c1d105.pNext))
	x.Type = (PerformanceConfigurationTypeINTEL)(x.ref16c1d105._type)
}

// allocPhysicalDevicePCIBusInfoPropertiesMemory allocates memory for type C.VkPhysicalDevicePCIBusInfoPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePCIBusInfoPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePCIBusInfoPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDevicePCIBusInfoPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDevicePCIBusInfoPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevicePCIBusInfoProperties) Ref() *C.VkPhysicalDevicePCIBusInfoPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refdd9947ff
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevicePCIBusInfoProperties) Free() {
	if x != nil && x.allocsdd9947ff != nil {
		x.allocsdd9947ff.(*cgoAllocMap).Free()
		x.refdd9947ff = nil
	}
}

// NewPhysicalDevicePCIBusInfoPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePCIBusInfoPropertiesRef(ref unsafe.Pointer) *PhysicalDevicePCIBusInfoProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevicePCIBusInfoProperties)
	obj.refdd9947ff = (*C.VkPhysicalDevicePCIBusInfoPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevicePCIBusInfoProperties) PassRef() (*C.VkPhysicalDevicePCIBusInfoPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdd9947ff != nil {
		return x.refdd9947ff, nil
	}
	memdd9947ff := allocPhysicalDevicePCIBusInfoPropertiesMemory(1)
	refdd9947ff := (*C.VkPhysicalDevicePCIBusInfoPropertiesEXT)(memdd9947ff)
	allocsdd9947ff := new(cgoAllocMap)
	allocsdd9947ff.Add(memdd9947ff)

	var csType_allocs *cgoAllocMap
	refdd9947ff.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdd9947ff.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdd9947ff.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdd9947ff.Borrow(cpNext_allocs)

	var cpciDomain_allocs *cgoAllocMap
	refdd9947ff.pciDomain, cpciDomain_allocs = (C.uint32_t)(x.PciDomain), cgoAllocsUnknown
	allocsdd9947ff.Borrow(cpciDomain_allocs)

	var cpciBus_allocs *cgoAllocMap
	refdd9947ff.pciBus, cpciBus_allocs = (C.uint32_t)(x.PciBus), cgoAllocsUnknown
	allocsdd9947ff.Borrow(cpciBus_allocs)

	var cpciDevice_allocs *cgoAllocMap
	refdd9947ff.pciDevice, cpciDevice_allocs = (C.uint32_t)(x.PciDevice), cgoAllocsUnknown
	allocsdd9947ff.Borrow(cpciDevice_allocs)

	var cpciFunction_allocs *cgoAllocMap
	refdd9947ff.pciFunction, cpciFunction_allocs = (C.uint32_t)(x.PciFunction), cgoAllocsUnknown
	allocsdd9947ff.Borrow(cpciFunction_allocs)

	x.refdd9947ff = refdd9947ff
	x.allocsdd9947ff = allocsdd9947ff
	return refdd9947ff, allocsdd9947ff

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevicePCIBusInfoProperties) PassValue() (C.VkPhysicalDevicePCIBusInfoPropertiesEXT, *cgoAllocMap) {
	if x.refdd9947ff != nil {
		return *x.refdd9947ff, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevicePCIBusInfoProperties) Deref() {
	if x.refdd9947ff == nil {
		return
	}
	x.SType = (StructureType)(x.refdd9947ff.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdd9947ff.pNext))
	x.PciDomain = (uint32)(x.refdd9947ff.pciDomain)
	x.PciBus = (uint32)(x.refdd9947ff.pciBus)
	x.PciDevice = (uint32)(x.refdd9947ff.pciDevice)
	x.PciFunction = (uint32)(x.refdd9947ff.pciFunction)
}

// allocDisplayNativeHdrSurfaceCapabilitiesAMDMemory allocates memory for type C.VkDisplayNativeHdrSurfaceCapabilitiesAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayNativeHdrSurfaceCapabilitiesAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayNativeHdrSurfaceCapabilitiesAMDValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayNativeHdrSurfaceCapabilitiesAMDValue = unsafe.Sizeof([1]C.VkDisplayNativeHdrSurfaceCapabilitiesAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayNativeHdrSurfaceCapabilitiesAMD) Ref() *C.VkDisplayNativeHdrSurfaceCapabilitiesAMD {
	if x == nil {
		return nil
	}
	return x.ref2521293a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayNativeHdrSurfaceCapabilitiesAMD) Free() {
	if x != nil && x.allocs2521293a != nil {
		x.allocs2521293a.(*cgoAllocMap).Free()
		x.ref2521293a = nil
	}
}

// NewDisplayNativeHdrSurfaceCapabilitiesAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayNativeHdrSurfaceCapabilitiesAMDRef(ref unsafe.Pointer) *DisplayNativeHdrSurfaceCapabilitiesAMD {
	if ref == nil {
		return nil
	}
	obj := new(DisplayNativeHdrSurfaceCapabilitiesAMD)
	obj.ref2521293a = (*C.VkDisplayNativeHdrSurfaceCapabilitiesAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayNativeHdrSurfaceCapabilitiesAMD) PassRef() (*C.VkDisplayNativeHdrSurfaceCapabilitiesAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2521293a != nil {
		return x.ref2521293a, nil
	}
	mem2521293a := allocDisplayNativeHdrSurfaceCapabilitiesAMDMemory(1)
	ref2521293a := (*C.VkDisplayNativeHdrSurfaceCapabilitiesAMD)(mem2521293a)
	allocs2521293a := new(cgoAllocMap)
	allocs2521293a.Add(mem2521293a)

	var csType_allocs *cgoAllocMap
	ref2521293a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2521293a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2521293a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2521293a.Borrow(cpNext_allocs)

	var clocalDimmingSupport_allocs *cgoAllocMap
	ref2521293a.localDimmingSupport, clocalDimmingSupport_allocs = (C.VkBool32)(x.LocalDimmingSupport), cgoAllocsUnknown
	allocs2521293a.Borrow(clocalDimmingSupport_allocs)

	x.ref2521293a = ref2521293a
	x.allocs2521293a = allocs2521293a
	return ref2521293a, allocs2521293a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayNativeHdrSurfaceCapabilitiesAMD) PassValue() (C.VkDisplayNativeHdrSurfaceCapabilitiesAMD, *cgoAllocMap) {
	if x.ref2521293a != nil {
		return *x.ref2521293a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayNativeHdrSurfaceCapabilitiesAMD) Deref() {
	if x.ref2521293a == nil {
		return
	}
	x.SType = (StructureType)(x.ref2521293a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2521293a.pNext))
	x.LocalDimmingSupport = (Bool32)(x.ref2521293a.localDimmingSupport)
}

// allocSwapchainDisplayNativeHdrCreateInfoAMDMemory allocates memory for type C.VkSwapchainDisplayNativeHdrCreateInfoAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSwapchainDisplayNativeHdrCreateInfoAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSwapchainDisplayNativeHdrCreateInfoAMDValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSwapchainDisplayNativeHdrCreateInfoAMDValue = unsafe.Sizeof([1]C.VkSwapchainDisplayNativeHdrCreateInfoAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SwapchainDisplayNativeHdrCreateInfoAMD) Ref() *C.VkSwapchainDisplayNativeHdrCreateInfoAMD {
	if x == nil {
		return nil
	}
	return x.refffbe2634
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SwapchainDisplayNativeHdrCreateInfoAMD) Free() {
	if x != nil && x.allocsffbe2634 != nil {
		x.allocsffbe2634.(*cgoAllocMap).Free()
		x.refffbe2634 = nil
	}
}

// NewSwapchainDisplayNativeHdrCreateInfoAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSwapchainDisplayNativeHdrCreateInfoAMDRef(ref unsafe.Pointer) *SwapchainDisplayNativeHdrCreateInfoAMD {
	if ref == nil {
		return nil
	}
	obj := new(SwapchainDisplayNativeHdrCreateInfoAMD)
	obj.refffbe2634 = (*C.VkSwapchainDisplayNativeHdrCreateInfoAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SwapchainDisplayNativeHdrCreateInfoAMD) PassRef() (*C.VkSwapchainDisplayNativeHdrCreateInfoAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refffbe2634 != nil {
		return x.refffbe2634, nil
	}
	memffbe2634 := allocSwapchainDisplayNativeHdrCreateInfoAMDMemory(1)
	refffbe2634 := (*C.VkSwapchainDisplayNativeHdrCreateInfoAMD)(memffbe2634)
	allocsffbe2634 := new(cgoAllocMap)
	allocsffbe2634.Add(memffbe2634)

	var csType_allocs *cgoAllocMap
	refffbe2634.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsffbe2634.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refffbe2634.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsffbe2634.Borrow(cpNext_allocs)

	var clocalDimmingEnable_allocs *cgoAllocMap
	refffbe2634.localDimmingEnable, clocalDimmingEnable_allocs = (C.VkBool32)(x.LocalDimmingEnable), cgoAllocsUnknown
	allocsffbe2634.Borrow(clocalDimmingEnable_allocs)

	x.refffbe2634 = refffbe2634
	x.allocsffbe2634 = allocsffbe2634
	return refffbe2634, allocsffbe2634

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SwapchainDisplayNativeHdrCreateInfoAMD) PassValue() (C.VkSwapchainDisplayNativeHdrCreateInfoAMD, *cgoAllocMap) {
	if x.refffbe2634 != nil {
		return *x.refffbe2634, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SwapchainDisplayNativeHdrCreateInfoAMD) Deref() {
	if x.refffbe2634 == nil {
		return
	}
	x.SType = (StructureType)(x.refffbe2634.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refffbe2634.pNext))
	x.LocalDimmingEnable = (Bool32)(x.refffbe2634.localDimmingEnable)
}

// allocPhysicalDeviceFragmentDensityMapFeaturesMemory allocates memory for type C.VkPhysicalDeviceFragmentDensityMapFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFragmentDensityMapFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFragmentDensityMapFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceFragmentDensityMapFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFragmentDensityMapFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFragmentDensityMapFeatures) Ref() *C.VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.reffa0bb2d9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFragmentDensityMapFeatures) Free() {
	if x != nil && x.allocsfa0bb2d9 != nil {
		x.allocsfa0bb2d9.(*cgoAllocMap).Free()
		x.reffa0bb2d9 = nil
	}
}

// NewPhysicalDeviceFragmentDensityMapFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFragmentDensityMapFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceFragmentDensityMapFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFragmentDensityMapFeatures)
	obj.reffa0bb2d9 = (*C.VkPhysicalDeviceFragmentDensityMapFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFragmentDensityMapFeatures) PassRef() (*C.VkPhysicalDeviceFragmentDensityMapFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffa0bb2d9 != nil {
		return x.reffa0bb2d9, nil
	}
	memfa0bb2d9 := allocPhysicalDeviceFragmentDensityMapFeaturesMemory(1)
	reffa0bb2d9 := (*C.VkPhysicalDeviceFragmentDensityMapFeaturesEXT)(memfa0bb2d9)
	allocsfa0bb2d9 := new(cgoAllocMap)
	allocsfa0bb2d9.Add(memfa0bb2d9)

	var csType_allocs *cgoAllocMap
	reffa0bb2d9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfa0bb2d9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffa0bb2d9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfa0bb2d9.Borrow(cpNext_allocs)

	var cfragmentDensityMap_allocs *cgoAllocMap
	reffa0bb2d9.fragmentDensityMap, cfragmentDensityMap_allocs = (C.VkBool32)(x.FragmentDensityMap), cgoAllocsUnknown
	allocsfa0bb2d9.Borrow(cfragmentDensityMap_allocs)

	var cfragmentDensityMapDynamic_allocs *cgoAllocMap
	reffa0bb2d9.fragmentDensityMapDynamic, cfragmentDensityMapDynamic_allocs = (C.VkBool32)(x.FragmentDensityMapDynamic), cgoAllocsUnknown
	allocsfa0bb2d9.Borrow(cfragmentDensityMapDynamic_allocs)

	var cfragmentDensityMapNonSubsampledImages_allocs *cgoAllocMap
	reffa0bb2d9.fragmentDensityMapNonSubsampledImages, cfragmentDensityMapNonSubsampledImages_allocs = (C.VkBool32)(x.FragmentDensityMapNonSubsampledImages), cgoAllocsUnknown
	allocsfa0bb2d9.Borrow(cfragmentDensityMapNonSubsampledImages_allocs)

	x.reffa0bb2d9 = reffa0bb2d9
	x.allocsfa0bb2d9 = allocsfa0bb2d9
	return reffa0bb2d9, allocsfa0bb2d9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFragmentDensityMapFeatures) PassValue() (C.VkPhysicalDeviceFragmentDensityMapFeaturesEXT, *cgoAllocMap) {
	if x.reffa0bb2d9 != nil {
		return *x.reffa0bb2d9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFragmentDensityMapFeatures) Deref() {
	if x.reffa0bb2d9 == nil {
		return
	}
	x.SType = (StructureType)(x.reffa0bb2d9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffa0bb2d9.pNext))
	x.FragmentDensityMap = (Bool32)(x.reffa0bb2d9.fragmentDensityMap)
	x.FragmentDensityMapDynamic = (Bool32)(x.reffa0bb2d9.fragmentDensityMapDynamic)
	x.FragmentDensityMapNonSubsampledImages = (Bool32)(x.reffa0bb2d9.fragmentDensityMapNonSubsampledImages)
}

// allocPhysicalDeviceFragmentDensityMapPropertiesMemory allocates memory for type C.VkPhysicalDeviceFragmentDensityMapPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFragmentDensityMapPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFragmentDensityMapPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceFragmentDensityMapPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFragmentDensityMapPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFragmentDensityMapProperties) Ref() *C.VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref79e5ca31
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFragmentDensityMapProperties) Free() {
	if x != nil && x.allocs79e5ca31 != nil {
		x.allocs79e5ca31.(*cgoAllocMap).Free()
		x.ref79e5ca31 = nil
	}
}

// NewPhysicalDeviceFragmentDensityMapPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFragmentDensityMapPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceFragmentDensityMapProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFragmentDensityMapProperties)
	obj.ref79e5ca31 = (*C.VkPhysicalDeviceFragmentDensityMapPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFragmentDensityMapProperties) PassRef() (*C.VkPhysicalDeviceFragmentDensityMapPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref79e5ca31 != nil {
		return x.ref79e5ca31, nil
	}
	mem79e5ca31 := allocPhysicalDeviceFragmentDensityMapPropertiesMemory(1)
	ref79e5ca31 := (*C.VkPhysicalDeviceFragmentDensityMapPropertiesEXT)(mem79e5ca31)
	allocs79e5ca31 := new(cgoAllocMap)
	allocs79e5ca31.Add(mem79e5ca31)

	var csType_allocs *cgoAllocMap
	ref79e5ca31.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs79e5ca31.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref79e5ca31.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs79e5ca31.Borrow(cpNext_allocs)

	var cminFragmentDensityTexelSize_allocs *cgoAllocMap
	ref79e5ca31.minFragmentDensityTexelSize, cminFragmentDensityTexelSize_allocs = x.MinFragmentDensityTexelSize.PassValue()
	allocs79e5ca31.Borrow(cminFragmentDensityTexelSize_allocs)

	var cmaxFragmentDensityTexelSize_allocs *cgoAllocMap
	ref79e5ca31.maxFragmentDensityTexelSize, cmaxFragmentDensityTexelSize_allocs = x.MaxFragmentDensityTexelSize.PassValue()
	allocs79e5ca31.Borrow(cmaxFragmentDensityTexelSize_allocs)

	var cfragmentDensityInvocations_allocs *cgoAllocMap
	ref79e5ca31.fragmentDensityInvocations, cfragmentDensityInvocations_allocs = (C.VkBool32)(x.FragmentDensityInvocations), cgoAllocsUnknown
	allocs79e5ca31.Borrow(cfragmentDensityInvocations_allocs)

	x.ref79e5ca31 = ref79e5ca31
	x.allocs79e5ca31 = allocs79e5ca31
	return ref79e5ca31, allocs79e5ca31

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFragmentDensityMapProperties) PassValue() (C.VkPhysicalDeviceFragmentDensityMapPropertiesEXT, *cgoAllocMap) {
	if x.ref79e5ca31 != nil {
		return *x.ref79e5ca31, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFragmentDensityMapProperties) Deref() {
	if x.ref79e5ca31 == nil {
		return
	}
	x.SType = (StructureType)(x.ref79e5ca31.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref79e5ca31.pNext))
	x.MinFragmentDensityTexelSize = *NewExtent2DRef(unsafe.Pointer(&x.ref79e5ca31.minFragmentDensityTexelSize))
	x.MaxFragmentDensityTexelSize = *NewExtent2DRef(unsafe.Pointer(&x.ref79e5ca31.maxFragmentDensityTexelSize))
	x.FragmentDensityInvocations = (Bool32)(x.ref79e5ca31.fragmentDensityInvocations)
}

// allocRenderPassFragmentDensityMapCreateInfoMemory allocates memory for type C.VkRenderPassFragmentDensityMapCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassFragmentDensityMapCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassFragmentDensityMapCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderPassFragmentDensityMapCreateInfoValue = unsafe.Sizeof([1]C.VkRenderPassFragmentDensityMapCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassFragmentDensityMapCreateInfo) Ref() *C.VkRenderPassFragmentDensityMapCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref76b25671
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassFragmentDensityMapCreateInfo) Free() {
	if x != nil && x.allocs76b25671 != nil {
		x.allocs76b25671.(*cgoAllocMap).Free()
		x.ref76b25671 = nil
	}
}

// NewRenderPassFragmentDensityMapCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassFragmentDensityMapCreateInfoRef(ref unsafe.Pointer) *RenderPassFragmentDensityMapCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassFragmentDensityMapCreateInfo)
	obj.ref76b25671 = (*C.VkRenderPassFragmentDensityMapCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassFragmentDensityMapCreateInfo) PassRef() (*C.VkRenderPassFragmentDensityMapCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref76b25671 != nil {
		return x.ref76b25671, nil
	}
	mem76b25671 := allocRenderPassFragmentDensityMapCreateInfoMemory(1)
	ref76b25671 := (*C.VkRenderPassFragmentDensityMapCreateInfoEXT)(mem76b25671)
	allocs76b25671 := new(cgoAllocMap)
	allocs76b25671.Add(mem76b25671)

	var csType_allocs *cgoAllocMap
	ref76b25671.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs76b25671.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref76b25671.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs76b25671.Borrow(cpNext_allocs)

	var cfragmentDensityMapAttachment_allocs *cgoAllocMap
	ref76b25671.fragmentDensityMapAttachment, cfragmentDensityMapAttachment_allocs = x.FragmentDensityMapAttachment.PassValue()
	allocs76b25671.Borrow(cfragmentDensityMapAttachment_allocs)

	x.ref76b25671 = ref76b25671
	x.allocs76b25671 = allocs76b25671
	return ref76b25671, allocs76b25671

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassFragmentDensityMapCreateInfo) PassValue() (C.VkRenderPassFragmentDensityMapCreateInfoEXT, *cgoAllocMap) {
	if x.ref76b25671 != nil {
		return *x.ref76b25671, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassFragmentDensityMapCreateInfo) Deref() {
	if x.ref76b25671 == nil {
		return
	}
	x.SType = (StructureType)(x.ref76b25671.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref76b25671.pNext))
	x.FragmentDensityMapAttachment = *NewAttachmentReferenceRef(unsafe.Pointer(&x.ref76b25671.fragmentDensityMapAttachment))
}

// allocPhysicalDeviceSubgroupSizeControlFeaturesMemory allocates memory for type C.VkPhysicalDeviceSubgroupSizeControlFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSubgroupSizeControlFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSubgroupSizeControlFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceSubgroupSizeControlFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSubgroupSizeControlFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSubgroupSizeControlFeatures) Ref() *C.VkPhysicalDeviceSubgroupSizeControlFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refeb219d16
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSubgroupSizeControlFeatures) Free() {
	if x != nil && x.allocseb219d16 != nil {
		x.allocseb219d16.(*cgoAllocMap).Free()
		x.refeb219d16 = nil
	}
}

// NewPhysicalDeviceSubgroupSizeControlFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSubgroupSizeControlFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceSubgroupSizeControlFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSubgroupSizeControlFeatures)
	obj.refeb219d16 = (*C.VkPhysicalDeviceSubgroupSizeControlFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSubgroupSizeControlFeatures) PassRef() (*C.VkPhysicalDeviceSubgroupSizeControlFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeb219d16 != nil {
		return x.refeb219d16, nil
	}
	memeb219d16 := allocPhysicalDeviceSubgroupSizeControlFeaturesMemory(1)
	refeb219d16 := (*C.VkPhysicalDeviceSubgroupSizeControlFeaturesEXT)(memeb219d16)
	allocseb219d16 := new(cgoAllocMap)
	allocseb219d16.Add(memeb219d16)

	var csType_allocs *cgoAllocMap
	refeb219d16.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseb219d16.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeb219d16.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseb219d16.Borrow(cpNext_allocs)

	var csubgroupSizeControl_allocs *cgoAllocMap
	refeb219d16.subgroupSizeControl, csubgroupSizeControl_allocs = (C.VkBool32)(x.SubgroupSizeControl), cgoAllocsUnknown
	allocseb219d16.Borrow(csubgroupSizeControl_allocs)

	var ccomputeFullSubgroups_allocs *cgoAllocMap
	refeb219d16.computeFullSubgroups, ccomputeFullSubgroups_allocs = (C.VkBool32)(x.ComputeFullSubgroups), cgoAllocsUnknown
	allocseb219d16.Borrow(ccomputeFullSubgroups_allocs)

	x.refeb219d16 = refeb219d16
	x.allocseb219d16 = allocseb219d16
	return refeb219d16, allocseb219d16

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSubgroupSizeControlFeatures) PassValue() (C.VkPhysicalDeviceSubgroupSizeControlFeaturesEXT, *cgoAllocMap) {
	if x.refeb219d16 != nil {
		return *x.refeb219d16, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSubgroupSizeControlFeatures) Deref() {
	if x.refeb219d16 == nil {
		return
	}
	x.SType = (StructureType)(x.refeb219d16.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeb219d16.pNext))
	x.SubgroupSizeControl = (Bool32)(x.refeb219d16.subgroupSizeControl)
	x.ComputeFullSubgroups = (Bool32)(x.refeb219d16.computeFullSubgroups)
}

// allocPhysicalDeviceSubgroupSizeControlPropertiesMemory allocates memory for type C.VkPhysicalDeviceSubgroupSizeControlPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSubgroupSizeControlPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSubgroupSizeControlPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceSubgroupSizeControlPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSubgroupSizeControlPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSubgroupSizeControlProperties) Ref() *C.VkPhysicalDeviceSubgroupSizeControlPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref9e562dc3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSubgroupSizeControlProperties) Free() {
	if x != nil && x.allocs9e562dc3 != nil {
		x.allocs9e562dc3.(*cgoAllocMap).Free()
		x.ref9e562dc3 = nil
	}
}

// NewPhysicalDeviceSubgroupSizeControlPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSubgroupSizeControlPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceSubgroupSizeControlProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSubgroupSizeControlProperties)
	obj.ref9e562dc3 = (*C.VkPhysicalDeviceSubgroupSizeControlPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSubgroupSizeControlProperties) PassRef() (*C.VkPhysicalDeviceSubgroupSizeControlPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9e562dc3 != nil {
		return x.ref9e562dc3, nil
	}
	mem9e562dc3 := allocPhysicalDeviceSubgroupSizeControlPropertiesMemory(1)
	ref9e562dc3 := (*C.VkPhysicalDeviceSubgroupSizeControlPropertiesEXT)(mem9e562dc3)
	allocs9e562dc3 := new(cgoAllocMap)
	allocs9e562dc3.Add(mem9e562dc3)

	var csType_allocs *cgoAllocMap
	ref9e562dc3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9e562dc3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9e562dc3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9e562dc3.Borrow(cpNext_allocs)

	var cminSubgroupSize_allocs *cgoAllocMap
	ref9e562dc3.minSubgroupSize, cminSubgroupSize_allocs = (C.uint32_t)(x.MinSubgroupSize), cgoAllocsUnknown
	allocs9e562dc3.Borrow(cminSubgroupSize_allocs)

	var cmaxSubgroupSize_allocs *cgoAllocMap
	ref9e562dc3.maxSubgroupSize, cmaxSubgroupSize_allocs = (C.uint32_t)(x.MaxSubgroupSize), cgoAllocsUnknown
	allocs9e562dc3.Borrow(cmaxSubgroupSize_allocs)

	var cmaxComputeWorkgroupSubgroups_allocs *cgoAllocMap
	ref9e562dc3.maxComputeWorkgroupSubgroups, cmaxComputeWorkgroupSubgroups_allocs = (C.uint32_t)(x.MaxComputeWorkgroupSubgroups), cgoAllocsUnknown
	allocs9e562dc3.Borrow(cmaxComputeWorkgroupSubgroups_allocs)

	var crequiredSubgroupSizeStages_allocs *cgoAllocMap
	ref9e562dc3.requiredSubgroupSizeStages, crequiredSubgroupSizeStages_allocs = (C.VkShaderStageFlags)(x.RequiredSubgroupSizeStages), cgoAllocsUnknown
	allocs9e562dc3.Borrow(crequiredSubgroupSizeStages_allocs)

	x.ref9e562dc3 = ref9e562dc3
	x.allocs9e562dc3 = allocs9e562dc3
	return ref9e562dc3, allocs9e562dc3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSubgroupSizeControlProperties) PassValue() (C.VkPhysicalDeviceSubgroupSizeControlPropertiesEXT, *cgoAllocMap) {
	if x.ref9e562dc3 != nil {
		return *x.ref9e562dc3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSubgroupSizeControlProperties) Deref() {
	if x.ref9e562dc3 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9e562dc3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9e562dc3.pNext))
	x.MinSubgroupSize = (uint32)(x.ref9e562dc3.minSubgroupSize)
	x.MaxSubgroupSize = (uint32)(x.ref9e562dc3.maxSubgroupSize)
	x.MaxComputeWorkgroupSubgroups = (uint32)(x.ref9e562dc3.maxComputeWorkgroupSubgroups)
	x.RequiredSubgroupSizeStages = (ShaderStageFlags)(x.ref9e562dc3.requiredSubgroupSizeStages)
}

// allocPipelineShaderStageRequiredSubgroupSizeCreateInfoMemory allocates memory for type C.VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineShaderStageRequiredSubgroupSizeCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineShaderStageRequiredSubgroupSizeCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineShaderStageRequiredSubgroupSizeCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineShaderStageRequiredSubgroupSizeCreateInfo) Ref() *C.VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref95ab965a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineShaderStageRequiredSubgroupSizeCreateInfo) Free() {
	if x != nil && x.allocs95ab965a != nil {
		x.allocs95ab965a.(*cgoAllocMap).Free()
		x.ref95ab965a = nil
	}
}

// NewPipelineShaderStageRequiredSubgroupSizeCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineShaderStageRequiredSubgroupSizeCreateInfoRef(ref unsafe.Pointer) *PipelineShaderStageRequiredSubgroupSizeCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineShaderStageRequiredSubgroupSizeCreateInfo)
	obj.ref95ab965a = (*C.VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineShaderStageRequiredSubgroupSizeCreateInfo) PassRef() (*C.VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref95ab965a != nil {
		return x.ref95ab965a, nil
	}
	mem95ab965a := allocPipelineShaderStageRequiredSubgroupSizeCreateInfoMemory(1)
	ref95ab965a := (*C.VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT)(mem95ab965a)
	allocs95ab965a := new(cgoAllocMap)
	allocs95ab965a.Add(mem95ab965a)

	var csType_allocs *cgoAllocMap
	ref95ab965a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs95ab965a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref95ab965a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs95ab965a.Borrow(cpNext_allocs)

	var crequiredSubgroupSize_allocs *cgoAllocMap
	ref95ab965a.requiredSubgroupSize, crequiredSubgroupSize_allocs = (C.uint32_t)(x.RequiredSubgroupSize), cgoAllocsUnknown
	allocs95ab965a.Borrow(crequiredSubgroupSize_allocs)

	x.ref95ab965a = ref95ab965a
	x.allocs95ab965a = allocs95ab965a
	return ref95ab965a, allocs95ab965a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineShaderStageRequiredSubgroupSizeCreateInfo) PassValue() (C.VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT, *cgoAllocMap) {
	if x.ref95ab965a != nil {
		return *x.ref95ab965a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineShaderStageRequiredSubgroupSizeCreateInfo) Deref() {
	if x.ref95ab965a == nil {
		return
	}
	x.SType = (StructureType)(x.ref95ab965a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref95ab965a.pNext))
	x.RequiredSubgroupSize = (uint32)(x.ref95ab965a.requiredSubgroupSize)
}

// allocPhysicalDeviceShaderCoreProperties2AMDMemory allocates memory for type C.VkPhysicalDeviceShaderCoreProperties2AMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderCoreProperties2AMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderCoreProperties2AMDValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShaderCoreProperties2AMDValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderCoreProperties2AMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderCoreProperties2AMD) Ref() *C.VkPhysicalDeviceShaderCoreProperties2AMD {
	if x == nil {
		return nil
	}
	return x.ref7be3d4c4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderCoreProperties2AMD) Free() {
	if x != nil && x.allocs7be3d4c4 != nil {
		x.allocs7be3d4c4.(*cgoAllocMap).Free()
		x.ref7be3d4c4 = nil
	}
}

// NewPhysicalDeviceShaderCoreProperties2AMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderCoreProperties2AMDRef(ref unsafe.Pointer) *PhysicalDeviceShaderCoreProperties2AMD {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderCoreProperties2AMD)
	obj.ref7be3d4c4 = (*C.VkPhysicalDeviceShaderCoreProperties2AMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderCoreProperties2AMD) PassRef() (*C.VkPhysicalDeviceShaderCoreProperties2AMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7be3d4c4 != nil {
		return x.ref7be3d4c4, nil
	}
	mem7be3d4c4 := allocPhysicalDeviceShaderCoreProperties2AMDMemory(1)
	ref7be3d4c4 := (*C.VkPhysicalDeviceShaderCoreProperties2AMD)(mem7be3d4c4)
	allocs7be3d4c4 := new(cgoAllocMap)
	allocs7be3d4c4.Add(mem7be3d4c4)

	var csType_allocs *cgoAllocMap
	ref7be3d4c4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7be3d4c4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7be3d4c4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7be3d4c4.Borrow(cpNext_allocs)

	var cshaderCoreFeatures_allocs *cgoAllocMap
	ref7be3d4c4.shaderCoreFeatures, cshaderCoreFeatures_allocs = (C.VkShaderCorePropertiesFlagsAMD)(x.ShaderCoreFeatures), cgoAllocsUnknown
	allocs7be3d4c4.Borrow(cshaderCoreFeatures_allocs)

	var cactiveComputeUnitCount_allocs *cgoAllocMap
	ref7be3d4c4.activeComputeUnitCount, cactiveComputeUnitCount_allocs = (C.uint32_t)(x.ActiveComputeUnitCount), cgoAllocsUnknown
	allocs7be3d4c4.Borrow(cactiveComputeUnitCount_allocs)

	x.ref7be3d4c4 = ref7be3d4c4
	x.allocs7be3d4c4 = allocs7be3d4c4
	return ref7be3d4c4, allocs7be3d4c4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderCoreProperties2AMD) PassValue() (C.VkPhysicalDeviceShaderCoreProperties2AMD, *cgoAllocMap) {
	if x.ref7be3d4c4 != nil {
		return *x.ref7be3d4c4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderCoreProperties2AMD) Deref() {
	if x.ref7be3d4c4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7be3d4c4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7be3d4c4.pNext))
	x.ShaderCoreFeatures = (ShaderCorePropertiesFlagsAMD)(x.ref7be3d4c4.shaderCoreFeatures)
	x.ActiveComputeUnitCount = (uint32)(x.ref7be3d4c4.activeComputeUnitCount)
}

// allocPhysicalDeviceCoherentMemoryFeaturesAMDMemory allocates memory for type C.VkPhysicalDeviceCoherentMemoryFeaturesAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceCoherentMemoryFeaturesAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceCoherentMemoryFeaturesAMDValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceCoherentMemoryFeaturesAMDValue = unsafe.Sizeof([1]C.VkPhysicalDeviceCoherentMemoryFeaturesAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceCoherentMemoryFeaturesAMD) Ref() *C.VkPhysicalDeviceCoherentMemoryFeaturesAMD {
	if x == nil {
		return nil
	}
	return x.ref34cb87b4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceCoherentMemoryFeaturesAMD) Free() {
	if x != nil && x.allocs34cb87b4 != nil {
		x.allocs34cb87b4.(*cgoAllocMap).Free()
		x.ref34cb87b4 = nil
	}
}

// NewPhysicalDeviceCoherentMemoryFeaturesAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceCoherentMemoryFeaturesAMDRef(ref unsafe.Pointer) *PhysicalDeviceCoherentMemoryFeaturesAMD {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceCoherentMemoryFeaturesAMD)
	obj.ref34cb87b4 = (*C.VkPhysicalDeviceCoherentMemoryFeaturesAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceCoherentMemoryFeaturesAMD) PassRef() (*C.VkPhysicalDeviceCoherentMemoryFeaturesAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref34cb87b4 != nil {
		return x.ref34cb87b4, nil
	}
	mem34cb87b4 := allocPhysicalDeviceCoherentMemoryFeaturesAMDMemory(1)
	ref34cb87b4 := (*C.VkPhysicalDeviceCoherentMemoryFeaturesAMD)(mem34cb87b4)
	allocs34cb87b4 := new(cgoAllocMap)
	allocs34cb87b4.Add(mem34cb87b4)

	var csType_allocs *cgoAllocMap
	ref34cb87b4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs34cb87b4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref34cb87b4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs34cb87b4.Borrow(cpNext_allocs)

	var cdeviceCoherentMemory_allocs *cgoAllocMap
	ref34cb87b4.deviceCoherentMemory, cdeviceCoherentMemory_allocs = (C.VkBool32)(x.DeviceCoherentMemory), cgoAllocsUnknown
	allocs34cb87b4.Borrow(cdeviceCoherentMemory_allocs)

	x.ref34cb87b4 = ref34cb87b4
	x.allocs34cb87b4 = allocs34cb87b4
	return ref34cb87b4, allocs34cb87b4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceCoherentMemoryFeaturesAMD) PassValue() (C.VkPhysicalDeviceCoherentMemoryFeaturesAMD, *cgoAllocMap) {
	if x.ref34cb87b4 != nil {
		return *x.ref34cb87b4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceCoherentMemoryFeaturesAMD) Deref() {
	if x.ref34cb87b4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref34cb87b4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref34cb87b4.pNext))
	x.DeviceCoherentMemory = (Bool32)(x.ref34cb87b4.deviceCoherentMemory)
}

// allocPhysicalDeviceShaderImageAtomicInt64FeaturesMemory allocates memory for type C.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderImageAtomicInt64FeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderImageAtomicInt64FeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShaderImageAtomicInt64FeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderImageAtomicInt64Features) Ref() *C.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref1b0fbd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderImageAtomicInt64Features) Free() {
	if x != nil && x.allocs1b0fbd != nil {
		x.allocs1b0fbd.(*cgoAllocMap).Free()
		x.ref1b0fbd = nil
	}
}

// NewPhysicalDeviceShaderImageAtomicInt64FeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderImageAtomicInt64FeaturesRef(ref unsafe.Pointer) *PhysicalDeviceShaderImageAtomicInt64Features {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderImageAtomicInt64Features)
	obj.ref1b0fbd = (*C.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderImageAtomicInt64Features) PassRef() (*C.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1b0fbd != nil {
		return x.ref1b0fbd, nil
	}
	mem1b0fbd := allocPhysicalDeviceShaderImageAtomicInt64FeaturesMemory(1)
	ref1b0fbd := (*C.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT)(mem1b0fbd)
	allocs1b0fbd := new(cgoAllocMap)
	allocs1b0fbd.Add(mem1b0fbd)

	var csType_allocs *cgoAllocMap
	ref1b0fbd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1b0fbd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1b0fbd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1b0fbd.Borrow(cpNext_allocs)

	var cshaderImageInt64Atomics_allocs *cgoAllocMap
	ref1b0fbd.shaderImageInt64Atomics, cshaderImageInt64Atomics_allocs = (C.VkBool32)(x.ShaderImageInt64Atomics), cgoAllocsUnknown
	allocs1b0fbd.Borrow(cshaderImageInt64Atomics_allocs)

	var csparseImageInt64Atomics_allocs *cgoAllocMap
	ref1b0fbd.sparseImageInt64Atomics, csparseImageInt64Atomics_allocs = (C.VkBool32)(x.SparseImageInt64Atomics), cgoAllocsUnknown
	allocs1b0fbd.Borrow(csparseImageInt64Atomics_allocs)

	x.ref1b0fbd = ref1b0fbd
	x.allocs1b0fbd = allocs1b0fbd
	return ref1b0fbd, allocs1b0fbd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderImageAtomicInt64Features) PassValue() (C.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, *cgoAllocMap) {
	if x.ref1b0fbd != nil {
		return *x.ref1b0fbd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderImageAtomicInt64Features) Deref() {
	if x.ref1b0fbd == nil {
		return
	}
	x.SType = (StructureType)(x.ref1b0fbd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1b0fbd.pNext))
	x.ShaderImageInt64Atomics = (Bool32)(x.ref1b0fbd.shaderImageInt64Atomics)
	x.SparseImageInt64Atomics = (Bool32)(x.ref1b0fbd.sparseImageInt64Atomics)
}

// allocPhysicalDeviceMemoryBudgetPropertiesMemory allocates memory for type C.VkPhysicalDeviceMemoryBudgetPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMemoryBudgetPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMemoryBudgetPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceMemoryBudgetPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMemoryBudgetPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMemoryBudgetProperties) Ref() *C.VkPhysicalDeviceMemoryBudgetPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refa7406c48
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMemoryBudgetProperties) Free() {
	if x != nil && x.allocsa7406c48 != nil {
		x.allocsa7406c48.(*cgoAllocMap).Free()
		x.refa7406c48 = nil
	}
}

// NewPhysicalDeviceMemoryBudgetPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMemoryBudgetPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceMemoryBudgetProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMemoryBudgetProperties)
	obj.refa7406c48 = (*C.VkPhysicalDeviceMemoryBudgetPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMemoryBudgetProperties) PassRef() (*C.VkPhysicalDeviceMemoryBudgetPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa7406c48 != nil {
		return x.refa7406c48, nil
	}
	mema7406c48 := allocPhysicalDeviceMemoryBudgetPropertiesMemory(1)
	refa7406c48 := (*C.VkPhysicalDeviceMemoryBudgetPropertiesEXT)(mema7406c48)
	allocsa7406c48 := new(cgoAllocMap)
	allocsa7406c48.Add(mema7406c48)

	var csType_allocs *cgoAllocMap
	refa7406c48.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa7406c48.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa7406c48.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa7406c48.Borrow(cpNext_allocs)

	var cheapBudget_allocs *cgoAllocMap
	refa7406c48.heapBudget, cheapBudget_allocs = *(*[16]C.VkDeviceSize)(unsafe.Pointer(&x.HeapBudget)), cgoAllocsUnknown
	allocsa7406c48.Borrow(cheapBudget_allocs)

	var cheapUsage_allocs *cgoAllocMap
	refa7406c48.heapUsage, cheapUsage_allocs = *(*[16]C.VkDeviceSize)(unsafe.Pointer(&x.HeapUsage)), cgoAllocsUnknown
	allocsa7406c48.Borrow(cheapUsage_allocs)

	x.refa7406c48 = refa7406c48
	x.allocsa7406c48 = allocsa7406c48
	return refa7406c48, allocsa7406c48

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMemoryBudgetProperties) PassValue() (C.VkPhysicalDeviceMemoryBudgetPropertiesEXT, *cgoAllocMap) {
	if x.refa7406c48 != nil {
		return *x.refa7406c48, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMemoryBudgetProperties) Deref() {
	if x.refa7406c48 == nil {
		return
	}
	x.SType = (StructureType)(x.refa7406c48.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa7406c48.pNext))
	x.HeapBudget = *(*[16]DeviceSize)(unsafe.Pointer(&x.refa7406c48.heapBudget))
	x.HeapUsage = *(*[16]DeviceSize)(unsafe.Pointer(&x.refa7406c48.heapUsage))
}

// allocPhysicalDeviceMemoryPriorityFeaturesMemory allocates memory for type C.VkPhysicalDeviceMemoryPriorityFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMemoryPriorityFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMemoryPriorityFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceMemoryPriorityFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMemoryPriorityFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMemoryPriorityFeatures) Ref() *C.VkPhysicalDeviceMemoryPriorityFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref24f8641c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMemoryPriorityFeatures) Free() {
	if x != nil && x.allocs24f8641c != nil {
		x.allocs24f8641c.(*cgoAllocMap).Free()
		x.ref24f8641c = nil
	}
}

// NewPhysicalDeviceMemoryPriorityFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMemoryPriorityFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceMemoryPriorityFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMemoryPriorityFeatures)
	obj.ref24f8641c = (*C.VkPhysicalDeviceMemoryPriorityFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMemoryPriorityFeatures) PassRef() (*C.VkPhysicalDeviceMemoryPriorityFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref24f8641c != nil {
		return x.ref24f8641c, nil
	}
	mem24f8641c := allocPhysicalDeviceMemoryPriorityFeaturesMemory(1)
	ref24f8641c := (*C.VkPhysicalDeviceMemoryPriorityFeaturesEXT)(mem24f8641c)
	allocs24f8641c := new(cgoAllocMap)
	allocs24f8641c.Add(mem24f8641c)

	var csType_allocs *cgoAllocMap
	ref24f8641c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs24f8641c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref24f8641c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs24f8641c.Borrow(cpNext_allocs)

	var cmemoryPriority_allocs *cgoAllocMap
	ref24f8641c.memoryPriority, cmemoryPriority_allocs = (C.VkBool32)(x.MemoryPriority), cgoAllocsUnknown
	allocs24f8641c.Borrow(cmemoryPriority_allocs)

	x.ref24f8641c = ref24f8641c
	x.allocs24f8641c = allocs24f8641c
	return ref24f8641c, allocs24f8641c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMemoryPriorityFeatures) PassValue() (C.VkPhysicalDeviceMemoryPriorityFeaturesEXT, *cgoAllocMap) {
	if x.ref24f8641c != nil {
		return *x.ref24f8641c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMemoryPriorityFeatures) Deref() {
	if x.ref24f8641c == nil {
		return
	}
	x.SType = (StructureType)(x.ref24f8641c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref24f8641c.pNext))
	x.MemoryPriority = (Bool32)(x.ref24f8641c.memoryPriority)
}

// allocMemoryPriorityAllocateInfoMemory allocates memory for type C.VkMemoryPriorityAllocateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryPriorityAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryPriorityAllocateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryPriorityAllocateInfoValue = unsafe.Sizeof([1]C.VkMemoryPriorityAllocateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryPriorityAllocateInfo) Ref() *C.VkMemoryPriorityAllocateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refd3540846
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryPriorityAllocateInfo) Free() {
	if x != nil && x.allocsd3540846 != nil {
		x.allocsd3540846.(*cgoAllocMap).Free()
		x.refd3540846 = nil
	}
}

// NewMemoryPriorityAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryPriorityAllocateInfoRef(ref unsafe.Pointer) *MemoryPriorityAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(MemoryPriorityAllocateInfo)
	obj.refd3540846 = (*C.VkMemoryPriorityAllocateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryPriorityAllocateInfo) PassRef() (*C.VkMemoryPriorityAllocateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd3540846 != nil {
		return x.refd3540846, nil
	}
	memd3540846 := allocMemoryPriorityAllocateInfoMemory(1)
	refd3540846 := (*C.VkMemoryPriorityAllocateInfoEXT)(memd3540846)
	allocsd3540846 := new(cgoAllocMap)
	allocsd3540846.Add(memd3540846)

	var csType_allocs *cgoAllocMap
	refd3540846.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd3540846.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd3540846.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd3540846.Borrow(cpNext_allocs)

	var cpriority_allocs *cgoAllocMap
	refd3540846.priority, cpriority_allocs = (C.float)(x.Priority), cgoAllocsUnknown
	allocsd3540846.Borrow(cpriority_allocs)

	x.refd3540846 = refd3540846
	x.allocsd3540846 = allocsd3540846
	return refd3540846, allocsd3540846

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryPriorityAllocateInfo) PassValue() (C.VkMemoryPriorityAllocateInfoEXT, *cgoAllocMap) {
	if x.refd3540846 != nil {
		return *x.refd3540846, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryPriorityAllocateInfo) Deref() {
	if x.refd3540846 == nil {
		return
	}
	x.SType = (StructureType)(x.refd3540846.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd3540846.pNext))
	x.Priority = (float32)(x.refd3540846.priority)
}

// allocPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV) Ref() *C.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
	if x == nil {
		return nil
	}
	return x.refade17227
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV) Free() {
	if x != nil && x.allocsade17227 != nil {
		x.allocsade17227.(*cgoAllocMap).Free()
		x.refade17227 = nil
	}
}

// NewPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV)
	obj.refade17227 = (*C.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV) PassRef() (*C.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refade17227 != nil {
		return x.refade17227, nil
	}
	memade17227 := allocPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVMemory(1)
	refade17227 := (*C.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV)(memade17227)
	allocsade17227 := new(cgoAllocMap)
	allocsade17227.Add(memade17227)

	var csType_allocs *cgoAllocMap
	refade17227.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsade17227.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refade17227.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsade17227.Borrow(cpNext_allocs)

	var cdedicatedAllocationImageAliasing_allocs *cgoAllocMap
	refade17227.dedicatedAllocationImageAliasing, cdedicatedAllocationImageAliasing_allocs = (C.VkBool32)(x.DedicatedAllocationImageAliasing), cgoAllocsUnknown
	allocsade17227.Borrow(cdedicatedAllocationImageAliasing_allocs)

	x.refade17227 = refade17227
	x.allocsade17227 = allocsade17227
	return refade17227, allocsade17227

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV) PassValue() (C.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, *cgoAllocMap) {
	if x.refade17227 != nil {
		return *x.refade17227, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV) Deref() {
	if x.refade17227 == nil {
		return
	}
	x.SType = (StructureType)(x.refade17227.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refade17227.pNext))
	x.DedicatedAllocationImageAliasing = (Bool32)(x.refade17227.dedicatedAllocationImageAliasing)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceBufferAddressFeatures) Ref() *C.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refe3bd03a5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceBufferAddressFeatures) Free() {
	if x != nil && x.allocse3bd03a5 != nil {
		x.allocse3bd03a5.(*cgoAllocMap).Free()
		x.refe3bd03a5 = nil
	}
}

// NewPhysicalDeviceBufferAddressFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceBufferAddressFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceBufferAddressFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceBufferAddressFeatures)
	obj.refe3bd03a5 = (*C.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceBufferAddressFeatures) PassRef() (*C.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe3bd03a5 != nil {
		return x.refe3bd03a5, nil
	}
	meme3bd03a5 := allocPhysicalDeviceBufferDeviceAddressFeaturesMemory(1)
	refe3bd03a5 := (*C.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT)(meme3bd03a5)
	allocse3bd03a5 := new(cgoAllocMap)
	allocse3bd03a5.Add(meme3bd03a5)

	var csType_allocs *cgoAllocMap
	refe3bd03a5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse3bd03a5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe3bd03a5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse3bd03a5.Borrow(cpNext_allocs)

	var cbufferDeviceAddress_allocs *cgoAllocMap
	refe3bd03a5.bufferDeviceAddress, cbufferDeviceAddress_allocs = (C.VkBool32)(x.BufferDeviceAddress), cgoAllocsUnknown
	allocse3bd03a5.Borrow(cbufferDeviceAddress_allocs)

	var cbufferDeviceAddressCaptureReplay_allocs *cgoAllocMap
	refe3bd03a5.bufferDeviceAddressCaptureReplay, cbufferDeviceAddressCaptureReplay_allocs = (C.VkBool32)(x.BufferDeviceAddressCaptureReplay), cgoAllocsUnknown
	allocse3bd03a5.Borrow(cbufferDeviceAddressCaptureReplay_allocs)

	var cbufferDeviceAddressMultiDevice_allocs *cgoAllocMap
	refe3bd03a5.bufferDeviceAddressMultiDevice, cbufferDeviceAddressMultiDevice_allocs = (C.VkBool32)(x.BufferDeviceAddressMultiDevice), cgoAllocsUnknown
	allocse3bd03a5.Borrow(cbufferDeviceAddressMultiDevice_allocs)

	x.refe3bd03a5 = refe3bd03a5
	x.allocse3bd03a5 = allocse3bd03a5
	return refe3bd03a5, allocse3bd03a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceBufferAddressFeatures) PassValue() (C.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, *cgoAllocMap) {
	if x.refe3bd03a5 != nil {
		return *x.refe3bd03a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceBufferAddressFeatures) Deref() {
	if x.refe3bd03a5 == nil {
		return
	}
	x.SType = (StructureType)(x.refe3bd03a5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe3bd03a5.pNext))
	x.BufferDeviceAddress = (Bool32)(x.refe3bd03a5.bufferDeviceAddress)
	x.BufferDeviceAddressCaptureReplay = (Bool32)(x.refe3bd03a5.bufferDeviceAddressCaptureReplay)
	x.BufferDeviceAddressMultiDevice = (Bool32)(x.refe3bd03a5.bufferDeviceAddressMultiDevice)
}

// allocBufferDeviceAddressCreateInfoMemory allocates memory for type C.VkBufferDeviceAddressCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferDeviceAddressCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferDeviceAddressCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferDeviceAddressCreateInfoValue = unsafe.Sizeof([1]C.VkBufferDeviceAddressCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferDeviceAddressCreateInfo) Ref() *C.VkBufferDeviceAddressCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref4c6937a9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferDeviceAddressCreateInfo) Free() {
	if x != nil && x.allocs4c6937a9 != nil {
		x.allocs4c6937a9.(*cgoAllocMap).Free()
		x.ref4c6937a9 = nil
	}
}

// NewBufferDeviceAddressCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferDeviceAddressCreateInfoRef(ref unsafe.Pointer) *BufferDeviceAddressCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(BufferDeviceAddressCreateInfo)
	obj.ref4c6937a9 = (*C.VkBufferDeviceAddressCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferDeviceAddressCreateInfo) PassRef() (*C.VkBufferDeviceAddressCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4c6937a9 != nil {
		return x.ref4c6937a9, nil
	}
	mem4c6937a9 := allocBufferDeviceAddressCreateInfoMemory(1)
	ref4c6937a9 := (*C.VkBufferDeviceAddressCreateInfoEXT)(mem4c6937a9)
	allocs4c6937a9 := new(cgoAllocMap)
	allocs4c6937a9.Add(mem4c6937a9)

	var csType_allocs *cgoAllocMap
	ref4c6937a9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4c6937a9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4c6937a9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4c6937a9.Borrow(cpNext_allocs)

	var cdeviceAddress_allocs *cgoAllocMap
	ref4c6937a9.deviceAddress, cdeviceAddress_allocs = (C.VkDeviceAddress)(x.DeviceAddress), cgoAllocsUnknown
	allocs4c6937a9.Borrow(cdeviceAddress_allocs)

	x.ref4c6937a9 = ref4c6937a9
	x.allocs4c6937a9 = allocs4c6937a9
	return ref4c6937a9, allocs4c6937a9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferDeviceAddressCreateInfo) PassValue() (C.VkBufferDeviceAddressCreateInfoEXT, *cgoAllocMap) {
	if x.ref4c6937a9 != nil {
		return *x.ref4c6937a9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferDeviceAddressCreateInfo) Deref() {
	if x.ref4c6937a9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref4c6937a9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4c6937a9.pNext))
	x.DeviceAddress = (DeviceAddress)(x.ref4c6937a9.deviceAddress)
}

// allocPhysicalDeviceToolPropertiesMemory allocates memory for type C.VkPhysicalDeviceToolPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceToolPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceToolPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceToolPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceToolPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceToolProperties) Ref() *C.VkPhysicalDeviceToolPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref65fc0364
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceToolProperties) Free() {
	if x != nil && x.allocs65fc0364 != nil {
		x.allocs65fc0364.(*cgoAllocMap).Free()
		x.ref65fc0364 = nil
	}
}

// NewPhysicalDeviceToolPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceToolPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceToolProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceToolProperties)
	obj.ref65fc0364 = (*C.VkPhysicalDeviceToolPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceToolProperties) PassRef() (*C.VkPhysicalDeviceToolPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref65fc0364 != nil {
		return x.ref65fc0364, nil
	}
	mem65fc0364 := allocPhysicalDeviceToolPropertiesMemory(1)
	ref65fc0364 := (*C.VkPhysicalDeviceToolPropertiesEXT)(mem65fc0364)
	allocs65fc0364 := new(cgoAllocMap)
	allocs65fc0364.Add(mem65fc0364)

	var csType_allocs *cgoAllocMap
	ref65fc0364.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs65fc0364.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref65fc0364.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs65fc0364.Borrow(cpNext_allocs)

	var cname_allocs *cgoAllocMap
	ref65fc0364.name, cname_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Name)), cgoAllocsUnknown
	allocs65fc0364.Borrow(cname_allocs)

	var cversion_allocs *cgoAllocMap
	ref65fc0364.version, cversion_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Version)), cgoAllocsUnknown
	allocs65fc0364.Borrow(cversion_allocs)

	var cpurposes_allocs *cgoAllocMap
	ref65fc0364.purposes, cpurposes_allocs = (C.VkToolPurposeFlagsEXT)(x.Purposes), cgoAllocsUnknown
	allocs65fc0364.Borrow(cpurposes_allocs)

	var cdescription_allocs *cgoAllocMap
	ref65fc0364.description, cdescription_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Description)), cgoAllocsUnknown
	allocs65fc0364.Borrow(cdescription_allocs)

	var clayer_allocs *cgoAllocMap
	ref65fc0364.layer, clayer_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Layer)), cgoAllocsUnknown
	allocs65fc0364.Borrow(clayer_allocs)

	x.ref65fc0364 = ref65fc0364
	x.allocs65fc0364 = allocs65fc0364
	return ref65fc0364, allocs65fc0364

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceToolProperties) PassValue() (C.VkPhysicalDeviceToolPropertiesEXT, *cgoAllocMap) {
	if x.ref65fc0364 != nil {
		return *x.ref65fc0364, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceToolProperties) Deref() {
	if x.ref65fc0364 == nil {
		return
	}
	x.SType = (StructureType)(x.ref65fc0364.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref65fc0364.pNext))
	x.Name = *(*[256]byte)(unsafe.Pointer(&x.ref65fc0364.name))
	x.Version = *(*[256]byte)(unsafe.Pointer(&x.ref65fc0364.version))
	x.Purposes = (ToolPurposeFlags)(x.ref65fc0364.purposes)
	x.Description = *(*[256]byte)(unsafe.Pointer(&x.ref65fc0364.description))
	x.Layer = *(*[256]byte)(unsafe.Pointer(&x.ref65fc0364.layer))
}

// allocValidationFeaturesMemory allocates memory for type C.VkValidationFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValidationFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValidationFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfValidationFeaturesValue = unsafe.Sizeof([1]C.VkValidationFeaturesEXT{})

// copyPValidationFeatureEnableBytes copies the data from Go slice as *C.VkValidationFeatureEnableEXT.
func copyPValidationFeatureEnableBytes(slice *sliceHeader) (*C.VkValidationFeatureEnableEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfValidationFeatureEnableValue) * slice.Len,
		Cap:  int(sizeOfValidationFeatureEnableValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkValidationFeatureEnableEXT)(mem0), allocs
}

// allocValidationFeatureEnableMemory allocates memory for type C.VkValidationFeatureEnableEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValidationFeatureEnableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValidationFeatureEnableValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfValidationFeatureEnableValue = unsafe.Sizeof([1]C.VkValidationFeatureEnableEXT{})

// copyPValidationFeatureDisableBytes copies the data from Go slice as *C.VkValidationFeatureDisableEXT.
func copyPValidationFeatureDisableBytes(slice *sliceHeader) (*C.VkValidationFeatureDisableEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfValidationFeatureDisableValue) * slice.Len,
		Cap:  int(sizeOfValidationFeatureDisableValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkValidationFeatureDisableEXT)(mem0), allocs
}

// allocValidationFeatureDisableMemory allocates memory for type C.VkValidationFeatureDisableEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValidationFeatureDisableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValidationFeatureDisableValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfValidationFeatureDisableValue = unsafe.Sizeof([1]C.VkValidationFeatureDisableEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ValidationFeatures) Ref() *C.VkValidationFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refcd8794ea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ValidationFeatures) Free() {
	if x != nil && x.allocscd8794ea != nil {
		x.allocscd8794ea.(*cgoAllocMap).Free()
		x.refcd8794ea = nil
	}
}

// NewValidationFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewValidationFeaturesRef(ref unsafe.Pointer) *ValidationFeatures {
	if ref == nil {
		return nil
	}
	obj := new(ValidationFeatures)
	obj.refcd8794ea = (*C.VkValidationFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ValidationFeatures) PassRef() (*C.VkValidationFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcd8794ea != nil {
		return x.refcd8794ea, nil
	}
	memcd8794ea := allocValidationFeaturesMemory(1)
	refcd8794ea := (*C.VkValidationFeaturesEXT)(memcd8794ea)
	allocscd8794ea := new(cgoAllocMap)
	allocscd8794ea.Add(memcd8794ea)

	var csType_allocs *cgoAllocMap
	refcd8794ea.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscd8794ea.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcd8794ea.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscd8794ea.Borrow(cpNext_allocs)

	var cenabledValidationFeatureCount_allocs *cgoAllocMap
	refcd8794ea.enabledValidationFeatureCount, cenabledValidationFeatureCount_allocs = (C.uint32_t)(x.EnabledValidationFeatureCount), cgoAllocsUnknown
	allocscd8794ea.Borrow(cenabledValidationFeatureCount_allocs)

	var cpEnabledValidationFeatures_allocs *cgoAllocMap
	refcd8794ea.pEnabledValidationFeatures, cpEnabledValidationFeatures_allocs = copyPValidationFeatureEnableBytes((*sliceHeader)(unsafe.Pointer(&x.PEnabledValidationFeatures)))
	allocscd8794ea.Borrow(cpEnabledValidationFeatures_allocs)

	var cdisabledValidationFeatureCount_allocs *cgoAllocMap
	refcd8794ea.disabledValidationFeatureCount, cdisabledValidationFeatureCount_allocs = (C.uint32_t)(x.DisabledValidationFeatureCount), cgoAllocsUnknown
	allocscd8794ea.Borrow(cdisabledValidationFeatureCount_allocs)

	var cpDisabledValidationFeatures_allocs *cgoAllocMap
	refcd8794ea.pDisabledValidationFeatures, cpDisabledValidationFeatures_allocs = copyPValidationFeatureDisableBytes((*sliceHeader)(unsafe.Pointer(&x.PDisabledValidationFeatures)))
	allocscd8794ea.Borrow(cpDisabledValidationFeatures_allocs)

	x.refcd8794ea = refcd8794ea
	x.allocscd8794ea = allocscd8794ea
	return refcd8794ea, allocscd8794ea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ValidationFeatures) PassValue() (C.VkValidationFeaturesEXT, *cgoAllocMap) {
	if x.refcd8794ea != nil {
		return *x.refcd8794ea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ValidationFeatures) Deref() {
	if x.refcd8794ea == nil {
		return
	}
	x.SType = (StructureType)(x.refcd8794ea.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcd8794ea.pNext))
	x.EnabledValidationFeatureCount = (uint32)(x.refcd8794ea.enabledValidationFeatureCount)
	hxf9b1633 := (*sliceHeader)(unsafe.Pointer(&x.PEnabledValidationFeatures))
	hxf9b1633.Data = unsafe.Pointer(x.refcd8794ea.pEnabledValidationFeatures)
	hxf9b1633.Cap = 0x7fffffff
	// hxf9b1633.Len = ?

	x.DisabledValidationFeatureCount = (uint32)(x.refcd8794ea.disabledValidationFeatureCount)
	hxf502c9a := (*sliceHeader)(unsafe.Pointer(&x.PDisabledValidationFeatures))
	hxf502c9a.Data = unsafe.Pointer(x.refcd8794ea.pDisabledValidationFeatures)
	hxf502c9a.Cap = 0x7fffffff
	// hxf502c9a.Len = ?

}

// allocCooperativeMatrixPropertiesNVMemory allocates memory for type C.VkCooperativeMatrixPropertiesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCooperativeMatrixPropertiesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCooperativeMatrixPropertiesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCooperativeMatrixPropertiesNVValue = unsafe.Sizeof([1]C.VkCooperativeMatrixPropertiesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CooperativeMatrixPropertiesNV) Ref() *C.VkCooperativeMatrixPropertiesNV {
	if x == nil {
		return nil
	}
	return x.ref4302be60
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CooperativeMatrixPropertiesNV) Free() {
	if x != nil && x.allocs4302be60 != nil {
		x.allocs4302be60.(*cgoAllocMap).Free()
		x.ref4302be60 = nil
	}
}

// NewCooperativeMatrixPropertiesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCooperativeMatrixPropertiesNVRef(ref unsafe.Pointer) *CooperativeMatrixPropertiesNV {
	if ref == nil {
		return nil
	}
	obj := new(CooperativeMatrixPropertiesNV)
	obj.ref4302be60 = (*C.VkCooperativeMatrixPropertiesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CooperativeMatrixPropertiesNV) PassRef() (*C.VkCooperativeMatrixPropertiesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4302be60 != nil {
		return x.ref4302be60, nil
	}
	mem4302be60 := allocCooperativeMatrixPropertiesNVMemory(1)
	ref4302be60 := (*C.VkCooperativeMatrixPropertiesNV)(mem4302be60)
	allocs4302be60 := new(cgoAllocMap)
	allocs4302be60.Add(mem4302be60)

	var csType_allocs *cgoAllocMap
	ref4302be60.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4302be60.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4302be60.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4302be60.Borrow(cpNext_allocs)

	var cMSize_allocs *cgoAllocMap
	ref4302be60.MSize, cMSize_allocs = (C.uint32_t)(x.MSize), cgoAllocsUnknown
	allocs4302be60.Borrow(cMSize_allocs)

	var cNSize_allocs *cgoAllocMap
	ref4302be60.NSize, cNSize_allocs = (C.uint32_t)(x.NSize), cgoAllocsUnknown
	allocs4302be60.Borrow(cNSize_allocs)

	var cKSize_allocs *cgoAllocMap
	ref4302be60.KSize, cKSize_allocs = (C.uint32_t)(x.KSize), cgoAllocsUnknown
	allocs4302be60.Borrow(cKSize_allocs)

	var cAType_allocs *cgoAllocMap
	ref4302be60.AType, cAType_allocs = (C.VkComponentTypeNV)(x.AType), cgoAllocsUnknown
	allocs4302be60.Borrow(cAType_allocs)

	var cBType_allocs *cgoAllocMap
	ref4302be60.BType, cBType_allocs = (C.VkComponentTypeNV)(x.BType), cgoAllocsUnknown
	allocs4302be60.Borrow(cBType_allocs)

	var cCType_allocs *cgoAllocMap
	ref4302be60.CType, cCType_allocs = (C.VkComponentTypeNV)(x.CType), cgoAllocsUnknown
	allocs4302be60.Borrow(cCType_allocs)

	var cDType_allocs *cgoAllocMap
	ref4302be60.DType, cDType_allocs = (C.VkComponentTypeNV)(x.DType), cgoAllocsUnknown
	allocs4302be60.Borrow(cDType_allocs)

	var cscope_allocs *cgoAllocMap
	ref4302be60.scope, cscope_allocs = (C.VkScopeNV)(x.Scope), cgoAllocsUnknown
	allocs4302be60.Borrow(cscope_allocs)

	x.ref4302be60 = ref4302be60
	x.allocs4302be60 = allocs4302be60
	return ref4302be60, allocs4302be60

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CooperativeMatrixPropertiesNV) PassValue() (C.VkCooperativeMatrixPropertiesNV, *cgoAllocMap) {
	if x.ref4302be60 != nil {
		return *x.ref4302be60, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CooperativeMatrixPropertiesNV) Deref() {
	if x.ref4302be60 == nil {
		return
	}
	x.SType = (StructureType)(x.ref4302be60.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4302be60.pNext))
	x.MSize = (uint32)(x.ref4302be60.MSize)
	x.NSize = (uint32)(x.ref4302be60.NSize)
	x.KSize = (uint32)(x.ref4302be60.KSize)
	x.AType = (ComponentTypeNV)(x.ref4302be60.AType)
	x.BType = (ComponentTypeNV)(x.ref4302be60.BType)
	x.CType = (ComponentTypeNV)(x.ref4302be60.CType)
	x.DType = (ComponentTypeNV)(x.ref4302be60.DType)
	x.Scope = (ScopeNV)(x.ref4302be60.scope)
}

// allocPhysicalDeviceCooperativeMatrixFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceCooperativeMatrixFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceCooperativeMatrixFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceCooperativeMatrixFeaturesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceCooperativeMatrixFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceCooperativeMatrixFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceCooperativeMatrixFeaturesNV) Ref() *C.VkPhysicalDeviceCooperativeMatrixFeaturesNV {
	if x == nil {
		return nil
	}
	return x.refff45ea3f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceCooperativeMatrixFeaturesNV) Free() {
	if x != nil && x.allocsff45ea3f != nil {
		x.allocsff45ea3f.(*cgoAllocMap).Free()
		x.refff45ea3f = nil
	}
}

// NewPhysicalDeviceCooperativeMatrixFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceCooperativeMatrixFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceCooperativeMatrixFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceCooperativeMatrixFeaturesNV)
	obj.refff45ea3f = (*C.VkPhysicalDeviceCooperativeMatrixFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceCooperativeMatrixFeaturesNV) PassRef() (*C.VkPhysicalDeviceCooperativeMatrixFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff45ea3f != nil {
		return x.refff45ea3f, nil
	}
	memff45ea3f := allocPhysicalDeviceCooperativeMatrixFeaturesNVMemory(1)
	refff45ea3f := (*C.VkPhysicalDeviceCooperativeMatrixFeaturesNV)(memff45ea3f)
	allocsff45ea3f := new(cgoAllocMap)
	allocsff45ea3f.Add(memff45ea3f)

	var csType_allocs *cgoAllocMap
	refff45ea3f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsff45ea3f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refff45ea3f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsff45ea3f.Borrow(cpNext_allocs)

	var ccooperativeMatrix_allocs *cgoAllocMap
	refff45ea3f.cooperativeMatrix, ccooperativeMatrix_allocs = (C.VkBool32)(x.CooperativeMatrix), cgoAllocsUnknown
	allocsff45ea3f.Borrow(ccooperativeMatrix_allocs)

	var ccooperativeMatrixRobustBufferAccess_allocs *cgoAllocMap
	refff45ea3f.cooperativeMatrixRobustBufferAccess, ccooperativeMatrixRobustBufferAccess_allocs = (C.VkBool32)(x.CooperativeMatrixRobustBufferAccess), cgoAllocsUnknown
	allocsff45ea3f.Borrow(ccooperativeMatrixRobustBufferAccess_allocs)

	x.refff45ea3f = refff45ea3f
	x.allocsff45ea3f = allocsff45ea3f
	return refff45ea3f, allocsff45ea3f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceCooperativeMatrixFeaturesNV) PassValue() (C.VkPhysicalDeviceCooperativeMatrixFeaturesNV, *cgoAllocMap) {
	if x.refff45ea3f != nil {
		return *x.refff45ea3f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceCooperativeMatrixFeaturesNV) Deref() {
	if x.refff45ea3f == nil {
		return
	}
	x.SType = (StructureType)(x.refff45ea3f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refff45ea3f.pNext))
	x.CooperativeMatrix = (Bool32)(x.refff45ea3f.cooperativeMatrix)
	x.CooperativeMatrixRobustBufferAccess = (Bool32)(x.refff45ea3f.cooperativeMatrixRobustBufferAccess)
}

// allocPhysicalDeviceCooperativeMatrixPropertiesNVMemory allocates memory for type C.VkPhysicalDeviceCooperativeMatrixPropertiesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceCooperativeMatrixPropertiesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceCooperativeMatrixPropertiesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceCooperativeMatrixPropertiesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceCooperativeMatrixPropertiesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceCooperativeMatrixPropertiesNV) Ref() *C.VkPhysicalDeviceCooperativeMatrixPropertiesNV {
	if x == nil {
		return nil
	}
	return x.ref45336143
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceCooperativeMatrixPropertiesNV) Free() {
	if x != nil && x.allocs45336143 != nil {
		x.allocs45336143.(*cgoAllocMap).Free()
		x.ref45336143 = nil
	}
}

// NewPhysicalDeviceCooperativeMatrixPropertiesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceCooperativeMatrixPropertiesNVRef(ref unsafe.Pointer) *PhysicalDeviceCooperativeMatrixPropertiesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceCooperativeMatrixPropertiesNV)
	obj.ref45336143 = (*C.VkPhysicalDeviceCooperativeMatrixPropertiesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceCooperativeMatrixPropertiesNV) PassRef() (*C.VkPhysicalDeviceCooperativeMatrixPropertiesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref45336143 != nil {
		return x.ref45336143, nil
	}
	mem45336143 := allocPhysicalDeviceCooperativeMatrixPropertiesNVMemory(1)
	ref45336143 := (*C.VkPhysicalDeviceCooperativeMatrixPropertiesNV)(mem45336143)
	allocs45336143 := new(cgoAllocMap)
	allocs45336143.Add(mem45336143)

	var csType_allocs *cgoAllocMap
	ref45336143.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs45336143.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref45336143.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs45336143.Borrow(cpNext_allocs)

	var ccooperativeMatrixSupportedStages_allocs *cgoAllocMap
	ref45336143.cooperativeMatrixSupportedStages, ccooperativeMatrixSupportedStages_allocs = (C.VkShaderStageFlags)(x.CooperativeMatrixSupportedStages), cgoAllocsUnknown
	allocs45336143.Borrow(ccooperativeMatrixSupportedStages_allocs)

	x.ref45336143 = ref45336143
	x.allocs45336143 = allocs45336143
	return ref45336143, allocs45336143

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceCooperativeMatrixPropertiesNV) PassValue() (C.VkPhysicalDeviceCooperativeMatrixPropertiesNV, *cgoAllocMap) {
	if x.ref45336143 != nil {
		return *x.ref45336143, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceCooperativeMatrixPropertiesNV) Deref() {
	if x.ref45336143 == nil {
		return
	}
	x.SType = (StructureType)(x.ref45336143.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref45336143.pNext))
	x.CooperativeMatrixSupportedStages = (ShaderStageFlags)(x.ref45336143.cooperativeMatrixSupportedStages)
}

// allocPhysicalDeviceCoverageReductionModeFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceCoverageReductionModeFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceCoverageReductionModeFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceCoverageReductionModeFeaturesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceCoverageReductionModeFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceCoverageReductionModeFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceCoverageReductionModeFeaturesNV) Ref() *C.VkPhysicalDeviceCoverageReductionModeFeaturesNV {
	if x == nil {
		return nil
	}
	return x.ref1066c79
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceCoverageReductionModeFeaturesNV) Free() {
	if x != nil && x.allocs1066c79 != nil {
		x.allocs1066c79.(*cgoAllocMap).Free()
		x.ref1066c79 = nil
	}
}

// NewPhysicalDeviceCoverageReductionModeFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceCoverageReductionModeFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceCoverageReductionModeFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceCoverageReductionModeFeaturesNV)
	obj.ref1066c79 = (*C.VkPhysicalDeviceCoverageReductionModeFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceCoverageReductionModeFeaturesNV) PassRef() (*C.VkPhysicalDeviceCoverageReductionModeFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1066c79 != nil {
		return x.ref1066c79, nil
	}
	mem1066c79 := allocPhysicalDeviceCoverageReductionModeFeaturesNVMemory(1)
	ref1066c79 := (*C.VkPhysicalDeviceCoverageReductionModeFeaturesNV)(mem1066c79)
	allocs1066c79 := new(cgoAllocMap)
	allocs1066c79.Add(mem1066c79)

	var csType_allocs *cgoAllocMap
	ref1066c79.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1066c79.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1066c79.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1066c79.Borrow(cpNext_allocs)

	var ccoverageReductionMode_allocs *cgoAllocMap
	ref1066c79.coverageReductionMode, ccoverageReductionMode_allocs = (C.VkBool32)(x.CoverageReductionMode), cgoAllocsUnknown
	allocs1066c79.Borrow(ccoverageReductionMode_allocs)

	x.ref1066c79 = ref1066c79
	x.allocs1066c79 = allocs1066c79
	return ref1066c79, allocs1066c79

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceCoverageReductionModeFeaturesNV) PassValue() (C.VkPhysicalDeviceCoverageReductionModeFeaturesNV, *cgoAllocMap) {
	if x.ref1066c79 != nil {
		return *x.ref1066c79, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceCoverageReductionModeFeaturesNV) Deref() {
	if x.ref1066c79 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1066c79.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1066c79.pNext))
	x.CoverageReductionMode = (Bool32)(x.ref1066c79.coverageReductionMode)
}

// allocPipelineCoverageReductionStateCreateInfoNVMemory allocates memory for type C.VkPipelineCoverageReductionStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCoverageReductionStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCoverageReductionStateCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineCoverageReductionStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineCoverageReductionStateCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineCoverageReductionStateCreateInfoNV) Ref() *C.VkPipelineCoverageReductionStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref39db618c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineCoverageReductionStateCreateInfoNV) Free() {
	if x != nil && x.allocs39db618c != nil {
		x.allocs39db618c.(*cgoAllocMap).Free()
		x.ref39db618c = nil
	}
}

// NewPipelineCoverageReductionStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineCoverageReductionStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineCoverageReductionStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCoverageReductionStateCreateInfoNV)
	obj.ref39db618c = (*C.VkPipelineCoverageReductionStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineCoverageReductionStateCreateInfoNV) PassRef() (*C.VkPipelineCoverageReductionStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref39db618c != nil {
		return x.ref39db618c, nil
	}
	mem39db618c := allocPipelineCoverageReductionStateCreateInfoNVMemory(1)
	ref39db618c := (*C.VkPipelineCoverageReductionStateCreateInfoNV)(mem39db618c)
	allocs39db618c := new(cgoAllocMap)
	allocs39db618c.Add(mem39db618c)

	var csType_allocs *cgoAllocMap
	ref39db618c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs39db618c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref39db618c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs39db618c.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref39db618c.flags, cflags_allocs = (C.VkPipelineCoverageReductionStateCreateFlagsNV)(x.Flags), cgoAllocsUnknown
	allocs39db618c.Borrow(cflags_allocs)

	var ccoverageReductionMode_allocs *cgoAllocMap
	ref39db618c.coverageReductionMode, ccoverageReductionMode_allocs = (C.VkCoverageReductionModeNV)(x.CoverageReductionMode), cgoAllocsUnknown
	allocs39db618c.Borrow(ccoverageReductionMode_allocs)

	x.ref39db618c = ref39db618c
	x.allocs39db618c = allocs39db618c
	return ref39db618c, allocs39db618c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineCoverageReductionStateCreateInfoNV) PassValue() (C.VkPipelineCoverageReductionStateCreateInfoNV, *cgoAllocMap) {
	if x.ref39db618c != nil {
		return *x.ref39db618c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineCoverageReductionStateCreateInfoNV) Deref() {
	if x.ref39db618c == nil {
		return
	}
	x.SType = (StructureType)(x.ref39db618c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref39db618c.pNext))
	x.Flags = (PipelineCoverageReductionStateCreateFlagsNV)(x.ref39db618c.flags)
	x.CoverageReductionMode = (CoverageReductionModeNV)(x.ref39db618c.coverageReductionMode)
}

// allocFramebufferMixedSamplesCombinationNVMemory allocates memory for type C.VkFramebufferMixedSamplesCombinationNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFramebufferMixedSamplesCombinationNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFramebufferMixedSamplesCombinationNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFramebufferMixedSamplesCombinationNVValue = unsafe.Sizeof([1]C.VkFramebufferMixedSamplesCombinationNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FramebufferMixedSamplesCombinationNV) Ref() *C.VkFramebufferMixedSamplesCombinationNV {
	if x == nil {
		return nil
	}
	return x.ref75affbab
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FramebufferMixedSamplesCombinationNV) Free() {
	if x != nil && x.allocs75affbab != nil {
		x.allocs75affbab.(*cgoAllocMap).Free()
		x.ref75affbab = nil
	}
}

// NewFramebufferMixedSamplesCombinationNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFramebufferMixedSamplesCombinationNVRef(ref unsafe.Pointer) *FramebufferMixedSamplesCombinationNV {
	if ref == nil {
		return nil
	}
	obj := new(FramebufferMixedSamplesCombinationNV)
	obj.ref75affbab = (*C.VkFramebufferMixedSamplesCombinationNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FramebufferMixedSamplesCombinationNV) PassRef() (*C.VkFramebufferMixedSamplesCombinationNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75affbab != nil {
		return x.ref75affbab, nil
	}
	mem75affbab := allocFramebufferMixedSamplesCombinationNVMemory(1)
	ref75affbab := (*C.VkFramebufferMixedSamplesCombinationNV)(mem75affbab)
	allocs75affbab := new(cgoAllocMap)
	allocs75affbab.Add(mem75affbab)

	var csType_allocs *cgoAllocMap
	ref75affbab.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs75affbab.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref75affbab.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs75affbab.Borrow(cpNext_allocs)

	var ccoverageReductionMode_allocs *cgoAllocMap
	ref75affbab.coverageReductionMode, ccoverageReductionMode_allocs = (C.VkCoverageReductionModeNV)(x.CoverageReductionMode), cgoAllocsUnknown
	allocs75affbab.Borrow(ccoverageReductionMode_allocs)

	var crasterizationSamples_allocs *cgoAllocMap
	ref75affbab.rasterizationSamples, crasterizationSamples_allocs = (C.VkSampleCountFlagBits)(x.RasterizationSamples), cgoAllocsUnknown
	allocs75affbab.Borrow(crasterizationSamples_allocs)

	var cdepthStencilSamples_allocs *cgoAllocMap
	ref75affbab.depthStencilSamples, cdepthStencilSamples_allocs = (C.VkSampleCountFlags)(x.DepthStencilSamples), cgoAllocsUnknown
	allocs75affbab.Borrow(cdepthStencilSamples_allocs)

	var ccolorSamples_allocs *cgoAllocMap
	ref75affbab.colorSamples, ccolorSamples_allocs = (C.VkSampleCountFlags)(x.ColorSamples), cgoAllocsUnknown
	allocs75affbab.Borrow(ccolorSamples_allocs)

	x.ref75affbab = ref75affbab
	x.allocs75affbab = allocs75affbab
	return ref75affbab, allocs75affbab

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FramebufferMixedSamplesCombinationNV) PassValue() (C.VkFramebufferMixedSamplesCombinationNV, *cgoAllocMap) {
	if x.ref75affbab != nil {
		return *x.ref75affbab, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FramebufferMixedSamplesCombinationNV) Deref() {
	if x.ref75affbab == nil {
		return
	}
	x.SType = (StructureType)(x.ref75affbab.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref75affbab.pNext))
	x.CoverageReductionMode = (CoverageReductionModeNV)(x.ref75affbab.coverageReductionMode)
	x.RasterizationSamples = (SampleCountFlagBits)(x.ref75affbab.rasterizationSamples)
	x.DepthStencilSamples = (SampleCountFlags)(x.ref75affbab.depthStencilSamples)
	x.ColorSamples = (SampleCountFlags)(x.ref75affbab.colorSamples)
}

// allocPhysicalDeviceFragmentShaderInterlockFeaturesMemory allocates memory for type C.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFragmentShaderInterlockFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFragmentShaderInterlockFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceFragmentShaderInterlockFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFragmentShaderInterlockFeatures) Ref() *C.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref1ed4955d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFragmentShaderInterlockFeatures) Free() {
	if x != nil && x.allocs1ed4955d != nil {
		x.allocs1ed4955d.(*cgoAllocMap).Free()
		x.ref1ed4955d = nil
	}
}

// NewPhysicalDeviceFragmentShaderInterlockFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFragmentShaderInterlockFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceFragmentShaderInterlockFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFragmentShaderInterlockFeatures)
	obj.ref1ed4955d = (*C.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFragmentShaderInterlockFeatures) PassRef() (*C.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1ed4955d != nil {
		return x.ref1ed4955d, nil
	}
	mem1ed4955d := allocPhysicalDeviceFragmentShaderInterlockFeaturesMemory(1)
	ref1ed4955d := (*C.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT)(mem1ed4955d)
	allocs1ed4955d := new(cgoAllocMap)
	allocs1ed4955d.Add(mem1ed4955d)

	var csType_allocs *cgoAllocMap
	ref1ed4955d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1ed4955d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1ed4955d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1ed4955d.Borrow(cpNext_allocs)

	var cfragmentShaderSampleInterlock_allocs *cgoAllocMap
	ref1ed4955d.fragmentShaderSampleInterlock, cfragmentShaderSampleInterlock_allocs = (C.VkBool32)(x.FragmentShaderSampleInterlock), cgoAllocsUnknown
	allocs1ed4955d.Borrow(cfragmentShaderSampleInterlock_allocs)

	var cfragmentShaderPixelInterlock_allocs *cgoAllocMap
	ref1ed4955d.fragmentShaderPixelInterlock, cfragmentShaderPixelInterlock_allocs = (C.VkBool32)(x.FragmentShaderPixelInterlock), cgoAllocsUnknown
	allocs1ed4955d.Borrow(cfragmentShaderPixelInterlock_allocs)

	var cfragmentShaderShadingRateInterlock_allocs *cgoAllocMap
	ref1ed4955d.fragmentShaderShadingRateInterlock, cfragmentShaderShadingRateInterlock_allocs = (C.VkBool32)(x.FragmentShaderShadingRateInterlock), cgoAllocsUnknown
	allocs1ed4955d.Borrow(cfragmentShaderShadingRateInterlock_allocs)

	x.ref1ed4955d = ref1ed4955d
	x.allocs1ed4955d = allocs1ed4955d
	return ref1ed4955d, allocs1ed4955d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFragmentShaderInterlockFeatures) PassValue() (C.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, *cgoAllocMap) {
	if x.ref1ed4955d != nil {
		return *x.ref1ed4955d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFragmentShaderInterlockFeatures) Deref() {
	if x.ref1ed4955d == nil {
		return
	}
	x.SType = (StructureType)(x.ref1ed4955d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1ed4955d.pNext))
	x.FragmentShaderSampleInterlock = (Bool32)(x.ref1ed4955d.fragmentShaderSampleInterlock)
	x.FragmentShaderPixelInterlock = (Bool32)(x.ref1ed4955d.fragmentShaderPixelInterlock)
	x.FragmentShaderShadingRateInterlock = (Bool32)(x.ref1ed4955d.fragmentShaderShadingRateInterlock)
}

// allocPhysicalDeviceYcbcrImageArraysFeaturesMemory allocates memory for type C.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceYcbcrImageArraysFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceYcbcrImageArraysFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceYcbcrImageArraysFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceYcbcrImageArraysFeatures) Ref() *C.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref3198007
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceYcbcrImageArraysFeatures) Free() {
	if x != nil && x.allocs3198007 != nil {
		x.allocs3198007.(*cgoAllocMap).Free()
		x.ref3198007 = nil
	}
}

// NewPhysicalDeviceYcbcrImageArraysFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceYcbcrImageArraysFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceYcbcrImageArraysFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceYcbcrImageArraysFeatures)
	obj.ref3198007 = (*C.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceYcbcrImageArraysFeatures) PassRef() (*C.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3198007 != nil {
		return x.ref3198007, nil
	}
	mem3198007 := allocPhysicalDeviceYcbcrImageArraysFeaturesMemory(1)
	ref3198007 := (*C.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT)(mem3198007)
	allocs3198007 := new(cgoAllocMap)
	allocs3198007.Add(mem3198007)

	var csType_allocs *cgoAllocMap
	ref3198007.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3198007.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3198007.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3198007.Borrow(cpNext_allocs)

	var cycbcrImageArrays_allocs *cgoAllocMap
	ref3198007.ycbcrImageArrays, cycbcrImageArrays_allocs = (C.VkBool32)(x.YcbcrImageArrays), cgoAllocsUnknown
	allocs3198007.Borrow(cycbcrImageArrays_allocs)

	x.ref3198007 = ref3198007
	x.allocs3198007 = allocs3198007
	return ref3198007, allocs3198007

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceYcbcrImageArraysFeatures) PassValue() (C.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, *cgoAllocMap) {
	if x.ref3198007 != nil {
		return *x.ref3198007, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceYcbcrImageArraysFeatures) Deref() {
	if x.ref3198007 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3198007.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3198007.pNext))
	x.YcbcrImageArrays = (Bool32)(x.ref3198007.ycbcrImageArrays)
}

// allocPhysicalDeviceProvokingVertexFeaturesMemory allocates memory for type C.VkPhysicalDeviceProvokingVertexFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceProvokingVertexFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceProvokingVertexFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceProvokingVertexFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceProvokingVertexFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProvokingVertexFeatures) Ref() *C.VkPhysicalDeviceProvokingVertexFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref3e34d575
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProvokingVertexFeatures) Free() {
	if x != nil && x.allocs3e34d575 != nil {
		x.allocs3e34d575.(*cgoAllocMap).Free()
		x.ref3e34d575 = nil
	}
}

// NewPhysicalDeviceProvokingVertexFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceProvokingVertexFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceProvokingVertexFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProvokingVertexFeatures)
	obj.ref3e34d575 = (*C.VkPhysicalDeviceProvokingVertexFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProvokingVertexFeatures) PassRef() (*C.VkPhysicalDeviceProvokingVertexFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3e34d575 != nil {
		return x.ref3e34d575, nil
	}
	mem3e34d575 := allocPhysicalDeviceProvokingVertexFeaturesMemory(1)
	ref3e34d575 := (*C.VkPhysicalDeviceProvokingVertexFeaturesEXT)(mem3e34d575)
	allocs3e34d575 := new(cgoAllocMap)
	allocs3e34d575.Add(mem3e34d575)

	var csType_allocs *cgoAllocMap
	ref3e34d575.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3e34d575.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3e34d575.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3e34d575.Borrow(cpNext_allocs)

	var cprovokingVertexLast_allocs *cgoAllocMap
	ref3e34d575.provokingVertexLast, cprovokingVertexLast_allocs = (C.VkBool32)(x.ProvokingVertexLast), cgoAllocsUnknown
	allocs3e34d575.Borrow(cprovokingVertexLast_allocs)

	var ctransformFeedbackPreservesProvokingVertex_allocs *cgoAllocMap
	ref3e34d575.transformFeedbackPreservesProvokingVertex, ctransformFeedbackPreservesProvokingVertex_allocs = (C.VkBool32)(x.TransformFeedbackPreservesProvokingVertex), cgoAllocsUnknown
	allocs3e34d575.Borrow(ctransformFeedbackPreservesProvokingVertex_allocs)

	x.ref3e34d575 = ref3e34d575
	x.allocs3e34d575 = allocs3e34d575
	return ref3e34d575, allocs3e34d575

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProvokingVertexFeatures) PassValue() (C.VkPhysicalDeviceProvokingVertexFeaturesEXT, *cgoAllocMap) {
	if x.ref3e34d575 != nil {
		return *x.ref3e34d575, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProvokingVertexFeatures) Deref() {
	if x.ref3e34d575 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3e34d575.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3e34d575.pNext))
	x.ProvokingVertexLast = (Bool32)(x.ref3e34d575.provokingVertexLast)
	x.TransformFeedbackPreservesProvokingVertex = (Bool32)(x.ref3e34d575.transformFeedbackPreservesProvokingVertex)
}

// allocPhysicalDeviceProvokingVertexPropertiesMemory allocates memory for type C.VkPhysicalDeviceProvokingVertexPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceProvokingVertexPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceProvokingVertexPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceProvokingVertexPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceProvokingVertexPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProvokingVertexProperties) Ref() *C.VkPhysicalDeviceProvokingVertexPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refa8810910
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProvokingVertexProperties) Free() {
	if x != nil && x.allocsa8810910 != nil {
		x.allocsa8810910.(*cgoAllocMap).Free()
		x.refa8810910 = nil
	}
}

// NewPhysicalDeviceProvokingVertexPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceProvokingVertexPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceProvokingVertexProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProvokingVertexProperties)
	obj.refa8810910 = (*C.VkPhysicalDeviceProvokingVertexPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProvokingVertexProperties) PassRef() (*C.VkPhysicalDeviceProvokingVertexPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa8810910 != nil {
		return x.refa8810910, nil
	}
	mema8810910 := allocPhysicalDeviceProvokingVertexPropertiesMemory(1)
	refa8810910 := (*C.VkPhysicalDeviceProvokingVertexPropertiesEXT)(mema8810910)
	allocsa8810910 := new(cgoAllocMap)
	allocsa8810910.Add(mema8810910)

	var csType_allocs *cgoAllocMap
	refa8810910.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa8810910.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa8810910.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa8810910.Borrow(cpNext_allocs)

	var cprovokingVertexModePerPipeline_allocs *cgoAllocMap
	refa8810910.provokingVertexModePerPipeline, cprovokingVertexModePerPipeline_allocs = (C.VkBool32)(x.ProvokingVertexModePerPipeline), cgoAllocsUnknown
	allocsa8810910.Borrow(cprovokingVertexModePerPipeline_allocs)

	var ctransformFeedbackPreservesTriangleFanProvokingVertex_allocs *cgoAllocMap
	refa8810910.transformFeedbackPreservesTriangleFanProvokingVertex, ctransformFeedbackPreservesTriangleFanProvokingVertex_allocs = (C.VkBool32)(x.TransformFeedbackPreservesTriangleFanProvokingVertex), cgoAllocsUnknown
	allocsa8810910.Borrow(ctransformFeedbackPreservesTriangleFanProvokingVertex_allocs)

	x.refa8810910 = refa8810910
	x.allocsa8810910 = allocsa8810910
	return refa8810910, allocsa8810910

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProvokingVertexProperties) PassValue() (C.VkPhysicalDeviceProvokingVertexPropertiesEXT, *cgoAllocMap) {
	if x.refa8810910 != nil {
		return *x.refa8810910, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProvokingVertexProperties) Deref() {
	if x.refa8810910 == nil {
		return
	}
	x.SType = (StructureType)(x.refa8810910.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa8810910.pNext))
	x.ProvokingVertexModePerPipeline = (Bool32)(x.refa8810910.provokingVertexModePerPipeline)
	x.TransformFeedbackPreservesTriangleFanProvokingVertex = (Bool32)(x.refa8810910.transformFeedbackPreservesTriangleFanProvokingVertex)
}

// allocPipelineRasterizationProvokingVertexStateCreateInfoMemory allocates memory for type C.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationProvokingVertexStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationProvokingVertexStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineRasterizationProvokingVertexStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRasterizationProvokingVertexStateCreateInfo) Ref() *C.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref367b4d68
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRasterizationProvokingVertexStateCreateInfo) Free() {
	if x != nil && x.allocs367b4d68 != nil {
		x.allocs367b4d68.(*cgoAllocMap).Free()
		x.ref367b4d68 = nil
	}
}

// NewPipelineRasterizationProvokingVertexStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRasterizationProvokingVertexStateCreateInfoRef(ref unsafe.Pointer) *PipelineRasterizationProvokingVertexStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRasterizationProvokingVertexStateCreateInfo)
	obj.ref367b4d68 = (*C.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRasterizationProvokingVertexStateCreateInfo) PassRef() (*C.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref367b4d68 != nil {
		return x.ref367b4d68, nil
	}
	mem367b4d68 := allocPipelineRasterizationProvokingVertexStateCreateInfoMemory(1)
	ref367b4d68 := (*C.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT)(mem367b4d68)
	allocs367b4d68 := new(cgoAllocMap)
	allocs367b4d68.Add(mem367b4d68)

	var csType_allocs *cgoAllocMap
	ref367b4d68.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs367b4d68.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref367b4d68.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs367b4d68.Borrow(cpNext_allocs)

	var cprovokingVertexMode_allocs *cgoAllocMap
	ref367b4d68.provokingVertexMode, cprovokingVertexMode_allocs = (C.VkProvokingVertexModeEXT)(x.ProvokingVertexMode), cgoAllocsUnknown
	allocs367b4d68.Borrow(cprovokingVertexMode_allocs)

	x.ref367b4d68 = ref367b4d68
	x.allocs367b4d68 = allocs367b4d68
	return ref367b4d68, allocs367b4d68

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRasterizationProvokingVertexStateCreateInfo) PassValue() (C.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT, *cgoAllocMap) {
	if x.ref367b4d68 != nil {
		return *x.ref367b4d68, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRasterizationProvokingVertexStateCreateInfo) Deref() {
	if x.ref367b4d68 == nil {
		return
	}
	x.SType = (StructureType)(x.ref367b4d68.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref367b4d68.pNext))
	x.ProvokingVertexMode = (ProvokingVertexMode)(x.ref367b4d68.provokingVertexMode)
}

// allocHeadlessSurfaceCreateInfoMemory allocates memory for type C.VkHeadlessSurfaceCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocHeadlessSurfaceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfHeadlessSurfaceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfHeadlessSurfaceCreateInfoValue = unsafe.Sizeof([1]C.VkHeadlessSurfaceCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *HeadlessSurfaceCreateInfo) Ref() *C.VkHeadlessSurfaceCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refed88b258
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *HeadlessSurfaceCreateInfo) Free() {
	if x != nil && x.allocsed88b258 != nil {
		x.allocsed88b258.(*cgoAllocMap).Free()
		x.refed88b258 = nil
	}
}

// NewHeadlessSurfaceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewHeadlessSurfaceCreateInfoRef(ref unsafe.Pointer) *HeadlessSurfaceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(HeadlessSurfaceCreateInfo)
	obj.refed88b258 = (*C.VkHeadlessSurfaceCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *HeadlessSurfaceCreateInfo) PassRef() (*C.VkHeadlessSurfaceCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refed88b258 != nil {
		return x.refed88b258, nil
	}
	memed88b258 := allocHeadlessSurfaceCreateInfoMemory(1)
	refed88b258 := (*C.VkHeadlessSurfaceCreateInfoEXT)(memed88b258)
	allocsed88b258 := new(cgoAllocMap)
	allocsed88b258.Add(memed88b258)

	var csType_allocs *cgoAllocMap
	refed88b258.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsed88b258.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refed88b258.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsed88b258.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refed88b258.flags, cflags_allocs = (C.VkHeadlessSurfaceCreateFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocsed88b258.Borrow(cflags_allocs)

	x.refed88b258 = refed88b258
	x.allocsed88b258 = allocsed88b258
	return refed88b258, allocsed88b258

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x HeadlessSurfaceCreateInfo) PassValue() (C.VkHeadlessSurfaceCreateInfoEXT, *cgoAllocMap) {
	if x.refed88b258 != nil {
		return *x.refed88b258, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *HeadlessSurfaceCreateInfo) Deref() {
	if x.refed88b258 == nil {
		return
	}
	x.SType = (StructureType)(x.refed88b258.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refed88b258.pNext))
	x.Flags = (HeadlessSurfaceCreateFlags)(x.refed88b258.flags)
}

// allocPhysicalDeviceLineRasterizationFeaturesMemory allocates memory for type C.VkPhysicalDeviceLineRasterizationFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceLineRasterizationFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceLineRasterizationFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceLineRasterizationFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceLineRasterizationFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceLineRasterizationFeatures) Ref() *C.VkPhysicalDeviceLineRasterizationFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refdb9049a7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceLineRasterizationFeatures) Free() {
	if x != nil && x.allocsdb9049a7 != nil {
		x.allocsdb9049a7.(*cgoAllocMap).Free()
		x.refdb9049a7 = nil
	}
}

// NewPhysicalDeviceLineRasterizationFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceLineRasterizationFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceLineRasterizationFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceLineRasterizationFeatures)
	obj.refdb9049a7 = (*C.VkPhysicalDeviceLineRasterizationFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceLineRasterizationFeatures) PassRef() (*C.VkPhysicalDeviceLineRasterizationFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdb9049a7 != nil {
		return x.refdb9049a7, nil
	}
	memdb9049a7 := allocPhysicalDeviceLineRasterizationFeaturesMemory(1)
	refdb9049a7 := (*C.VkPhysicalDeviceLineRasterizationFeaturesEXT)(memdb9049a7)
	allocsdb9049a7 := new(cgoAllocMap)
	allocsdb9049a7.Add(memdb9049a7)

	var csType_allocs *cgoAllocMap
	refdb9049a7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdb9049a7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdb9049a7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdb9049a7.Borrow(cpNext_allocs)

	var crectangularLines_allocs *cgoAllocMap
	refdb9049a7.rectangularLines, crectangularLines_allocs = (C.VkBool32)(x.RectangularLines), cgoAllocsUnknown
	allocsdb9049a7.Borrow(crectangularLines_allocs)

	var cbresenhamLines_allocs *cgoAllocMap
	refdb9049a7.bresenhamLines, cbresenhamLines_allocs = (C.VkBool32)(x.BresenhamLines), cgoAllocsUnknown
	allocsdb9049a7.Borrow(cbresenhamLines_allocs)

	var csmoothLines_allocs *cgoAllocMap
	refdb9049a7.smoothLines, csmoothLines_allocs = (C.VkBool32)(x.SmoothLines), cgoAllocsUnknown
	allocsdb9049a7.Borrow(csmoothLines_allocs)

	var cstippledRectangularLines_allocs *cgoAllocMap
	refdb9049a7.stippledRectangularLines, cstippledRectangularLines_allocs = (C.VkBool32)(x.StippledRectangularLines), cgoAllocsUnknown
	allocsdb9049a7.Borrow(cstippledRectangularLines_allocs)

	var cstippledBresenhamLines_allocs *cgoAllocMap
	refdb9049a7.stippledBresenhamLines, cstippledBresenhamLines_allocs = (C.VkBool32)(x.StippledBresenhamLines), cgoAllocsUnknown
	allocsdb9049a7.Borrow(cstippledBresenhamLines_allocs)

	var cstippledSmoothLines_allocs *cgoAllocMap
	refdb9049a7.stippledSmoothLines, cstippledSmoothLines_allocs = (C.VkBool32)(x.StippledSmoothLines), cgoAllocsUnknown
	allocsdb9049a7.Borrow(cstippledSmoothLines_allocs)

	x.refdb9049a7 = refdb9049a7
	x.allocsdb9049a7 = allocsdb9049a7
	return refdb9049a7, allocsdb9049a7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceLineRasterizationFeatures) PassValue() (C.VkPhysicalDeviceLineRasterizationFeaturesEXT, *cgoAllocMap) {
	if x.refdb9049a7 != nil {
		return *x.refdb9049a7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceLineRasterizationFeatures) Deref() {
	if x.refdb9049a7 == nil {
		return
	}
	x.SType = (StructureType)(x.refdb9049a7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdb9049a7.pNext))
	x.RectangularLines = (Bool32)(x.refdb9049a7.rectangularLines)
	x.BresenhamLines = (Bool32)(x.refdb9049a7.bresenhamLines)
	x.SmoothLines = (Bool32)(x.refdb9049a7.smoothLines)
	x.StippledRectangularLines = (Bool32)(x.refdb9049a7.stippledRectangularLines)
	x.StippledBresenhamLines = (Bool32)(x.refdb9049a7.stippledBresenhamLines)
	x.StippledSmoothLines = (Bool32)(x.refdb9049a7.stippledSmoothLines)
}

// allocPhysicalDeviceLineRasterizationPropertiesMemory allocates memory for type C.VkPhysicalDeviceLineRasterizationPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceLineRasterizationPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceLineRasterizationPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceLineRasterizationPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceLineRasterizationPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceLineRasterizationProperties) Ref() *C.VkPhysicalDeviceLineRasterizationPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refe2369446
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceLineRasterizationProperties) Free() {
	if x != nil && x.allocse2369446 != nil {
		x.allocse2369446.(*cgoAllocMap).Free()
		x.refe2369446 = nil
	}
}

// NewPhysicalDeviceLineRasterizationPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceLineRasterizationPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceLineRasterizationProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceLineRasterizationProperties)
	obj.refe2369446 = (*C.VkPhysicalDeviceLineRasterizationPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceLineRasterizationProperties) PassRef() (*C.VkPhysicalDeviceLineRasterizationPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe2369446 != nil {
		return x.refe2369446, nil
	}
	meme2369446 := allocPhysicalDeviceLineRasterizationPropertiesMemory(1)
	refe2369446 := (*C.VkPhysicalDeviceLineRasterizationPropertiesEXT)(meme2369446)
	allocse2369446 := new(cgoAllocMap)
	allocse2369446.Add(meme2369446)

	var csType_allocs *cgoAllocMap
	refe2369446.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse2369446.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe2369446.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse2369446.Borrow(cpNext_allocs)

	var clineSubPixelPrecisionBits_allocs *cgoAllocMap
	refe2369446.lineSubPixelPrecisionBits, clineSubPixelPrecisionBits_allocs = (C.uint32_t)(x.LineSubPixelPrecisionBits), cgoAllocsUnknown
	allocse2369446.Borrow(clineSubPixelPrecisionBits_allocs)

	x.refe2369446 = refe2369446
	x.allocse2369446 = allocse2369446
	return refe2369446, allocse2369446

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceLineRasterizationProperties) PassValue() (C.VkPhysicalDeviceLineRasterizationPropertiesEXT, *cgoAllocMap) {
	if x.refe2369446 != nil {
		return *x.refe2369446, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceLineRasterizationProperties) Deref() {
	if x.refe2369446 == nil {
		return
	}
	x.SType = (StructureType)(x.refe2369446.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe2369446.pNext))
	x.LineSubPixelPrecisionBits = (uint32)(x.refe2369446.lineSubPixelPrecisionBits)
}

// allocPipelineRasterizationLineStateCreateInfoMemory allocates memory for type C.VkPipelineRasterizationLineStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationLineStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationLineStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineRasterizationLineStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineRasterizationLineStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRasterizationLineStateCreateInfo) Ref() *C.VkPipelineRasterizationLineStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref649f4226
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRasterizationLineStateCreateInfo) Free() {
	if x != nil && x.allocs649f4226 != nil {
		x.allocs649f4226.(*cgoAllocMap).Free()
		x.ref649f4226 = nil
	}
}

// NewPipelineRasterizationLineStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRasterizationLineStateCreateInfoRef(ref unsafe.Pointer) *PipelineRasterizationLineStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRasterizationLineStateCreateInfo)
	obj.ref649f4226 = (*C.VkPipelineRasterizationLineStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRasterizationLineStateCreateInfo) PassRef() (*C.VkPipelineRasterizationLineStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref649f4226 != nil {
		return x.ref649f4226, nil
	}
	mem649f4226 := allocPipelineRasterizationLineStateCreateInfoMemory(1)
	ref649f4226 := (*C.VkPipelineRasterizationLineStateCreateInfoEXT)(mem649f4226)
	allocs649f4226 := new(cgoAllocMap)
	allocs649f4226.Add(mem649f4226)

	var csType_allocs *cgoAllocMap
	ref649f4226.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs649f4226.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref649f4226.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs649f4226.Borrow(cpNext_allocs)

	var clineRasterizationMode_allocs *cgoAllocMap
	ref649f4226.lineRasterizationMode, clineRasterizationMode_allocs = (C.VkLineRasterizationModeEXT)(x.LineRasterizationMode), cgoAllocsUnknown
	allocs649f4226.Borrow(clineRasterizationMode_allocs)

	var cstippledLineEnable_allocs *cgoAllocMap
	ref649f4226.stippledLineEnable, cstippledLineEnable_allocs = (C.VkBool32)(x.StippledLineEnable), cgoAllocsUnknown
	allocs649f4226.Borrow(cstippledLineEnable_allocs)

	var clineStippleFactor_allocs *cgoAllocMap
	ref649f4226.lineStippleFactor, clineStippleFactor_allocs = (C.uint32_t)(x.LineStippleFactor), cgoAllocsUnknown
	allocs649f4226.Borrow(clineStippleFactor_allocs)

	var clineStipplePattern_allocs *cgoAllocMap
	ref649f4226.lineStipplePattern, clineStipplePattern_allocs = (C.uint16_t)(x.LineStipplePattern), cgoAllocsUnknown
	allocs649f4226.Borrow(clineStipplePattern_allocs)

	x.ref649f4226 = ref649f4226
	x.allocs649f4226 = allocs649f4226
	return ref649f4226, allocs649f4226

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRasterizationLineStateCreateInfo) PassValue() (C.VkPipelineRasterizationLineStateCreateInfoEXT, *cgoAllocMap) {
	if x.ref649f4226 != nil {
		return *x.ref649f4226, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRasterizationLineStateCreateInfo) Deref() {
	if x.ref649f4226 == nil {
		return
	}
	x.SType = (StructureType)(x.ref649f4226.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref649f4226.pNext))
	x.LineRasterizationMode = (LineRasterizationMode)(x.ref649f4226.lineRasterizationMode)
	x.StippledLineEnable = (Bool32)(x.ref649f4226.stippledLineEnable)
	x.LineStippleFactor = (uint32)(x.ref649f4226.lineStippleFactor)
	x.LineStipplePattern = (uint16)(x.ref649f4226.lineStipplePattern)
}

// allocPhysicalDeviceShaderAtomicFloatFeaturesMemory allocates memory for type C.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderAtomicFloatFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderAtomicFloatFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShaderAtomicFloatFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderAtomicFloatFeatures) Ref() *C.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refb387c45b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderAtomicFloatFeatures) Free() {
	if x != nil && x.allocsb387c45b != nil {
		x.allocsb387c45b.(*cgoAllocMap).Free()
		x.refb387c45b = nil
	}
}

// NewPhysicalDeviceShaderAtomicFloatFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderAtomicFloatFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceShaderAtomicFloatFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderAtomicFloatFeatures)
	obj.refb387c45b = (*C.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderAtomicFloatFeatures) PassRef() (*C.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb387c45b != nil {
		return x.refb387c45b, nil
	}
	memb387c45b := allocPhysicalDeviceShaderAtomicFloatFeaturesMemory(1)
	refb387c45b := (*C.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT)(memb387c45b)
	allocsb387c45b := new(cgoAllocMap)
	allocsb387c45b.Add(memb387c45b)

	var csType_allocs *cgoAllocMap
	refb387c45b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb387c45b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb387c45b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb387c45b.Borrow(cpNext_allocs)

	var cshaderBufferFloat32Atomics_allocs *cgoAllocMap
	refb387c45b.shaderBufferFloat32Atomics, cshaderBufferFloat32Atomics_allocs = (C.VkBool32)(x.ShaderBufferFloat32Atomics), cgoAllocsUnknown
	allocsb387c45b.Borrow(cshaderBufferFloat32Atomics_allocs)

	var cshaderBufferFloat32AtomicAdd_allocs *cgoAllocMap
	refb387c45b.shaderBufferFloat32AtomicAdd, cshaderBufferFloat32AtomicAdd_allocs = (C.VkBool32)(x.ShaderBufferFloat32AtomicAdd), cgoAllocsUnknown
	allocsb387c45b.Borrow(cshaderBufferFloat32AtomicAdd_allocs)

	var cshaderBufferFloat64Atomics_allocs *cgoAllocMap
	refb387c45b.shaderBufferFloat64Atomics, cshaderBufferFloat64Atomics_allocs = (C.VkBool32)(x.ShaderBufferFloat64Atomics), cgoAllocsUnknown
	allocsb387c45b.Borrow(cshaderBufferFloat64Atomics_allocs)

	var cshaderBufferFloat64AtomicAdd_allocs *cgoAllocMap
	refb387c45b.shaderBufferFloat64AtomicAdd, cshaderBufferFloat64AtomicAdd_allocs = (C.VkBool32)(x.ShaderBufferFloat64AtomicAdd), cgoAllocsUnknown
	allocsb387c45b.Borrow(cshaderBufferFloat64AtomicAdd_allocs)

	var cshaderSharedFloat32Atomics_allocs *cgoAllocMap
	refb387c45b.shaderSharedFloat32Atomics, cshaderSharedFloat32Atomics_allocs = (C.VkBool32)(x.ShaderSharedFloat32Atomics), cgoAllocsUnknown
	allocsb387c45b.Borrow(cshaderSharedFloat32Atomics_allocs)

	var cshaderSharedFloat32AtomicAdd_allocs *cgoAllocMap
	refb387c45b.shaderSharedFloat32AtomicAdd, cshaderSharedFloat32AtomicAdd_allocs = (C.VkBool32)(x.ShaderSharedFloat32AtomicAdd), cgoAllocsUnknown
	allocsb387c45b.Borrow(cshaderSharedFloat32AtomicAdd_allocs)

	var cshaderSharedFloat64Atomics_allocs *cgoAllocMap
	refb387c45b.shaderSharedFloat64Atomics, cshaderSharedFloat64Atomics_allocs = (C.VkBool32)(x.ShaderSharedFloat64Atomics), cgoAllocsUnknown
	allocsb387c45b.Borrow(cshaderSharedFloat64Atomics_allocs)

	var cshaderSharedFloat64AtomicAdd_allocs *cgoAllocMap
	refb387c45b.shaderSharedFloat64AtomicAdd, cshaderSharedFloat64AtomicAdd_allocs = (C.VkBool32)(x.ShaderSharedFloat64AtomicAdd), cgoAllocsUnknown
	allocsb387c45b.Borrow(cshaderSharedFloat64AtomicAdd_allocs)

	var cshaderImageFloat32Atomics_allocs *cgoAllocMap
	refb387c45b.shaderImageFloat32Atomics, cshaderImageFloat32Atomics_allocs = (C.VkBool32)(x.ShaderImageFloat32Atomics), cgoAllocsUnknown
	allocsb387c45b.Borrow(cshaderImageFloat32Atomics_allocs)

	var cshaderImageFloat32AtomicAdd_allocs *cgoAllocMap
	refb387c45b.shaderImageFloat32AtomicAdd, cshaderImageFloat32AtomicAdd_allocs = (C.VkBool32)(x.ShaderImageFloat32AtomicAdd), cgoAllocsUnknown
	allocsb387c45b.Borrow(cshaderImageFloat32AtomicAdd_allocs)

	var csparseImageFloat32Atomics_allocs *cgoAllocMap
	refb387c45b.sparseImageFloat32Atomics, csparseImageFloat32Atomics_allocs = (C.VkBool32)(x.SparseImageFloat32Atomics), cgoAllocsUnknown
	allocsb387c45b.Borrow(csparseImageFloat32Atomics_allocs)

	var csparseImageFloat32AtomicAdd_allocs *cgoAllocMap
	refb387c45b.sparseImageFloat32AtomicAdd, csparseImageFloat32AtomicAdd_allocs = (C.VkBool32)(x.SparseImageFloat32AtomicAdd), cgoAllocsUnknown
	allocsb387c45b.Borrow(csparseImageFloat32AtomicAdd_allocs)

	x.refb387c45b = refb387c45b
	x.allocsb387c45b = allocsb387c45b
	return refb387c45b, allocsb387c45b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderAtomicFloatFeatures) PassValue() (C.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, *cgoAllocMap) {
	if x.refb387c45b != nil {
		return *x.refb387c45b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderAtomicFloatFeatures) Deref() {
	if x.refb387c45b == nil {
		return
	}
	x.SType = (StructureType)(x.refb387c45b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb387c45b.pNext))
	x.ShaderBufferFloat32Atomics = (Bool32)(x.refb387c45b.shaderBufferFloat32Atomics)
	x.ShaderBufferFloat32AtomicAdd = (Bool32)(x.refb387c45b.shaderBufferFloat32AtomicAdd)
	x.ShaderBufferFloat64Atomics = (Bool32)(x.refb387c45b.shaderBufferFloat64Atomics)
	x.ShaderBufferFloat64AtomicAdd = (Bool32)(x.refb387c45b.shaderBufferFloat64AtomicAdd)
	x.ShaderSharedFloat32Atomics = (Bool32)(x.refb387c45b.shaderSharedFloat32Atomics)
	x.ShaderSharedFloat32AtomicAdd = (Bool32)(x.refb387c45b.shaderSharedFloat32AtomicAdd)
	x.ShaderSharedFloat64Atomics = (Bool32)(x.refb387c45b.shaderSharedFloat64Atomics)
	x.ShaderSharedFloat64AtomicAdd = (Bool32)(x.refb387c45b.shaderSharedFloat64AtomicAdd)
	x.ShaderImageFloat32Atomics = (Bool32)(x.refb387c45b.shaderImageFloat32Atomics)
	x.ShaderImageFloat32AtomicAdd = (Bool32)(x.refb387c45b.shaderImageFloat32AtomicAdd)
	x.SparseImageFloat32Atomics = (Bool32)(x.refb387c45b.sparseImageFloat32Atomics)
	x.SparseImageFloat32AtomicAdd = (Bool32)(x.refb387c45b.sparseImageFloat32AtomicAdd)
}

// allocPhysicalDeviceIndexTypeUint8FeaturesMemory allocates memory for type C.VkPhysicalDeviceIndexTypeUint8FeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceIndexTypeUint8FeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceIndexTypeUint8FeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceIndexTypeUint8FeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceIndexTypeUint8FeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceIndexTypeUint8Features) Ref() *C.VkPhysicalDeviceIndexTypeUint8FeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refd29dc94
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceIndexTypeUint8Features) Free() {
	if x != nil && x.allocsd29dc94 != nil {
		x.allocsd29dc94.(*cgoAllocMap).Free()
		x.refd29dc94 = nil
	}
}

// NewPhysicalDeviceIndexTypeUint8FeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceIndexTypeUint8FeaturesRef(ref unsafe.Pointer) *PhysicalDeviceIndexTypeUint8Features {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceIndexTypeUint8Features)
	obj.refd29dc94 = (*C.VkPhysicalDeviceIndexTypeUint8FeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceIndexTypeUint8Features) PassRef() (*C.VkPhysicalDeviceIndexTypeUint8FeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd29dc94 != nil {
		return x.refd29dc94, nil
	}
	memd29dc94 := allocPhysicalDeviceIndexTypeUint8FeaturesMemory(1)
	refd29dc94 := (*C.VkPhysicalDeviceIndexTypeUint8FeaturesEXT)(memd29dc94)
	allocsd29dc94 := new(cgoAllocMap)
	allocsd29dc94.Add(memd29dc94)

	var csType_allocs *cgoAllocMap
	refd29dc94.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd29dc94.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd29dc94.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd29dc94.Borrow(cpNext_allocs)

	var cindexTypeUint8_allocs *cgoAllocMap
	refd29dc94.indexTypeUint8, cindexTypeUint8_allocs = (C.VkBool32)(x.IndexTypeUint8), cgoAllocsUnknown
	allocsd29dc94.Borrow(cindexTypeUint8_allocs)

	x.refd29dc94 = refd29dc94
	x.allocsd29dc94 = allocsd29dc94
	return refd29dc94, allocsd29dc94

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceIndexTypeUint8Features) PassValue() (C.VkPhysicalDeviceIndexTypeUint8FeaturesEXT, *cgoAllocMap) {
	if x.refd29dc94 != nil {
		return *x.refd29dc94, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceIndexTypeUint8Features) Deref() {
	if x.refd29dc94 == nil {
		return
	}
	x.SType = (StructureType)(x.refd29dc94.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd29dc94.pNext))
	x.IndexTypeUint8 = (Bool32)(x.refd29dc94.indexTypeUint8)
}

// allocPhysicalDeviceExtendedDynamicStateFeaturesMemory allocates memory for type C.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExtendedDynamicStateFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExtendedDynamicStateFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceExtendedDynamicStateFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExtendedDynamicStateFeatures) Ref() *C.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.reff7bd87ab
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExtendedDynamicStateFeatures) Free() {
	if x != nil && x.allocsf7bd87ab != nil {
		x.allocsf7bd87ab.(*cgoAllocMap).Free()
		x.reff7bd87ab = nil
	}
}

// NewPhysicalDeviceExtendedDynamicStateFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExtendedDynamicStateFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceExtendedDynamicStateFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExtendedDynamicStateFeatures)
	obj.reff7bd87ab = (*C.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExtendedDynamicStateFeatures) PassRef() (*C.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff7bd87ab != nil {
		return x.reff7bd87ab, nil
	}
	memf7bd87ab := allocPhysicalDeviceExtendedDynamicStateFeaturesMemory(1)
	reff7bd87ab := (*C.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT)(memf7bd87ab)
	allocsf7bd87ab := new(cgoAllocMap)
	allocsf7bd87ab.Add(memf7bd87ab)

	var csType_allocs *cgoAllocMap
	reff7bd87ab.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf7bd87ab.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff7bd87ab.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf7bd87ab.Borrow(cpNext_allocs)

	var cextendedDynamicState_allocs *cgoAllocMap
	reff7bd87ab.extendedDynamicState, cextendedDynamicState_allocs = (C.VkBool32)(x.ExtendedDynamicState), cgoAllocsUnknown
	allocsf7bd87ab.Borrow(cextendedDynamicState_allocs)

	x.reff7bd87ab = reff7bd87ab
	x.allocsf7bd87ab = allocsf7bd87ab
	return reff7bd87ab, allocsf7bd87ab

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExtendedDynamicStateFeatures) PassValue() (C.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, *cgoAllocMap) {
	if x.reff7bd87ab != nil {
		return *x.reff7bd87ab, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExtendedDynamicStateFeatures) Deref() {
	if x.reff7bd87ab == nil {
		return
	}
	x.SType = (StructureType)(x.reff7bd87ab.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff7bd87ab.pNext))
	x.ExtendedDynamicState = (Bool32)(x.reff7bd87ab.extendedDynamicState)
}

// allocPhysicalDeviceShaderDemoteToHelperInvocationFeaturesMemory allocates memory for type C.VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderDemoteToHelperInvocationFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderDemoteToHelperInvocationFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceShaderDemoteToHelperInvocationFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderDemoteToHelperInvocationFeatures) Ref() *C.VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refea6aac1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderDemoteToHelperInvocationFeatures) Free() {
	if x != nil && x.allocsea6aac1 != nil {
		x.allocsea6aac1.(*cgoAllocMap).Free()
		x.refea6aac1 = nil
	}
}

// NewPhysicalDeviceShaderDemoteToHelperInvocationFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderDemoteToHelperInvocationFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderDemoteToHelperInvocationFeatures)
	obj.refea6aac1 = (*C.VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderDemoteToHelperInvocationFeatures) PassRef() (*C.VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refea6aac1 != nil {
		return x.refea6aac1, nil
	}
	memea6aac1 := allocPhysicalDeviceShaderDemoteToHelperInvocationFeaturesMemory(1)
	refea6aac1 := (*C.VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT)(memea6aac1)
	allocsea6aac1 := new(cgoAllocMap)
	allocsea6aac1.Add(memea6aac1)

	var csType_allocs *cgoAllocMap
	refea6aac1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsea6aac1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refea6aac1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsea6aac1.Borrow(cpNext_allocs)

	var cshaderDemoteToHelperInvocation_allocs *cgoAllocMap
	refea6aac1.shaderDemoteToHelperInvocation, cshaderDemoteToHelperInvocation_allocs = (C.VkBool32)(x.ShaderDemoteToHelperInvocation), cgoAllocsUnknown
	allocsea6aac1.Borrow(cshaderDemoteToHelperInvocation_allocs)

	x.refea6aac1 = refea6aac1
	x.allocsea6aac1 = allocsea6aac1
	return refea6aac1, allocsea6aac1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) PassValue() (C.VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT, *cgoAllocMap) {
	if x.refea6aac1 != nil {
		return *x.refea6aac1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderDemoteToHelperInvocationFeatures) Deref() {
	if x.refea6aac1 == nil {
		return
	}
	x.SType = (StructureType)(x.refea6aac1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refea6aac1.pNext))
	x.ShaderDemoteToHelperInvocation = (Bool32)(x.refea6aac1.shaderDemoteToHelperInvocation)
}

// allocPhysicalDeviceDeviceGeneratedCommandsPropertiesNVMemory allocates memory for type C.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDeviceGeneratedCommandsPropertiesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDeviceGeneratedCommandsPropertiesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceDeviceGeneratedCommandsPropertiesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDeviceGeneratedCommandsPropertiesNV) Ref() *C.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
	if x == nil {
		return nil
	}
	return x.ref569def06
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDeviceGeneratedCommandsPropertiesNV) Free() {
	if x != nil && x.allocs569def06 != nil {
		x.allocs569def06.(*cgoAllocMap).Free()
		x.ref569def06 = nil
	}
}

// NewPhysicalDeviceDeviceGeneratedCommandsPropertiesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDeviceGeneratedCommandsPropertiesNVRef(ref unsafe.Pointer) *PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDeviceGeneratedCommandsPropertiesNV)
	obj.ref569def06 = (*C.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDeviceGeneratedCommandsPropertiesNV) PassRef() (*C.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref569def06 != nil {
		return x.ref569def06, nil
	}
	mem569def06 := allocPhysicalDeviceDeviceGeneratedCommandsPropertiesNVMemory(1)
	ref569def06 := (*C.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV)(mem569def06)
	allocs569def06 := new(cgoAllocMap)
	allocs569def06.Add(mem569def06)

	var csType_allocs *cgoAllocMap
	ref569def06.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs569def06.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref569def06.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs569def06.Borrow(cpNext_allocs)

	var cmaxGraphicsShaderGroupCount_allocs *cgoAllocMap
	ref569def06.maxGraphicsShaderGroupCount, cmaxGraphicsShaderGroupCount_allocs = (C.uint32_t)(x.MaxGraphicsShaderGroupCount), cgoAllocsUnknown
	allocs569def06.Borrow(cmaxGraphicsShaderGroupCount_allocs)

	var cmaxIndirectSequenceCount_allocs *cgoAllocMap
	ref569def06.maxIndirectSequenceCount, cmaxIndirectSequenceCount_allocs = (C.uint32_t)(x.MaxIndirectSequenceCount), cgoAllocsUnknown
	allocs569def06.Borrow(cmaxIndirectSequenceCount_allocs)

	var cmaxIndirectCommandsTokenCount_allocs *cgoAllocMap
	ref569def06.maxIndirectCommandsTokenCount, cmaxIndirectCommandsTokenCount_allocs = (C.uint32_t)(x.MaxIndirectCommandsTokenCount), cgoAllocsUnknown
	allocs569def06.Borrow(cmaxIndirectCommandsTokenCount_allocs)

	var cmaxIndirectCommandsStreamCount_allocs *cgoAllocMap
	ref569def06.maxIndirectCommandsStreamCount, cmaxIndirectCommandsStreamCount_allocs = (C.uint32_t)(x.MaxIndirectCommandsStreamCount), cgoAllocsUnknown
	allocs569def06.Borrow(cmaxIndirectCommandsStreamCount_allocs)

	var cmaxIndirectCommandsTokenOffset_allocs *cgoAllocMap
	ref569def06.maxIndirectCommandsTokenOffset, cmaxIndirectCommandsTokenOffset_allocs = (C.uint32_t)(x.MaxIndirectCommandsTokenOffset), cgoAllocsUnknown
	allocs569def06.Borrow(cmaxIndirectCommandsTokenOffset_allocs)

	var cmaxIndirectCommandsStreamStride_allocs *cgoAllocMap
	ref569def06.maxIndirectCommandsStreamStride, cmaxIndirectCommandsStreamStride_allocs = (C.uint32_t)(x.MaxIndirectCommandsStreamStride), cgoAllocsUnknown
	allocs569def06.Borrow(cmaxIndirectCommandsStreamStride_allocs)

	var cminSequencesCountBufferOffsetAlignment_allocs *cgoAllocMap
	ref569def06.minSequencesCountBufferOffsetAlignment, cminSequencesCountBufferOffsetAlignment_allocs = (C.uint32_t)(x.MinSequencesCountBufferOffsetAlignment), cgoAllocsUnknown
	allocs569def06.Borrow(cminSequencesCountBufferOffsetAlignment_allocs)

	var cminSequencesIndexBufferOffsetAlignment_allocs *cgoAllocMap
	ref569def06.minSequencesIndexBufferOffsetAlignment, cminSequencesIndexBufferOffsetAlignment_allocs = (C.uint32_t)(x.MinSequencesIndexBufferOffsetAlignment), cgoAllocsUnknown
	allocs569def06.Borrow(cminSequencesIndexBufferOffsetAlignment_allocs)

	var cminIndirectCommandsBufferOffsetAlignment_allocs *cgoAllocMap
	ref569def06.minIndirectCommandsBufferOffsetAlignment, cminIndirectCommandsBufferOffsetAlignment_allocs = (C.uint32_t)(x.MinIndirectCommandsBufferOffsetAlignment), cgoAllocsUnknown
	allocs569def06.Borrow(cminIndirectCommandsBufferOffsetAlignment_allocs)

	x.ref569def06 = ref569def06
	x.allocs569def06 = allocs569def06
	return ref569def06, allocs569def06

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDeviceGeneratedCommandsPropertiesNV) PassValue() (C.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, *cgoAllocMap) {
	if x.ref569def06 != nil {
		return *x.ref569def06, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDeviceGeneratedCommandsPropertiesNV) Deref() {
	if x.ref569def06 == nil {
		return
	}
	x.SType = (StructureType)(x.ref569def06.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref569def06.pNext))
	x.MaxGraphicsShaderGroupCount = (uint32)(x.ref569def06.maxGraphicsShaderGroupCount)
	x.MaxIndirectSequenceCount = (uint32)(x.ref569def06.maxIndirectSequenceCount)
	x.MaxIndirectCommandsTokenCount = (uint32)(x.ref569def06.maxIndirectCommandsTokenCount)
	x.MaxIndirectCommandsStreamCount = (uint32)(x.ref569def06.maxIndirectCommandsStreamCount)
	x.MaxIndirectCommandsTokenOffset = (uint32)(x.ref569def06.maxIndirectCommandsTokenOffset)
	x.MaxIndirectCommandsStreamStride = (uint32)(x.ref569def06.maxIndirectCommandsStreamStride)
	x.MinSequencesCountBufferOffsetAlignment = (uint32)(x.ref569def06.minSequencesCountBufferOffsetAlignment)
	x.MinSequencesIndexBufferOffsetAlignment = (uint32)(x.ref569def06.minSequencesIndexBufferOffsetAlignment)
	x.MinIndirectCommandsBufferOffsetAlignment = (uint32)(x.ref569def06.minIndirectCommandsBufferOffsetAlignment)
}

// allocPhysicalDeviceDeviceGeneratedCommandsFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDeviceGeneratedCommandsFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDeviceGeneratedCommandsFeaturesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceDeviceGeneratedCommandsFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDeviceGeneratedCommandsFeaturesNV) Ref() *C.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
	if x == nil {
		return nil
	}
	return x.ref3ea95583
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDeviceGeneratedCommandsFeaturesNV) Free() {
	if x != nil && x.allocs3ea95583 != nil {
		x.allocs3ea95583.(*cgoAllocMap).Free()
		x.ref3ea95583 = nil
	}
}

// NewPhysicalDeviceDeviceGeneratedCommandsFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDeviceGeneratedCommandsFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDeviceGeneratedCommandsFeaturesNV)
	obj.ref3ea95583 = (*C.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDeviceGeneratedCommandsFeaturesNV) PassRef() (*C.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3ea95583 != nil {
		return x.ref3ea95583, nil
	}
	mem3ea95583 := allocPhysicalDeviceDeviceGeneratedCommandsFeaturesNVMemory(1)
	ref3ea95583 := (*C.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV)(mem3ea95583)
	allocs3ea95583 := new(cgoAllocMap)
	allocs3ea95583.Add(mem3ea95583)

	var csType_allocs *cgoAllocMap
	ref3ea95583.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3ea95583.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3ea95583.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3ea95583.Borrow(cpNext_allocs)

	var cdeviceGeneratedCommands_allocs *cgoAllocMap
	ref3ea95583.deviceGeneratedCommands, cdeviceGeneratedCommands_allocs = (C.VkBool32)(x.DeviceGeneratedCommands), cgoAllocsUnknown
	allocs3ea95583.Borrow(cdeviceGeneratedCommands_allocs)

	x.ref3ea95583 = ref3ea95583
	x.allocs3ea95583 = allocs3ea95583
	return ref3ea95583, allocs3ea95583

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDeviceGeneratedCommandsFeaturesNV) PassValue() (C.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, *cgoAllocMap) {
	if x.ref3ea95583 != nil {
		return *x.ref3ea95583, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDeviceGeneratedCommandsFeaturesNV) Deref() {
	if x.ref3ea95583 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3ea95583.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3ea95583.pNext))
	x.DeviceGeneratedCommands = (Bool32)(x.ref3ea95583.deviceGeneratedCommands)
}

// allocGraphicsShaderGroupCreateInfoNVMemory allocates memory for type C.VkGraphicsShaderGroupCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGraphicsShaderGroupCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGraphicsShaderGroupCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGraphicsShaderGroupCreateInfoNVValue = unsafe.Sizeof([1]C.VkGraphicsShaderGroupCreateInfoNV{})

// unpackSPipelineVertexInputStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineVertexInputStateCreateInfo(x []PipelineVertexInputStateCreateInfo) (unpacked *C.VkPipelineVertexInputStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineVertexInputStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineVertexInputStateCreateInfo)(h.Data)
	return
}

// unpackSPipelineTessellationStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineTessellationStateCreateInfo(x []PipelineTessellationStateCreateInfo) (unpacked *C.VkPipelineTessellationStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineTessellationStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineTessellationStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineTessellationStateCreateInfo)(h.Data)
	return
}

// packSPipelineVertexInputStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineVertexInputStateCreateInfo(v []PipelineVertexInputStateCreateInfo, ptr0 *C.VkPipelineVertexInputStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineVertexInputStateCreateInfoValue]C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineVertexInputStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineTessellationStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineTessellationStateCreateInfo(v []PipelineTessellationStateCreateInfo, ptr0 *C.VkPipelineTessellationStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineTessellationStateCreateInfoValue]C.VkPipelineTessellationStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineTessellationStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GraphicsShaderGroupCreateInfoNV) Ref() *C.VkGraphicsShaderGroupCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refa9d954e5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GraphicsShaderGroupCreateInfoNV) Free() {
	if x != nil && x.allocsa9d954e5 != nil {
		x.allocsa9d954e5.(*cgoAllocMap).Free()
		x.refa9d954e5 = nil
	}
}

// NewGraphicsShaderGroupCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGraphicsShaderGroupCreateInfoNVRef(ref unsafe.Pointer) *GraphicsShaderGroupCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(GraphicsShaderGroupCreateInfoNV)
	obj.refa9d954e5 = (*C.VkGraphicsShaderGroupCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GraphicsShaderGroupCreateInfoNV) PassRef() (*C.VkGraphicsShaderGroupCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa9d954e5 != nil {
		return x.refa9d954e5, nil
	}
	mema9d954e5 := allocGraphicsShaderGroupCreateInfoNVMemory(1)
	refa9d954e5 := (*C.VkGraphicsShaderGroupCreateInfoNV)(mema9d954e5)
	allocsa9d954e5 := new(cgoAllocMap)
	allocsa9d954e5.Add(mema9d954e5)

	var csType_allocs *cgoAllocMap
	refa9d954e5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa9d954e5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa9d954e5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa9d954e5.Borrow(cpNext_allocs)

	var cstageCount_allocs *cgoAllocMap
	refa9d954e5.stageCount, cstageCount_allocs = (C.uint32_t)(x.StageCount), cgoAllocsUnknown
	allocsa9d954e5.Borrow(cstageCount_allocs)

	var cpStages_allocs *cgoAllocMap
	refa9d954e5.pStages, cpStages_allocs = unpackSPipelineShaderStageCreateInfo(x.PStages)
	allocsa9d954e5.Borrow(cpStages_allocs)

	var cpVertexInputState_allocs *cgoAllocMap
	refa9d954e5.pVertexInputState, cpVertexInputState_allocs = unpackSPipelineVertexInputStateCreateInfo(x.PVertexInputState)
	allocsa9d954e5.Borrow(cpVertexInputState_allocs)

	var cpTessellationState_allocs *cgoAllocMap
	refa9d954e5.pTessellationState, cpTessellationState_allocs = unpackSPipelineTessellationStateCreateInfo(x.PTessellationState)
	allocsa9d954e5.Borrow(cpTessellationState_allocs)

	x.refa9d954e5 = refa9d954e5
	x.allocsa9d954e5 = allocsa9d954e5
	return refa9d954e5, allocsa9d954e5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GraphicsShaderGroupCreateInfoNV) PassValue() (C.VkGraphicsShaderGroupCreateInfoNV, *cgoAllocMap) {
	if x.refa9d954e5 != nil {
		return *x.refa9d954e5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GraphicsShaderGroupCreateInfoNV) Deref() {
	if x.refa9d954e5 == nil {
		return
	}
	x.SType = (StructureType)(x.refa9d954e5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa9d954e5.pNext))
	x.StageCount = (uint32)(x.refa9d954e5.stageCount)
	packSPipelineShaderStageCreateInfo(x.PStages, x.refa9d954e5.pStages)
	packSPipelineVertexInputStateCreateInfo(x.PVertexInputState, x.refa9d954e5.pVertexInputState)
	packSPipelineTessellationStateCreateInfo(x.PTessellationState, x.refa9d954e5.pTessellationState)
}

// allocGraphicsPipelineShaderGroupsCreateInfoNVMemory allocates memory for type C.VkGraphicsPipelineShaderGroupsCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGraphicsPipelineShaderGroupsCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGraphicsPipelineShaderGroupsCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGraphicsPipelineShaderGroupsCreateInfoNVValue = unsafe.Sizeof([1]C.VkGraphicsPipelineShaderGroupsCreateInfoNV{})

// unpackSGraphicsShaderGroupCreateInfoNV transforms a sliced Go data structure into plain C format.
func unpackSGraphicsShaderGroupCreateInfoNV(x []GraphicsShaderGroupCreateInfoNV) (unpacked *C.VkGraphicsShaderGroupCreateInfoNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocGraphicsShaderGroupCreateInfoNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkGraphicsShaderGroupCreateInfoNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkGraphicsShaderGroupCreateInfoNV)(h.Data)
	return
}

// packSGraphicsShaderGroupCreateInfoNV reads sliced Go data structure out from plain C format.
func packSGraphicsShaderGroupCreateInfoNV(v []GraphicsShaderGroupCreateInfoNV, ptr0 *C.VkGraphicsShaderGroupCreateInfoNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfGraphicsShaderGroupCreateInfoNVValue]C.VkGraphicsShaderGroupCreateInfoNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewGraphicsShaderGroupCreateInfoNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GraphicsPipelineShaderGroupsCreateInfoNV) Ref() *C.VkGraphicsPipelineShaderGroupsCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refabf1b7d9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GraphicsPipelineShaderGroupsCreateInfoNV) Free() {
	if x != nil && x.allocsabf1b7d9 != nil {
		x.allocsabf1b7d9.(*cgoAllocMap).Free()
		x.refabf1b7d9 = nil
	}
}

// NewGraphicsPipelineShaderGroupsCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGraphicsPipelineShaderGroupsCreateInfoNVRef(ref unsafe.Pointer) *GraphicsPipelineShaderGroupsCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(GraphicsPipelineShaderGroupsCreateInfoNV)
	obj.refabf1b7d9 = (*C.VkGraphicsPipelineShaderGroupsCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GraphicsPipelineShaderGroupsCreateInfoNV) PassRef() (*C.VkGraphicsPipelineShaderGroupsCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refabf1b7d9 != nil {
		return x.refabf1b7d9, nil
	}
	memabf1b7d9 := allocGraphicsPipelineShaderGroupsCreateInfoNVMemory(1)
	refabf1b7d9 := (*C.VkGraphicsPipelineShaderGroupsCreateInfoNV)(memabf1b7d9)
	allocsabf1b7d9 := new(cgoAllocMap)
	allocsabf1b7d9.Add(memabf1b7d9)

	var csType_allocs *cgoAllocMap
	refabf1b7d9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsabf1b7d9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refabf1b7d9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsabf1b7d9.Borrow(cpNext_allocs)

	var cgroupCount_allocs *cgoAllocMap
	refabf1b7d9.groupCount, cgroupCount_allocs = (C.uint32_t)(x.GroupCount), cgoAllocsUnknown
	allocsabf1b7d9.Borrow(cgroupCount_allocs)

	var cpGroups_allocs *cgoAllocMap
	refabf1b7d9.pGroups, cpGroups_allocs = unpackSGraphicsShaderGroupCreateInfoNV(x.PGroups)
	allocsabf1b7d9.Borrow(cpGroups_allocs)

	var cpipelineCount_allocs *cgoAllocMap
	refabf1b7d9.pipelineCount, cpipelineCount_allocs = (C.uint32_t)(x.PipelineCount), cgoAllocsUnknown
	allocsabf1b7d9.Borrow(cpipelineCount_allocs)

	var cpPipelines_allocs *cgoAllocMap
	refabf1b7d9.pPipelines, cpPipelines_allocs = copyPPipelineBytes((*sliceHeader)(unsafe.Pointer(&x.PPipelines)))
	allocsabf1b7d9.Borrow(cpPipelines_allocs)

	x.refabf1b7d9 = refabf1b7d9
	x.allocsabf1b7d9 = allocsabf1b7d9
	return refabf1b7d9, allocsabf1b7d9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GraphicsPipelineShaderGroupsCreateInfoNV) PassValue() (C.VkGraphicsPipelineShaderGroupsCreateInfoNV, *cgoAllocMap) {
	if x.refabf1b7d9 != nil {
		return *x.refabf1b7d9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GraphicsPipelineShaderGroupsCreateInfoNV) Deref() {
	if x.refabf1b7d9 == nil {
		return
	}
	x.SType = (StructureType)(x.refabf1b7d9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refabf1b7d9.pNext))
	x.GroupCount = (uint32)(x.refabf1b7d9.groupCount)
	packSGraphicsShaderGroupCreateInfoNV(x.PGroups, x.refabf1b7d9.pGroups)
	x.PipelineCount = (uint32)(x.refabf1b7d9.pipelineCount)
	hxf4a9453 := (*sliceHeader)(unsafe.Pointer(&x.PPipelines))
	hxf4a9453.Data = unsafe.Pointer(x.refabf1b7d9.pPipelines)
	hxf4a9453.Cap = 0x7fffffff
	// hxf4a9453.Len = ?

}

// allocBindShaderGroupIndirectCommandNVMemory allocates memory for type C.VkBindShaderGroupIndirectCommandNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindShaderGroupIndirectCommandNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindShaderGroupIndirectCommandNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindShaderGroupIndirectCommandNVValue = unsafe.Sizeof([1]C.VkBindShaderGroupIndirectCommandNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindShaderGroupIndirectCommandNV) Ref() *C.VkBindShaderGroupIndirectCommandNV {
	if x == nil {
		return nil
	}
	return x.ref4b098fa3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindShaderGroupIndirectCommandNV) Free() {
	if x != nil && x.allocs4b098fa3 != nil {
		x.allocs4b098fa3.(*cgoAllocMap).Free()
		x.ref4b098fa3 = nil
	}
}

// NewBindShaderGroupIndirectCommandNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindShaderGroupIndirectCommandNVRef(ref unsafe.Pointer) *BindShaderGroupIndirectCommandNV {
	if ref == nil {
		return nil
	}
	obj := new(BindShaderGroupIndirectCommandNV)
	obj.ref4b098fa3 = (*C.VkBindShaderGroupIndirectCommandNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindShaderGroupIndirectCommandNV) PassRef() (*C.VkBindShaderGroupIndirectCommandNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b098fa3 != nil {
		return x.ref4b098fa3, nil
	}
	mem4b098fa3 := allocBindShaderGroupIndirectCommandNVMemory(1)
	ref4b098fa3 := (*C.VkBindShaderGroupIndirectCommandNV)(mem4b098fa3)
	allocs4b098fa3 := new(cgoAllocMap)
	allocs4b098fa3.Add(mem4b098fa3)

	var cgroupIndex_allocs *cgoAllocMap
	ref4b098fa3.groupIndex, cgroupIndex_allocs = (C.uint32_t)(x.GroupIndex), cgoAllocsUnknown
	allocs4b098fa3.Borrow(cgroupIndex_allocs)

	x.ref4b098fa3 = ref4b098fa3
	x.allocs4b098fa3 = allocs4b098fa3
	return ref4b098fa3, allocs4b098fa3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindShaderGroupIndirectCommandNV) PassValue() (C.VkBindShaderGroupIndirectCommandNV, *cgoAllocMap) {
	if x.ref4b098fa3 != nil {
		return *x.ref4b098fa3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindShaderGroupIndirectCommandNV) Deref() {
	if x.ref4b098fa3 == nil {
		return
	}
	x.GroupIndex = (uint32)(x.ref4b098fa3.groupIndex)
}

// allocBindIndexBufferIndirectCommandNVMemory allocates memory for type C.VkBindIndexBufferIndirectCommandNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindIndexBufferIndirectCommandNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindIndexBufferIndirectCommandNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindIndexBufferIndirectCommandNVValue = unsafe.Sizeof([1]C.VkBindIndexBufferIndirectCommandNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindIndexBufferIndirectCommandNV) Ref() *C.VkBindIndexBufferIndirectCommandNV {
	if x == nil {
		return nil
	}
	return x.ref74143926
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindIndexBufferIndirectCommandNV) Free() {
	if x != nil && x.allocs74143926 != nil {
		x.allocs74143926.(*cgoAllocMap).Free()
		x.ref74143926 = nil
	}
}

// NewBindIndexBufferIndirectCommandNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindIndexBufferIndirectCommandNVRef(ref unsafe.Pointer) *BindIndexBufferIndirectCommandNV {
	if ref == nil {
		return nil
	}
	obj := new(BindIndexBufferIndirectCommandNV)
	obj.ref74143926 = (*C.VkBindIndexBufferIndirectCommandNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindIndexBufferIndirectCommandNV) PassRef() (*C.VkBindIndexBufferIndirectCommandNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref74143926 != nil {
		return x.ref74143926, nil
	}
	mem74143926 := allocBindIndexBufferIndirectCommandNVMemory(1)
	ref74143926 := (*C.VkBindIndexBufferIndirectCommandNV)(mem74143926)
	allocs74143926 := new(cgoAllocMap)
	allocs74143926.Add(mem74143926)

	var cbufferAddress_allocs *cgoAllocMap
	ref74143926.bufferAddress, cbufferAddress_allocs = (C.VkDeviceAddress)(x.BufferAddress), cgoAllocsUnknown
	allocs74143926.Borrow(cbufferAddress_allocs)

	var csize_allocs *cgoAllocMap
	ref74143926.size, csize_allocs = (C.uint32_t)(x.Size), cgoAllocsUnknown
	allocs74143926.Borrow(csize_allocs)

	var cindexType_allocs *cgoAllocMap
	ref74143926.indexType, cindexType_allocs = (C.VkIndexType)(x.IndexType), cgoAllocsUnknown
	allocs74143926.Borrow(cindexType_allocs)

	x.ref74143926 = ref74143926
	x.allocs74143926 = allocs74143926
	return ref74143926, allocs74143926

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindIndexBufferIndirectCommandNV) PassValue() (C.VkBindIndexBufferIndirectCommandNV, *cgoAllocMap) {
	if x.ref74143926 != nil {
		return *x.ref74143926, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindIndexBufferIndirectCommandNV) Deref() {
	if x.ref74143926 == nil {
		return
	}
	x.BufferAddress = (DeviceAddress)(x.ref74143926.bufferAddress)
	x.Size = (uint32)(x.ref74143926.size)
	x.IndexType = (IndexType)(x.ref74143926.indexType)
}

// allocBindVertexBufferIndirectCommandNVMemory allocates memory for type C.VkBindVertexBufferIndirectCommandNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindVertexBufferIndirectCommandNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindVertexBufferIndirectCommandNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindVertexBufferIndirectCommandNVValue = unsafe.Sizeof([1]C.VkBindVertexBufferIndirectCommandNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindVertexBufferIndirectCommandNV) Ref() *C.VkBindVertexBufferIndirectCommandNV {
	if x == nil {
		return nil
	}
	return x.refca56f95c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindVertexBufferIndirectCommandNV) Free() {
	if x != nil && x.allocsca56f95c != nil {
		x.allocsca56f95c.(*cgoAllocMap).Free()
		x.refca56f95c = nil
	}
}

// NewBindVertexBufferIndirectCommandNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindVertexBufferIndirectCommandNVRef(ref unsafe.Pointer) *BindVertexBufferIndirectCommandNV {
	if ref == nil {
		return nil
	}
	obj := new(BindVertexBufferIndirectCommandNV)
	obj.refca56f95c = (*C.VkBindVertexBufferIndirectCommandNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindVertexBufferIndirectCommandNV) PassRef() (*C.VkBindVertexBufferIndirectCommandNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refca56f95c != nil {
		return x.refca56f95c, nil
	}
	memca56f95c := allocBindVertexBufferIndirectCommandNVMemory(1)
	refca56f95c := (*C.VkBindVertexBufferIndirectCommandNV)(memca56f95c)
	allocsca56f95c := new(cgoAllocMap)
	allocsca56f95c.Add(memca56f95c)

	var cbufferAddress_allocs *cgoAllocMap
	refca56f95c.bufferAddress, cbufferAddress_allocs = (C.VkDeviceAddress)(x.BufferAddress), cgoAllocsUnknown
	allocsca56f95c.Borrow(cbufferAddress_allocs)

	var csize_allocs *cgoAllocMap
	refca56f95c.size, csize_allocs = (C.uint32_t)(x.Size), cgoAllocsUnknown
	allocsca56f95c.Borrow(csize_allocs)

	var cstride_allocs *cgoAllocMap
	refca56f95c.stride, cstride_allocs = (C.uint32_t)(x.Stride), cgoAllocsUnknown
	allocsca56f95c.Borrow(cstride_allocs)

	x.refca56f95c = refca56f95c
	x.allocsca56f95c = allocsca56f95c
	return refca56f95c, allocsca56f95c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindVertexBufferIndirectCommandNV) PassValue() (C.VkBindVertexBufferIndirectCommandNV, *cgoAllocMap) {
	if x.refca56f95c != nil {
		return *x.refca56f95c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindVertexBufferIndirectCommandNV) Deref() {
	if x.refca56f95c == nil {
		return
	}
	x.BufferAddress = (DeviceAddress)(x.refca56f95c.bufferAddress)
	x.Size = (uint32)(x.refca56f95c.size)
	x.Stride = (uint32)(x.refca56f95c.stride)
}

// allocSetStateFlagsIndirectCommandNVMemory allocates memory for type C.VkSetStateFlagsIndirectCommandNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSetStateFlagsIndirectCommandNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSetStateFlagsIndirectCommandNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSetStateFlagsIndirectCommandNVValue = unsafe.Sizeof([1]C.VkSetStateFlagsIndirectCommandNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SetStateFlagsIndirectCommandNV) Ref() *C.VkSetStateFlagsIndirectCommandNV {
	if x == nil {
		return nil
	}
	return x.ref89ae676d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SetStateFlagsIndirectCommandNV) Free() {
	if x != nil && x.allocs89ae676d != nil {
		x.allocs89ae676d.(*cgoAllocMap).Free()
		x.ref89ae676d = nil
	}
}

// NewSetStateFlagsIndirectCommandNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSetStateFlagsIndirectCommandNVRef(ref unsafe.Pointer) *SetStateFlagsIndirectCommandNV {
	if ref == nil {
		return nil
	}
	obj := new(SetStateFlagsIndirectCommandNV)
	obj.ref89ae676d = (*C.VkSetStateFlagsIndirectCommandNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SetStateFlagsIndirectCommandNV) PassRef() (*C.VkSetStateFlagsIndirectCommandNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref89ae676d != nil {
		return x.ref89ae676d, nil
	}
	mem89ae676d := allocSetStateFlagsIndirectCommandNVMemory(1)
	ref89ae676d := (*C.VkSetStateFlagsIndirectCommandNV)(mem89ae676d)
	allocs89ae676d := new(cgoAllocMap)
	allocs89ae676d.Add(mem89ae676d)

	var cdata_allocs *cgoAllocMap
	ref89ae676d.data, cdata_allocs = (C.uint32_t)(x.Data), cgoAllocsUnknown
	allocs89ae676d.Borrow(cdata_allocs)

	x.ref89ae676d = ref89ae676d
	x.allocs89ae676d = allocs89ae676d
	return ref89ae676d, allocs89ae676d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SetStateFlagsIndirectCommandNV) PassValue() (C.VkSetStateFlagsIndirectCommandNV, *cgoAllocMap) {
	if x.ref89ae676d != nil {
		return *x.ref89ae676d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SetStateFlagsIndirectCommandNV) Deref() {
	if x.ref89ae676d == nil {
		return
	}
	x.Data = (uint32)(x.ref89ae676d.data)
}

// allocIndirectCommandsStreamNVMemory allocates memory for type C.VkIndirectCommandsStreamNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIndirectCommandsStreamNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIndirectCommandsStreamNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIndirectCommandsStreamNVValue = unsafe.Sizeof([1]C.VkIndirectCommandsStreamNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *IndirectCommandsStreamNV) Ref() *C.VkIndirectCommandsStreamNV {
	if x == nil {
		return nil
	}
	return x.refc623636a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *IndirectCommandsStreamNV) Free() {
	if x != nil && x.allocsc623636a != nil {
		x.allocsc623636a.(*cgoAllocMap).Free()
		x.refc623636a = nil
	}
}

// NewIndirectCommandsStreamNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewIndirectCommandsStreamNVRef(ref unsafe.Pointer) *IndirectCommandsStreamNV {
	if ref == nil {
		return nil
	}
	obj := new(IndirectCommandsStreamNV)
	obj.refc623636a = (*C.VkIndirectCommandsStreamNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *IndirectCommandsStreamNV) PassRef() (*C.VkIndirectCommandsStreamNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc623636a != nil {
		return x.refc623636a, nil
	}
	memc623636a := allocIndirectCommandsStreamNVMemory(1)
	refc623636a := (*C.VkIndirectCommandsStreamNV)(memc623636a)
	allocsc623636a := new(cgoAllocMap)
	allocsc623636a.Add(memc623636a)

	var cbuffer_allocs *cgoAllocMap
	refc623636a.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsc623636a.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	refc623636a.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocsc623636a.Borrow(coffset_allocs)

	x.refc623636a = refc623636a
	x.allocsc623636a = allocsc623636a
	return refc623636a, allocsc623636a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x IndirectCommandsStreamNV) PassValue() (C.VkIndirectCommandsStreamNV, *cgoAllocMap) {
	if x.refc623636a != nil {
		return *x.refc623636a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *IndirectCommandsStreamNV) Deref() {
	if x.refc623636a == nil {
		return
	}
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refc623636a.buffer))
	x.Offset = (DeviceSize)(x.refc623636a.offset)
}

// allocIndirectCommandsLayoutTokenNVMemory allocates memory for type C.VkIndirectCommandsLayoutTokenNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIndirectCommandsLayoutTokenNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIndirectCommandsLayoutTokenNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIndirectCommandsLayoutTokenNVValue = unsafe.Sizeof([1]C.VkIndirectCommandsLayoutTokenNV{})

// copyPIndexTypeBytes copies the data from Go slice as *C.VkIndexType.
func copyPIndexTypeBytes(slice *sliceHeader) (*C.VkIndexType, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfIndexTypeValue) * slice.Len,
		Cap:  int(sizeOfIndexTypeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkIndexType)(mem0), allocs
}

// allocIndexTypeMemory allocates memory for type C.VkIndexType in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIndexTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIndexTypeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIndexTypeValue = unsafe.Sizeof([1]C.VkIndexType{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *IndirectCommandsLayoutTokenNV) Ref() *C.VkIndirectCommandsLayoutTokenNV {
	if x == nil {
		return nil
	}
	return x.ref96f52b76
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *IndirectCommandsLayoutTokenNV) Free() {
	if x != nil && x.allocs96f52b76 != nil {
		x.allocs96f52b76.(*cgoAllocMap).Free()
		x.ref96f52b76 = nil
	}
}

// NewIndirectCommandsLayoutTokenNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewIndirectCommandsLayoutTokenNVRef(ref unsafe.Pointer) *IndirectCommandsLayoutTokenNV {
	if ref == nil {
		return nil
	}
	obj := new(IndirectCommandsLayoutTokenNV)
	obj.ref96f52b76 = (*C.VkIndirectCommandsLayoutTokenNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *IndirectCommandsLayoutTokenNV) PassRef() (*C.VkIndirectCommandsLayoutTokenNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref96f52b76 != nil {
		return x.ref96f52b76, nil
	}
	mem96f52b76 := allocIndirectCommandsLayoutTokenNVMemory(1)
	ref96f52b76 := (*C.VkIndirectCommandsLayoutTokenNV)(mem96f52b76)
	allocs96f52b76 := new(cgoAllocMap)
	allocs96f52b76.Add(mem96f52b76)

	var csType_allocs *cgoAllocMap
	ref96f52b76.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs96f52b76.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref96f52b76.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs96f52b76.Borrow(cpNext_allocs)

	var ctokenType_allocs *cgoAllocMap
	ref96f52b76.tokenType, ctokenType_allocs = (C.VkIndirectCommandsTokenTypeNV)(x.TokenType), cgoAllocsUnknown
	allocs96f52b76.Borrow(ctokenType_allocs)

	var cstream_allocs *cgoAllocMap
	ref96f52b76.stream, cstream_allocs = (C.uint32_t)(x.Stream), cgoAllocsUnknown
	allocs96f52b76.Borrow(cstream_allocs)

	var coffset_allocs *cgoAllocMap
	ref96f52b76.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocs96f52b76.Borrow(coffset_allocs)

	var cvertexBindingUnit_allocs *cgoAllocMap
	ref96f52b76.vertexBindingUnit, cvertexBindingUnit_allocs = (C.uint32_t)(x.VertexBindingUnit), cgoAllocsUnknown
	allocs96f52b76.Borrow(cvertexBindingUnit_allocs)

	var cvertexDynamicStride_allocs *cgoAllocMap
	ref96f52b76.vertexDynamicStride, cvertexDynamicStride_allocs = (C.VkBool32)(x.VertexDynamicStride), cgoAllocsUnknown
	allocs96f52b76.Borrow(cvertexDynamicStride_allocs)

	var cpushconstantPipelineLayout_allocs *cgoAllocMap
	ref96f52b76.pushconstantPipelineLayout, cpushconstantPipelineLayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.PushconstantPipelineLayout)), cgoAllocsUnknown
	allocs96f52b76.Borrow(cpushconstantPipelineLayout_allocs)

	var cpushconstantShaderStageFlags_allocs *cgoAllocMap
	ref96f52b76.pushconstantShaderStageFlags, cpushconstantShaderStageFlags_allocs = (C.VkShaderStageFlags)(x.PushconstantShaderStageFlags), cgoAllocsUnknown
	allocs96f52b76.Borrow(cpushconstantShaderStageFlags_allocs)

	var cpushconstantOffset_allocs *cgoAllocMap
	ref96f52b76.pushconstantOffset, cpushconstantOffset_allocs = (C.uint32_t)(x.PushconstantOffset), cgoAllocsUnknown
	allocs96f52b76.Borrow(cpushconstantOffset_allocs)

	var cpushconstantSize_allocs *cgoAllocMap
	ref96f52b76.pushconstantSize, cpushconstantSize_allocs = (C.uint32_t)(x.PushconstantSize), cgoAllocsUnknown
	allocs96f52b76.Borrow(cpushconstantSize_allocs)

	var cindirectStateFlags_allocs *cgoAllocMap
	ref96f52b76.indirectStateFlags, cindirectStateFlags_allocs = (C.VkIndirectStateFlagsNV)(x.IndirectStateFlags), cgoAllocsUnknown
	allocs96f52b76.Borrow(cindirectStateFlags_allocs)

	var cindexTypeCount_allocs *cgoAllocMap
	ref96f52b76.indexTypeCount, cindexTypeCount_allocs = (C.uint32_t)(x.IndexTypeCount), cgoAllocsUnknown
	allocs96f52b76.Borrow(cindexTypeCount_allocs)

	var cpIndexTypes_allocs *cgoAllocMap
	ref96f52b76.pIndexTypes, cpIndexTypes_allocs = copyPIndexTypeBytes((*sliceHeader)(unsafe.Pointer(&x.PIndexTypes)))
	allocs96f52b76.Borrow(cpIndexTypes_allocs)

	var cpIndexTypeValues_allocs *cgoAllocMap
	ref96f52b76.pIndexTypeValues, cpIndexTypeValues_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PIndexTypeValues)))
	allocs96f52b76.Borrow(cpIndexTypeValues_allocs)

	x.ref96f52b76 = ref96f52b76
	x.allocs96f52b76 = allocs96f52b76
	return ref96f52b76, allocs96f52b76

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x IndirectCommandsLayoutTokenNV) PassValue() (C.VkIndirectCommandsLayoutTokenNV, *cgoAllocMap) {
	if x.ref96f52b76 != nil {
		return *x.ref96f52b76, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *IndirectCommandsLayoutTokenNV) Deref() {
	if x.ref96f52b76 == nil {
		return
	}
	x.SType = (StructureType)(x.ref96f52b76.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref96f52b76.pNext))
	x.TokenType = (IndirectCommandsTokenTypeNV)(x.ref96f52b76.tokenType)
	x.Stream = (uint32)(x.ref96f52b76.stream)
	x.Offset = (uint32)(x.ref96f52b76.offset)
	x.VertexBindingUnit = (uint32)(x.ref96f52b76.vertexBindingUnit)
	x.VertexDynamicStride = (Bool32)(x.ref96f52b76.vertexDynamicStride)
	x.PushconstantPipelineLayout = *(*PipelineLayout)(unsafe.Pointer(&x.ref96f52b76.pushconstantPipelineLayout))
	x.PushconstantShaderStageFlags = (ShaderStageFlags)(x.ref96f52b76.pushconstantShaderStageFlags)
	x.PushconstantOffset = (uint32)(x.ref96f52b76.pushconstantOffset)
	x.PushconstantSize = (uint32)(x.ref96f52b76.pushconstantSize)
	x.IndirectStateFlags = (IndirectStateFlagsNV)(x.ref96f52b76.indirectStateFlags)
	x.IndexTypeCount = (uint32)(x.ref96f52b76.indexTypeCount)
	hxf1a1416 := (*sliceHeader)(unsafe.Pointer(&x.PIndexTypes))
	hxf1a1416.Data = unsafe.Pointer(x.ref96f52b76.pIndexTypes)
	hxf1a1416.Cap = 0x7fffffff
	// hxf1a1416.Len = ?

	hxf92be66 := (*sliceHeader)(unsafe.Pointer(&x.PIndexTypeValues))
	hxf92be66.Data = unsafe.Pointer(x.ref96f52b76.pIndexTypeValues)
	hxf92be66.Cap = 0x7fffffff
	// hxf92be66.Len = ?

}

// allocIndirectCommandsLayoutCreateInfoNVMemory allocates memory for type C.VkIndirectCommandsLayoutCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIndirectCommandsLayoutCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIndirectCommandsLayoutCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIndirectCommandsLayoutCreateInfoNVValue = unsafe.Sizeof([1]C.VkIndirectCommandsLayoutCreateInfoNV{})

// unpackSIndirectCommandsLayoutTokenNV transforms a sliced Go data structure into plain C format.
func unpackSIndirectCommandsLayoutTokenNV(x []IndirectCommandsLayoutTokenNV) (unpacked *C.VkIndirectCommandsLayoutTokenNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocIndirectCommandsLayoutTokenNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkIndirectCommandsLayoutTokenNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkIndirectCommandsLayoutTokenNV)(h.Data)
	return
}

// packSIndirectCommandsLayoutTokenNV reads sliced Go data structure out from plain C format.
func packSIndirectCommandsLayoutTokenNV(v []IndirectCommandsLayoutTokenNV, ptr0 *C.VkIndirectCommandsLayoutTokenNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfIndirectCommandsLayoutTokenNVValue]C.VkIndirectCommandsLayoutTokenNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewIndirectCommandsLayoutTokenNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *IndirectCommandsLayoutCreateInfoNV) Ref() *C.VkIndirectCommandsLayoutCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref48273185
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *IndirectCommandsLayoutCreateInfoNV) Free() {
	if x != nil && x.allocs48273185 != nil {
		x.allocs48273185.(*cgoAllocMap).Free()
		x.ref48273185 = nil
	}
}

// NewIndirectCommandsLayoutCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewIndirectCommandsLayoutCreateInfoNVRef(ref unsafe.Pointer) *IndirectCommandsLayoutCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(IndirectCommandsLayoutCreateInfoNV)
	obj.ref48273185 = (*C.VkIndirectCommandsLayoutCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *IndirectCommandsLayoutCreateInfoNV) PassRef() (*C.VkIndirectCommandsLayoutCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref48273185 != nil {
		return x.ref48273185, nil
	}
	mem48273185 := allocIndirectCommandsLayoutCreateInfoNVMemory(1)
	ref48273185 := (*C.VkIndirectCommandsLayoutCreateInfoNV)(mem48273185)
	allocs48273185 := new(cgoAllocMap)
	allocs48273185.Add(mem48273185)

	var csType_allocs *cgoAllocMap
	ref48273185.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs48273185.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref48273185.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs48273185.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref48273185.flags, cflags_allocs = (C.VkIndirectCommandsLayoutUsageFlagsNV)(x.Flags), cgoAllocsUnknown
	allocs48273185.Borrow(cflags_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	ref48273185.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocs48273185.Borrow(cpipelineBindPoint_allocs)

	var ctokenCount_allocs *cgoAllocMap
	ref48273185.tokenCount, ctokenCount_allocs = (C.uint32_t)(x.TokenCount), cgoAllocsUnknown
	allocs48273185.Borrow(ctokenCount_allocs)

	var cpTokens_allocs *cgoAllocMap
	ref48273185.pTokens, cpTokens_allocs = unpackSIndirectCommandsLayoutTokenNV(x.PTokens)
	allocs48273185.Borrow(cpTokens_allocs)

	var cstreamCount_allocs *cgoAllocMap
	ref48273185.streamCount, cstreamCount_allocs = (C.uint32_t)(x.StreamCount), cgoAllocsUnknown
	allocs48273185.Borrow(cstreamCount_allocs)

	var cpStreamStrides_allocs *cgoAllocMap
	ref48273185.pStreamStrides, cpStreamStrides_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PStreamStrides)))
	allocs48273185.Borrow(cpStreamStrides_allocs)

	x.ref48273185 = ref48273185
	x.allocs48273185 = allocs48273185
	return ref48273185, allocs48273185

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x IndirectCommandsLayoutCreateInfoNV) PassValue() (C.VkIndirectCommandsLayoutCreateInfoNV, *cgoAllocMap) {
	if x.ref48273185 != nil {
		return *x.ref48273185, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *IndirectCommandsLayoutCreateInfoNV) Deref() {
	if x.ref48273185 == nil {
		return
	}
	x.SType = (StructureType)(x.ref48273185.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref48273185.pNext))
	x.Flags = (IndirectCommandsLayoutUsageFlagsNV)(x.ref48273185.flags)
	x.PipelineBindPoint = (PipelineBindPoint)(x.ref48273185.pipelineBindPoint)
	x.TokenCount = (uint32)(x.ref48273185.tokenCount)
	packSIndirectCommandsLayoutTokenNV(x.PTokens, x.ref48273185.pTokens)
	x.StreamCount = (uint32)(x.ref48273185.streamCount)
	hxf4b5187 := (*sliceHeader)(unsafe.Pointer(&x.PStreamStrides))
	hxf4b5187.Data = unsafe.Pointer(x.ref48273185.pStreamStrides)
	hxf4b5187.Cap = 0x7fffffff
	// hxf4b5187.Len = ?

}

// allocGeneratedCommandsInfoNVMemory allocates memory for type C.VkGeneratedCommandsInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGeneratedCommandsInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGeneratedCommandsInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGeneratedCommandsInfoNVValue = unsafe.Sizeof([1]C.VkGeneratedCommandsInfoNV{})

// unpackSIndirectCommandsStreamNV transforms a sliced Go data structure into plain C format.
func unpackSIndirectCommandsStreamNV(x []IndirectCommandsStreamNV) (unpacked *C.VkIndirectCommandsStreamNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocIndirectCommandsStreamNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkIndirectCommandsStreamNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkIndirectCommandsStreamNV)(h.Data)
	return
}

// packSIndirectCommandsStreamNV reads sliced Go data structure out from plain C format.
func packSIndirectCommandsStreamNV(v []IndirectCommandsStreamNV, ptr0 *C.VkIndirectCommandsStreamNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfIndirectCommandsStreamNVValue]C.VkIndirectCommandsStreamNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewIndirectCommandsStreamNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GeneratedCommandsInfoNV) Ref() *C.VkGeneratedCommandsInfoNV {
	if x == nil {
		return nil
	}
	return x.refc05396ea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GeneratedCommandsInfoNV) Free() {
	if x != nil && x.allocsc05396ea != nil {
		x.allocsc05396ea.(*cgoAllocMap).Free()
		x.refc05396ea = nil
	}
}

// NewGeneratedCommandsInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGeneratedCommandsInfoNVRef(ref unsafe.Pointer) *GeneratedCommandsInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(GeneratedCommandsInfoNV)
	obj.refc05396ea = (*C.VkGeneratedCommandsInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GeneratedCommandsInfoNV) PassRef() (*C.VkGeneratedCommandsInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc05396ea != nil {
		return x.refc05396ea, nil
	}
	memc05396ea := allocGeneratedCommandsInfoNVMemory(1)
	refc05396ea := (*C.VkGeneratedCommandsInfoNV)(memc05396ea)
	allocsc05396ea := new(cgoAllocMap)
	allocsc05396ea.Add(memc05396ea)

	var csType_allocs *cgoAllocMap
	refc05396ea.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc05396ea.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc05396ea.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc05396ea.Borrow(cpNext_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	refc05396ea.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocsc05396ea.Borrow(cpipelineBindPoint_allocs)

	var cpipeline_allocs *cgoAllocMap
	refc05396ea.pipeline, cpipeline_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.Pipeline)), cgoAllocsUnknown
	allocsc05396ea.Borrow(cpipeline_allocs)

	var cindirectCommandsLayout_allocs *cgoAllocMap
	refc05396ea.indirectCommandsLayout, cindirectCommandsLayout_allocs = *(*C.VkIndirectCommandsLayoutNV)(unsafe.Pointer(&x.IndirectCommandsLayout)), cgoAllocsUnknown
	allocsc05396ea.Borrow(cindirectCommandsLayout_allocs)

	var cstreamCount_allocs *cgoAllocMap
	refc05396ea.streamCount, cstreamCount_allocs = (C.uint32_t)(x.StreamCount), cgoAllocsUnknown
	allocsc05396ea.Borrow(cstreamCount_allocs)

	var cpStreams_allocs *cgoAllocMap
	refc05396ea.pStreams, cpStreams_allocs = unpackSIndirectCommandsStreamNV(x.PStreams)
	allocsc05396ea.Borrow(cpStreams_allocs)

	var csequencesCount_allocs *cgoAllocMap
	refc05396ea.sequencesCount, csequencesCount_allocs = (C.uint32_t)(x.SequencesCount), cgoAllocsUnknown
	allocsc05396ea.Borrow(csequencesCount_allocs)

	var cpreprocessBuffer_allocs *cgoAllocMap
	refc05396ea.preprocessBuffer, cpreprocessBuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.PreprocessBuffer)), cgoAllocsUnknown
	allocsc05396ea.Borrow(cpreprocessBuffer_allocs)

	var cpreprocessOffset_allocs *cgoAllocMap
	refc05396ea.preprocessOffset, cpreprocessOffset_allocs = (C.VkDeviceSize)(x.PreprocessOffset), cgoAllocsUnknown
	allocsc05396ea.Borrow(cpreprocessOffset_allocs)

	var cpreprocessSize_allocs *cgoAllocMap
	refc05396ea.preprocessSize, cpreprocessSize_allocs = (C.VkDeviceSize)(x.PreprocessSize), cgoAllocsUnknown
	allocsc05396ea.Borrow(cpreprocessSize_allocs)

	var csequencesCountBuffer_allocs *cgoAllocMap
	refc05396ea.sequencesCountBuffer, csequencesCountBuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.SequencesCountBuffer)), cgoAllocsUnknown
	allocsc05396ea.Borrow(csequencesCountBuffer_allocs)

	var csequencesCountOffset_allocs *cgoAllocMap
	refc05396ea.sequencesCountOffset, csequencesCountOffset_allocs = (C.VkDeviceSize)(x.SequencesCountOffset), cgoAllocsUnknown
	allocsc05396ea.Borrow(csequencesCountOffset_allocs)

	var csequencesIndexBuffer_allocs *cgoAllocMap
	refc05396ea.sequencesIndexBuffer, csequencesIndexBuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.SequencesIndexBuffer)), cgoAllocsUnknown
	allocsc05396ea.Borrow(csequencesIndexBuffer_allocs)

	var csequencesIndexOffset_allocs *cgoAllocMap
	refc05396ea.sequencesIndexOffset, csequencesIndexOffset_allocs = (C.VkDeviceSize)(x.SequencesIndexOffset), cgoAllocsUnknown
	allocsc05396ea.Borrow(csequencesIndexOffset_allocs)

	x.refc05396ea = refc05396ea
	x.allocsc05396ea = allocsc05396ea
	return refc05396ea, allocsc05396ea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GeneratedCommandsInfoNV) PassValue() (C.VkGeneratedCommandsInfoNV, *cgoAllocMap) {
	if x.refc05396ea != nil {
		return *x.refc05396ea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GeneratedCommandsInfoNV) Deref() {
	if x.refc05396ea == nil {
		return
	}
	x.SType = (StructureType)(x.refc05396ea.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc05396ea.pNext))
	x.PipelineBindPoint = (PipelineBindPoint)(x.refc05396ea.pipelineBindPoint)
	x.Pipeline = *(*Pipeline)(unsafe.Pointer(&x.refc05396ea.pipeline))
	x.IndirectCommandsLayout = *(*IndirectCommandsLayoutNV)(unsafe.Pointer(&x.refc05396ea.indirectCommandsLayout))
	x.StreamCount = (uint32)(x.refc05396ea.streamCount)
	packSIndirectCommandsStreamNV(x.PStreams, x.refc05396ea.pStreams)
	x.SequencesCount = (uint32)(x.refc05396ea.sequencesCount)
	x.PreprocessBuffer = *(*Buffer)(unsafe.Pointer(&x.refc05396ea.preprocessBuffer))
	x.PreprocessOffset = (DeviceSize)(x.refc05396ea.preprocessOffset)
	x.PreprocessSize = (DeviceSize)(x.refc05396ea.preprocessSize)
	x.SequencesCountBuffer = *(*Buffer)(unsafe.Pointer(&x.refc05396ea.sequencesCountBuffer))
	x.SequencesCountOffset = (DeviceSize)(x.refc05396ea.sequencesCountOffset)
	x.SequencesIndexBuffer = *(*Buffer)(unsafe.Pointer(&x.refc05396ea.sequencesIndexBuffer))
	x.SequencesIndexOffset = (DeviceSize)(x.refc05396ea.sequencesIndexOffset)
}

// allocGeneratedCommandsMemoryRequirementsInfoNVMemory allocates memory for type C.VkGeneratedCommandsMemoryRequirementsInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGeneratedCommandsMemoryRequirementsInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGeneratedCommandsMemoryRequirementsInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGeneratedCommandsMemoryRequirementsInfoNVValue = unsafe.Sizeof([1]C.VkGeneratedCommandsMemoryRequirementsInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GeneratedCommandsMemoryRequirementsInfoNV) Ref() *C.VkGeneratedCommandsMemoryRequirementsInfoNV {
	if x == nil {
		return nil
	}
	return x.refe82e5c4c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GeneratedCommandsMemoryRequirementsInfoNV) Free() {
	if x != nil && x.allocse82e5c4c != nil {
		x.allocse82e5c4c.(*cgoAllocMap).Free()
		x.refe82e5c4c = nil
	}
}

// NewGeneratedCommandsMemoryRequirementsInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGeneratedCommandsMemoryRequirementsInfoNVRef(ref unsafe.Pointer) *GeneratedCommandsMemoryRequirementsInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(GeneratedCommandsMemoryRequirementsInfoNV)
	obj.refe82e5c4c = (*C.VkGeneratedCommandsMemoryRequirementsInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GeneratedCommandsMemoryRequirementsInfoNV) PassRef() (*C.VkGeneratedCommandsMemoryRequirementsInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe82e5c4c != nil {
		return x.refe82e5c4c, nil
	}
	meme82e5c4c := allocGeneratedCommandsMemoryRequirementsInfoNVMemory(1)
	refe82e5c4c := (*C.VkGeneratedCommandsMemoryRequirementsInfoNV)(meme82e5c4c)
	allocse82e5c4c := new(cgoAllocMap)
	allocse82e5c4c.Add(meme82e5c4c)

	var csType_allocs *cgoAllocMap
	refe82e5c4c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse82e5c4c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe82e5c4c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse82e5c4c.Borrow(cpNext_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	refe82e5c4c.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocse82e5c4c.Borrow(cpipelineBindPoint_allocs)

	var cpipeline_allocs *cgoAllocMap
	refe82e5c4c.pipeline, cpipeline_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.Pipeline)), cgoAllocsUnknown
	allocse82e5c4c.Borrow(cpipeline_allocs)

	var cindirectCommandsLayout_allocs *cgoAllocMap
	refe82e5c4c.indirectCommandsLayout, cindirectCommandsLayout_allocs = *(*C.VkIndirectCommandsLayoutNV)(unsafe.Pointer(&x.IndirectCommandsLayout)), cgoAllocsUnknown
	allocse82e5c4c.Borrow(cindirectCommandsLayout_allocs)

	var cmaxSequencesCount_allocs *cgoAllocMap
	refe82e5c4c.maxSequencesCount, cmaxSequencesCount_allocs = (C.uint32_t)(x.MaxSequencesCount), cgoAllocsUnknown
	allocse82e5c4c.Borrow(cmaxSequencesCount_allocs)

	x.refe82e5c4c = refe82e5c4c
	x.allocse82e5c4c = allocse82e5c4c
	return refe82e5c4c, allocse82e5c4c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GeneratedCommandsMemoryRequirementsInfoNV) PassValue() (C.VkGeneratedCommandsMemoryRequirementsInfoNV, *cgoAllocMap) {
	if x.refe82e5c4c != nil {
		return *x.refe82e5c4c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GeneratedCommandsMemoryRequirementsInfoNV) Deref() {
	if x.refe82e5c4c == nil {
		return
	}
	x.SType = (StructureType)(x.refe82e5c4c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe82e5c4c.pNext))
	x.PipelineBindPoint = (PipelineBindPoint)(x.refe82e5c4c.pipelineBindPoint)
	x.Pipeline = *(*Pipeline)(unsafe.Pointer(&x.refe82e5c4c.pipeline))
	x.IndirectCommandsLayout = *(*IndirectCommandsLayoutNV)(unsafe.Pointer(&x.refe82e5c4c.indirectCommandsLayout))
	x.MaxSequencesCount = (uint32)(x.refe82e5c4c.maxSequencesCount)
}

// allocPhysicalDeviceInheritedViewportScissorFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceInheritedViewportScissorFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceInheritedViewportScissorFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceInheritedViewportScissorFeaturesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceInheritedViewportScissorFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceInheritedViewportScissorFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceInheritedViewportScissorFeaturesNV) Ref() *C.VkPhysicalDeviceInheritedViewportScissorFeaturesNV {
	if x == nil {
		return nil
	}
	return x.refcec68147
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceInheritedViewportScissorFeaturesNV) Free() {
	if x != nil && x.allocscec68147 != nil {
		x.allocscec68147.(*cgoAllocMap).Free()
		x.refcec68147 = nil
	}
}

// NewPhysicalDeviceInheritedViewportScissorFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceInheritedViewportScissorFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceInheritedViewportScissorFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceInheritedViewportScissorFeaturesNV)
	obj.refcec68147 = (*C.VkPhysicalDeviceInheritedViewportScissorFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceInheritedViewportScissorFeaturesNV) PassRef() (*C.VkPhysicalDeviceInheritedViewportScissorFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcec68147 != nil {
		return x.refcec68147, nil
	}
	memcec68147 := allocPhysicalDeviceInheritedViewportScissorFeaturesNVMemory(1)
	refcec68147 := (*C.VkPhysicalDeviceInheritedViewportScissorFeaturesNV)(memcec68147)
	allocscec68147 := new(cgoAllocMap)
	allocscec68147.Add(memcec68147)

	var csType_allocs *cgoAllocMap
	refcec68147.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscec68147.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcec68147.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscec68147.Borrow(cpNext_allocs)

	var cinheritedViewportScissor2D_allocs *cgoAllocMap
	refcec68147.inheritedViewportScissor2D, cinheritedViewportScissor2D_allocs = (C.VkBool32)(x.InheritedViewportScissor2D), cgoAllocsUnknown
	allocscec68147.Borrow(cinheritedViewportScissor2D_allocs)

	x.refcec68147 = refcec68147
	x.allocscec68147 = allocscec68147
	return refcec68147, allocscec68147

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceInheritedViewportScissorFeaturesNV) PassValue() (C.VkPhysicalDeviceInheritedViewportScissorFeaturesNV, *cgoAllocMap) {
	if x.refcec68147 != nil {
		return *x.refcec68147, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceInheritedViewportScissorFeaturesNV) Deref() {
	if x.refcec68147 == nil {
		return
	}
	x.SType = (StructureType)(x.refcec68147.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcec68147.pNext))
	x.InheritedViewportScissor2D = (Bool32)(x.refcec68147.inheritedViewportScissor2D)
}

// allocCommandBufferInheritanceViewportScissorInfoNVMemory allocates memory for type C.VkCommandBufferInheritanceViewportScissorInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferInheritanceViewportScissorInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferInheritanceViewportScissorInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCommandBufferInheritanceViewportScissorInfoNVValue = unsafe.Sizeof([1]C.VkCommandBufferInheritanceViewportScissorInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferInheritanceViewportScissorInfoNV) Ref() *C.VkCommandBufferInheritanceViewportScissorInfoNV {
	if x == nil {
		return nil
	}
	return x.refc206d63
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferInheritanceViewportScissorInfoNV) Free() {
	if x != nil && x.allocsc206d63 != nil {
		x.allocsc206d63.(*cgoAllocMap).Free()
		x.refc206d63 = nil
	}
}

// NewCommandBufferInheritanceViewportScissorInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferInheritanceViewportScissorInfoNVRef(ref unsafe.Pointer) *CommandBufferInheritanceViewportScissorInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferInheritanceViewportScissorInfoNV)
	obj.refc206d63 = (*C.VkCommandBufferInheritanceViewportScissorInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferInheritanceViewportScissorInfoNV) PassRef() (*C.VkCommandBufferInheritanceViewportScissorInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc206d63 != nil {
		return x.refc206d63, nil
	}
	memc206d63 := allocCommandBufferInheritanceViewportScissorInfoNVMemory(1)
	refc206d63 := (*C.VkCommandBufferInheritanceViewportScissorInfoNV)(memc206d63)
	allocsc206d63 := new(cgoAllocMap)
	allocsc206d63.Add(memc206d63)

	var csType_allocs *cgoAllocMap
	refc206d63.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc206d63.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc206d63.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc206d63.Borrow(cpNext_allocs)

	var cviewportScissor2D_allocs *cgoAllocMap
	refc206d63.viewportScissor2D, cviewportScissor2D_allocs = (C.VkBool32)(x.ViewportScissor2D), cgoAllocsUnknown
	allocsc206d63.Borrow(cviewportScissor2D_allocs)

	var cviewportDepthCount_allocs *cgoAllocMap
	refc206d63.viewportDepthCount, cviewportDepthCount_allocs = (C.uint32_t)(x.ViewportDepthCount), cgoAllocsUnknown
	allocsc206d63.Borrow(cviewportDepthCount_allocs)

	var cpViewportDepths_allocs *cgoAllocMap
	refc206d63.pViewportDepths, cpViewportDepths_allocs = unpackSViewport(x.PViewportDepths)
	allocsc206d63.Borrow(cpViewportDepths_allocs)

	x.refc206d63 = refc206d63
	x.allocsc206d63 = allocsc206d63
	return refc206d63, allocsc206d63

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferInheritanceViewportScissorInfoNV) PassValue() (C.VkCommandBufferInheritanceViewportScissorInfoNV, *cgoAllocMap) {
	if x.refc206d63 != nil {
		return *x.refc206d63, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferInheritanceViewportScissorInfoNV) Deref() {
	if x.refc206d63 == nil {
		return
	}
	x.SType = (StructureType)(x.refc206d63.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc206d63.pNext))
	x.ViewportScissor2D = (Bool32)(x.refc206d63.viewportScissor2D)
	x.ViewportDepthCount = (uint32)(x.refc206d63.viewportDepthCount)
	packSViewport(x.PViewportDepths, x.refc206d63.pViewportDepths)
}

// allocPhysicalDeviceTexelBufferAlignmentFeaturesMemory allocates memory for type C.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceTexelBufferAlignmentFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceTexelBufferAlignmentFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceTexelBufferAlignmentFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceTexelBufferAlignmentFeatures) Ref() *C.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref2c4411b2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceTexelBufferAlignmentFeatures) Free() {
	if x != nil && x.allocs2c4411b2 != nil {
		x.allocs2c4411b2.(*cgoAllocMap).Free()
		x.ref2c4411b2 = nil
	}
}

// NewPhysicalDeviceTexelBufferAlignmentFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceTexelBufferAlignmentFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceTexelBufferAlignmentFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceTexelBufferAlignmentFeatures)
	obj.ref2c4411b2 = (*C.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceTexelBufferAlignmentFeatures) PassRef() (*C.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2c4411b2 != nil {
		return x.ref2c4411b2, nil
	}
	mem2c4411b2 := allocPhysicalDeviceTexelBufferAlignmentFeaturesMemory(1)
	ref2c4411b2 := (*C.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT)(mem2c4411b2)
	allocs2c4411b2 := new(cgoAllocMap)
	allocs2c4411b2.Add(mem2c4411b2)

	var csType_allocs *cgoAllocMap
	ref2c4411b2.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2c4411b2.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2c4411b2.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2c4411b2.Borrow(cpNext_allocs)

	var ctexelBufferAlignment_allocs *cgoAllocMap
	ref2c4411b2.texelBufferAlignment, ctexelBufferAlignment_allocs = (C.VkBool32)(x.TexelBufferAlignment), cgoAllocsUnknown
	allocs2c4411b2.Borrow(ctexelBufferAlignment_allocs)

	x.ref2c4411b2 = ref2c4411b2
	x.allocs2c4411b2 = allocs2c4411b2
	return ref2c4411b2, allocs2c4411b2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceTexelBufferAlignmentFeatures) PassValue() (C.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, *cgoAllocMap) {
	if x.ref2c4411b2 != nil {
		return *x.ref2c4411b2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceTexelBufferAlignmentFeatures) Deref() {
	if x.ref2c4411b2 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2c4411b2.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2c4411b2.pNext))
	x.TexelBufferAlignment = (Bool32)(x.ref2c4411b2.texelBufferAlignment)
}

// allocPhysicalDeviceTexelBufferAlignmentPropertiesMemory allocates memory for type C.VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceTexelBufferAlignmentPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceTexelBufferAlignmentPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceTexelBufferAlignmentPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceTexelBufferAlignmentProperties) Ref() *C.VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refb0335c40
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceTexelBufferAlignmentProperties) Free() {
	if x != nil && x.allocsb0335c40 != nil {
		x.allocsb0335c40.(*cgoAllocMap).Free()
		x.refb0335c40 = nil
	}
}

// NewPhysicalDeviceTexelBufferAlignmentPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceTexelBufferAlignmentPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceTexelBufferAlignmentProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceTexelBufferAlignmentProperties)
	obj.refb0335c40 = (*C.VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceTexelBufferAlignmentProperties) PassRef() (*C.VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0335c40 != nil {
		return x.refb0335c40, nil
	}
	memb0335c40 := allocPhysicalDeviceTexelBufferAlignmentPropertiesMemory(1)
	refb0335c40 := (*C.VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT)(memb0335c40)
	allocsb0335c40 := new(cgoAllocMap)
	allocsb0335c40.Add(memb0335c40)

	var csType_allocs *cgoAllocMap
	refb0335c40.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb0335c40.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb0335c40.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb0335c40.Borrow(cpNext_allocs)

	var cstorageTexelBufferOffsetAlignmentBytes_allocs *cgoAllocMap
	refb0335c40.storageTexelBufferOffsetAlignmentBytes, cstorageTexelBufferOffsetAlignmentBytes_allocs = (C.VkDeviceSize)(x.StorageTexelBufferOffsetAlignmentBytes), cgoAllocsUnknown
	allocsb0335c40.Borrow(cstorageTexelBufferOffsetAlignmentBytes_allocs)

	var cstorageTexelBufferOffsetSingleTexelAlignment_allocs *cgoAllocMap
	refb0335c40.storageTexelBufferOffsetSingleTexelAlignment, cstorageTexelBufferOffsetSingleTexelAlignment_allocs = (C.VkBool32)(x.StorageTexelBufferOffsetSingleTexelAlignment), cgoAllocsUnknown
	allocsb0335c40.Borrow(cstorageTexelBufferOffsetSingleTexelAlignment_allocs)

	var cuniformTexelBufferOffsetAlignmentBytes_allocs *cgoAllocMap
	refb0335c40.uniformTexelBufferOffsetAlignmentBytes, cuniformTexelBufferOffsetAlignmentBytes_allocs = (C.VkDeviceSize)(x.UniformTexelBufferOffsetAlignmentBytes), cgoAllocsUnknown
	allocsb0335c40.Borrow(cuniformTexelBufferOffsetAlignmentBytes_allocs)

	var cuniformTexelBufferOffsetSingleTexelAlignment_allocs *cgoAllocMap
	refb0335c40.uniformTexelBufferOffsetSingleTexelAlignment, cuniformTexelBufferOffsetSingleTexelAlignment_allocs = (C.VkBool32)(x.UniformTexelBufferOffsetSingleTexelAlignment), cgoAllocsUnknown
	allocsb0335c40.Borrow(cuniformTexelBufferOffsetSingleTexelAlignment_allocs)

	x.refb0335c40 = refb0335c40
	x.allocsb0335c40 = allocsb0335c40
	return refb0335c40, allocsb0335c40

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceTexelBufferAlignmentProperties) PassValue() (C.VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT, *cgoAllocMap) {
	if x.refb0335c40 != nil {
		return *x.refb0335c40, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceTexelBufferAlignmentProperties) Deref() {
	if x.refb0335c40 == nil {
		return
	}
	x.SType = (StructureType)(x.refb0335c40.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb0335c40.pNext))
	x.StorageTexelBufferOffsetAlignmentBytes = (DeviceSize)(x.refb0335c40.storageTexelBufferOffsetAlignmentBytes)
	x.StorageTexelBufferOffsetSingleTexelAlignment = (Bool32)(x.refb0335c40.storageTexelBufferOffsetSingleTexelAlignment)
	x.UniformTexelBufferOffsetAlignmentBytes = (DeviceSize)(x.refb0335c40.uniformTexelBufferOffsetAlignmentBytes)
	x.UniformTexelBufferOffsetSingleTexelAlignment = (Bool32)(x.refb0335c40.uniformTexelBufferOffsetSingleTexelAlignment)
}

// allocRenderPassTransformBeginInfoQCOMMemory allocates memory for type C.VkRenderPassTransformBeginInfoQCOM in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassTransformBeginInfoQCOMMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassTransformBeginInfoQCOMValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderPassTransformBeginInfoQCOMValue = unsafe.Sizeof([1]C.VkRenderPassTransformBeginInfoQCOM{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassTransformBeginInfoQCOM) Ref() *C.VkRenderPassTransformBeginInfoQCOM {
	if x == nil {
		return nil
	}
	return x.ref938e681d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassTransformBeginInfoQCOM) Free() {
	if x != nil && x.allocs938e681d != nil {
		x.allocs938e681d.(*cgoAllocMap).Free()
		x.ref938e681d = nil
	}
}

// NewRenderPassTransformBeginInfoQCOMRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassTransformBeginInfoQCOMRef(ref unsafe.Pointer) *RenderPassTransformBeginInfoQCOM {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassTransformBeginInfoQCOM)
	obj.ref938e681d = (*C.VkRenderPassTransformBeginInfoQCOM)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassTransformBeginInfoQCOM) PassRef() (*C.VkRenderPassTransformBeginInfoQCOM, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref938e681d != nil {
		return x.ref938e681d, nil
	}
	mem938e681d := allocRenderPassTransformBeginInfoQCOMMemory(1)
	ref938e681d := (*C.VkRenderPassTransformBeginInfoQCOM)(mem938e681d)
	allocs938e681d := new(cgoAllocMap)
	allocs938e681d.Add(mem938e681d)

	var csType_allocs *cgoAllocMap
	ref938e681d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs938e681d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref938e681d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs938e681d.Borrow(cpNext_allocs)

	var ctransform_allocs *cgoAllocMap
	ref938e681d.transform, ctransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.Transform), cgoAllocsUnknown
	allocs938e681d.Borrow(ctransform_allocs)

	x.ref938e681d = ref938e681d
	x.allocs938e681d = allocs938e681d
	return ref938e681d, allocs938e681d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassTransformBeginInfoQCOM) PassValue() (C.VkRenderPassTransformBeginInfoQCOM, *cgoAllocMap) {
	if x.ref938e681d != nil {
		return *x.ref938e681d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassTransformBeginInfoQCOM) Deref() {
	if x.ref938e681d == nil {
		return
	}
	x.SType = (StructureType)(x.ref938e681d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref938e681d.pNext))
	x.Transform = (SurfaceTransformFlagBits)(x.ref938e681d.transform)
}

// allocCommandBufferInheritanceRenderPassTransformInfoQCOMMemory allocates memory for type C.VkCommandBufferInheritanceRenderPassTransformInfoQCOM in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferInheritanceRenderPassTransformInfoQCOMMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferInheritanceRenderPassTransformInfoQCOMValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCommandBufferInheritanceRenderPassTransformInfoQCOMValue = unsafe.Sizeof([1]C.VkCommandBufferInheritanceRenderPassTransformInfoQCOM{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferInheritanceRenderPassTransformInfoQCOM) Ref() *C.VkCommandBufferInheritanceRenderPassTransformInfoQCOM {
	if x == nil {
		return nil
	}
	return x.refee6ff04
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferInheritanceRenderPassTransformInfoQCOM) Free() {
	if x != nil && x.allocsee6ff04 != nil {
		x.allocsee6ff04.(*cgoAllocMap).Free()
		x.refee6ff04 = nil
	}
}

// NewCommandBufferInheritanceRenderPassTransformInfoQCOMRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferInheritanceRenderPassTransformInfoQCOMRef(ref unsafe.Pointer) *CommandBufferInheritanceRenderPassTransformInfoQCOM {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferInheritanceRenderPassTransformInfoQCOM)
	obj.refee6ff04 = (*C.VkCommandBufferInheritanceRenderPassTransformInfoQCOM)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferInheritanceRenderPassTransformInfoQCOM) PassRef() (*C.VkCommandBufferInheritanceRenderPassTransformInfoQCOM, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refee6ff04 != nil {
		return x.refee6ff04, nil
	}
	memee6ff04 := allocCommandBufferInheritanceRenderPassTransformInfoQCOMMemory(1)
	refee6ff04 := (*C.VkCommandBufferInheritanceRenderPassTransformInfoQCOM)(memee6ff04)
	allocsee6ff04 := new(cgoAllocMap)
	allocsee6ff04.Add(memee6ff04)

	var csType_allocs *cgoAllocMap
	refee6ff04.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsee6ff04.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refee6ff04.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsee6ff04.Borrow(cpNext_allocs)

	var ctransform_allocs *cgoAllocMap
	refee6ff04.transform, ctransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.Transform), cgoAllocsUnknown
	allocsee6ff04.Borrow(ctransform_allocs)

	var crenderArea_allocs *cgoAllocMap
	refee6ff04.renderArea, crenderArea_allocs = x.RenderArea.PassValue()
	allocsee6ff04.Borrow(crenderArea_allocs)

	x.refee6ff04 = refee6ff04
	x.allocsee6ff04 = allocsee6ff04
	return refee6ff04, allocsee6ff04

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferInheritanceRenderPassTransformInfoQCOM) PassValue() (C.VkCommandBufferInheritanceRenderPassTransformInfoQCOM, *cgoAllocMap) {
	if x.refee6ff04 != nil {
		return *x.refee6ff04, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferInheritanceRenderPassTransformInfoQCOM) Deref() {
	if x.refee6ff04 == nil {
		return
	}
	x.SType = (StructureType)(x.refee6ff04.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refee6ff04.pNext))
	x.Transform = (SurfaceTransformFlagBits)(x.refee6ff04.transform)
	x.RenderArea = *NewRect2DRef(unsafe.Pointer(&x.refee6ff04.renderArea))
}

// allocPhysicalDeviceDeviceMemoryReportFeaturesMemory allocates memory for type C.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDeviceMemoryReportFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDeviceMemoryReportFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceDeviceMemoryReportFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDeviceMemoryReportFeatures) Ref() *C.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref477470f6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDeviceMemoryReportFeatures) Free() {
	if x != nil && x.allocs477470f6 != nil {
		x.allocs477470f6.(*cgoAllocMap).Free()
		x.ref477470f6 = nil
	}
}

// NewPhysicalDeviceDeviceMemoryReportFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDeviceMemoryReportFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceDeviceMemoryReportFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDeviceMemoryReportFeatures)
	obj.ref477470f6 = (*C.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDeviceMemoryReportFeatures) PassRef() (*C.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref477470f6 != nil {
		return x.ref477470f6, nil
	}
	mem477470f6 := allocPhysicalDeviceDeviceMemoryReportFeaturesMemory(1)
	ref477470f6 := (*C.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT)(mem477470f6)
	allocs477470f6 := new(cgoAllocMap)
	allocs477470f6.Add(mem477470f6)

	var csType_allocs *cgoAllocMap
	ref477470f6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs477470f6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref477470f6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs477470f6.Borrow(cpNext_allocs)

	var cdeviceMemoryReport_allocs *cgoAllocMap
	ref477470f6.deviceMemoryReport, cdeviceMemoryReport_allocs = (C.VkBool32)(x.DeviceMemoryReport), cgoAllocsUnknown
	allocs477470f6.Borrow(cdeviceMemoryReport_allocs)

	x.ref477470f6 = ref477470f6
	x.allocs477470f6 = allocs477470f6
	return ref477470f6, allocs477470f6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDeviceMemoryReportFeatures) PassValue() (C.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, *cgoAllocMap) {
	if x.ref477470f6 != nil {
		return *x.ref477470f6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDeviceMemoryReportFeatures) Deref() {
	if x.ref477470f6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref477470f6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref477470f6.pNext))
	x.DeviceMemoryReport = (Bool32)(x.ref477470f6.deviceMemoryReport)
}

// allocDeviceMemoryReportCallbackDataMemory allocates memory for type C.VkDeviceMemoryReportCallbackDataEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceMemoryReportCallbackDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceMemoryReportCallbackDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceMemoryReportCallbackDataValue = unsafe.Sizeof([1]C.VkDeviceMemoryReportCallbackDataEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceMemoryReportCallbackData) Ref() *C.VkDeviceMemoryReportCallbackDataEXT {
	if x == nil {
		return nil
	}
	return x.ref3150dbde
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceMemoryReportCallbackData) Free() {
	if x != nil && x.allocs3150dbde != nil {
		x.allocs3150dbde.(*cgoAllocMap).Free()
		x.ref3150dbde = nil
	}
}

// NewDeviceMemoryReportCallbackDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceMemoryReportCallbackDataRef(ref unsafe.Pointer) *DeviceMemoryReportCallbackData {
	if ref == nil {
		return nil
	}
	obj := new(DeviceMemoryReportCallbackData)
	obj.ref3150dbde = (*C.VkDeviceMemoryReportCallbackDataEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceMemoryReportCallbackData) PassRef() (*C.VkDeviceMemoryReportCallbackDataEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3150dbde != nil {
		return x.ref3150dbde, nil
	}
	mem3150dbde := allocDeviceMemoryReportCallbackDataMemory(1)
	ref3150dbde := (*C.VkDeviceMemoryReportCallbackDataEXT)(mem3150dbde)
	allocs3150dbde := new(cgoAllocMap)
	allocs3150dbde.Add(mem3150dbde)

	var csType_allocs *cgoAllocMap
	ref3150dbde.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3150dbde.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3150dbde.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3150dbde.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref3150dbde.flags, cflags_allocs = (C.VkDeviceMemoryReportFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocs3150dbde.Borrow(cflags_allocs)

	var c_type_allocs *cgoAllocMap
	ref3150dbde._type, c_type_allocs = (C.VkDeviceMemoryReportEventTypeEXT)(x.Type), cgoAllocsUnknown
	allocs3150dbde.Borrow(c_type_allocs)

	var cmemoryObjectId_allocs *cgoAllocMap
	ref3150dbde.memoryObjectId, cmemoryObjectId_allocs = (C.uint64_t)(x.MemoryObjectId), cgoAllocsUnknown
	allocs3150dbde.Borrow(cmemoryObjectId_allocs)

	var csize_allocs *cgoAllocMap
	ref3150dbde.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs3150dbde.Borrow(csize_allocs)

	var cobjectType_allocs *cgoAllocMap
	ref3150dbde.objectType, cobjectType_allocs = (C.VkObjectType)(x.ObjectType), cgoAllocsUnknown
	allocs3150dbde.Borrow(cobjectType_allocs)

	var cobjectHandle_allocs *cgoAllocMap
	ref3150dbde.objectHandle, cobjectHandle_allocs = (C.uint64_t)(x.ObjectHandle), cgoAllocsUnknown
	allocs3150dbde.Borrow(cobjectHandle_allocs)

	var cheapIndex_allocs *cgoAllocMap
	ref3150dbde.heapIndex, cheapIndex_allocs = (C.uint32_t)(x.HeapIndex), cgoAllocsUnknown
	allocs3150dbde.Borrow(cheapIndex_allocs)

	x.ref3150dbde = ref3150dbde
	x.allocs3150dbde = allocs3150dbde
	return ref3150dbde, allocs3150dbde

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceMemoryReportCallbackData) PassValue() (C.VkDeviceMemoryReportCallbackDataEXT, *cgoAllocMap) {
	if x.ref3150dbde != nil {
		return *x.ref3150dbde, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceMemoryReportCallbackData) Deref() {
	if x.ref3150dbde == nil {
		return
	}
	x.SType = (StructureType)(x.ref3150dbde.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3150dbde.pNext))
	x.Flags = (DeviceMemoryReportFlags)(x.ref3150dbde.flags)
	x.Type = (DeviceMemoryReportEventType)(x.ref3150dbde._type)
	x.MemoryObjectId = (uint32)(x.ref3150dbde.memoryObjectId)
	x.Size = (DeviceSize)(x.ref3150dbde.size)
	x.ObjectType = (ObjectType)(x.ref3150dbde.objectType)
	x.ObjectHandle = (uint32)(x.ref3150dbde.objectHandle)
	x.HeapIndex = (uint32)(x.ref3150dbde.heapIndex)
}

// allocDeviceDeviceMemoryReportCreateInfoMemory allocates memory for type C.VkDeviceDeviceMemoryReportCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceDeviceMemoryReportCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceDeviceMemoryReportCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceDeviceMemoryReportCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceDeviceMemoryReportCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceDeviceMemoryReportCreateInfo) Ref() *C.VkDeviceDeviceMemoryReportCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refe99f2c76
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceDeviceMemoryReportCreateInfo) Free() {
	if x != nil && x.allocse99f2c76 != nil {
		x.allocse99f2c76.(*cgoAllocMap).Free()
		x.refe99f2c76 = nil
	}
}

// NewDeviceDeviceMemoryReportCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceDeviceMemoryReportCreateInfoRef(ref unsafe.Pointer) *DeviceDeviceMemoryReportCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceDeviceMemoryReportCreateInfo)
	obj.refe99f2c76 = (*C.VkDeviceDeviceMemoryReportCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceDeviceMemoryReportCreateInfo) PassRef() (*C.VkDeviceDeviceMemoryReportCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe99f2c76 != nil {
		return x.refe99f2c76, nil
	}
	meme99f2c76 := allocDeviceDeviceMemoryReportCreateInfoMemory(1)
	refe99f2c76 := (*C.VkDeviceDeviceMemoryReportCreateInfoEXT)(meme99f2c76)
	allocse99f2c76 := new(cgoAllocMap)
	allocse99f2c76.Add(meme99f2c76)

	var csType_allocs *cgoAllocMap
	refe99f2c76.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse99f2c76.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe99f2c76.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse99f2c76.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refe99f2c76.flags, cflags_allocs = (C.VkDeviceMemoryReportFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocse99f2c76.Borrow(cflags_allocs)

	// var cpfnUserCallback_allocs *cgoAllocMap
	// refe99f2c76.pfnUserCallback, cpfnUserCallback_allocs = x.PfnUserCallback.PassValue()
	// allocse99f2c76.Borrow(cpfnUserCallback_allocs)

	var cpUserData_allocs *cgoAllocMap
	refe99f2c76.pUserData, cpUserData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PUserData)), cgoAllocsUnknown
	allocse99f2c76.Borrow(cpUserData_allocs)

	x.refe99f2c76 = refe99f2c76
	x.allocse99f2c76 = allocse99f2c76
	return refe99f2c76, allocse99f2c76

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceDeviceMemoryReportCreateInfo) PassValue() (C.VkDeviceDeviceMemoryReportCreateInfoEXT, *cgoAllocMap) {
	if x.refe99f2c76 != nil {
		return *x.refe99f2c76, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceDeviceMemoryReportCreateInfo) Deref() {
	if x.refe99f2c76 == nil {
		return
	}
	x.SType = (StructureType)(x.refe99f2c76.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe99f2c76.pNext))
	x.Flags = (DeviceMemoryReportFlags)(x.refe99f2c76.flags)
	// x.PfnUserCallback = *NewRef(unsafe.Pointer(&x.refe99f2c76.pfnUserCallback))
	x.PUserData = (unsafe.Pointer)(unsafe.Pointer(x.refe99f2c76.pUserData))
}

// allocPhysicalDeviceRobustness2FeaturesMemory allocates memory for type C.VkPhysicalDeviceRobustness2FeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceRobustness2FeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceRobustness2FeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceRobustness2FeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceRobustness2FeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceRobustness2Features) Ref() *C.VkPhysicalDeviceRobustness2FeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refa1d6be35
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceRobustness2Features) Free() {
	if x != nil && x.allocsa1d6be35 != nil {
		x.allocsa1d6be35.(*cgoAllocMap).Free()
		x.refa1d6be35 = nil
	}
}

// NewPhysicalDeviceRobustness2FeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceRobustness2FeaturesRef(ref unsafe.Pointer) *PhysicalDeviceRobustness2Features {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceRobustness2Features)
	obj.refa1d6be35 = (*C.VkPhysicalDeviceRobustness2FeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceRobustness2Features) PassRef() (*C.VkPhysicalDeviceRobustness2FeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa1d6be35 != nil {
		return x.refa1d6be35, nil
	}
	mema1d6be35 := allocPhysicalDeviceRobustness2FeaturesMemory(1)
	refa1d6be35 := (*C.VkPhysicalDeviceRobustness2FeaturesEXT)(mema1d6be35)
	allocsa1d6be35 := new(cgoAllocMap)
	allocsa1d6be35.Add(mema1d6be35)

	var csType_allocs *cgoAllocMap
	refa1d6be35.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa1d6be35.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa1d6be35.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa1d6be35.Borrow(cpNext_allocs)

	var crobustBufferAccess2_allocs *cgoAllocMap
	refa1d6be35.robustBufferAccess2, crobustBufferAccess2_allocs = (C.VkBool32)(x.RobustBufferAccess2), cgoAllocsUnknown
	allocsa1d6be35.Borrow(crobustBufferAccess2_allocs)

	var crobustImageAccess2_allocs *cgoAllocMap
	refa1d6be35.robustImageAccess2, crobustImageAccess2_allocs = (C.VkBool32)(x.RobustImageAccess2), cgoAllocsUnknown
	allocsa1d6be35.Borrow(crobustImageAccess2_allocs)

	var cnullDescriptor_allocs *cgoAllocMap
	refa1d6be35.nullDescriptor, cnullDescriptor_allocs = (C.VkBool32)(x.NullDescriptor), cgoAllocsUnknown
	allocsa1d6be35.Borrow(cnullDescriptor_allocs)

	x.refa1d6be35 = refa1d6be35
	x.allocsa1d6be35 = allocsa1d6be35
	return refa1d6be35, allocsa1d6be35

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceRobustness2Features) PassValue() (C.VkPhysicalDeviceRobustness2FeaturesEXT, *cgoAllocMap) {
	if x.refa1d6be35 != nil {
		return *x.refa1d6be35, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceRobustness2Features) Deref() {
	if x.refa1d6be35 == nil {
		return
	}
	x.SType = (StructureType)(x.refa1d6be35.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa1d6be35.pNext))
	x.RobustBufferAccess2 = (Bool32)(x.refa1d6be35.robustBufferAccess2)
	x.RobustImageAccess2 = (Bool32)(x.refa1d6be35.robustImageAccess2)
	x.NullDescriptor = (Bool32)(x.refa1d6be35.nullDescriptor)
}

// allocPhysicalDeviceRobustness2PropertiesMemory allocates memory for type C.VkPhysicalDeviceRobustness2PropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceRobustness2PropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceRobustness2PropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceRobustness2PropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceRobustness2PropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceRobustness2Properties) Ref() *C.VkPhysicalDeviceRobustness2PropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref82986127
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceRobustness2Properties) Free() {
	if x != nil && x.allocs82986127 != nil {
		x.allocs82986127.(*cgoAllocMap).Free()
		x.ref82986127 = nil
	}
}

// NewPhysicalDeviceRobustness2PropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceRobustness2PropertiesRef(ref unsafe.Pointer) *PhysicalDeviceRobustness2Properties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceRobustness2Properties)
	obj.ref82986127 = (*C.VkPhysicalDeviceRobustness2PropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceRobustness2Properties) PassRef() (*C.VkPhysicalDeviceRobustness2PropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref82986127 != nil {
		return x.ref82986127, nil
	}
	mem82986127 := allocPhysicalDeviceRobustness2PropertiesMemory(1)
	ref82986127 := (*C.VkPhysicalDeviceRobustness2PropertiesEXT)(mem82986127)
	allocs82986127 := new(cgoAllocMap)
	allocs82986127.Add(mem82986127)

	var csType_allocs *cgoAllocMap
	ref82986127.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs82986127.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref82986127.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs82986127.Borrow(cpNext_allocs)

	var crobustStorageBufferAccessSizeAlignment_allocs *cgoAllocMap
	ref82986127.robustStorageBufferAccessSizeAlignment, crobustStorageBufferAccessSizeAlignment_allocs = (C.VkDeviceSize)(x.RobustStorageBufferAccessSizeAlignment), cgoAllocsUnknown
	allocs82986127.Borrow(crobustStorageBufferAccessSizeAlignment_allocs)

	var crobustUniformBufferAccessSizeAlignment_allocs *cgoAllocMap
	ref82986127.robustUniformBufferAccessSizeAlignment, crobustUniformBufferAccessSizeAlignment_allocs = (C.VkDeviceSize)(x.RobustUniformBufferAccessSizeAlignment), cgoAllocsUnknown
	allocs82986127.Borrow(crobustUniformBufferAccessSizeAlignment_allocs)

	x.ref82986127 = ref82986127
	x.allocs82986127 = allocs82986127
	return ref82986127, allocs82986127

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceRobustness2Properties) PassValue() (C.VkPhysicalDeviceRobustness2PropertiesEXT, *cgoAllocMap) {
	if x.ref82986127 != nil {
		return *x.ref82986127, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceRobustness2Properties) Deref() {
	if x.ref82986127 == nil {
		return
	}
	x.SType = (StructureType)(x.ref82986127.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref82986127.pNext))
	x.RobustStorageBufferAccessSizeAlignment = (DeviceSize)(x.ref82986127.robustStorageBufferAccessSizeAlignment)
	x.RobustUniformBufferAccessSizeAlignment = (DeviceSize)(x.ref82986127.robustUniformBufferAccessSizeAlignment)
}

// allocSamplerCustomBorderColorCreateInfoMemory allocates memory for type C.VkSamplerCustomBorderColorCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerCustomBorderColorCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerCustomBorderColorCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSamplerCustomBorderColorCreateInfoValue = unsafe.Sizeof([1]C.VkSamplerCustomBorderColorCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerCustomBorderColorCreateInfo) Ref() *C.VkSamplerCustomBorderColorCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refcac2582e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerCustomBorderColorCreateInfo) Free() {
	if x != nil && x.allocscac2582e != nil {
		x.allocscac2582e.(*cgoAllocMap).Free()
		x.refcac2582e = nil
	}
}

// NewSamplerCustomBorderColorCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerCustomBorderColorCreateInfoRef(ref unsafe.Pointer) *SamplerCustomBorderColorCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SamplerCustomBorderColorCreateInfo)
	obj.refcac2582e = (*C.VkSamplerCustomBorderColorCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerCustomBorderColorCreateInfo) PassRef() (*C.VkSamplerCustomBorderColorCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcac2582e != nil {
		return x.refcac2582e, nil
	}
	memcac2582e := allocSamplerCustomBorderColorCreateInfoMemory(1)
	refcac2582e := (*C.VkSamplerCustomBorderColorCreateInfoEXT)(memcac2582e)
	allocscac2582e := new(cgoAllocMap)
	allocscac2582e.Add(memcac2582e)

	var csType_allocs *cgoAllocMap
	refcac2582e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscac2582e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcac2582e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscac2582e.Borrow(cpNext_allocs)

	var ccustomBorderColor_allocs *cgoAllocMap
	refcac2582e.customBorderColor, ccustomBorderColor_allocs = *(*C.VkClearColorValue)(unsafe.Pointer(&x.CustomBorderColor)), cgoAllocsUnknown
	allocscac2582e.Borrow(ccustomBorderColor_allocs)

	var cformat_allocs *cgoAllocMap
	refcac2582e.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocscac2582e.Borrow(cformat_allocs)

	x.refcac2582e = refcac2582e
	x.allocscac2582e = allocscac2582e
	return refcac2582e, allocscac2582e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerCustomBorderColorCreateInfo) PassValue() (C.VkSamplerCustomBorderColorCreateInfoEXT, *cgoAllocMap) {
	if x.refcac2582e != nil {
		return *x.refcac2582e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerCustomBorderColorCreateInfo) Deref() {
	if x.refcac2582e == nil {
		return
	}
	x.SType = (StructureType)(x.refcac2582e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcac2582e.pNext))
	x.CustomBorderColor = *(*ClearColorValue)(unsafe.Pointer(&x.refcac2582e.customBorderColor))
	x.Format = (Format)(x.refcac2582e.format)
}

// allocPhysicalDeviceCustomBorderColorPropertiesMemory allocates memory for type C.VkPhysicalDeviceCustomBorderColorPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceCustomBorderColorPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceCustomBorderColorPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceCustomBorderColorPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceCustomBorderColorPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceCustomBorderColorProperties) Ref() *C.VkPhysicalDeviceCustomBorderColorPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref4b62d3cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceCustomBorderColorProperties) Free() {
	if x != nil && x.allocs4b62d3cd != nil {
		x.allocs4b62d3cd.(*cgoAllocMap).Free()
		x.ref4b62d3cd = nil
	}
}

// NewPhysicalDeviceCustomBorderColorPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceCustomBorderColorPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceCustomBorderColorProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceCustomBorderColorProperties)
	obj.ref4b62d3cd = (*C.VkPhysicalDeviceCustomBorderColorPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceCustomBorderColorProperties) PassRef() (*C.VkPhysicalDeviceCustomBorderColorPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b62d3cd != nil {
		return x.ref4b62d3cd, nil
	}
	mem4b62d3cd := allocPhysicalDeviceCustomBorderColorPropertiesMemory(1)
	ref4b62d3cd := (*C.VkPhysicalDeviceCustomBorderColorPropertiesEXT)(mem4b62d3cd)
	allocs4b62d3cd := new(cgoAllocMap)
	allocs4b62d3cd.Add(mem4b62d3cd)

	var csType_allocs *cgoAllocMap
	ref4b62d3cd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4b62d3cd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4b62d3cd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4b62d3cd.Borrow(cpNext_allocs)

	var cmaxCustomBorderColorSamplers_allocs *cgoAllocMap
	ref4b62d3cd.maxCustomBorderColorSamplers, cmaxCustomBorderColorSamplers_allocs = (C.uint32_t)(x.MaxCustomBorderColorSamplers), cgoAllocsUnknown
	allocs4b62d3cd.Borrow(cmaxCustomBorderColorSamplers_allocs)

	x.ref4b62d3cd = ref4b62d3cd
	x.allocs4b62d3cd = allocs4b62d3cd
	return ref4b62d3cd, allocs4b62d3cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceCustomBorderColorProperties) PassValue() (C.VkPhysicalDeviceCustomBorderColorPropertiesEXT, *cgoAllocMap) {
	if x.ref4b62d3cd != nil {
		return *x.ref4b62d3cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceCustomBorderColorProperties) Deref() {
	if x.ref4b62d3cd == nil {
		return
	}
	x.SType = (StructureType)(x.ref4b62d3cd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4b62d3cd.pNext))
	x.MaxCustomBorderColorSamplers = (uint32)(x.ref4b62d3cd.maxCustomBorderColorSamplers)
}

// allocPhysicalDeviceCustomBorderColorFeaturesMemory allocates memory for type C.VkPhysicalDeviceCustomBorderColorFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceCustomBorderColorFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceCustomBorderColorFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceCustomBorderColorFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceCustomBorderColorFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceCustomBorderColorFeatures) Ref() *C.VkPhysicalDeviceCustomBorderColorFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref8a9c96e0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceCustomBorderColorFeatures) Free() {
	if x != nil && x.allocs8a9c96e0 != nil {
		x.allocs8a9c96e0.(*cgoAllocMap).Free()
		x.ref8a9c96e0 = nil
	}
}

// NewPhysicalDeviceCustomBorderColorFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceCustomBorderColorFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceCustomBorderColorFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceCustomBorderColorFeatures)
	obj.ref8a9c96e0 = (*C.VkPhysicalDeviceCustomBorderColorFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceCustomBorderColorFeatures) PassRef() (*C.VkPhysicalDeviceCustomBorderColorFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8a9c96e0 != nil {
		return x.ref8a9c96e0, nil
	}
	mem8a9c96e0 := allocPhysicalDeviceCustomBorderColorFeaturesMemory(1)
	ref8a9c96e0 := (*C.VkPhysicalDeviceCustomBorderColorFeaturesEXT)(mem8a9c96e0)
	allocs8a9c96e0 := new(cgoAllocMap)
	allocs8a9c96e0.Add(mem8a9c96e0)

	var csType_allocs *cgoAllocMap
	ref8a9c96e0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8a9c96e0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8a9c96e0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8a9c96e0.Borrow(cpNext_allocs)

	var ccustomBorderColors_allocs *cgoAllocMap
	ref8a9c96e0.customBorderColors, ccustomBorderColors_allocs = (C.VkBool32)(x.CustomBorderColors), cgoAllocsUnknown
	allocs8a9c96e0.Borrow(ccustomBorderColors_allocs)

	var ccustomBorderColorWithoutFormat_allocs *cgoAllocMap
	ref8a9c96e0.customBorderColorWithoutFormat, ccustomBorderColorWithoutFormat_allocs = (C.VkBool32)(x.CustomBorderColorWithoutFormat), cgoAllocsUnknown
	allocs8a9c96e0.Borrow(ccustomBorderColorWithoutFormat_allocs)

	x.ref8a9c96e0 = ref8a9c96e0
	x.allocs8a9c96e0 = allocs8a9c96e0
	return ref8a9c96e0, allocs8a9c96e0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceCustomBorderColorFeatures) PassValue() (C.VkPhysicalDeviceCustomBorderColorFeaturesEXT, *cgoAllocMap) {
	if x.ref8a9c96e0 != nil {
		return *x.ref8a9c96e0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceCustomBorderColorFeatures) Deref() {
	if x.ref8a9c96e0 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8a9c96e0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8a9c96e0.pNext))
	x.CustomBorderColors = (Bool32)(x.ref8a9c96e0.customBorderColors)
	x.CustomBorderColorWithoutFormat = (Bool32)(x.ref8a9c96e0.customBorderColorWithoutFormat)
}

// allocPhysicalDevicePrivateDataFeaturesMemory allocates memory for type C.VkPhysicalDevicePrivateDataFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePrivateDataFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePrivateDataFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDevicePrivateDataFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDevicePrivateDataFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevicePrivateDataFeatures) Ref() *C.VkPhysicalDevicePrivateDataFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refc4f79ee
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevicePrivateDataFeatures) Free() {
	if x != nil && x.allocsc4f79ee != nil {
		x.allocsc4f79ee.(*cgoAllocMap).Free()
		x.refc4f79ee = nil
	}
}

// NewPhysicalDevicePrivateDataFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePrivateDataFeaturesRef(ref unsafe.Pointer) *PhysicalDevicePrivateDataFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevicePrivateDataFeatures)
	obj.refc4f79ee = (*C.VkPhysicalDevicePrivateDataFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevicePrivateDataFeatures) PassRef() (*C.VkPhysicalDevicePrivateDataFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc4f79ee != nil {
		return x.refc4f79ee, nil
	}
	memc4f79ee := allocPhysicalDevicePrivateDataFeaturesMemory(1)
	refc4f79ee := (*C.VkPhysicalDevicePrivateDataFeaturesEXT)(memc4f79ee)
	allocsc4f79ee := new(cgoAllocMap)
	allocsc4f79ee.Add(memc4f79ee)

	var csType_allocs *cgoAllocMap
	refc4f79ee.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc4f79ee.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc4f79ee.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc4f79ee.Borrow(cpNext_allocs)

	var cprivateData_allocs *cgoAllocMap
	refc4f79ee.privateData, cprivateData_allocs = (C.VkBool32)(x.PrivateData), cgoAllocsUnknown
	allocsc4f79ee.Borrow(cprivateData_allocs)

	x.refc4f79ee = refc4f79ee
	x.allocsc4f79ee = allocsc4f79ee
	return refc4f79ee, allocsc4f79ee

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevicePrivateDataFeatures) PassValue() (C.VkPhysicalDevicePrivateDataFeaturesEXT, *cgoAllocMap) {
	if x.refc4f79ee != nil {
		return *x.refc4f79ee, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevicePrivateDataFeatures) Deref() {
	if x.refc4f79ee == nil {
		return
	}
	x.SType = (StructureType)(x.refc4f79ee.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc4f79ee.pNext))
	x.PrivateData = (Bool32)(x.refc4f79ee.privateData)
}

// allocDevicePrivateDataCreateInfoMemory allocates memory for type C.VkDevicePrivateDataCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDevicePrivateDataCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDevicePrivateDataCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDevicePrivateDataCreateInfoValue = unsafe.Sizeof([1]C.VkDevicePrivateDataCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DevicePrivateDataCreateInfo) Ref() *C.VkDevicePrivateDataCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref5266a46e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DevicePrivateDataCreateInfo) Free() {
	if x != nil && x.allocs5266a46e != nil {
		x.allocs5266a46e.(*cgoAllocMap).Free()
		x.ref5266a46e = nil
	}
}

// NewDevicePrivateDataCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDevicePrivateDataCreateInfoRef(ref unsafe.Pointer) *DevicePrivateDataCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DevicePrivateDataCreateInfo)
	obj.ref5266a46e = (*C.VkDevicePrivateDataCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DevicePrivateDataCreateInfo) PassRef() (*C.VkDevicePrivateDataCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5266a46e != nil {
		return x.ref5266a46e, nil
	}
	mem5266a46e := allocDevicePrivateDataCreateInfoMemory(1)
	ref5266a46e := (*C.VkDevicePrivateDataCreateInfoEXT)(mem5266a46e)
	allocs5266a46e := new(cgoAllocMap)
	allocs5266a46e.Add(mem5266a46e)

	var csType_allocs *cgoAllocMap
	ref5266a46e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5266a46e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5266a46e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5266a46e.Borrow(cpNext_allocs)

	var cprivateDataSlotRequestCount_allocs *cgoAllocMap
	ref5266a46e.privateDataSlotRequestCount, cprivateDataSlotRequestCount_allocs = (C.uint32_t)(x.PrivateDataSlotRequestCount), cgoAllocsUnknown
	allocs5266a46e.Borrow(cprivateDataSlotRequestCount_allocs)

	x.ref5266a46e = ref5266a46e
	x.allocs5266a46e = allocs5266a46e
	return ref5266a46e, allocs5266a46e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DevicePrivateDataCreateInfo) PassValue() (C.VkDevicePrivateDataCreateInfoEXT, *cgoAllocMap) {
	if x.ref5266a46e != nil {
		return *x.ref5266a46e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DevicePrivateDataCreateInfo) Deref() {
	if x.ref5266a46e == nil {
		return
	}
	x.SType = (StructureType)(x.ref5266a46e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5266a46e.pNext))
	x.PrivateDataSlotRequestCount = (uint32)(x.ref5266a46e.privateDataSlotRequestCount)
}

// allocPrivateDataSlotCreateInfoMemory allocates memory for type C.VkPrivateDataSlotCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPrivateDataSlotCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPrivateDataSlotCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPrivateDataSlotCreateInfoValue = unsafe.Sizeof([1]C.VkPrivateDataSlotCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PrivateDataSlotCreateInfo) Ref() *C.VkPrivateDataSlotCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref7d0ebde3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PrivateDataSlotCreateInfo) Free() {
	if x != nil && x.allocs7d0ebde3 != nil {
		x.allocs7d0ebde3.(*cgoAllocMap).Free()
		x.ref7d0ebde3 = nil
	}
}

// NewPrivateDataSlotCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPrivateDataSlotCreateInfoRef(ref unsafe.Pointer) *PrivateDataSlotCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PrivateDataSlotCreateInfo)
	obj.ref7d0ebde3 = (*C.VkPrivateDataSlotCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PrivateDataSlotCreateInfo) PassRef() (*C.VkPrivateDataSlotCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7d0ebde3 != nil {
		return x.ref7d0ebde3, nil
	}
	mem7d0ebde3 := allocPrivateDataSlotCreateInfoMemory(1)
	ref7d0ebde3 := (*C.VkPrivateDataSlotCreateInfoEXT)(mem7d0ebde3)
	allocs7d0ebde3 := new(cgoAllocMap)
	allocs7d0ebde3.Add(mem7d0ebde3)

	var csType_allocs *cgoAllocMap
	ref7d0ebde3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7d0ebde3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7d0ebde3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7d0ebde3.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref7d0ebde3.flags, cflags_allocs = (C.VkPrivateDataSlotCreateFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocs7d0ebde3.Borrow(cflags_allocs)

	x.ref7d0ebde3 = ref7d0ebde3
	x.allocs7d0ebde3 = allocs7d0ebde3
	return ref7d0ebde3, allocs7d0ebde3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PrivateDataSlotCreateInfo) PassValue() (C.VkPrivateDataSlotCreateInfoEXT, *cgoAllocMap) {
	if x.ref7d0ebde3 != nil {
		return *x.ref7d0ebde3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PrivateDataSlotCreateInfo) Deref() {
	if x.ref7d0ebde3 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7d0ebde3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7d0ebde3.pNext))
	x.Flags = (PrivateDataSlotCreateFlags)(x.ref7d0ebde3.flags)
}

// allocPhysicalDevicePipelineCreationCacheControlFeaturesMemory allocates memory for type C.VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePipelineCreationCacheControlFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePipelineCreationCacheControlFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDevicePipelineCreationCacheControlFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevicePipelineCreationCacheControlFeatures) Ref() *C.VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref2a19c3b9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevicePipelineCreationCacheControlFeatures) Free() {
	if x != nil && x.allocs2a19c3b9 != nil {
		x.allocs2a19c3b9.(*cgoAllocMap).Free()
		x.ref2a19c3b9 = nil
	}
}

// NewPhysicalDevicePipelineCreationCacheControlFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePipelineCreationCacheControlFeaturesRef(ref unsafe.Pointer) *PhysicalDevicePipelineCreationCacheControlFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevicePipelineCreationCacheControlFeatures)
	obj.ref2a19c3b9 = (*C.VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevicePipelineCreationCacheControlFeatures) PassRef() (*C.VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2a19c3b9 != nil {
		return x.ref2a19c3b9, nil
	}
	mem2a19c3b9 := allocPhysicalDevicePipelineCreationCacheControlFeaturesMemory(1)
	ref2a19c3b9 := (*C.VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT)(mem2a19c3b9)
	allocs2a19c3b9 := new(cgoAllocMap)
	allocs2a19c3b9.Add(mem2a19c3b9)

	var csType_allocs *cgoAllocMap
	ref2a19c3b9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2a19c3b9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2a19c3b9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2a19c3b9.Borrow(cpNext_allocs)

	var cpipelineCreationCacheControl_allocs *cgoAllocMap
	ref2a19c3b9.pipelineCreationCacheControl, cpipelineCreationCacheControl_allocs = (C.VkBool32)(x.PipelineCreationCacheControl), cgoAllocsUnknown
	allocs2a19c3b9.Borrow(cpipelineCreationCacheControl_allocs)

	x.ref2a19c3b9 = ref2a19c3b9
	x.allocs2a19c3b9 = allocs2a19c3b9
	return ref2a19c3b9, allocs2a19c3b9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevicePipelineCreationCacheControlFeatures) PassValue() (C.VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT, *cgoAllocMap) {
	if x.ref2a19c3b9 != nil {
		return *x.ref2a19c3b9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevicePipelineCreationCacheControlFeatures) Deref() {
	if x.ref2a19c3b9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2a19c3b9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2a19c3b9.pNext))
	x.PipelineCreationCacheControl = (Bool32)(x.ref2a19c3b9.pipelineCreationCacheControl)
}

// allocPhysicalDeviceDiagnosticsConfigFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceDiagnosticsConfigFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDiagnosticsConfigFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDiagnosticsConfigFeaturesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceDiagnosticsConfigFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDiagnosticsConfigFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDiagnosticsConfigFeaturesNV) Ref() *C.VkPhysicalDeviceDiagnosticsConfigFeaturesNV {
	if x == nil {
		return nil
	}
	return x.refd354d3ba
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDiagnosticsConfigFeaturesNV) Free() {
	if x != nil && x.allocsd354d3ba != nil {
		x.allocsd354d3ba.(*cgoAllocMap).Free()
		x.refd354d3ba = nil
	}
}

// NewPhysicalDeviceDiagnosticsConfigFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDiagnosticsConfigFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceDiagnosticsConfigFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDiagnosticsConfigFeaturesNV)
	obj.refd354d3ba = (*C.VkPhysicalDeviceDiagnosticsConfigFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDiagnosticsConfigFeaturesNV) PassRef() (*C.VkPhysicalDeviceDiagnosticsConfigFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd354d3ba != nil {
		return x.refd354d3ba, nil
	}
	memd354d3ba := allocPhysicalDeviceDiagnosticsConfigFeaturesNVMemory(1)
	refd354d3ba := (*C.VkPhysicalDeviceDiagnosticsConfigFeaturesNV)(memd354d3ba)
	allocsd354d3ba := new(cgoAllocMap)
	allocsd354d3ba.Add(memd354d3ba)

	var csType_allocs *cgoAllocMap
	refd354d3ba.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd354d3ba.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd354d3ba.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd354d3ba.Borrow(cpNext_allocs)

	var cdiagnosticsConfig_allocs *cgoAllocMap
	refd354d3ba.diagnosticsConfig, cdiagnosticsConfig_allocs = (C.VkBool32)(x.DiagnosticsConfig), cgoAllocsUnknown
	allocsd354d3ba.Borrow(cdiagnosticsConfig_allocs)

	x.refd354d3ba = refd354d3ba
	x.allocsd354d3ba = allocsd354d3ba
	return refd354d3ba, allocsd354d3ba

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDiagnosticsConfigFeaturesNV) PassValue() (C.VkPhysicalDeviceDiagnosticsConfigFeaturesNV, *cgoAllocMap) {
	if x.refd354d3ba != nil {
		return *x.refd354d3ba, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDiagnosticsConfigFeaturesNV) Deref() {
	if x.refd354d3ba == nil {
		return
	}
	x.SType = (StructureType)(x.refd354d3ba.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd354d3ba.pNext))
	x.DiagnosticsConfig = (Bool32)(x.refd354d3ba.diagnosticsConfig)
}

// allocDeviceDiagnosticsConfigCreateInfoNVMemory allocates memory for type C.VkDeviceDiagnosticsConfigCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceDiagnosticsConfigCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceDiagnosticsConfigCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceDiagnosticsConfigCreateInfoNVValue = unsafe.Sizeof([1]C.VkDeviceDiagnosticsConfigCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceDiagnosticsConfigCreateInfoNV) Ref() *C.VkDeviceDiagnosticsConfigCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref856c966a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceDiagnosticsConfigCreateInfoNV) Free() {
	if x != nil && x.allocs856c966a != nil {
		x.allocs856c966a.(*cgoAllocMap).Free()
		x.ref856c966a = nil
	}
}

// NewDeviceDiagnosticsConfigCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceDiagnosticsConfigCreateInfoNVRef(ref unsafe.Pointer) *DeviceDiagnosticsConfigCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(DeviceDiagnosticsConfigCreateInfoNV)
	obj.ref856c966a = (*C.VkDeviceDiagnosticsConfigCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceDiagnosticsConfigCreateInfoNV) PassRef() (*C.VkDeviceDiagnosticsConfigCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref856c966a != nil {
		return x.ref856c966a, nil
	}
	mem856c966a := allocDeviceDiagnosticsConfigCreateInfoNVMemory(1)
	ref856c966a := (*C.VkDeviceDiagnosticsConfigCreateInfoNV)(mem856c966a)
	allocs856c966a := new(cgoAllocMap)
	allocs856c966a.Add(mem856c966a)

	var csType_allocs *cgoAllocMap
	ref856c966a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs856c966a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref856c966a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs856c966a.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref856c966a.flags, cflags_allocs = (C.VkDeviceDiagnosticsConfigFlagsNV)(x.Flags), cgoAllocsUnknown
	allocs856c966a.Borrow(cflags_allocs)

	x.ref856c966a = ref856c966a
	x.allocs856c966a = allocs856c966a
	return ref856c966a, allocs856c966a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceDiagnosticsConfigCreateInfoNV) PassValue() (C.VkDeviceDiagnosticsConfigCreateInfoNV, *cgoAllocMap) {
	if x.ref856c966a != nil {
		return *x.ref856c966a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceDiagnosticsConfigCreateInfoNV) Deref() {
	if x.ref856c966a == nil {
		return
	}
	x.SType = (StructureType)(x.ref856c966a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref856c966a.pNext))
	x.Flags = (DeviceDiagnosticsConfigFlagsNV)(x.ref856c966a.flags)
}

// allocPhysicalDeviceFragmentShadingRateEnumsFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFragmentShadingRateEnumsFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFragmentShadingRateEnumsFeaturesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceFragmentShadingRateEnumsFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFragmentShadingRateEnumsFeaturesNV) Ref() *C.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
	if x == nil {
		return nil
	}
	return x.refd295c0e9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFragmentShadingRateEnumsFeaturesNV) Free() {
	if x != nil && x.allocsd295c0e9 != nil {
		x.allocsd295c0e9.(*cgoAllocMap).Free()
		x.refd295c0e9 = nil
	}
}

// NewPhysicalDeviceFragmentShadingRateEnumsFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFragmentShadingRateEnumsFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFragmentShadingRateEnumsFeaturesNV)
	obj.refd295c0e9 = (*C.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFragmentShadingRateEnumsFeaturesNV) PassRef() (*C.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd295c0e9 != nil {
		return x.refd295c0e9, nil
	}
	memd295c0e9 := allocPhysicalDeviceFragmentShadingRateEnumsFeaturesNVMemory(1)
	refd295c0e9 := (*C.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV)(memd295c0e9)
	allocsd295c0e9 := new(cgoAllocMap)
	allocsd295c0e9.Add(memd295c0e9)

	var csType_allocs *cgoAllocMap
	refd295c0e9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd295c0e9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd295c0e9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd295c0e9.Borrow(cpNext_allocs)

	var cfragmentShadingRateEnums_allocs *cgoAllocMap
	refd295c0e9.fragmentShadingRateEnums, cfragmentShadingRateEnums_allocs = (C.VkBool32)(x.FragmentShadingRateEnums), cgoAllocsUnknown
	allocsd295c0e9.Borrow(cfragmentShadingRateEnums_allocs)

	var csupersampleFragmentShadingRates_allocs *cgoAllocMap
	refd295c0e9.supersampleFragmentShadingRates, csupersampleFragmentShadingRates_allocs = (C.VkBool32)(x.SupersampleFragmentShadingRates), cgoAllocsUnknown
	allocsd295c0e9.Borrow(csupersampleFragmentShadingRates_allocs)

	var cnoInvocationFragmentShadingRates_allocs *cgoAllocMap
	refd295c0e9.noInvocationFragmentShadingRates, cnoInvocationFragmentShadingRates_allocs = (C.VkBool32)(x.NoInvocationFragmentShadingRates), cgoAllocsUnknown
	allocsd295c0e9.Borrow(cnoInvocationFragmentShadingRates_allocs)

	x.refd295c0e9 = refd295c0e9
	x.allocsd295c0e9 = allocsd295c0e9
	return refd295c0e9, allocsd295c0e9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFragmentShadingRateEnumsFeaturesNV) PassValue() (C.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, *cgoAllocMap) {
	if x.refd295c0e9 != nil {
		return *x.refd295c0e9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFragmentShadingRateEnumsFeaturesNV) Deref() {
	if x.refd295c0e9 == nil {
		return
	}
	x.SType = (StructureType)(x.refd295c0e9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd295c0e9.pNext))
	x.FragmentShadingRateEnums = (Bool32)(x.refd295c0e9.fragmentShadingRateEnums)
	x.SupersampleFragmentShadingRates = (Bool32)(x.refd295c0e9.supersampleFragmentShadingRates)
	x.NoInvocationFragmentShadingRates = (Bool32)(x.refd295c0e9.noInvocationFragmentShadingRates)
}

// allocPhysicalDeviceFragmentShadingRateEnumsPropertiesNVMemory allocates memory for type C.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFragmentShadingRateEnumsPropertiesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFragmentShadingRateEnumsPropertiesNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceFragmentShadingRateEnumsPropertiesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFragmentShadingRateEnumsPropertiesNV) Ref() *C.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
	if x == nil {
		return nil
	}
	return x.ref49eae7dc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFragmentShadingRateEnumsPropertiesNV) Free() {
	if x != nil && x.allocs49eae7dc != nil {
		x.allocs49eae7dc.(*cgoAllocMap).Free()
		x.ref49eae7dc = nil
	}
}

// NewPhysicalDeviceFragmentShadingRateEnumsPropertiesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFragmentShadingRateEnumsPropertiesNVRef(ref unsafe.Pointer) *PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFragmentShadingRateEnumsPropertiesNV)
	obj.ref49eae7dc = (*C.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFragmentShadingRateEnumsPropertiesNV) PassRef() (*C.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref49eae7dc != nil {
		return x.ref49eae7dc, nil
	}
	mem49eae7dc := allocPhysicalDeviceFragmentShadingRateEnumsPropertiesNVMemory(1)
	ref49eae7dc := (*C.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV)(mem49eae7dc)
	allocs49eae7dc := new(cgoAllocMap)
	allocs49eae7dc.Add(mem49eae7dc)

	var csType_allocs *cgoAllocMap
	ref49eae7dc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs49eae7dc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref49eae7dc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs49eae7dc.Borrow(cpNext_allocs)

	var cmaxFragmentShadingRateInvocationCount_allocs *cgoAllocMap
	ref49eae7dc.maxFragmentShadingRateInvocationCount, cmaxFragmentShadingRateInvocationCount_allocs = (C.VkSampleCountFlagBits)(x.MaxFragmentShadingRateInvocationCount), cgoAllocsUnknown
	allocs49eae7dc.Borrow(cmaxFragmentShadingRateInvocationCount_allocs)

	x.ref49eae7dc = ref49eae7dc
	x.allocs49eae7dc = allocs49eae7dc
	return ref49eae7dc, allocs49eae7dc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFragmentShadingRateEnumsPropertiesNV) PassValue() (C.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV, *cgoAllocMap) {
	if x.ref49eae7dc != nil {
		return *x.ref49eae7dc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFragmentShadingRateEnumsPropertiesNV) Deref() {
	if x.ref49eae7dc == nil {
		return
	}
	x.SType = (StructureType)(x.ref49eae7dc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref49eae7dc.pNext))
	x.MaxFragmentShadingRateInvocationCount = (SampleCountFlagBits)(x.ref49eae7dc.maxFragmentShadingRateInvocationCount)
}

// allocPipelineFragmentShadingRateEnumStateCreateInfoNVMemory allocates memory for type C.VkPipelineFragmentShadingRateEnumStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineFragmentShadingRateEnumStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineFragmentShadingRateEnumStateCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineFragmentShadingRateEnumStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineFragmentShadingRateEnumStateCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineFragmentShadingRateEnumStateCreateInfoNV) Ref() *C.VkPipelineFragmentShadingRateEnumStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref82a7e17b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineFragmentShadingRateEnumStateCreateInfoNV) Free() {
	if x != nil && x.allocs82a7e17b != nil {
		x.allocs82a7e17b.(*cgoAllocMap).Free()
		x.ref82a7e17b = nil
	}
}

// NewPipelineFragmentShadingRateEnumStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineFragmentShadingRateEnumStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineFragmentShadingRateEnumStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineFragmentShadingRateEnumStateCreateInfoNV)
	obj.ref82a7e17b = (*C.VkPipelineFragmentShadingRateEnumStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineFragmentShadingRateEnumStateCreateInfoNV) PassRef() (*C.VkPipelineFragmentShadingRateEnumStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref82a7e17b != nil {
		return x.ref82a7e17b, nil
	}
	mem82a7e17b := allocPipelineFragmentShadingRateEnumStateCreateInfoNVMemory(1)
	ref82a7e17b := (*C.VkPipelineFragmentShadingRateEnumStateCreateInfoNV)(mem82a7e17b)
	allocs82a7e17b := new(cgoAllocMap)
	allocs82a7e17b.Add(mem82a7e17b)

	var csType_allocs *cgoAllocMap
	ref82a7e17b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs82a7e17b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref82a7e17b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs82a7e17b.Borrow(cpNext_allocs)

	var cshadingRateType_allocs *cgoAllocMap
	ref82a7e17b.shadingRateType, cshadingRateType_allocs = (C.VkFragmentShadingRateTypeNV)(x.ShadingRateType), cgoAllocsUnknown
	allocs82a7e17b.Borrow(cshadingRateType_allocs)

	var cshadingRate_allocs *cgoAllocMap
	ref82a7e17b.shadingRate, cshadingRate_allocs = (C.VkFragmentShadingRateNV)(x.ShadingRate), cgoAllocsUnknown
	allocs82a7e17b.Borrow(cshadingRate_allocs)

	var ccombinerOps_allocs *cgoAllocMap
	ref82a7e17b.combinerOps, ccombinerOps_allocs = *(*[2]C.VkFragmentShadingRateCombinerOpKHR)(unsafe.Pointer(&x.CombinerOps)), cgoAllocsUnknown
	allocs82a7e17b.Borrow(ccombinerOps_allocs)

	x.ref82a7e17b = ref82a7e17b
	x.allocs82a7e17b = allocs82a7e17b
	return ref82a7e17b, allocs82a7e17b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineFragmentShadingRateEnumStateCreateInfoNV) PassValue() (C.VkPipelineFragmentShadingRateEnumStateCreateInfoNV, *cgoAllocMap) {
	if x.ref82a7e17b != nil {
		return *x.ref82a7e17b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineFragmentShadingRateEnumStateCreateInfoNV) Deref() {
	if x.ref82a7e17b == nil {
		return
	}
	x.SType = (StructureType)(x.ref82a7e17b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref82a7e17b.pNext))
	x.ShadingRateType = (FragmentShadingRateTypeNV)(x.ref82a7e17b.shadingRateType)
	x.ShadingRate = (FragmentShadingRateNV)(x.ref82a7e17b.shadingRate)
	x.CombinerOps = *(*[2]FragmentShadingRateCombinerOp)(unsafe.Pointer(&x.ref82a7e17b.combinerOps))
}

// allocPhysicalDeviceYcbcr2Plane444FormatsFeaturesMemory allocates memory for type C.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceYcbcr2Plane444FormatsFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceYcbcr2Plane444FormatsFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceYcbcr2Plane444FormatsFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceYcbcr2Plane444FormatsFeatures) Ref() *C.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.reff075d674
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceYcbcr2Plane444FormatsFeatures) Free() {
	if x != nil && x.allocsf075d674 != nil {
		x.allocsf075d674.(*cgoAllocMap).Free()
		x.reff075d674 = nil
	}
}

// NewPhysicalDeviceYcbcr2Plane444FormatsFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceYcbcr2Plane444FormatsFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceYcbcr2Plane444FormatsFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceYcbcr2Plane444FormatsFeatures)
	obj.reff075d674 = (*C.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceYcbcr2Plane444FormatsFeatures) PassRef() (*C.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff075d674 != nil {
		return x.reff075d674, nil
	}
	memf075d674 := allocPhysicalDeviceYcbcr2Plane444FormatsFeaturesMemory(1)
	reff075d674 := (*C.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT)(memf075d674)
	allocsf075d674 := new(cgoAllocMap)
	allocsf075d674.Add(memf075d674)

	var csType_allocs *cgoAllocMap
	reff075d674.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf075d674.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff075d674.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf075d674.Borrow(cpNext_allocs)

	var cycbcr2plane444Formats_allocs *cgoAllocMap
	reff075d674.ycbcr2plane444Formats, cycbcr2plane444Formats_allocs = (C.VkBool32)(x.Ycbcr2plane444Formats), cgoAllocsUnknown
	allocsf075d674.Borrow(cycbcr2plane444Formats_allocs)

	x.reff075d674 = reff075d674
	x.allocsf075d674 = allocsf075d674
	return reff075d674, allocsf075d674

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceYcbcr2Plane444FormatsFeatures) PassValue() (C.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, *cgoAllocMap) {
	if x.reff075d674 != nil {
		return *x.reff075d674, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceYcbcr2Plane444FormatsFeatures) Deref() {
	if x.reff075d674 == nil {
		return
	}
	x.SType = (StructureType)(x.reff075d674.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff075d674.pNext))
	x.Ycbcr2plane444Formats = (Bool32)(x.reff075d674.ycbcr2plane444Formats)
}

// allocPhysicalDeviceFragmentDensityMap2FeaturesMemory allocates memory for type C.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFragmentDensityMap2FeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFragmentDensityMap2FeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceFragmentDensityMap2FeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFragmentDensityMap2Features) Ref() *C.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref30a59f8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFragmentDensityMap2Features) Free() {
	if x != nil && x.allocs30a59f8 != nil {
		x.allocs30a59f8.(*cgoAllocMap).Free()
		x.ref30a59f8 = nil
	}
}

// NewPhysicalDeviceFragmentDensityMap2FeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFragmentDensityMap2FeaturesRef(ref unsafe.Pointer) *PhysicalDeviceFragmentDensityMap2Features {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFragmentDensityMap2Features)
	obj.ref30a59f8 = (*C.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFragmentDensityMap2Features) PassRef() (*C.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref30a59f8 != nil {
		return x.ref30a59f8, nil
	}
	mem30a59f8 := allocPhysicalDeviceFragmentDensityMap2FeaturesMemory(1)
	ref30a59f8 := (*C.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT)(mem30a59f8)
	allocs30a59f8 := new(cgoAllocMap)
	allocs30a59f8.Add(mem30a59f8)

	var csType_allocs *cgoAllocMap
	ref30a59f8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs30a59f8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref30a59f8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs30a59f8.Borrow(cpNext_allocs)

	var cfragmentDensityMapDeferred_allocs *cgoAllocMap
	ref30a59f8.fragmentDensityMapDeferred, cfragmentDensityMapDeferred_allocs = (C.VkBool32)(x.FragmentDensityMapDeferred), cgoAllocsUnknown
	allocs30a59f8.Borrow(cfragmentDensityMapDeferred_allocs)

	x.ref30a59f8 = ref30a59f8
	x.allocs30a59f8 = allocs30a59f8
	return ref30a59f8, allocs30a59f8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFragmentDensityMap2Features) PassValue() (C.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, *cgoAllocMap) {
	if x.ref30a59f8 != nil {
		return *x.ref30a59f8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFragmentDensityMap2Features) Deref() {
	if x.ref30a59f8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref30a59f8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref30a59f8.pNext))
	x.FragmentDensityMapDeferred = (Bool32)(x.ref30a59f8.fragmentDensityMapDeferred)
}

// allocPhysicalDeviceFragmentDensityMap2PropertiesMemory allocates memory for type C.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFragmentDensityMap2PropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFragmentDensityMap2PropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceFragmentDensityMap2PropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFragmentDensityMap2Properties) Ref() *C.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refc2a21d23
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFragmentDensityMap2Properties) Free() {
	if x != nil && x.allocsc2a21d23 != nil {
		x.allocsc2a21d23.(*cgoAllocMap).Free()
		x.refc2a21d23 = nil
	}
}

// NewPhysicalDeviceFragmentDensityMap2PropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFragmentDensityMap2PropertiesRef(ref unsafe.Pointer) *PhysicalDeviceFragmentDensityMap2Properties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFragmentDensityMap2Properties)
	obj.refc2a21d23 = (*C.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFragmentDensityMap2Properties) PassRef() (*C.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc2a21d23 != nil {
		return x.refc2a21d23, nil
	}
	memc2a21d23 := allocPhysicalDeviceFragmentDensityMap2PropertiesMemory(1)
	refc2a21d23 := (*C.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT)(memc2a21d23)
	allocsc2a21d23 := new(cgoAllocMap)
	allocsc2a21d23.Add(memc2a21d23)

	var csType_allocs *cgoAllocMap
	refc2a21d23.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc2a21d23.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc2a21d23.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc2a21d23.Borrow(cpNext_allocs)

	var csubsampledLoads_allocs *cgoAllocMap
	refc2a21d23.subsampledLoads, csubsampledLoads_allocs = (C.VkBool32)(x.SubsampledLoads), cgoAllocsUnknown
	allocsc2a21d23.Borrow(csubsampledLoads_allocs)

	var csubsampledCoarseReconstructionEarlyAccess_allocs *cgoAllocMap
	refc2a21d23.subsampledCoarseReconstructionEarlyAccess, csubsampledCoarseReconstructionEarlyAccess_allocs = (C.VkBool32)(x.SubsampledCoarseReconstructionEarlyAccess), cgoAllocsUnknown
	allocsc2a21d23.Borrow(csubsampledCoarseReconstructionEarlyAccess_allocs)

	var cmaxSubsampledArrayLayers_allocs *cgoAllocMap
	refc2a21d23.maxSubsampledArrayLayers, cmaxSubsampledArrayLayers_allocs = (C.uint32_t)(x.MaxSubsampledArrayLayers), cgoAllocsUnknown
	allocsc2a21d23.Borrow(cmaxSubsampledArrayLayers_allocs)

	var cmaxDescriptorSetSubsampledSamplers_allocs *cgoAllocMap
	refc2a21d23.maxDescriptorSetSubsampledSamplers, cmaxDescriptorSetSubsampledSamplers_allocs = (C.uint32_t)(x.MaxDescriptorSetSubsampledSamplers), cgoAllocsUnknown
	allocsc2a21d23.Borrow(cmaxDescriptorSetSubsampledSamplers_allocs)

	x.refc2a21d23 = refc2a21d23
	x.allocsc2a21d23 = allocsc2a21d23
	return refc2a21d23, allocsc2a21d23

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFragmentDensityMap2Properties) PassValue() (C.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, *cgoAllocMap) {
	if x.refc2a21d23 != nil {
		return *x.refc2a21d23, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFragmentDensityMap2Properties) Deref() {
	if x.refc2a21d23 == nil {
		return
	}
	x.SType = (StructureType)(x.refc2a21d23.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc2a21d23.pNext))
	x.SubsampledLoads = (Bool32)(x.refc2a21d23.subsampledLoads)
	x.SubsampledCoarseReconstructionEarlyAccess = (Bool32)(x.refc2a21d23.subsampledCoarseReconstructionEarlyAccess)
	x.MaxSubsampledArrayLayers = (uint32)(x.refc2a21d23.maxSubsampledArrayLayers)
	x.MaxDescriptorSetSubsampledSamplers = (uint32)(x.refc2a21d23.maxDescriptorSetSubsampledSamplers)
}

// allocCopyCommandTransformInfoQCOMMemory allocates memory for type C.VkCopyCommandTransformInfoQCOM in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyCommandTransformInfoQCOMMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyCommandTransformInfoQCOMValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCopyCommandTransformInfoQCOMValue = unsafe.Sizeof([1]C.VkCopyCommandTransformInfoQCOM{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CopyCommandTransformInfoQCOM) Ref() *C.VkCopyCommandTransformInfoQCOM {
	if x == nil {
		return nil
	}
	return x.refeaa6777c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CopyCommandTransformInfoQCOM) Free() {
	if x != nil && x.allocseaa6777c != nil {
		x.allocseaa6777c.(*cgoAllocMap).Free()
		x.refeaa6777c = nil
	}
}

// NewCopyCommandTransformInfoQCOMRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCopyCommandTransformInfoQCOMRef(ref unsafe.Pointer) *CopyCommandTransformInfoQCOM {
	if ref == nil {
		return nil
	}
	obj := new(CopyCommandTransformInfoQCOM)
	obj.refeaa6777c = (*C.VkCopyCommandTransformInfoQCOM)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CopyCommandTransformInfoQCOM) PassRef() (*C.VkCopyCommandTransformInfoQCOM, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeaa6777c != nil {
		return x.refeaa6777c, nil
	}
	memeaa6777c := allocCopyCommandTransformInfoQCOMMemory(1)
	refeaa6777c := (*C.VkCopyCommandTransformInfoQCOM)(memeaa6777c)
	allocseaa6777c := new(cgoAllocMap)
	allocseaa6777c.Add(memeaa6777c)

	var csType_allocs *cgoAllocMap
	refeaa6777c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseaa6777c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeaa6777c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseaa6777c.Borrow(cpNext_allocs)

	var ctransform_allocs *cgoAllocMap
	refeaa6777c.transform, ctransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.Transform), cgoAllocsUnknown
	allocseaa6777c.Borrow(ctransform_allocs)

	x.refeaa6777c = refeaa6777c
	x.allocseaa6777c = allocseaa6777c
	return refeaa6777c, allocseaa6777c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CopyCommandTransformInfoQCOM) PassValue() (C.VkCopyCommandTransformInfoQCOM, *cgoAllocMap) {
	if x.refeaa6777c != nil {
		return *x.refeaa6777c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CopyCommandTransformInfoQCOM) Deref() {
	if x.refeaa6777c == nil {
		return
	}
	x.SType = (StructureType)(x.refeaa6777c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeaa6777c.pNext))
	x.Transform = (SurfaceTransformFlagBits)(x.refeaa6777c.transform)
}

// allocPhysicalDeviceImageRobustnessFeaturesMemory allocates memory for type C.VkPhysicalDeviceImageRobustnessFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceImageRobustnessFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceImageRobustnessFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceImageRobustnessFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceImageRobustnessFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceImageRobustnessFeatures) Ref() *C.VkPhysicalDeviceImageRobustnessFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refd7bde095
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceImageRobustnessFeatures) Free() {
	if x != nil && x.allocsd7bde095 != nil {
		x.allocsd7bde095.(*cgoAllocMap).Free()
		x.refd7bde095 = nil
	}
}

// NewPhysicalDeviceImageRobustnessFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceImageRobustnessFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceImageRobustnessFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceImageRobustnessFeatures)
	obj.refd7bde095 = (*C.VkPhysicalDeviceImageRobustnessFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceImageRobustnessFeatures) PassRef() (*C.VkPhysicalDeviceImageRobustnessFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd7bde095 != nil {
		return x.refd7bde095, nil
	}
	memd7bde095 := allocPhysicalDeviceImageRobustnessFeaturesMemory(1)
	refd7bde095 := (*C.VkPhysicalDeviceImageRobustnessFeaturesEXT)(memd7bde095)
	allocsd7bde095 := new(cgoAllocMap)
	allocsd7bde095.Add(memd7bde095)

	var csType_allocs *cgoAllocMap
	refd7bde095.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd7bde095.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd7bde095.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd7bde095.Borrow(cpNext_allocs)

	var crobustImageAccess_allocs *cgoAllocMap
	refd7bde095.robustImageAccess, crobustImageAccess_allocs = (C.VkBool32)(x.RobustImageAccess), cgoAllocsUnknown
	allocsd7bde095.Borrow(crobustImageAccess_allocs)

	x.refd7bde095 = refd7bde095
	x.allocsd7bde095 = allocsd7bde095
	return refd7bde095, allocsd7bde095

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceImageRobustnessFeatures) PassValue() (C.VkPhysicalDeviceImageRobustnessFeaturesEXT, *cgoAllocMap) {
	if x.refd7bde095 != nil {
		return *x.refd7bde095, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceImageRobustnessFeatures) Deref() {
	if x.refd7bde095 == nil {
		return
	}
	x.SType = (StructureType)(x.refd7bde095.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd7bde095.pNext))
	x.RobustImageAccess = (Bool32)(x.refd7bde095.robustImageAccess)
}

// allocPhysicalDevice4444FormatsFeaturesMemory allocates memory for type C.VkPhysicalDevice4444FormatsFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevice4444FormatsFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevice4444FormatsFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDevice4444FormatsFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDevice4444FormatsFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevice4444FormatsFeatures) Ref() *C.VkPhysicalDevice4444FormatsFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref51c957d0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevice4444FormatsFeatures) Free() {
	if x != nil && x.allocs51c957d0 != nil {
		x.allocs51c957d0.(*cgoAllocMap).Free()
		x.ref51c957d0 = nil
	}
}

// NewPhysicalDevice4444FormatsFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevice4444FormatsFeaturesRef(ref unsafe.Pointer) *PhysicalDevice4444FormatsFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevice4444FormatsFeatures)
	obj.ref51c957d0 = (*C.VkPhysicalDevice4444FormatsFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevice4444FormatsFeatures) PassRef() (*C.VkPhysicalDevice4444FormatsFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref51c957d0 != nil {
		return x.ref51c957d0, nil
	}
	mem51c957d0 := allocPhysicalDevice4444FormatsFeaturesMemory(1)
	ref51c957d0 := (*C.VkPhysicalDevice4444FormatsFeaturesEXT)(mem51c957d0)
	allocs51c957d0 := new(cgoAllocMap)
	allocs51c957d0.Add(mem51c957d0)

	var csType_allocs *cgoAllocMap
	ref51c957d0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs51c957d0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref51c957d0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs51c957d0.Borrow(cpNext_allocs)

	var cformatA4R4G4B4_allocs *cgoAllocMap
	ref51c957d0.formatA4R4G4B4, cformatA4R4G4B4_allocs = (C.VkBool32)(x.FormatA4R4G4B4), cgoAllocsUnknown
	allocs51c957d0.Borrow(cformatA4R4G4B4_allocs)

	var cformatA4B4G4R4_allocs *cgoAllocMap
	ref51c957d0.formatA4B4G4R4, cformatA4B4G4R4_allocs = (C.VkBool32)(x.FormatA4B4G4R4), cgoAllocsUnknown
	allocs51c957d0.Borrow(cformatA4B4G4R4_allocs)

	x.ref51c957d0 = ref51c957d0
	x.allocs51c957d0 = allocs51c957d0
	return ref51c957d0, allocs51c957d0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevice4444FormatsFeatures) PassValue() (C.VkPhysicalDevice4444FormatsFeaturesEXT, *cgoAllocMap) {
	if x.ref51c957d0 != nil {
		return *x.ref51c957d0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevice4444FormatsFeatures) Deref() {
	if x.ref51c957d0 == nil {
		return
	}
	x.SType = (StructureType)(x.ref51c957d0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref51c957d0.pNext))
	x.FormatA4R4G4B4 = (Bool32)(x.ref51c957d0.formatA4R4G4B4)
	x.FormatA4B4G4R4 = (Bool32)(x.ref51c957d0.formatA4B4G4R4)
}

// allocPhysicalDeviceMutableDescriptorTypeFeaturesVALVEMemory allocates memory for type C.VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMutableDescriptorTypeFeaturesVALVEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMutableDescriptorTypeFeaturesVALVEValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceMutableDescriptorTypeFeaturesVALVEValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMutableDescriptorTypeFeaturesVALVE) Ref() *C.VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE {
	if x == nil {
		return nil
	}
	return x.ref2b2ab5ea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMutableDescriptorTypeFeaturesVALVE) Free() {
	if x != nil && x.allocs2b2ab5ea != nil {
		x.allocs2b2ab5ea.(*cgoAllocMap).Free()
		x.ref2b2ab5ea = nil
	}
}

// NewPhysicalDeviceMutableDescriptorTypeFeaturesVALVERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMutableDescriptorTypeFeaturesVALVERef(ref unsafe.Pointer) *PhysicalDeviceMutableDescriptorTypeFeaturesVALVE {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMutableDescriptorTypeFeaturesVALVE)
	obj.ref2b2ab5ea = (*C.VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMutableDescriptorTypeFeaturesVALVE) PassRef() (*C.VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2b2ab5ea != nil {
		return x.ref2b2ab5ea, nil
	}
	mem2b2ab5ea := allocPhysicalDeviceMutableDescriptorTypeFeaturesVALVEMemory(1)
	ref2b2ab5ea := (*C.VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE)(mem2b2ab5ea)
	allocs2b2ab5ea := new(cgoAllocMap)
	allocs2b2ab5ea.Add(mem2b2ab5ea)

	var csType_allocs *cgoAllocMap
	ref2b2ab5ea.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2b2ab5ea.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2b2ab5ea.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2b2ab5ea.Borrow(cpNext_allocs)

	var cmutableDescriptorType_allocs *cgoAllocMap
	ref2b2ab5ea.mutableDescriptorType, cmutableDescriptorType_allocs = (C.VkBool32)(x.MutableDescriptorType), cgoAllocsUnknown
	allocs2b2ab5ea.Borrow(cmutableDescriptorType_allocs)

	x.ref2b2ab5ea = ref2b2ab5ea
	x.allocs2b2ab5ea = allocs2b2ab5ea
	return ref2b2ab5ea, allocs2b2ab5ea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMutableDescriptorTypeFeaturesVALVE) PassValue() (C.VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE, *cgoAllocMap) {
	if x.ref2b2ab5ea != nil {
		return *x.ref2b2ab5ea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMutableDescriptorTypeFeaturesVALVE) Deref() {
	if x.ref2b2ab5ea == nil {
		return
	}
	x.SType = (StructureType)(x.ref2b2ab5ea.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2b2ab5ea.pNext))
	x.MutableDescriptorType = (Bool32)(x.ref2b2ab5ea.mutableDescriptorType)
}

// allocMutableDescriptorTypeListVALVEMemory allocates memory for type C.VkMutableDescriptorTypeListVALVE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMutableDescriptorTypeListVALVEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMutableDescriptorTypeListVALVEValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMutableDescriptorTypeListVALVEValue = unsafe.Sizeof([1]C.VkMutableDescriptorTypeListVALVE{})

// copyPDescriptorTypeBytes copies the data from Go slice as *C.VkDescriptorType.
func copyPDescriptorTypeBytes(slice *sliceHeader) (*C.VkDescriptorType, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDescriptorTypeValue) * slice.Len,
		Cap:  int(sizeOfDescriptorTypeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDescriptorType)(mem0), allocs
}

// allocDescriptorTypeMemory allocates memory for type C.VkDescriptorType in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorTypeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorTypeValue = unsafe.Sizeof([1]C.VkDescriptorType{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MutableDescriptorTypeListVALVE) Ref() *C.VkMutableDescriptorTypeListVALVE {
	if x == nil {
		return nil
	}
	return x.ref957e9078
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MutableDescriptorTypeListVALVE) Free() {
	if x != nil && x.allocs957e9078 != nil {
		x.allocs957e9078.(*cgoAllocMap).Free()
		x.ref957e9078 = nil
	}
}

// NewMutableDescriptorTypeListVALVERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMutableDescriptorTypeListVALVERef(ref unsafe.Pointer) *MutableDescriptorTypeListVALVE {
	if ref == nil {
		return nil
	}
	obj := new(MutableDescriptorTypeListVALVE)
	obj.ref957e9078 = (*C.VkMutableDescriptorTypeListVALVE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MutableDescriptorTypeListVALVE) PassRef() (*C.VkMutableDescriptorTypeListVALVE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref957e9078 != nil {
		return x.ref957e9078, nil
	}
	mem957e9078 := allocMutableDescriptorTypeListVALVEMemory(1)
	ref957e9078 := (*C.VkMutableDescriptorTypeListVALVE)(mem957e9078)
	allocs957e9078 := new(cgoAllocMap)
	allocs957e9078.Add(mem957e9078)

	var cdescriptorTypeCount_allocs *cgoAllocMap
	ref957e9078.descriptorTypeCount, cdescriptorTypeCount_allocs = (C.uint32_t)(x.DescriptorTypeCount), cgoAllocsUnknown
	allocs957e9078.Borrow(cdescriptorTypeCount_allocs)

	var cpDescriptorTypes_allocs *cgoAllocMap
	ref957e9078.pDescriptorTypes, cpDescriptorTypes_allocs = copyPDescriptorTypeBytes((*sliceHeader)(unsafe.Pointer(&x.PDescriptorTypes)))
	allocs957e9078.Borrow(cpDescriptorTypes_allocs)

	x.ref957e9078 = ref957e9078
	x.allocs957e9078 = allocs957e9078
	return ref957e9078, allocs957e9078

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MutableDescriptorTypeListVALVE) PassValue() (C.VkMutableDescriptorTypeListVALVE, *cgoAllocMap) {
	if x.ref957e9078 != nil {
		return *x.ref957e9078, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MutableDescriptorTypeListVALVE) Deref() {
	if x.ref957e9078 == nil {
		return
	}
	x.DescriptorTypeCount = (uint32)(x.ref957e9078.descriptorTypeCount)
	hxf177f79 := (*sliceHeader)(unsafe.Pointer(&x.PDescriptorTypes))
	hxf177f79.Data = unsafe.Pointer(x.ref957e9078.pDescriptorTypes)
	hxf177f79.Cap = 0x7fffffff
	// hxf177f79.Len = ?

}

// allocMutableDescriptorTypeCreateInfoVALVEMemory allocates memory for type C.VkMutableDescriptorTypeCreateInfoVALVE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMutableDescriptorTypeCreateInfoVALVEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMutableDescriptorTypeCreateInfoVALVEValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMutableDescriptorTypeCreateInfoVALVEValue = unsafe.Sizeof([1]C.VkMutableDescriptorTypeCreateInfoVALVE{})

// unpackSMutableDescriptorTypeListVALVE transforms a sliced Go data structure into plain C format.
func unpackSMutableDescriptorTypeListVALVE(x []MutableDescriptorTypeListVALVE) (unpacked *C.VkMutableDescriptorTypeListVALVE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocMutableDescriptorTypeListVALVEMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMutableDescriptorTypeListVALVE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMutableDescriptorTypeListVALVE)(h.Data)
	return
}

// packSMutableDescriptorTypeListVALVE reads sliced Go data structure out from plain C format.
func packSMutableDescriptorTypeListVALVE(v []MutableDescriptorTypeListVALVE, ptr0 *C.VkMutableDescriptorTypeListVALVE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMutableDescriptorTypeListVALVEValue]C.VkMutableDescriptorTypeListVALVE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMutableDescriptorTypeListVALVERef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MutableDescriptorTypeCreateInfoVALVE) Ref() *C.VkMutableDescriptorTypeCreateInfoVALVE {
	if x == nil {
		return nil
	}
	return x.ref8ef4bbb3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MutableDescriptorTypeCreateInfoVALVE) Free() {
	if x != nil && x.allocs8ef4bbb3 != nil {
		x.allocs8ef4bbb3.(*cgoAllocMap).Free()
		x.ref8ef4bbb3 = nil
	}
}

// NewMutableDescriptorTypeCreateInfoVALVERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMutableDescriptorTypeCreateInfoVALVERef(ref unsafe.Pointer) *MutableDescriptorTypeCreateInfoVALVE {
	if ref == nil {
		return nil
	}
	obj := new(MutableDescriptorTypeCreateInfoVALVE)
	obj.ref8ef4bbb3 = (*C.VkMutableDescriptorTypeCreateInfoVALVE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MutableDescriptorTypeCreateInfoVALVE) PassRef() (*C.VkMutableDescriptorTypeCreateInfoVALVE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8ef4bbb3 != nil {
		return x.ref8ef4bbb3, nil
	}
	mem8ef4bbb3 := allocMutableDescriptorTypeCreateInfoVALVEMemory(1)
	ref8ef4bbb3 := (*C.VkMutableDescriptorTypeCreateInfoVALVE)(mem8ef4bbb3)
	allocs8ef4bbb3 := new(cgoAllocMap)
	allocs8ef4bbb3.Add(mem8ef4bbb3)

	var csType_allocs *cgoAllocMap
	ref8ef4bbb3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8ef4bbb3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8ef4bbb3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8ef4bbb3.Borrow(cpNext_allocs)

	var cmutableDescriptorTypeListCount_allocs *cgoAllocMap
	ref8ef4bbb3.mutableDescriptorTypeListCount, cmutableDescriptorTypeListCount_allocs = (C.uint32_t)(x.MutableDescriptorTypeListCount), cgoAllocsUnknown
	allocs8ef4bbb3.Borrow(cmutableDescriptorTypeListCount_allocs)

	var cpMutableDescriptorTypeLists_allocs *cgoAllocMap
	ref8ef4bbb3.pMutableDescriptorTypeLists, cpMutableDescriptorTypeLists_allocs = unpackSMutableDescriptorTypeListVALVE(x.PMutableDescriptorTypeLists)
	allocs8ef4bbb3.Borrow(cpMutableDescriptorTypeLists_allocs)

	x.ref8ef4bbb3 = ref8ef4bbb3
	x.allocs8ef4bbb3 = allocs8ef4bbb3
	return ref8ef4bbb3, allocs8ef4bbb3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MutableDescriptorTypeCreateInfoVALVE) PassValue() (C.VkMutableDescriptorTypeCreateInfoVALVE, *cgoAllocMap) {
	if x.ref8ef4bbb3 != nil {
		return *x.ref8ef4bbb3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MutableDescriptorTypeCreateInfoVALVE) Deref() {
	if x.ref8ef4bbb3 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8ef4bbb3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8ef4bbb3.pNext))
	x.MutableDescriptorTypeListCount = (uint32)(x.ref8ef4bbb3.mutableDescriptorTypeListCount)
	packSMutableDescriptorTypeListVALVE(x.PMutableDescriptorTypeLists, x.ref8ef4bbb3.pMutableDescriptorTypeLists)
}

// allocPhysicalDeviceVertexInputDynamicStateFeaturesMemory allocates memory for type C.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVertexInputDynamicStateFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVertexInputDynamicStateFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceVertexInputDynamicStateFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVertexInputDynamicStateFeatures) Ref() *C.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref69e7b956
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVertexInputDynamicStateFeatures) Free() {
	if x != nil && x.allocs69e7b956 != nil {
		x.allocs69e7b956.(*cgoAllocMap).Free()
		x.ref69e7b956 = nil
	}
}

// NewPhysicalDeviceVertexInputDynamicStateFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVertexInputDynamicStateFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceVertexInputDynamicStateFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVertexInputDynamicStateFeatures)
	obj.ref69e7b956 = (*C.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVertexInputDynamicStateFeatures) PassRef() (*C.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref69e7b956 != nil {
		return x.ref69e7b956, nil
	}
	mem69e7b956 := allocPhysicalDeviceVertexInputDynamicStateFeaturesMemory(1)
	ref69e7b956 := (*C.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT)(mem69e7b956)
	allocs69e7b956 := new(cgoAllocMap)
	allocs69e7b956.Add(mem69e7b956)

	var csType_allocs *cgoAllocMap
	ref69e7b956.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs69e7b956.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref69e7b956.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs69e7b956.Borrow(cpNext_allocs)

	var cvertexInputDynamicState_allocs *cgoAllocMap
	ref69e7b956.vertexInputDynamicState, cvertexInputDynamicState_allocs = (C.VkBool32)(x.VertexInputDynamicState), cgoAllocsUnknown
	allocs69e7b956.Borrow(cvertexInputDynamicState_allocs)

	x.ref69e7b956 = ref69e7b956
	x.allocs69e7b956 = allocs69e7b956
	return ref69e7b956, allocs69e7b956

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVertexInputDynamicStateFeatures) PassValue() (C.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT, *cgoAllocMap) {
	if x.ref69e7b956 != nil {
		return *x.ref69e7b956, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVertexInputDynamicStateFeatures) Deref() {
	if x.ref69e7b956 == nil {
		return
	}
	x.SType = (StructureType)(x.ref69e7b956.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref69e7b956.pNext))
	x.VertexInputDynamicState = (Bool32)(x.ref69e7b956.vertexInputDynamicState)
}

// allocVertexInputBindingDescription2Memory allocates memory for type C.VkVertexInputBindingDescription2EXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputBindingDescription2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputBindingDescription2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVertexInputBindingDescription2Value = unsafe.Sizeof([1]C.VkVertexInputBindingDescription2EXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VertexInputBindingDescription2) Ref() *C.VkVertexInputBindingDescription2EXT {
	if x == nil {
		return nil
	}
	return x.refefc9e910
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VertexInputBindingDescription2) Free() {
	if x != nil && x.allocsefc9e910 != nil {
		x.allocsefc9e910.(*cgoAllocMap).Free()
		x.refefc9e910 = nil
	}
}

// NewVertexInputBindingDescription2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVertexInputBindingDescription2Ref(ref unsafe.Pointer) *VertexInputBindingDescription2 {
	if ref == nil {
		return nil
	}
	obj := new(VertexInputBindingDescription2)
	obj.refefc9e910 = (*C.VkVertexInputBindingDescription2EXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VertexInputBindingDescription2) PassRef() (*C.VkVertexInputBindingDescription2EXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refefc9e910 != nil {
		return x.refefc9e910, nil
	}
	memefc9e910 := allocVertexInputBindingDescription2Memory(1)
	refefc9e910 := (*C.VkVertexInputBindingDescription2EXT)(memefc9e910)
	allocsefc9e910 := new(cgoAllocMap)
	allocsefc9e910.Add(memefc9e910)

	var csType_allocs *cgoAllocMap
	refefc9e910.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsefc9e910.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refefc9e910.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsefc9e910.Borrow(cpNext_allocs)

	var cbinding_allocs *cgoAllocMap
	refefc9e910.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocsefc9e910.Borrow(cbinding_allocs)

	var cstride_allocs *cgoAllocMap
	refefc9e910.stride, cstride_allocs = (C.uint32_t)(x.Stride), cgoAllocsUnknown
	allocsefc9e910.Borrow(cstride_allocs)

	var cinputRate_allocs *cgoAllocMap
	refefc9e910.inputRate, cinputRate_allocs = (C.VkVertexInputRate)(x.InputRate), cgoAllocsUnknown
	allocsefc9e910.Borrow(cinputRate_allocs)

	var cdivisor_allocs *cgoAllocMap
	refefc9e910.divisor, cdivisor_allocs = (C.uint32_t)(x.Divisor), cgoAllocsUnknown
	allocsefc9e910.Borrow(cdivisor_allocs)

	x.refefc9e910 = refefc9e910
	x.allocsefc9e910 = allocsefc9e910
	return refefc9e910, allocsefc9e910

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VertexInputBindingDescription2) PassValue() (C.VkVertexInputBindingDescription2EXT, *cgoAllocMap) {
	if x.refefc9e910 != nil {
		return *x.refefc9e910, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VertexInputBindingDescription2) Deref() {
	if x.refefc9e910 == nil {
		return
	}
	x.SType = (StructureType)(x.refefc9e910.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refefc9e910.pNext))
	x.Binding = (uint32)(x.refefc9e910.binding)
	x.Stride = (uint32)(x.refefc9e910.stride)
	x.InputRate = (VertexInputRate)(x.refefc9e910.inputRate)
	x.Divisor = (uint32)(x.refefc9e910.divisor)
}

// allocVertexInputAttributeDescription2Memory allocates memory for type C.VkVertexInputAttributeDescription2EXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputAttributeDescription2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputAttributeDescription2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVertexInputAttributeDescription2Value = unsafe.Sizeof([1]C.VkVertexInputAttributeDescription2EXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VertexInputAttributeDescription2) Ref() *C.VkVertexInputAttributeDescription2EXT {
	if x == nil {
		return nil
	}
	return x.refc6b0b55a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VertexInputAttributeDescription2) Free() {
	if x != nil && x.allocsc6b0b55a != nil {
		x.allocsc6b0b55a.(*cgoAllocMap).Free()
		x.refc6b0b55a = nil
	}
}

// NewVertexInputAttributeDescription2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVertexInputAttributeDescription2Ref(ref unsafe.Pointer) *VertexInputAttributeDescription2 {
	if ref == nil {
		return nil
	}
	obj := new(VertexInputAttributeDescription2)
	obj.refc6b0b55a = (*C.VkVertexInputAttributeDescription2EXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VertexInputAttributeDescription2) PassRef() (*C.VkVertexInputAttributeDescription2EXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc6b0b55a != nil {
		return x.refc6b0b55a, nil
	}
	memc6b0b55a := allocVertexInputAttributeDescription2Memory(1)
	refc6b0b55a := (*C.VkVertexInputAttributeDescription2EXT)(memc6b0b55a)
	allocsc6b0b55a := new(cgoAllocMap)
	allocsc6b0b55a.Add(memc6b0b55a)

	var csType_allocs *cgoAllocMap
	refc6b0b55a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc6b0b55a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc6b0b55a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc6b0b55a.Borrow(cpNext_allocs)

	var clocation_allocs *cgoAllocMap
	refc6b0b55a.location, clocation_allocs = (C.uint32_t)(x.Location), cgoAllocsUnknown
	allocsc6b0b55a.Borrow(clocation_allocs)

	var cbinding_allocs *cgoAllocMap
	refc6b0b55a.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocsc6b0b55a.Borrow(cbinding_allocs)

	var cformat_allocs *cgoAllocMap
	refc6b0b55a.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsc6b0b55a.Borrow(cformat_allocs)

	var coffset_allocs *cgoAllocMap
	refc6b0b55a.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocsc6b0b55a.Borrow(coffset_allocs)

	x.refc6b0b55a = refc6b0b55a
	x.allocsc6b0b55a = allocsc6b0b55a
	return refc6b0b55a, allocsc6b0b55a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VertexInputAttributeDescription2) PassValue() (C.VkVertexInputAttributeDescription2EXT, *cgoAllocMap) {
	if x.refc6b0b55a != nil {
		return *x.refc6b0b55a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VertexInputAttributeDescription2) Deref() {
	if x.refc6b0b55a == nil {
		return
	}
	x.SType = (StructureType)(x.refc6b0b55a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc6b0b55a.pNext))
	x.Location = (uint32)(x.refc6b0b55a.location)
	x.Binding = (uint32)(x.refc6b0b55a.binding)
	x.Format = (Format)(x.refc6b0b55a.format)
	x.Offset = (uint32)(x.refc6b0b55a.offset)
}

// allocPhysicalDeviceExtendedDynamicState2FeaturesMemory allocates memory for type C.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExtendedDynamicState2FeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExtendedDynamicState2FeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceExtendedDynamicState2FeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExtendedDynamicState2Features) Ref() *C.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refbd0cffdd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExtendedDynamicState2Features) Free() {
	if x != nil && x.allocsbd0cffdd != nil {
		x.allocsbd0cffdd.(*cgoAllocMap).Free()
		x.refbd0cffdd = nil
	}
}

// NewPhysicalDeviceExtendedDynamicState2FeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExtendedDynamicState2FeaturesRef(ref unsafe.Pointer) *PhysicalDeviceExtendedDynamicState2Features {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExtendedDynamicState2Features)
	obj.refbd0cffdd = (*C.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExtendedDynamicState2Features) PassRef() (*C.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbd0cffdd != nil {
		return x.refbd0cffdd, nil
	}
	membd0cffdd := allocPhysicalDeviceExtendedDynamicState2FeaturesMemory(1)
	refbd0cffdd := (*C.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT)(membd0cffdd)
	allocsbd0cffdd := new(cgoAllocMap)
	allocsbd0cffdd.Add(membd0cffdd)

	var csType_allocs *cgoAllocMap
	refbd0cffdd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbd0cffdd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbd0cffdd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbd0cffdd.Borrow(cpNext_allocs)

	var cextendedDynamicState2_allocs *cgoAllocMap
	refbd0cffdd.extendedDynamicState2, cextendedDynamicState2_allocs = (C.VkBool32)(x.ExtendedDynamicState2), cgoAllocsUnknown
	allocsbd0cffdd.Borrow(cextendedDynamicState2_allocs)

	var cextendedDynamicState2LogicOp_allocs *cgoAllocMap
	refbd0cffdd.extendedDynamicState2LogicOp, cextendedDynamicState2LogicOp_allocs = (C.VkBool32)(x.ExtendedDynamicState2LogicOp), cgoAllocsUnknown
	allocsbd0cffdd.Borrow(cextendedDynamicState2LogicOp_allocs)

	var cextendedDynamicState2PatchControlPoints_allocs *cgoAllocMap
	refbd0cffdd.extendedDynamicState2PatchControlPoints, cextendedDynamicState2PatchControlPoints_allocs = (C.VkBool32)(x.ExtendedDynamicState2PatchControlPoints), cgoAllocsUnknown
	allocsbd0cffdd.Borrow(cextendedDynamicState2PatchControlPoints_allocs)

	x.refbd0cffdd = refbd0cffdd
	x.allocsbd0cffdd = allocsbd0cffdd
	return refbd0cffdd, allocsbd0cffdd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExtendedDynamicState2Features) PassValue() (C.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, *cgoAllocMap) {
	if x.refbd0cffdd != nil {
		return *x.refbd0cffdd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExtendedDynamicState2Features) Deref() {
	if x.refbd0cffdd == nil {
		return
	}
	x.SType = (StructureType)(x.refbd0cffdd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbd0cffdd.pNext))
	x.ExtendedDynamicState2 = (Bool32)(x.refbd0cffdd.extendedDynamicState2)
	x.ExtendedDynamicState2LogicOp = (Bool32)(x.refbd0cffdd.extendedDynamicState2LogicOp)
	x.ExtendedDynamicState2PatchControlPoints = (Bool32)(x.refbd0cffdd.extendedDynamicState2PatchControlPoints)
}

// allocPhysicalDeviceColorWriteEnableFeaturesMemory allocates memory for type C.VkPhysicalDeviceColorWriteEnableFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceColorWriteEnableFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceColorWriteEnableFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceColorWriteEnableFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceColorWriteEnableFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceColorWriteEnableFeatures) Ref() *C.VkPhysicalDeviceColorWriteEnableFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refd894aa7b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceColorWriteEnableFeatures) Free() {
	if x != nil && x.allocsd894aa7b != nil {
		x.allocsd894aa7b.(*cgoAllocMap).Free()
		x.refd894aa7b = nil
	}
}

// NewPhysicalDeviceColorWriteEnableFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceColorWriteEnableFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceColorWriteEnableFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceColorWriteEnableFeatures)
	obj.refd894aa7b = (*C.VkPhysicalDeviceColorWriteEnableFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceColorWriteEnableFeatures) PassRef() (*C.VkPhysicalDeviceColorWriteEnableFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd894aa7b != nil {
		return x.refd894aa7b, nil
	}
	memd894aa7b := allocPhysicalDeviceColorWriteEnableFeaturesMemory(1)
	refd894aa7b := (*C.VkPhysicalDeviceColorWriteEnableFeaturesEXT)(memd894aa7b)
	allocsd894aa7b := new(cgoAllocMap)
	allocsd894aa7b.Add(memd894aa7b)

	var csType_allocs *cgoAllocMap
	refd894aa7b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd894aa7b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd894aa7b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd894aa7b.Borrow(cpNext_allocs)

	var ccolorWriteEnable_allocs *cgoAllocMap
	refd894aa7b.colorWriteEnable, ccolorWriteEnable_allocs = (C.VkBool32)(x.ColorWriteEnable), cgoAllocsUnknown
	allocsd894aa7b.Borrow(ccolorWriteEnable_allocs)

	x.refd894aa7b = refd894aa7b
	x.allocsd894aa7b = allocsd894aa7b
	return refd894aa7b, allocsd894aa7b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceColorWriteEnableFeatures) PassValue() (C.VkPhysicalDeviceColorWriteEnableFeaturesEXT, *cgoAllocMap) {
	if x.refd894aa7b != nil {
		return *x.refd894aa7b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceColorWriteEnableFeatures) Deref() {
	if x.refd894aa7b == nil {
		return
	}
	x.SType = (StructureType)(x.refd894aa7b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd894aa7b.pNext))
	x.ColorWriteEnable = (Bool32)(x.refd894aa7b.colorWriteEnable)
}

// allocPipelineColorWriteCreateInfoMemory allocates memory for type C.VkPipelineColorWriteCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineColorWriteCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineColorWriteCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineColorWriteCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineColorWriteCreateInfoEXT{})

// copyPBool32Bytes copies the data from Go slice as *C.VkBool32.
func copyPBool32Bytes(slice *sliceHeader) (*C.VkBool32, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfBool32Value) * slice.Len,
		Cap:  int(sizeOfBool32Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkBool32)(mem0), allocs
}

// allocBool32Memory allocates memory for type C.VkBool32 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBool32Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBool32Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBool32Value = unsafe.Sizeof([1]C.VkBool32{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineColorWriteCreateInfo) Ref() *C.VkPipelineColorWriteCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refa0609dbc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineColorWriteCreateInfo) Free() {
	if x != nil && x.allocsa0609dbc != nil {
		x.allocsa0609dbc.(*cgoAllocMap).Free()
		x.refa0609dbc = nil
	}
}

// NewPipelineColorWriteCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineColorWriteCreateInfoRef(ref unsafe.Pointer) *PipelineColorWriteCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineColorWriteCreateInfo)
	obj.refa0609dbc = (*C.VkPipelineColorWriteCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineColorWriteCreateInfo) PassRef() (*C.VkPipelineColorWriteCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa0609dbc != nil {
		return x.refa0609dbc, nil
	}
	mema0609dbc := allocPipelineColorWriteCreateInfoMemory(1)
	refa0609dbc := (*C.VkPipelineColorWriteCreateInfoEXT)(mema0609dbc)
	allocsa0609dbc := new(cgoAllocMap)
	allocsa0609dbc.Add(mema0609dbc)

	var csType_allocs *cgoAllocMap
	refa0609dbc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa0609dbc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa0609dbc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa0609dbc.Borrow(cpNext_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	refa0609dbc.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocsa0609dbc.Borrow(cattachmentCount_allocs)

	var cpColorWriteEnables_allocs *cgoAllocMap
	refa0609dbc.pColorWriteEnables, cpColorWriteEnables_allocs = copyPBool32Bytes((*sliceHeader)(unsafe.Pointer(&x.PColorWriteEnables)))
	allocsa0609dbc.Borrow(cpColorWriteEnables_allocs)

	x.refa0609dbc = refa0609dbc
	x.allocsa0609dbc = allocsa0609dbc
	return refa0609dbc, allocsa0609dbc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineColorWriteCreateInfo) PassValue() (C.VkPipelineColorWriteCreateInfoEXT, *cgoAllocMap) {
	if x.refa0609dbc != nil {
		return *x.refa0609dbc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineColorWriteCreateInfo) Deref() {
	if x.refa0609dbc == nil {
		return
	}
	x.SType = (StructureType)(x.refa0609dbc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa0609dbc.pNext))
	x.AttachmentCount = (uint32)(x.refa0609dbc.attachmentCount)
	hxfaa359c := (*sliceHeader)(unsafe.Pointer(&x.PColorWriteEnables))
	hxfaa359c.Data = unsafe.Pointer(x.refa0609dbc.pColorWriteEnables)
	hxfaa359c.Cap = 0x7fffffff
	// hxfaa359c.Len = ?

}

// allocAccelerationStructureBuildRangeInfoMemory allocates memory for type C.VkAccelerationStructureBuildRangeInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureBuildRangeInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureBuildRangeInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAccelerationStructureBuildRangeInfoValue = unsafe.Sizeof([1]C.VkAccelerationStructureBuildRangeInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureBuildRangeInfo) Ref() *C.VkAccelerationStructureBuildRangeInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref1c140562
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureBuildRangeInfo) Free() {
	if x != nil && x.allocs1c140562 != nil {
		x.allocs1c140562.(*cgoAllocMap).Free()
		x.ref1c140562 = nil
	}
}

// NewAccelerationStructureBuildRangeInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureBuildRangeInfoRef(ref unsafe.Pointer) *AccelerationStructureBuildRangeInfo {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureBuildRangeInfo)
	obj.ref1c140562 = (*C.VkAccelerationStructureBuildRangeInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureBuildRangeInfo) PassRef() (*C.VkAccelerationStructureBuildRangeInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1c140562 != nil {
		return x.ref1c140562, nil
	}
	mem1c140562 := allocAccelerationStructureBuildRangeInfoMemory(1)
	ref1c140562 := (*C.VkAccelerationStructureBuildRangeInfoKHR)(mem1c140562)
	allocs1c140562 := new(cgoAllocMap)
	allocs1c140562.Add(mem1c140562)

	var cprimitiveCount_allocs *cgoAllocMap
	ref1c140562.primitiveCount, cprimitiveCount_allocs = (C.uint32_t)(x.PrimitiveCount), cgoAllocsUnknown
	allocs1c140562.Borrow(cprimitiveCount_allocs)

	var cprimitiveOffset_allocs *cgoAllocMap
	ref1c140562.primitiveOffset, cprimitiveOffset_allocs = (C.uint32_t)(x.PrimitiveOffset), cgoAllocsUnknown
	allocs1c140562.Borrow(cprimitiveOffset_allocs)

	var cfirstVertex_allocs *cgoAllocMap
	ref1c140562.firstVertex, cfirstVertex_allocs = (C.uint32_t)(x.FirstVertex), cgoAllocsUnknown
	allocs1c140562.Borrow(cfirstVertex_allocs)

	var ctransformOffset_allocs *cgoAllocMap
	ref1c140562.transformOffset, ctransformOffset_allocs = (C.uint32_t)(x.TransformOffset), cgoAllocsUnknown
	allocs1c140562.Borrow(ctransformOffset_allocs)

	x.ref1c140562 = ref1c140562
	x.allocs1c140562 = allocs1c140562
	return ref1c140562, allocs1c140562

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureBuildRangeInfo) PassValue() (C.VkAccelerationStructureBuildRangeInfoKHR, *cgoAllocMap) {
	if x.ref1c140562 != nil {
		return *x.ref1c140562, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureBuildRangeInfo) Deref() {
	if x.ref1c140562 == nil {
		return
	}
	x.PrimitiveCount = (uint32)(x.ref1c140562.primitiveCount)
	x.PrimitiveOffset = (uint32)(x.ref1c140562.primitiveOffset)
	x.FirstVertex = (uint32)(x.ref1c140562.firstVertex)
	x.TransformOffset = (uint32)(x.ref1c140562.transformOffset)
}

// allocAccelerationStructureGeometryTrianglesDataMemory allocates memory for type C.VkAccelerationStructureGeometryTrianglesDataKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureGeometryTrianglesDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureGeometryTrianglesDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAccelerationStructureGeometryTrianglesDataValue = unsafe.Sizeof([1]C.VkAccelerationStructureGeometryTrianglesDataKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureGeometryTrianglesData) Ref() *C.VkAccelerationStructureGeometryTrianglesDataKHR {
	if x == nil {
		return nil
	}
	return x.reff021c4cc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureGeometryTrianglesData) Free() {
	if x != nil && x.allocsf021c4cc != nil {
		x.allocsf021c4cc.(*cgoAllocMap).Free()
		x.reff021c4cc = nil
	}
}

// NewAccelerationStructureGeometryTrianglesDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureGeometryTrianglesDataRef(ref unsafe.Pointer) *AccelerationStructureGeometryTrianglesData {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureGeometryTrianglesData)
	obj.reff021c4cc = (*C.VkAccelerationStructureGeometryTrianglesDataKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureGeometryTrianglesData) PassRef() (*C.VkAccelerationStructureGeometryTrianglesDataKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff021c4cc != nil {
		return x.reff021c4cc, nil
	}
	memf021c4cc := allocAccelerationStructureGeometryTrianglesDataMemory(1)
	reff021c4cc := (*C.VkAccelerationStructureGeometryTrianglesDataKHR)(memf021c4cc)
	allocsf021c4cc := new(cgoAllocMap)
	allocsf021c4cc.Add(memf021c4cc)

	var csType_allocs *cgoAllocMap
	reff021c4cc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf021c4cc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff021c4cc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf021c4cc.Borrow(cpNext_allocs)

	var cvertexFormat_allocs *cgoAllocMap
	reff021c4cc.vertexFormat, cvertexFormat_allocs = (C.VkFormat)(x.VertexFormat), cgoAllocsUnknown
	allocsf021c4cc.Borrow(cvertexFormat_allocs)

	var cvertexData_allocs *cgoAllocMap
	reff021c4cc.vertexData, cvertexData_allocs = *(*C.VkDeviceOrHostAddressConstKHR)(unsafe.Pointer(&x.VertexData)), cgoAllocsUnknown
	allocsf021c4cc.Borrow(cvertexData_allocs)

	var cvertexStride_allocs *cgoAllocMap
	reff021c4cc.vertexStride, cvertexStride_allocs = (C.VkDeviceSize)(x.VertexStride), cgoAllocsUnknown
	allocsf021c4cc.Borrow(cvertexStride_allocs)

	var cmaxVertex_allocs *cgoAllocMap
	reff021c4cc.maxVertex, cmaxVertex_allocs = (C.uint32_t)(x.MaxVertex), cgoAllocsUnknown
	allocsf021c4cc.Borrow(cmaxVertex_allocs)

	var cindexType_allocs *cgoAllocMap
	reff021c4cc.indexType, cindexType_allocs = (C.VkIndexType)(x.IndexType), cgoAllocsUnknown
	allocsf021c4cc.Borrow(cindexType_allocs)

	var cindexData_allocs *cgoAllocMap
	reff021c4cc.indexData, cindexData_allocs = *(*C.VkDeviceOrHostAddressConstKHR)(unsafe.Pointer(&x.IndexData)), cgoAllocsUnknown
	allocsf021c4cc.Borrow(cindexData_allocs)

	var ctransformData_allocs *cgoAllocMap
	reff021c4cc.transformData, ctransformData_allocs = *(*C.VkDeviceOrHostAddressConstKHR)(unsafe.Pointer(&x.TransformData)), cgoAllocsUnknown
	allocsf021c4cc.Borrow(ctransformData_allocs)

	x.reff021c4cc = reff021c4cc
	x.allocsf021c4cc = allocsf021c4cc
	return reff021c4cc, allocsf021c4cc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureGeometryTrianglesData) PassValue() (C.VkAccelerationStructureGeometryTrianglesDataKHR, *cgoAllocMap) {
	if x.reff021c4cc != nil {
		return *x.reff021c4cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureGeometryTrianglesData) Deref() {
	if x.reff021c4cc == nil {
		return
	}
	x.SType = (StructureType)(x.reff021c4cc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff021c4cc.pNext))
	x.VertexFormat = (Format)(x.reff021c4cc.vertexFormat)
	x.VertexData = *(*DeviceOrHostAddressConst)(unsafe.Pointer(&x.reff021c4cc.vertexData))
	x.VertexStride = (DeviceSize)(x.reff021c4cc.vertexStride)
	x.MaxVertex = (uint32)(x.reff021c4cc.maxVertex)
	x.IndexType = (IndexType)(x.reff021c4cc.indexType)
	x.IndexData = *(*DeviceOrHostAddressConst)(unsafe.Pointer(&x.reff021c4cc.indexData))
	x.TransformData = *(*DeviceOrHostAddressConst)(unsafe.Pointer(&x.reff021c4cc.transformData))
}

// allocAccelerationStructureGeometryAabbsDataMemory allocates memory for type C.VkAccelerationStructureGeometryAabbsDataKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureGeometryAabbsDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureGeometryAabbsDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAccelerationStructureGeometryAabbsDataValue = unsafe.Sizeof([1]C.VkAccelerationStructureGeometryAabbsDataKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureGeometryAabbsData) Ref() *C.VkAccelerationStructureGeometryAabbsDataKHR {
	if x == nil {
		return nil
	}
	return x.refbb925f8f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureGeometryAabbsData) Free() {
	if x != nil && x.allocsbb925f8f != nil {
		x.allocsbb925f8f.(*cgoAllocMap).Free()
		x.refbb925f8f = nil
	}
}

// NewAccelerationStructureGeometryAabbsDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureGeometryAabbsDataRef(ref unsafe.Pointer) *AccelerationStructureGeometryAabbsData {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureGeometryAabbsData)
	obj.refbb925f8f = (*C.VkAccelerationStructureGeometryAabbsDataKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureGeometryAabbsData) PassRef() (*C.VkAccelerationStructureGeometryAabbsDataKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbb925f8f != nil {
		return x.refbb925f8f, nil
	}
	membb925f8f := allocAccelerationStructureGeometryAabbsDataMemory(1)
	refbb925f8f := (*C.VkAccelerationStructureGeometryAabbsDataKHR)(membb925f8f)
	allocsbb925f8f := new(cgoAllocMap)
	allocsbb925f8f.Add(membb925f8f)

	var csType_allocs *cgoAllocMap
	refbb925f8f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbb925f8f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbb925f8f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbb925f8f.Borrow(cpNext_allocs)

	var cdata_allocs *cgoAllocMap
	refbb925f8f.data, cdata_allocs = *(*C.VkDeviceOrHostAddressConstKHR)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocsbb925f8f.Borrow(cdata_allocs)

	var cstride_allocs *cgoAllocMap
	refbb925f8f.stride, cstride_allocs = (C.VkDeviceSize)(x.Stride), cgoAllocsUnknown
	allocsbb925f8f.Borrow(cstride_allocs)

	x.refbb925f8f = refbb925f8f
	x.allocsbb925f8f = allocsbb925f8f
	return refbb925f8f, allocsbb925f8f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureGeometryAabbsData) PassValue() (C.VkAccelerationStructureGeometryAabbsDataKHR, *cgoAllocMap) {
	if x.refbb925f8f != nil {
		return *x.refbb925f8f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureGeometryAabbsData) Deref() {
	if x.refbb925f8f == nil {
		return
	}
	x.SType = (StructureType)(x.refbb925f8f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbb925f8f.pNext))
	x.Data = *(*DeviceOrHostAddressConst)(unsafe.Pointer(&x.refbb925f8f.data))
	x.Stride = (DeviceSize)(x.refbb925f8f.stride)
}

// allocAccelerationStructureGeometryInstancesDataMemory allocates memory for type C.VkAccelerationStructureGeometryInstancesDataKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureGeometryInstancesDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureGeometryInstancesDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAccelerationStructureGeometryInstancesDataValue = unsafe.Sizeof([1]C.VkAccelerationStructureGeometryInstancesDataKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureGeometryInstancesData) Ref() *C.VkAccelerationStructureGeometryInstancesDataKHR {
	if x == nil {
		return nil
	}
	return x.reffba487e7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureGeometryInstancesData) Free() {
	if x != nil && x.allocsfba487e7 != nil {
		x.allocsfba487e7.(*cgoAllocMap).Free()
		x.reffba487e7 = nil
	}
}

// NewAccelerationStructureGeometryInstancesDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureGeometryInstancesDataRef(ref unsafe.Pointer) *AccelerationStructureGeometryInstancesData {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureGeometryInstancesData)
	obj.reffba487e7 = (*C.VkAccelerationStructureGeometryInstancesDataKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureGeometryInstancesData) PassRef() (*C.VkAccelerationStructureGeometryInstancesDataKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffba487e7 != nil {
		return x.reffba487e7, nil
	}
	memfba487e7 := allocAccelerationStructureGeometryInstancesDataMemory(1)
	reffba487e7 := (*C.VkAccelerationStructureGeometryInstancesDataKHR)(memfba487e7)
	allocsfba487e7 := new(cgoAllocMap)
	allocsfba487e7.Add(memfba487e7)

	var csType_allocs *cgoAllocMap
	reffba487e7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfba487e7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffba487e7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfba487e7.Borrow(cpNext_allocs)

	var carrayOfPointers_allocs *cgoAllocMap
	reffba487e7.arrayOfPointers, carrayOfPointers_allocs = (C.VkBool32)(x.ArrayOfPointers), cgoAllocsUnknown
	allocsfba487e7.Borrow(carrayOfPointers_allocs)

	var cdata_allocs *cgoAllocMap
	reffba487e7.data, cdata_allocs = *(*C.VkDeviceOrHostAddressConstKHR)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocsfba487e7.Borrow(cdata_allocs)

	x.reffba487e7 = reffba487e7
	x.allocsfba487e7 = allocsfba487e7
	return reffba487e7, allocsfba487e7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureGeometryInstancesData) PassValue() (C.VkAccelerationStructureGeometryInstancesDataKHR, *cgoAllocMap) {
	if x.reffba487e7 != nil {
		return *x.reffba487e7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureGeometryInstancesData) Deref() {
	if x.reffba487e7 == nil {
		return
	}
	x.SType = (StructureType)(x.reffba487e7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffba487e7.pNext))
	x.ArrayOfPointers = (Bool32)(x.reffba487e7.arrayOfPointers)
	x.Data = *(*DeviceOrHostAddressConst)(unsafe.Pointer(&x.reffba487e7.data))
}

// allocAccelerationStructureGeometryMemory allocates memory for type C.VkAccelerationStructureGeometryKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureGeometryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureGeometryValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAccelerationStructureGeometryValue = unsafe.Sizeof([1]C.VkAccelerationStructureGeometryKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureGeometry) Ref() *C.VkAccelerationStructureGeometryKHR {
	if x == nil {
		return nil
	}
	return x.ref44f55570
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureGeometry) Free() {
	if x != nil && x.allocs44f55570 != nil {
		x.allocs44f55570.(*cgoAllocMap).Free()
		x.ref44f55570 = nil
	}
}

// NewAccelerationStructureGeometryRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureGeometryRef(ref unsafe.Pointer) *AccelerationStructureGeometry {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureGeometry)
	obj.ref44f55570 = (*C.VkAccelerationStructureGeometryKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureGeometry) PassRef() (*C.VkAccelerationStructureGeometryKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref44f55570 != nil {
		return x.ref44f55570, nil
	}
	mem44f55570 := allocAccelerationStructureGeometryMemory(1)
	ref44f55570 := (*C.VkAccelerationStructureGeometryKHR)(mem44f55570)
	allocs44f55570 := new(cgoAllocMap)
	allocs44f55570.Add(mem44f55570)

	var csType_allocs *cgoAllocMap
	ref44f55570.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs44f55570.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref44f55570.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs44f55570.Borrow(cpNext_allocs)

	var cgeometryType_allocs *cgoAllocMap
	ref44f55570.geometryType, cgeometryType_allocs = (C.VkGeometryTypeKHR)(x.GeometryType), cgoAllocsUnknown
	allocs44f55570.Borrow(cgeometryType_allocs)

	var cgeometry_allocs *cgoAllocMap
	ref44f55570.geometry, cgeometry_allocs = *(*C.VkAccelerationStructureGeometryDataKHR)(unsafe.Pointer(&x.Geometry)), cgoAllocsUnknown
	allocs44f55570.Borrow(cgeometry_allocs)

	var cflags_allocs *cgoAllocMap
	ref44f55570.flags, cflags_allocs = (C.VkGeometryFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs44f55570.Borrow(cflags_allocs)

	x.ref44f55570 = ref44f55570
	x.allocs44f55570 = allocs44f55570
	return ref44f55570, allocs44f55570

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureGeometry) PassValue() (C.VkAccelerationStructureGeometryKHR, *cgoAllocMap) {
	if x.ref44f55570 != nil {
		return *x.ref44f55570, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureGeometry) Deref() {
	if x.ref44f55570 == nil {
		return
	}
	x.SType = (StructureType)(x.ref44f55570.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref44f55570.pNext))
	x.GeometryType = (GeometryType)(x.ref44f55570.geometryType)
	x.Geometry = *(*AccelerationStructureGeometryData)(unsafe.Pointer(&x.ref44f55570.geometry))
	x.Flags = (GeometryFlags)(x.ref44f55570.flags)
}

// allocAccelerationStructureBuildGeometryInfoMemory allocates memory for type C.VkAccelerationStructureBuildGeometryInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureBuildGeometryInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureBuildGeometryInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAccelerationStructureBuildGeometryInfoValue = unsafe.Sizeof([1]C.VkAccelerationStructureBuildGeometryInfoKHR{})

// unpackSAccelerationStructureGeometry transforms a sliced Go data structure into plain C format.
func unpackSAccelerationStructureGeometry(x []AccelerationStructureGeometry) (unpacked *C.VkAccelerationStructureGeometryKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocAccelerationStructureGeometryMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAccelerationStructureGeometryKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAccelerationStructureGeometryKHR)(h.Data)
	return
}

// allocPAccelerationStructureGeometryMemory allocates memory for type *C.VkAccelerationStructureGeometryKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPAccelerationStructureGeometryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPAccelerationStructureGeometryValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPAccelerationStructureGeometryValue = unsafe.Sizeof([1]*C.VkAccelerationStructureGeometryKHR{})

// unpackSSAccelerationStructureGeometry transforms a sliced Go data structure into plain C format.
func unpackSSAccelerationStructureGeometry(x [][]AccelerationStructureGeometry) (unpacked **C.VkAccelerationStructureGeometryKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPAccelerationStructureGeometryMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.VkAccelerationStructureGeometryKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocAccelerationStructureGeometryMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.VkAccelerationStructureGeometryKHR)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.VkAccelerationStructureGeometryKHR)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.VkAccelerationStructureGeometryKHR)(h.Data)
	return
}

// packSAccelerationStructureGeometry reads sliced Go data structure out from plain C format.
func packSAccelerationStructureGeometry(v []AccelerationStructureGeometry, ptr0 *C.VkAccelerationStructureGeometryKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAccelerationStructureGeometryValue]C.VkAccelerationStructureGeometryKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAccelerationStructureGeometryRef(unsafe.Pointer(&ptr1))
	}
}

// packSSAccelerationStructureGeometry reads sliced Go data structure out from plain C format.
func packSSAccelerationStructureGeometry(v [][]AccelerationStructureGeometry, ptr0 **C.VkAccelerationStructureGeometryKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.VkAccelerationStructureGeometryKHR)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfAccelerationStructureGeometryValue]C.VkAccelerationStructureGeometryKHR)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewAccelerationStructureGeometryRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureBuildGeometryInfo) Ref() *C.VkAccelerationStructureBuildGeometryInfoKHR {
	if x == nil {
		return nil
	}
	return x.refbe835ce7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureBuildGeometryInfo) Free() {
	if x != nil && x.allocsbe835ce7 != nil {
		x.allocsbe835ce7.(*cgoAllocMap).Free()
		x.refbe835ce7 = nil
	}
}

// NewAccelerationStructureBuildGeometryInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureBuildGeometryInfoRef(ref unsafe.Pointer) *AccelerationStructureBuildGeometryInfo {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureBuildGeometryInfo)
	obj.refbe835ce7 = (*C.VkAccelerationStructureBuildGeometryInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureBuildGeometryInfo) PassRef() (*C.VkAccelerationStructureBuildGeometryInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbe835ce7 != nil {
		return x.refbe835ce7, nil
	}
	membe835ce7 := allocAccelerationStructureBuildGeometryInfoMemory(1)
	refbe835ce7 := (*C.VkAccelerationStructureBuildGeometryInfoKHR)(membe835ce7)
	allocsbe835ce7 := new(cgoAllocMap)
	allocsbe835ce7.Add(membe835ce7)

	var csType_allocs *cgoAllocMap
	refbe835ce7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbe835ce7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbe835ce7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbe835ce7.Borrow(cpNext_allocs)

	var c_type_allocs *cgoAllocMap
	refbe835ce7._type, c_type_allocs = (C.VkAccelerationStructureTypeKHR)(x.Type), cgoAllocsUnknown
	allocsbe835ce7.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	refbe835ce7.flags, cflags_allocs = (C.VkBuildAccelerationStructureFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocsbe835ce7.Borrow(cflags_allocs)

	var cmode_allocs *cgoAllocMap
	refbe835ce7.mode, cmode_allocs = (C.VkBuildAccelerationStructureModeKHR)(x.Mode), cgoAllocsUnknown
	allocsbe835ce7.Borrow(cmode_allocs)

	var csrcAccelerationStructure_allocs *cgoAllocMap
	refbe835ce7.srcAccelerationStructure, csrcAccelerationStructure_allocs = *(*C.VkAccelerationStructureKHR)(unsafe.Pointer(&x.SrcAccelerationStructure)), cgoAllocsUnknown
	allocsbe835ce7.Borrow(csrcAccelerationStructure_allocs)

	var cdstAccelerationStructure_allocs *cgoAllocMap
	refbe835ce7.dstAccelerationStructure, cdstAccelerationStructure_allocs = *(*C.VkAccelerationStructureKHR)(unsafe.Pointer(&x.DstAccelerationStructure)), cgoAllocsUnknown
	allocsbe835ce7.Borrow(cdstAccelerationStructure_allocs)

	var cgeometryCount_allocs *cgoAllocMap
	refbe835ce7.geometryCount, cgeometryCount_allocs = (C.uint32_t)(x.GeometryCount), cgoAllocsUnknown
	allocsbe835ce7.Borrow(cgeometryCount_allocs)

	var cpGeometries_allocs *cgoAllocMap
	refbe835ce7.pGeometries, cpGeometries_allocs = unpackSAccelerationStructureGeometry(x.PGeometries)
	allocsbe835ce7.Borrow(cpGeometries_allocs)

	var cppGeometries_allocs *cgoAllocMap
	refbe835ce7.ppGeometries, cppGeometries_allocs = unpackSSAccelerationStructureGeometry(x.PpGeometries)
	allocsbe835ce7.Borrow(cppGeometries_allocs)

	var cscratchData_allocs *cgoAllocMap
	refbe835ce7.scratchData, cscratchData_allocs = *(*C.VkDeviceOrHostAddressKHR)(unsafe.Pointer(&x.ScratchData)), cgoAllocsUnknown
	allocsbe835ce7.Borrow(cscratchData_allocs)

	x.refbe835ce7 = refbe835ce7
	x.allocsbe835ce7 = allocsbe835ce7
	return refbe835ce7, allocsbe835ce7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureBuildGeometryInfo) PassValue() (C.VkAccelerationStructureBuildGeometryInfoKHR, *cgoAllocMap) {
	if x.refbe835ce7 != nil {
		return *x.refbe835ce7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureBuildGeometryInfo) Deref() {
	if x.refbe835ce7 == nil {
		return
	}
	x.SType = (StructureType)(x.refbe835ce7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbe835ce7.pNext))
	x.Type = (AccelerationStructureType)(x.refbe835ce7._type)
	x.Flags = (BuildAccelerationStructureFlags)(x.refbe835ce7.flags)
	x.Mode = (BuildAccelerationStructureMode)(x.refbe835ce7.mode)
	x.SrcAccelerationStructure = *(*AccelerationStructure)(unsafe.Pointer(&x.refbe835ce7.srcAccelerationStructure))
	x.DstAccelerationStructure = *(*AccelerationStructure)(unsafe.Pointer(&x.refbe835ce7.dstAccelerationStructure))
	x.GeometryCount = (uint32)(x.refbe835ce7.geometryCount)
	packSAccelerationStructureGeometry(x.PGeometries, x.refbe835ce7.pGeometries)
	packSSAccelerationStructureGeometry(x.PpGeometries, x.refbe835ce7.ppGeometries)
	x.ScratchData = *(*DeviceOrHostAddress)(unsafe.Pointer(&x.refbe835ce7.scratchData))
}

// allocAccelerationStructureCreateInfoMemory allocates memory for type C.VkAccelerationStructureCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAccelerationStructureCreateInfoValue = unsafe.Sizeof([1]C.VkAccelerationStructureCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureCreateInfo) Ref() *C.VkAccelerationStructureCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref20d6e97c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureCreateInfo) Free() {
	if x != nil && x.allocs20d6e97c != nil {
		x.allocs20d6e97c.(*cgoAllocMap).Free()
		x.ref20d6e97c = nil
	}
}

// NewAccelerationStructureCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureCreateInfoRef(ref unsafe.Pointer) *AccelerationStructureCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureCreateInfo)
	obj.ref20d6e97c = (*C.VkAccelerationStructureCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureCreateInfo) PassRef() (*C.VkAccelerationStructureCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref20d6e97c != nil {
		return x.ref20d6e97c, nil
	}
	mem20d6e97c := allocAccelerationStructureCreateInfoMemory(1)
	ref20d6e97c := (*C.VkAccelerationStructureCreateInfoKHR)(mem20d6e97c)
	allocs20d6e97c := new(cgoAllocMap)
	allocs20d6e97c.Add(mem20d6e97c)

	var csType_allocs *cgoAllocMap
	ref20d6e97c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs20d6e97c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref20d6e97c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs20d6e97c.Borrow(cpNext_allocs)

	var ccreateFlags_allocs *cgoAllocMap
	ref20d6e97c.createFlags, ccreateFlags_allocs = (C.VkAccelerationStructureCreateFlagsKHR)(x.CreateFlags), cgoAllocsUnknown
	allocs20d6e97c.Borrow(ccreateFlags_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref20d6e97c.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs20d6e97c.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	ref20d6e97c.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs20d6e97c.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref20d6e97c.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs20d6e97c.Borrow(csize_allocs)

	var c_type_allocs *cgoAllocMap
	ref20d6e97c._type, c_type_allocs = (C.VkAccelerationStructureTypeKHR)(x.Type), cgoAllocsUnknown
	allocs20d6e97c.Borrow(c_type_allocs)

	var cdeviceAddress_allocs *cgoAllocMap
	ref20d6e97c.deviceAddress, cdeviceAddress_allocs = (C.VkDeviceAddress)(x.DeviceAddress), cgoAllocsUnknown
	allocs20d6e97c.Borrow(cdeviceAddress_allocs)

	x.ref20d6e97c = ref20d6e97c
	x.allocs20d6e97c = allocs20d6e97c
	return ref20d6e97c, allocs20d6e97c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureCreateInfo) PassValue() (C.VkAccelerationStructureCreateInfoKHR, *cgoAllocMap) {
	if x.ref20d6e97c != nil {
		return *x.ref20d6e97c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureCreateInfo) Deref() {
	if x.ref20d6e97c == nil {
		return
	}
	x.SType = (StructureType)(x.ref20d6e97c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref20d6e97c.pNext))
	x.CreateFlags = (AccelerationStructureCreateFlags)(x.ref20d6e97c.createFlags)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref20d6e97c.buffer))
	x.Offset = (DeviceSize)(x.ref20d6e97c.offset)
	x.Size = (DeviceSize)(x.ref20d6e97c.size)
	x.Type = (AccelerationStructureType)(x.ref20d6e97c._type)
	x.DeviceAddress = (DeviceAddress)(x.ref20d6e97c.deviceAddress)
}

// allocWriteDescriptorSetAccelerationStructureMemory allocates memory for type C.VkWriteDescriptorSetAccelerationStructureKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWriteDescriptorSetAccelerationStructureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWriteDescriptorSetAccelerationStructureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfWriteDescriptorSetAccelerationStructureValue = unsafe.Sizeof([1]C.VkWriteDescriptorSetAccelerationStructureKHR{})

// copyPAccelerationStructureBytes copies the data from Go slice as *C.VkAccelerationStructureKHR.
func copyPAccelerationStructureBytes(slice *sliceHeader) (*C.VkAccelerationStructureKHR, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfAccelerationStructureValue) * slice.Len,
		Cap:  int(sizeOfAccelerationStructureValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkAccelerationStructureKHR)(mem0), allocs
}

// allocAccelerationStructureMemory allocates memory for type C.VkAccelerationStructureKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAccelerationStructureValue = unsafe.Sizeof([1]C.VkAccelerationStructureKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *WriteDescriptorSetAccelerationStructure) Ref() *C.VkWriteDescriptorSetAccelerationStructureKHR {
	if x == nil {
		return nil
	}
	return x.ref6ac14190
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *WriteDescriptorSetAccelerationStructure) Free() {
	if x != nil && x.allocs6ac14190 != nil {
		x.allocs6ac14190.(*cgoAllocMap).Free()
		x.ref6ac14190 = nil
	}
}

// NewWriteDescriptorSetAccelerationStructureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWriteDescriptorSetAccelerationStructureRef(ref unsafe.Pointer) *WriteDescriptorSetAccelerationStructure {
	if ref == nil {
		return nil
	}
	obj := new(WriteDescriptorSetAccelerationStructure)
	obj.ref6ac14190 = (*C.VkWriteDescriptorSetAccelerationStructureKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *WriteDescriptorSetAccelerationStructure) PassRef() (*C.VkWriteDescriptorSetAccelerationStructureKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6ac14190 != nil {
		return x.ref6ac14190, nil
	}
	mem6ac14190 := allocWriteDescriptorSetAccelerationStructureMemory(1)
	ref6ac14190 := (*C.VkWriteDescriptorSetAccelerationStructureKHR)(mem6ac14190)
	allocs6ac14190 := new(cgoAllocMap)
	allocs6ac14190.Add(mem6ac14190)

	var csType_allocs *cgoAllocMap
	ref6ac14190.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6ac14190.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6ac14190.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6ac14190.Borrow(cpNext_allocs)

	var caccelerationStructureCount_allocs *cgoAllocMap
	ref6ac14190.accelerationStructureCount, caccelerationStructureCount_allocs = (C.uint32_t)(x.AccelerationStructureCount), cgoAllocsUnknown
	allocs6ac14190.Borrow(caccelerationStructureCount_allocs)

	var cpAccelerationStructures_allocs *cgoAllocMap
	ref6ac14190.pAccelerationStructures, cpAccelerationStructures_allocs = copyPAccelerationStructureBytes((*sliceHeader)(unsafe.Pointer(&x.PAccelerationStructures)))
	allocs6ac14190.Borrow(cpAccelerationStructures_allocs)

	x.ref6ac14190 = ref6ac14190
	x.allocs6ac14190 = allocs6ac14190
	return ref6ac14190, allocs6ac14190

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x WriteDescriptorSetAccelerationStructure) PassValue() (C.VkWriteDescriptorSetAccelerationStructureKHR, *cgoAllocMap) {
	if x.ref6ac14190 != nil {
		return *x.ref6ac14190, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *WriteDescriptorSetAccelerationStructure) Deref() {
	if x.ref6ac14190 == nil {
		return
	}
	x.SType = (StructureType)(x.ref6ac14190.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6ac14190.pNext))
	x.AccelerationStructureCount = (uint32)(x.ref6ac14190.accelerationStructureCount)
	hxfa897de := (*sliceHeader)(unsafe.Pointer(&x.PAccelerationStructures))
	hxfa897de.Data = unsafe.Pointer(x.ref6ac14190.pAccelerationStructures)
	hxfa897de.Cap = 0x7fffffff
	// hxfa897de.Len = ?

}

// allocPhysicalDeviceAccelerationStructureFeaturesMemory allocates memory for type C.VkPhysicalDeviceAccelerationStructureFeaturesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceAccelerationStructureFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceAccelerationStructureFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceAccelerationStructureFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceAccelerationStructureFeaturesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceAccelerationStructureFeatures) Ref() *C.VkPhysicalDeviceAccelerationStructureFeaturesKHR {
	if x == nil {
		return nil
	}
	return x.ref4fc28e52
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceAccelerationStructureFeatures) Free() {
	if x != nil && x.allocs4fc28e52 != nil {
		x.allocs4fc28e52.(*cgoAllocMap).Free()
		x.ref4fc28e52 = nil
	}
}

// NewPhysicalDeviceAccelerationStructureFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceAccelerationStructureFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceAccelerationStructureFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceAccelerationStructureFeatures)
	obj.ref4fc28e52 = (*C.VkPhysicalDeviceAccelerationStructureFeaturesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceAccelerationStructureFeatures) PassRef() (*C.VkPhysicalDeviceAccelerationStructureFeaturesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4fc28e52 != nil {
		return x.ref4fc28e52, nil
	}
	mem4fc28e52 := allocPhysicalDeviceAccelerationStructureFeaturesMemory(1)
	ref4fc28e52 := (*C.VkPhysicalDeviceAccelerationStructureFeaturesKHR)(mem4fc28e52)
	allocs4fc28e52 := new(cgoAllocMap)
	allocs4fc28e52.Add(mem4fc28e52)

	var csType_allocs *cgoAllocMap
	ref4fc28e52.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4fc28e52.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4fc28e52.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4fc28e52.Borrow(cpNext_allocs)

	var caccelerationStructure_allocs *cgoAllocMap
	ref4fc28e52.accelerationStructure, caccelerationStructure_allocs = (C.VkBool32)(x.AccelerationStructure), cgoAllocsUnknown
	allocs4fc28e52.Borrow(caccelerationStructure_allocs)

	var caccelerationStructureCaptureReplay_allocs *cgoAllocMap
	ref4fc28e52.accelerationStructureCaptureReplay, caccelerationStructureCaptureReplay_allocs = (C.VkBool32)(x.AccelerationStructureCaptureReplay), cgoAllocsUnknown
	allocs4fc28e52.Borrow(caccelerationStructureCaptureReplay_allocs)

	var caccelerationStructureIndirectBuild_allocs *cgoAllocMap
	ref4fc28e52.accelerationStructureIndirectBuild, caccelerationStructureIndirectBuild_allocs = (C.VkBool32)(x.AccelerationStructureIndirectBuild), cgoAllocsUnknown
	allocs4fc28e52.Borrow(caccelerationStructureIndirectBuild_allocs)

	var caccelerationStructureHostCommands_allocs *cgoAllocMap
	ref4fc28e52.accelerationStructureHostCommands, caccelerationStructureHostCommands_allocs = (C.VkBool32)(x.AccelerationStructureHostCommands), cgoAllocsUnknown
	allocs4fc28e52.Borrow(caccelerationStructureHostCommands_allocs)

	var cdescriptorBindingAccelerationStructureUpdateAfterBind_allocs *cgoAllocMap
	ref4fc28e52.descriptorBindingAccelerationStructureUpdateAfterBind, cdescriptorBindingAccelerationStructureUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingAccelerationStructureUpdateAfterBind), cgoAllocsUnknown
	allocs4fc28e52.Borrow(cdescriptorBindingAccelerationStructureUpdateAfterBind_allocs)

	x.ref4fc28e52 = ref4fc28e52
	x.allocs4fc28e52 = allocs4fc28e52
	return ref4fc28e52, allocs4fc28e52

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceAccelerationStructureFeatures) PassValue() (C.VkPhysicalDeviceAccelerationStructureFeaturesKHR, *cgoAllocMap) {
	if x.ref4fc28e52 != nil {
		return *x.ref4fc28e52, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceAccelerationStructureFeatures) Deref() {
	if x.ref4fc28e52 == nil {
		return
	}
	x.SType = (StructureType)(x.ref4fc28e52.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4fc28e52.pNext))
	x.AccelerationStructure = (Bool32)(x.ref4fc28e52.accelerationStructure)
	x.AccelerationStructureCaptureReplay = (Bool32)(x.ref4fc28e52.accelerationStructureCaptureReplay)
	x.AccelerationStructureIndirectBuild = (Bool32)(x.ref4fc28e52.accelerationStructureIndirectBuild)
	x.AccelerationStructureHostCommands = (Bool32)(x.ref4fc28e52.accelerationStructureHostCommands)
	x.DescriptorBindingAccelerationStructureUpdateAfterBind = (Bool32)(x.ref4fc28e52.descriptorBindingAccelerationStructureUpdateAfterBind)
}

// allocPhysicalDeviceAccelerationStructurePropertiesMemory allocates memory for type C.VkPhysicalDeviceAccelerationStructurePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceAccelerationStructurePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceAccelerationStructurePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceAccelerationStructurePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceAccelerationStructurePropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceAccelerationStructureProperties) Ref() *C.VkPhysicalDeviceAccelerationStructurePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.refcc664ddd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceAccelerationStructureProperties) Free() {
	if x != nil && x.allocscc664ddd != nil {
		x.allocscc664ddd.(*cgoAllocMap).Free()
		x.refcc664ddd = nil
	}
}

// NewPhysicalDeviceAccelerationStructurePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceAccelerationStructurePropertiesRef(ref unsafe.Pointer) *PhysicalDeviceAccelerationStructureProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceAccelerationStructureProperties)
	obj.refcc664ddd = (*C.VkPhysicalDeviceAccelerationStructurePropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceAccelerationStructureProperties) PassRef() (*C.VkPhysicalDeviceAccelerationStructurePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcc664ddd != nil {
		return x.refcc664ddd, nil
	}
	memcc664ddd := allocPhysicalDeviceAccelerationStructurePropertiesMemory(1)
	refcc664ddd := (*C.VkPhysicalDeviceAccelerationStructurePropertiesKHR)(memcc664ddd)
	allocscc664ddd := new(cgoAllocMap)
	allocscc664ddd.Add(memcc664ddd)

	var csType_allocs *cgoAllocMap
	refcc664ddd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscc664ddd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcc664ddd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscc664ddd.Borrow(cpNext_allocs)

	var cmaxGeometryCount_allocs *cgoAllocMap
	refcc664ddd.maxGeometryCount, cmaxGeometryCount_allocs = (C.uint64_t)(x.MaxGeometryCount), cgoAllocsUnknown
	allocscc664ddd.Borrow(cmaxGeometryCount_allocs)

	var cmaxInstanceCount_allocs *cgoAllocMap
	refcc664ddd.maxInstanceCount, cmaxInstanceCount_allocs = (C.uint64_t)(x.MaxInstanceCount), cgoAllocsUnknown
	allocscc664ddd.Borrow(cmaxInstanceCount_allocs)

	var cmaxPrimitiveCount_allocs *cgoAllocMap
	refcc664ddd.maxPrimitiveCount, cmaxPrimitiveCount_allocs = (C.uint64_t)(x.MaxPrimitiveCount), cgoAllocsUnknown
	allocscc664ddd.Borrow(cmaxPrimitiveCount_allocs)

	var cmaxPerStageDescriptorAccelerationStructures_allocs *cgoAllocMap
	refcc664ddd.maxPerStageDescriptorAccelerationStructures, cmaxPerStageDescriptorAccelerationStructures_allocs = (C.uint32_t)(x.MaxPerStageDescriptorAccelerationStructures), cgoAllocsUnknown
	allocscc664ddd.Borrow(cmaxPerStageDescriptorAccelerationStructures_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindAccelerationStructures_allocs *cgoAllocMap
	refcc664ddd.maxPerStageDescriptorUpdateAfterBindAccelerationStructures, cmaxPerStageDescriptorUpdateAfterBindAccelerationStructures_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindAccelerationStructures), cgoAllocsUnknown
	allocscc664ddd.Borrow(cmaxPerStageDescriptorUpdateAfterBindAccelerationStructures_allocs)

	var cmaxDescriptorSetAccelerationStructures_allocs *cgoAllocMap
	refcc664ddd.maxDescriptorSetAccelerationStructures, cmaxDescriptorSetAccelerationStructures_allocs = (C.uint32_t)(x.MaxDescriptorSetAccelerationStructures), cgoAllocsUnknown
	allocscc664ddd.Borrow(cmaxDescriptorSetAccelerationStructures_allocs)

	var cmaxDescriptorSetUpdateAfterBindAccelerationStructures_allocs *cgoAllocMap
	refcc664ddd.maxDescriptorSetUpdateAfterBindAccelerationStructures, cmaxDescriptorSetUpdateAfterBindAccelerationStructures_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindAccelerationStructures), cgoAllocsUnknown
	allocscc664ddd.Borrow(cmaxDescriptorSetUpdateAfterBindAccelerationStructures_allocs)

	var cminAccelerationStructureScratchOffsetAlignment_allocs *cgoAllocMap
	refcc664ddd.minAccelerationStructureScratchOffsetAlignment, cminAccelerationStructureScratchOffsetAlignment_allocs = (C.uint32_t)(x.MinAccelerationStructureScratchOffsetAlignment), cgoAllocsUnknown
	allocscc664ddd.Borrow(cminAccelerationStructureScratchOffsetAlignment_allocs)

	x.refcc664ddd = refcc664ddd
	x.allocscc664ddd = allocscc664ddd
	return refcc664ddd, allocscc664ddd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceAccelerationStructureProperties) PassValue() (C.VkPhysicalDeviceAccelerationStructurePropertiesKHR, *cgoAllocMap) {
	if x.refcc664ddd != nil {
		return *x.refcc664ddd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceAccelerationStructureProperties) Deref() {
	if x.refcc664ddd == nil {
		return
	}
	x.SType = (StructureType)(x.refcc664ddd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcc664ddd.pNext))
	x.MaxGeometryCount = (uint32)(x.refcc664ddd.maxGeometryCount)
	x.MaxInstanceCount = (uint32)(x.refcc664ddd.maxInstanceCount)
	x.MaxPrimitiveCount = (uint32)(x.refcc664ddd.maxPrimitiveCount)
	x.MaxPerStageDescriptorAccelerationStructures = (uint32)(x.refcc664ddd.maxPerStageDescriptorAccelerationStructures)
	x.MaxPerStageDescriptorUpdateAfterBindAccelerationStructures = (uint32)(x.refcc664ddd.maxPerStageDescriptorUpdateAfterBindAccelerationStructures)
	x.MaxDescriptorSetAccelerationStructures = (uint32)(x.refcc664ddd.maxDescriptorSetAccelerationStructures)
	x.MaxDescriptorSetUpdateAfterBindAccelerationStructures = (uint32)(x.refcc664ddd.maxDescriptorSetUpdateAfterBindAccelerationStructures)
	x.MinAccelerationStructureScratchOffsetAlignment = (uint32)(x.refcc664ddd.minAccelerationStructureScratchOffsetAlignment)
}

// allocAccelerationStructureDeviceAddressInfoMemory allocates memory for type C.VkAccelerationStructureDeviceAddressInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureDeviceAddressInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureDeviceAddressInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAccelerationStructureDeviceAddressInfoValue = unsafe.Sizeof([1]C.VkAccelerationStructureDeviceAddressInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureDeviceAddressInfo) Ref() *C.VkAccelerationStructureDeviceAddressInfoKHR {
	if x == nil {
		return nil
	}
	return x.refbf98d85a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureDeviceAddressInfo) Free() {
	if x != nil && x.allocsbf98d85a != nil {
		x.allocsbf98d85a.(*cgoAllocMap).Free()
		x.refbf98d85a = nil
	}
}

// NewAccelerationStructureDeviceAddressInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureDeviceAddressInfoRef(ref unsafe.Pointer) *AccelerationStructureDeviceAddressInfo {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureDeviceAddressInfo)
	obj.refbf98d85a = (*C.VkAccelerationStructureDeviceAddressInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureDeviceAddressInfo) PassRef() (*C.VkAccelerationStructureDeviceAddressInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbf98d85a != nil {
		return x.refbf98d85a, nil
	}
	membf98d85a := allocAccelerationStructureDeviceAddressInfoMemory(1)
	refbf98d85a := (*C.VkAccelerationStructureDeviceAddressInfoKHR)(membf98d85a)
	allocsbf98d85a := new(cgoAllocMap)
	allocsbf98d85a.Add(membf98d85a)

	var csType_allocs *cgoAllocMap
	refbf98d85a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbf98d85a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbf98d85a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbf98d85a.Borrow(cpNext_allocs)

	var caccelerationStructure_allocs *cgoAllocMap
	refbf98d85a.accelerationStructure, caccelerationStructure_allocs = *(*C.VkAccelerationStructureKHR)(unsafe.Pointer(&x.AccelerationStructure)), cgoAllocsUnknown
	allocsbf98d85a.Borrow(caccelerationStructure_allocs)

	x.refbf98d85a = refbf98d85a
	x.allocsbf98d85a = allocsbf98d85a
	return refbf98d85a, allocsbf98d85a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureDeviceAddressInfo) PassValue() (C.VkAccelerationStructureDeviceAddressInfoKHR, *cgoAllocMap) {
	if x.refbf98d85a != nil {
		return *x.refbf98d85a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureDeviceAddressInfo) Deref() {
	if x.refbf98d85a == nil {
		return
	}
	x.SType = (StructureType)(x.refbf98d85a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbf98d85a.pNext))
	x.AccelerationStructure = *(*AccelerationStructure)(unsafe.Pointer(&x.refbf98d85a.accelerationStructure))
}

// allocAccelerationStructureVersionInfoMemory allocates memory for type C.VkAccelerationStructureVersionInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureVersionInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureVersionInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAccelerationStructureVersionInfoValue = unsafe.Sizeof([1]C.VkAccelerationStructureVersionInfoKHR{})

// copyPUint8_tBytes copies the data from Go slice as *C.uint8_t.
func copyPUint8_tBytes(slice *sliceHeader) (*C.uint8_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint8_tValue) * slice.Len,
		Cap:  int(sizeOfUint8_tValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint8_t)(mem0), allocs
}

// allocUint8_tMemory allocates memory for type C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint8_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint8_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint8_tValue = unsafe.Sizeof([1]C.uint8_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureVersionInfo) Ref() *C.VkAccelerationStructureVersionInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref6924cf3d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureVersionInfo) Free() {
	if x != nil && x.allocs6924cf3d != nil {
		x.allocs6924cf3d.(*cgoAllocMap).Free()
		x.ref6924cf3d = nil
	}
}

// NewAccelerationStructureVersionInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureVersionInfoRef(ref unsafe.Pointer) *AccelerationStructureVersionInfo {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureVersionInfo)
	obj.ref6924cf3d = (*C.VkAccelerationStructureVersionInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureVersionInfo) PassRef() (*C.VkAccelerationStructureVersionInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6924cf3d != nil {
		return x.ref6924cf3d, nil
	}
	mem6924cf3d := allocAccelerationStructureVersionInfoMemory(1)
	ref6924cf3d := (*C.VkAccelerationStructureVersionInfoKHR)(mem6924cf3d)
	allocs6924cf3d := new(cgoAllocMap)
	allocs6924cf3d.Add(mem6924cf3d)

	var csType_allocs *cgoAllocMap
	ref6924cf3d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6924cf3d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6924cf3d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6924cf3d.Borrow(cpNext_allocs)

	var cpVersionData_allocs *cgoAllocMap
	ref6924cf3d.pVersionData, cpVersionData_allocs = copyPUint8_tBytes((*sliceHeader)(unsafe.Pointer(&x.PVersionData)))
	allocs6924cf3d.Borrow(cpVersionData_allocs)

	x.ref6924cf3d = ref6924cf3d
	x.allocs6924cf3d = allocs6924cf3d
	return ref6924cf3d, allocs6924cf3d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureVersionInfo) PassValue() (C.VkAccelerationStructureVersionInfoKHR, *cgoAllocMap) {
	if x.ref6924cf3d != nil {
		return *x.ref6924cf3d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureVersionInfo) Deref() {
	if x.ref6924cf3d == nil {
		return
	}
	x.SType = (StructureType)(x.ref6924cf3d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6924cf3d.pNext))
	hxfe33f90 := (*sliceHeader)(unsafe.Pointer(&x.PVersionData))
	hxfe33f90.Data = unsafe.Pointer(x.ref6924cf3d.pVersionData)
	hxfe33f90.Cap = 0x7fffffff
	// hxfe33f90.Len = ?

}

// allocCopyAccelerationStructureToMemoryInfoMemory allocates memory for type C.VkCopyAccelerationStructureToMemoryInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyAccelerationStructureToMemoryInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyAccelerationStructureToMemoryInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCopyAccelerationStructureToMemoryInfoValue = unsafe.Sizeof([1]C.VkCopyAccelerationStructureToMemoryInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CopyAccelerationStructureToMemoryInfo) Ref() *C.VkCopyAccelerationStructureToMemoryInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref7918d4bb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CopyAccelerationStructureToMemoryInfo) Free() {
	if x != nil && x.allocs7918d4bb != nil {
		x.allocs7918d4bb.(*cgoAllocMap).Free()
		x.ref7918d4bb = nil
	}
}

// NewCopyAccelerationStructureToMemoryInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCopyAccelerationStructureToMemoryInfoRef(ref unsafe.Pointer) *CopyAccelerationStructureToMemoryInfo {
	if ref == nil {
		return nil
	}
	obj := new(CopyAccelerationStructureToMemoryInfo)
	obj.ref7918d4bb = (*C.VkCopyAccelerationStructureToMemoryInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CopyAccelerationStructureToMemoryInfo) PassRef() (*C.VkCopyAccelerationStructureToMemoryInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7918d4bb != nil {
		return x.ref7918d4bb, nil
	}
	mem7918d4bb := allocCopyAccelerationStructureToMemoryInfoMemory(1)
	ref7918d4bb := (*C.VkCopyAccelerationStructureToMemoryInfoKHR)(mem7918d4bb)
	allocs7918d4bb := new(cgoAllocMap)
	allocs7918d4bb.Add(mem7918d4bb)

	var csType_allocs *cgoAllocMap
	ref7918d4bb.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7918d4bb.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7918d4bb.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7918d4bb.Borrow(cpNext_allocs)

	var csrc_allocs *cgoAllocMap
	ref7918d4bb.src, csrc_allocs = *(*C.VkAccelerationStructureKHR)(unsafe.Pointer(&x.Src)), cgoAllocsUnknown
	allocs7918d4bb.Borrow(csrc_allocs)

	var cdst_allocs *cgoAllocMap
	ref7918d4bb.dst, cdst_allocs = *(*C.VkDeviceOrHostAddressKHR)(unsafe.Pointer(&x.Dst)), cgoAllocsUnknown
	allocs7918d4bb.Borrow(cdst_allocs)

	var cmode_allocs *cgoAllocMap
	ref7918d4bb.mode, cmode_allocs = (C.VkCopyAccelerationStructureModeKHR)(x.Mode), cgoAllocsUnknown
	allocs7918d4bb.Borrow(cmode_allocs)

	x.ref7918d4bb = ref7918d4bb
	x.allocs7918d4bb = allocs7918d4bb
	return ref7918d4bb, allocs7918d4bb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CopyAccelerationStructureToMemoryInfo) PassValue() (C.VkCopyAccelerationStructureToMemoryInfoKHR, *cgoAllocMap) {
	if x.ref7918d4bb != nil {
		return *x.ref7918d4bb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CopyAccelerationStructureToMemoryInfo) Deref() {
	if x.ref7918d4bb == nil {
		return
	}
	x.SType = (StructureType)(x.ref7918d4bb.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7918d4bb.pNext))
	x.Src = *(*AccelerationStructure)(unsafe.Pointer(&x.ref7918d4bb.src))
	x.Dst = *(*DeviceOrHostAddress)(unsafe.Pointer(&x.ref7918d4bb.dst))
	x.Mode = (CopyAccelerationStructureMode)(x.ref7918d4bb.mode)
}

// allocCopyMemoryToAccelerationStructureInfoMemory allocates memory for type C.VkCopyMemoryToAccelerationStructureInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyMemoryToAccelerationStructureInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyMemoryToAccelerationStructureInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCopyMemoryToAccelerationStructureInfoValue = unsafe.Sizeof([1]C.VkCopyMemoryToAccelerationStructureInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CopyMemoryToAccelerationStructureInfo) Ref() *C.VkCopyMemoryToAccelerationStructureInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref74b9bdb3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CopyMemoryToAccelerationStructureInfo) Free() {
	if x != nil && x.allocs74b9bdb3 != nil {
		x.allocs74b9bdb3.(*cgoAllocMap).Free()
		x.ref74b9bdb3 = nil
	}
}

// NewCopyMemoryToAccelerationStructureInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCopyMemoryToAccelerationStructureInfoRef(ref unsafe.Pointer) *CopyMemoryToAccelerationStructureInfo {
	if ref == nil {
		return nil
	}
	obj := new(CopyMemoryToAccelerationStructureInfo)
	obj.ref74b9bdb3 = (*C.VkCopyMemoryToAccelerationStructureInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CopyMemoryToAccelerationStructureInfo) PassRef() (*C.VkCopyMemoryToAccelerationStructureInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref74b9bdb3 != nil {
		return x.ref74b9bdb3, nil
	}
	mem74b9bdb3 := allocCopyMemoryToAccelerationStructureInfoMemory(1)
	ref74b9bdb3 := (*C.VkCopyMemoryToAccelerationStructureInfoKHR)(mem74b9bdb3)
	allocs74b9bdb3 := new(cgoAllocMap)
	allocs74b9bdb3.Add(mem74b9bdb3)

	var csType_allocs *cgoAllocMap
	ref74b9bdb3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs74b9bdb3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref74b9bdb3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs74b9bdb3.Borrow(cpNext_allocs)

	var csrc_allocs *cgoAllocMap
	ref74b9bdb3.src, csrc_allocs = *(*C.VkDeviceOrHostAddressConstKHR)(unsafe.Pointer(&x.Src)), cgoAllocsUnknown
	allocs74b9bdb3.Borrow(csrc_allocs)

	var cdst_allocs *cgoAllocMap
	ref74b9bdb3.dst, cdst_allocs = *(*C.VkAccelerationStructureKHR)(unsafe.Pointer(&x.Dst)), cgoAllocsUnknown
	allocs74b9bdb3.Borrow(cdst_allocs)

	var cmode_allocs *cgoAllocMap
	ref74b9bdb3.mode, cmode_allocs = (C.VkCopyAccelerationStructureModeKHR)(x.Mode), cgoAllocsUnknown
	allocs74b9bdb3.Borrow(cmode_allocs)

	x.ref74b9bdb3 = ref74b9bdb3
	x.allocs74b9bdb3 = allocs74b9bdb3
	return ref74b9bdb3, allocs74b9bdb3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CopyMemoryToAccelerationStructureInfo) PassValue() (C.VkCopyMemoryToAccelerationStructureInfoKHR, *cgoAllocMap) {
	if x.ref74b9bdb3 != nil {
		return *x.ref74b9bdb3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CopyMemoryToAccelerationStructureInfo) Deref() {
	if x.ref74b9bdb3 == nil {
		return
	}
	x.SType = (StructureType)(x.ref74b9bdb3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref74b9bdb3.pNext))
	x.Src = *(*DeviceOrHostAddressConst)(unsafe.Pointer(&x.ref74b9bdb3.src))
	x.Dst = *(*AccelerationStructure)(unsafe.Pointer(&x.ref74b9bdb3.dst))
	x.Mode = (CopyAccelerationStructureMode)(x.ref74b9bdb3.mode)
}

// allocCopyAccelerationStructureInfoMemory allocates memory for type C.VkCopyAccelerationStructureInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyAccelerationStructureInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyAccelerationStructureInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCopyAccelerationStructureInfoValue = unsafe.Sizeof([1]C.VkCopyAccelerationStructureInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CopyAccelerationStructureInfo) Ref() *C.VkCopyAccelerationStructureInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref342c57e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CopyAccelerationStructureInfo) Free() {
	if x != nil && x.allocs342c57e != nil {
		x.allocs342c57e.(*cgoAllocMap).Free()
		x.ref342c57e = nil
	}
}

// NewCopyAccelerationStructureInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCopyAccelerationStructureInfoRef(ref unsafe.Pointer) *CopyAccelerationStructureInfo {
	if ref == nil {
		return nil
	}
	obj := new(CopyAccelerationStructureInfo)
	obj.ref342c57e = (*C.VkCopyAccelerationStructureInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CopyAccelerationStructureInfo) PassRef() (*C.VkCopyAccelerationStructureInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref342c57e != nil {
		return x.ref342c57e, nil
	}
	mem342c57e := allocCopyAccelerationStructureInfoMemory(1)
	ref342c57e := (*C.VkCopyAccelerationStructureInfoKHR)(mem342c57e)
	allocs342c57e := new(cgoAllocMap)
	allocs342c57e.Add(mem342c57e)

	var csType_allocs *cgoAllocMap
	ref342c57e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs342c57e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref342c57e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs342c57e.Borrow(cpNext_allocs)

	var csrc_allocs *cgoAllocMap
	ref342c57e.src, csrc_allocs = *(*C.VkAccelerationStructureKHR)(unsafe.Pointer(&x.Src)), cgoAllocsUnknown
	allocs342c57e.Borrow(csrc_allocs)

	var cdst_allocs *cgoAllocMap
	ref342c57e.dst, cdst_allocs = *(*C.VkAccelerationStructureKHR)(unsafe.Pointer(&x.Dst)), cgoAllocsUnknown
	allocs342c57e.Borrow(cdst_allocs)

	var cmode_allocs *cgoAllocMap
	ref342c57e.mode, cmode_allocs = (C.VkCopyAccelerationStructureModeKHR)(x.Mode), cgoAllocsUnknown
	allocs342c57e.Borrow(cmode_allocs)

	x.ref342c57e = ref342c57e
	x.allocs342c57e = allocs342c57e
	return ref342c57e, allocs342c57e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CopyAccelerationStructureInfo) PassValue() (C.VkCopyAccelerationStructureInfoKHR, *cgoAllocMap) {
	if x.ref342c57e != nil {
		return *x.ref342c57e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CopyAccelerationStructureInfo) Deref() {
	if x.ref342c57e == nil {
		return
	}
	x.SType = (StructureType)(x.ref342c57e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref342c57e.pNext))
	x.Src = *(*AccelerationStructure)(unsafe.Pointer(&x.ref342c57e.src))
	x.Dst = *(*AccelerationStructure)(unsafe.Pointer(&x.ref342c57e.dst))
	x.Mode = (CopyAccelerationStructureMode)(x.ref342c57e.mode)
}

// allocAccelerationStructureBuildSizesInfoMemory allocates memory for type C.VkAccelerationStructureBuildSizesInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureBuildSizesInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureBuildSizesInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAccelerationStructureBuildSizesInfoValue = unsafe.Sizeof([1]C.VkAccelerationStructureBuildSizesInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureBuildSizesInfo) Ref() *C.VkAccelerationStructureBuildSizesInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref871599f0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureBuildSizesInfo) Free() {
	if x != nil && x.allocs871599f0 != nil {
		x.allocs871599f0.(*cgoAllocMap).Free()
		x.ref871599f0 = nil
	}
}

// NewAccelerationStructureBuildSizesInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureBuildSizesInfoRef(ref unsafe.Pointer) *AccelerationStructureBuildSizesInfo {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureBuildSizesInfo)
	obj.ref871599f0 = (*C.VkAccelerationStructureBuildSizesInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureBuildSizesInfo) PassRef() (*C.VkAccelerationStructureBuildSizesInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref871599f0 != nil {
		return x.ref871599f0, nil
	}
	mem871599f0 := allocAccelerationStructureBuildSizesInfoMemory(1)
	ref871599f0 := (*C.VkAccelerationStructureBuildSizesInfoKHR)(mem871599f0)
	allocs871599f0 := new(cgoAllocMap)
	allocs871599f0.Add(mem871599f0)

	var csType_allocs *cgoAllocMap
	ref871599f0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs871599f0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref871599f0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs871599f0.Borrow(cpNext_allocs)

	var caccelerationStructureSize_allocs *cgoAllocMap
	ref871599f0.accelerationStructureSize, caccelerationStructureSize_allocs = (C.VkDeviceSize)(x.AccelerationStructureSize), cgoAllocsUnknown
	allocs871599f0.Borrow(caccelerationStructureSize_allocs)

	var cupdateScratchSize_allocs *cgoAllocMap
	ref871599f0.updateScratchSize, cupdateScratchSize_allocs = (C.VkDeviceSize)(x.UpdateScratchSize), cgoAllocsUnknown
	allocs871599f0.Borrow(cupdateScratchSize_allocs)

	var cbuildScratchSize_allocs *cgoAllocMap
	ref871599f0.buildScratchSize, cbuildScratchSize_allocs = (C.VkDeviceSize)(x.BuildScratchSize), cgoAllocsUnknown
	allocs871599f0.Borrow(cbuildScratchSize_allocs)

	x.ref871599f0 = ref871599f0
	x.allocs871599f0 = allocs871599f0
	return ref871599f0, allocs871599f0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureBuildSizesInfo) PassValue() (C.VkAccelerationStructureBuildSizesInfoKHR, *cgoAllocMap) {
	if x.ref871599f0 != nil {
		return *x.ref871599f0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureBuildSizesInfo) Deref() {
	if x.ref871599f0 == nil {
		return
	}
	x.SType = (StructureType)(x.ref871599f0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref871599f0.pNext))
	x.AccelerationStructureSize = (DeviceSize)(x.ref871599f0.accelerationStructureSize)
	x.UpdateScratchSize = (DeviceSize)(x.ref871599f0.updateScratchSize)
	x.BuildScratchSize = (DeviceSize)(x.ref871599f0.buildScratchSize)
}

// allocRayTracingShaderGroupCreateInfoMemory allocates memory for type C.VkRayTracingShaderGroupCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayTracingShaderGroupCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayTracingShaderGroupCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRayTracingShaderGroupCreateInfoValue = unsafe.Sizeof([1]C.VkRayTracingShaderGroupCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RayTracingShaderGroupCreateInfo) Ref() *C.VkRayTracingShaderGroupCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref85e3eb2c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RayTracingShaderGroupCreateInfo) Free() {
	if x != nil && x.allocs85e3eb2c != nil {
		x.allocs85e3eb2c.(*cgoAllocMap).Free()
		x.ref85e3eb2c = nil
	}
}

// NewRayTracingShaderGroupCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRayTracingShaderGroupCreateInfoRef(ref unsafe.Pointer) *RayTracingShaderGroupCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RayTracingShaderGroupCreateInfo)
	obj.ref85e3eb2c = (*C.VkRayTracingShaderGroupCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RayTracingShaderGroupCreateInfo) PassRef() (*C.VkRayTracingShaderGroupCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85e3eb2c != nil {
		return x.ref85e3eb2c, nil
	}
	mem85e3eb2c := allocRayTracingShaderGroupCreateInfoMemory(1)
	ref85e3eb2c := (*C.VkRayTracingShaderGroupCreateInfoKHR)(mem85e3eb2c)
	allocs85e3eb2c := new(cgoAllocMap)
	allocs85e3eb2c.Add(mem85e3eb2c)

	var csType_allocs *cgoAllocMap
	ref85e3eb2c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs85e3eb2c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref85e3eb2c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs85e3eb2c.Borrow(cpNext_allocs)

	var c_type_allocs *cgoAllocMap
	ref85e3eb2c._type, c_type_allocs = (C.VkRayTracingShaderGroupTypeKHR)(x.Type), cgoAllocsUnknown
	allocs85e3eb2c.Borrow(c_type_allocs)

	var cgeneralShader_allocs *cgoAllocMap
	ref85e3eb2c.generalShader, cgeneralShader_allocs = (C.uint32_t)(x.GeneralShader), cgoAllocsUnknown
	allocs85e3eb2c.Borrow(cgeneralShader_allocs)

	var cclosestHitShader_allocs *cgoAllocMap
	ref85e3eb2c.closestHitShader, cclosestHitShader_allocs = (C.uint32_t)(x.ClosestHitShader), cgoAllocsUnknown
	allocs85e3eb2c.Borrow(cclosestHitShader_allocs)

	var canyHitShader_allocs *cgoAllocMap
	ref85e3eb2c.anyHitShader, canyHitShader_allocs = (C.uint32_t)(x.AnyHitShader), cgoAllocsUnknown
	allocs85e3eb2c.Borrow(canyHitShader_allocs)

	var cintersectionShader_allocs *cgoAllocMap
	ref85e3eb2c.intersectionShader, cintersectionShader_allocs = (C.uint32_t)(x.IntersectionShader), cgoAllocsUnknown
	allocs85e3eb2c.Borrow(cintersectionShader_allocs)

	var cpShaderGroupCaptureReplayHandle_allocs *cgoAllocMap
	ref85e3eb2c.pShaderGroupCaptureReplayHandle, cpShaderGroupCaptureReplayHandle_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PShaderGroupCaptureReplayHandle)), cgoAllocsUnknown
	allocs85e3eb2c.Borrow(cpShaderGroupCaptureReplayHandle_allocs)

	x.ref85e3eb2c = ref85e3eb2c
	x.allocs85e3eb2c = allocs85e3eb2c
	return ref85e3eb2c, allocs85e3eb2c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RayTracingShaderGroupCreateInfo) PassValue() (C.VkRayTracingShaderGroupCreateInfoKHR, *cgoAllocMap) {
	if x.ref85e3eb2c != nil {
		return *x.ref85e3eb2c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RayTracingShaderGroupCreateInfo) Deref() {
	if x.ref85e3eb2c == nil {
		return
	}
	x.SType = (StructureType)(x.ref85e3eb2c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref85e3eb2c.pNext))
	x.Type = (RayTracingShaderGroupType)(x.ref85e3eb2c._type)
	x.GeneralShader = (uint32)(x.ref85e3eb2c.generalShader)
	x.ClosestHitShader = (uint32)(x.ref85e3eb2c.closestHitShader)
	x.AnyHitShader = (uint32)(x.ref85e3eb2c.anyHitShader)
	x.IntersectionShader = (uint32)(x.ref85e3eb2c.intersectionShader)
	x.PShaderGroupCaptureReplayHandle = (unsafe.Pointer)(unsafe.Pointer(x.ref85e3eb2c.pShaderGroupCaptureReplayHandle))
}

// allocRayTracingPipelineInterfaceCreateInfoMemory allocates memory for type C.VkRayTracingPipelineInterfaceCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayTracingPipelineInterfaceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayTracingPipelineInterfaceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRayTracingPipelineInterfaceCreateInfoValue = unsafe.Sizeof([1]C.VkRayTracingPipelineInterfaceCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RayTracingPipelineInterfaceCreateInfo) Ref() *C.VkRayTracingPipelineInterfaceCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref9501ee07
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RayTracingPipelineInterfaceCreateInfo) Free() {
	if x != nil && x.allocs9501ee07 != nil {
		x.allocs9501ee07.(*cgoAllocMap).Free()
		x.ref9501ee07 = nil
	}
}

// NewRayTracingPipelineInterfaceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRayTracingPipelineInterfaceCreateInfoRef(ref unsafe.Pointer) *RayTracingPipelineInterfaceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RayTracingPipelineInterfaceCreateInfo)
	obj.ref9501ee07 = (*C.VkRayTracingPipelineInterfaceCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RayTracingPipelineInterfaceCreateInfo) PassRef() (*C.VkRayTracingPipelineInterfaceCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9501ee07 != nil {
		return x.ref9501ee07, nil
	}
	mem9501ee07 := allocRayTracingPipelineInterfaceCreateInfoMemory(1)
	ref9501ee07 := (*C.VkRayTracingPipelineInterfaceCreateInfoKHR)(mem9501ee07)
	allocs9501ee07 := new(cgoAllocMap)
	allocs9501ee07.Add(mem9501ee07)

	var csType_allocs *cgoAllocMap
	ref9501ee07.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9501ee07.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9501ee07.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9501ee07.Borrow(cpNext_allocs)

	var cmaxPipelineRayPayloadSize_allocs *cgoAllocMap
	ref9501ee07.maxPipelineRayPayloadSize, cmaxPipelineRayPayloadSize_allocs = (C.uint32_t)(x.MaxPipelineRayPayloadSize), cgoAllocsUnknown
	allocs9501ee07.Borrow(cmaxPipelineRayPayloadSize_allocs)

	var cmaxPipelineRayHitAttributeSize_allocs *cgoAllocMap
	ref9501ee07.maxPipelineRayHitAttributeSize, cmaxPipelineRayHitAttributeSize_allocs = (C.uint32_t)(x.MaxPipelineRayHitAttributeSize), cgoAllocsUnknown
	allocs9501ee07.Borrow(cmaxPipelineRayHitAttributeSize_allocs)

	x.ref9501ee07 = ref9501ee07
	x.allocs9501ee07 = allocs9501ee07
	return ref9501ee07, allocs9501ee07

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RayTracingPipelineInterfaceCreateInfo) PassValue() (C.VkRayTracingPipelineInterfaceCreateInfoKHR, *cgoAllocMap) {
	if x.ref9501ee07 != nil {
		return *x.ref9501ee07, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RayTracingPipelineInterfaceCreateInfo) Deref() {
	if x.ref9501ee07 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9501ee07.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9501ee07.pNext))
	x.MaxPipelineRayPayloadSize = (uint32)(x.ref9501ee07.maxPipelineRayPayloadSize)
	x.MaxPipelineRayHitAttributeSize = (uint32)(x.ref9501ee07.maxPipelineRayHitAttributeSize)
}

// allocRayTracingPipelineCreateInfoMemory allocates memory for type C.VkRayTracingPipelineCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayTracingPipelineCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayTracingPipelineCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRayTracingPipelineCreateInfoValue = unsafe.Sizeof([1]C.VkRayTracingPipelineCreateInfoKHR{})

// unpackSRayTracingShaderGroupCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSRayTracingShaderGroupCreateInfo(x []RayTracingShaderGroupCreateInfo) (unpacked *C.VkRayTracingShaderGroupCreateInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRayTracingShaderGroupCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRayTracingShaderGroupCreateInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRayTracingShaderGroupCreateInfoKHR)(h.Data)
	return
}

// unpackSPipelineLibraryCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineLibraryCreateInfo(x []PipelineLibraryCreateInfo) (unpacked *C.VkPipelineLibraryCreateInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineLibraryCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineLibraryCreateInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineLibraryCreateInfoKHR)(h.Data)
	return
}

// unpackSRayTracingPipelineInterfaceCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSRayTracingPipelineInterfaceCreateInfo(x []RayTracingPipelineInterfaceCreateInfo) (unpacked *C.VkRayTracingPipelineInterfaceCreateInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRayTracingPipelineInterfaceCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRayTracingPipelineInterfaceCreateInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRayTracingPipelineInterfaceCreateInfoKHR)(h.Data)
	return
}

// unpackSPipelineDynamicStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineDynamicStateCreateInfo(x []PipelineDynamicStateCreateInfo) (unpacked *C.VkPipelineDynamicStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineDynamicStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineDynamicStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineDynamicStateCreateInfo)(h.Data)
	return
}

// packSRayTracingShaderGroupCreateInfo reads sliced Go data structure out from plain C format.
func packSRayTracingShaderGroupCreateInfo(v []RayTracingShaderGroupCreateInfo, ptr0 *C.VkRayTracingShaderGroupCreateInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRayTracingShaderGroupCreateInfoValue]C.VkRayTracingShaderGroupCreateInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRayTracingShaderGroupCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineLibraryCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineLibraryCreateInfo(v []PipelineLibraryCreateInfo, ptr0 *C.VkPipelineLibraryCreateInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineLibraryCreateInfoValue]C.VkPipelineLibraryCreateInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineLibraryCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSRayTracingPipelineInterfaceCreateInfo reads sliced Go data structure out from plain C format.
func packSRayTracingPipelineInterfaceCreateInfo(v []RayTracingPipelineInterfaceCreateInfo, ptr0 *C.VkRayTracingPipelineInterfaceCreateInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRayTracingPipelineInterfaceCreateInfoValue]C.VkRayTracingPipelineInterfaceCreateInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRayTracingPipelineInterfaceCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPipelineDynamicStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineDynamicStateCreateInfo(v []PipelineDynamicStateCreateInfo, ptr0 *C.VkPipelineDynamicStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineDynamicStateCreateInfoValue]C.VkPipelineDynamicStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineDynamicStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RayTracingPipelineCreateInfo) Ref() *C.VkRayTracingPipelineCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref497132a0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RayTracingPipelineCreateInfo) Free() {
	if x != nil && x.allocs497132a0 != nil {
		x.allocs497132a0.(*cgoAllocMap).Free()
		x.ref497132a0 = nil
	}
}

// NewRayTracingPipelineCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRayTracingPipelineCreateInfoRef(ref unsafe.Pointer) *RayTracingPipelineCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RayTracingPipelineCreateInfo)
	obj.ref497132a0 = (*C.VkRayTracingPipelineCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RayTracingPipelineCreateInfo) PassRef() (*C.VkRayTracingPipelineCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref497132a0 != nil {
		return x.ref497132a0, nil
	}
	mem497132a0 := allocRayTracingPipelineCreateInfoMemory(1)
	ref497132a0 := (*C.VkRayTracingPipelineCreateInfoKHR)(mem497132a0)
	allocs497132a0 := new(cgoAllocMap)
	allocs497132a0.Add(mem497132a0)

	var csType_allocs *cgoAllocMap
	ref497132a0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs497132a0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref497132a0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs497132a0.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref497132a0.flags, cflags_allocs = (C.VkPipelineCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs497132a0.Borrow(cflags_allocs)

	var cstageCount_allocs *cgoAllocMap
	ref497132a0.stageCount, cstageCount_allocs = (C.uint32_t)(x.StageCount), cgoAllocsUnknown
	allocs497132a0.Borrow(cstageCount_allocs)

	var cpStages_allocs *cgoAllocMap
	ref497132a0.pStages, cpStages_allocs = unpackSPipelineShaderStageCreateInfo(x.PStages)
	allocs497132a0.Borrow(cpStages_allocs)

	var cgroupCount_allocs *cgoAllocMap
	ref497132a0.groupCount, cgroupCount_allocs = (C.uint32_t)(x.GroupCount), cgoAllocsUnknown
	allocs497132a0.Borrow(cgroupCount_allocs)

	var cpGroups_allocs *cgoAllocMap
	ref497132a0.pGroups, cpGroups_allocs = unpackSRayTracingShaderGroupCreateInfo(x.PGroups)
	allocs497132a0.Borrow(cpGroups_allocs)

	var cmaxPipelineRayRecursionDepth_allocs *cgoAllocMap
	ref497132a0.maxPipelineRayRecursionDepth, cmaxPipelineRayRecursionDepth_allocs = (C.uint32_t)(x.MaxPipelineRayRecursionDepth), cgoAllocsUnknown
	allocs497132a0.Borrow(cmaxPipelineRayRecursionDepth_allocs)

	var cpLibraryInfo_allocs *cgoAllocMap
	ref497132a0.pLibraryInfo, cpLibraryInfo_allocs = unpackSPipelineLibraryCreateInfo(x.PLibraryInfo)
	allocs497132a0.Borrow(cpLibraryInfo_allocs)

	var cpLibraryInterface_allocs *cgoAllocMap
	ref497132a0.pLibraryInterface, cpLibraryInterface_allocs = unpackSRayTracingPipelineInterfaceCreateInfo(x.PLibraryInterface)
	allocs497132a0.Borrow(cpLibraryInterface_allocs)

	var cpDynamicState_allocs *cgoAllocMap
	ref497132a0.pDynamicState, cpDynamicState_allocs = unpackSPipelineDynamicStateCreateInfo(x.PDynamicState)
	allocs497132a0.Borrow(cpDynamicState_allocs)

	var clayout_allocs *cgoAllocMap
	ref497132a0.layout, clayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.Layout)), cgoAllocsUnknown
	allocs497132a0.Borrow(clayout_allocs)

	var cbasePipelineHandle_allocs *cgoAllocMap
	ref497132a0.basePipelineHandle, cbasePipelineHandle_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.BasePipelineHandle)), cgoAllocsUnknown
	allocs497132a0.Borrow(cbasePipelineHandle_allocs)

	var cbasePipelineIndex_allocs *cgoAllocMap
	ref497132a0.basePipelineIndex, cbasePipelineIndex_allocs = (C.int32_t)(x.BasePipelineIndex), cgoAllocsUnknown
	allocs497132a0.Borrow(cbasePipelineIndex_allocs)

	x.ref497132a0 = ref497132a0
	x.allocs497132a0 = allocs497132a0
	return ref497132a0, allocs497132a0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RayTracingPipelineCreateInfo) PassValue() (C.VkRayTracingPipelineCreateInfoKHR, *cgoAllocMap) {
	if x.ref497132a0 != nil {
		return *x.ref497132a0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RayTracingPipelineCreateInfo) Deref() {
	if x.ref497132a0 == nil {
		return
	}
	x.SType = (StructureType)(x.ref497132a0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref497132a0.pNext))
	x.Flags = (PipelineCreateFlags)(x.ref497132a0.flags)
	x.StageCount = (uint32)(x.ref497132a0.stageCount)
	packSPipelineShaderStageCreateInfo(x.PStages, x.ref497132a0.pStages)
	x.GroupCount = (uint32)(x.ref497132a0.groupCount)
	packSRayTracingShaderGroupCreateInfo(x.PGroups, x.ref497132a0.pGroups)
	x.MaxPipelineRayRecursionDepth = (uint32)(x.ref497132a0.maxPipelineRayRecursionDepth)
	packSPipelineLibraryCreateInfo(x.PLibraryInfo, x.ref497132a0.pLibraryInfo)
	packSRayTracingPipelineInterfaceCreateInfo(x.PLibraryInterface, x.ref497132a0.pLibraryInterface)
	packSPipelineDynamicStateCreateInfo(x.PDynamicState, x.ref497132a0.pDynamicState)
	x.Layout = *(*PipelineLayout)(unsafe.Pointer(&x.ref497132a0.layout))
	x.BasePipelineHandle = *(*Pipeline)(unsafe.Pointer(&x.ref497132a0.basePipelineHandle))
	x.BasePipelineIndex = (int32)(x.ref497132a0.basePipelineIndex)
}

// allocPhysicalDeviceRayTracingPipelineFeaturesMemory allocates memory for type C.VkPhysicalDeviceRayTracingPipelineFeaturesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceRayTracingPipelineFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceRayTracingPipelineFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceRayTracingPipelineFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceRayTracingPipelineFeaturesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceRayTracingPipelineFeatures) Ref() *C.VkPhysicalDeviceRayTracingPipelineFeaturesKHR {
	if x == nil {
		return nil
	}
	return x.refec379d85
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceRayTracingPipelineFeatures) Free() {
	if x != nil && x.allocsec379d85 != nil {
		x.allocsec379d85.(*cgoAllocMap).Free()
		x.refec379d85 = nil
	}
}

// NewPhysicalDeviceRayTracingPipelineFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceRayTracingPipelineFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceRayTracingPipelineFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceRayTracingPipelineFeatures)
	obj.refec379d85 = (*C.VkPhysicalDeviceRayTracingPipelineFeaturesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceRayTracingPipelineFeatures) PassRef() (*C.VkPhysicalDeviceRayTracingPipelineFeaturesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refec379d85 != nil {
		return x.refec379d85, nil
	}
	memec379d85 := allocPhysicalDeviceRayTracingPipelineFeaturesMemory(1)
	refec379d85 := (*C.VkPhysicalDeviceRayTracingPipelineFeaturesKHR)(memec379d85)
	allocsec379d85 := new(cgoAllocMap)
	allocsec379d85.Add(memec379d85)

	var csType_allocs *cgoAllocMap
	refec379d85.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsec379d85.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refec379d85.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsec379d85.Borrow(cpNext_allocs)

	var crayTracingPipeline_allocs *cgoAllocMap
	refec379d85.rayTracingPipeline, crayTracingPipeline_allocs = (C.VkBool32)(x.RayTracingPipeline), cgoAllocsUnknown
	allocsec379d85.Borrow(crayTracingPipeline_allocs)

	var crayTracingPipelineShaderGroupHandleCaptureReplay_allocs *cgoAllocMap
	refec379d85.rayTracingPipelineShaderGroupHandleCaptureReplay, crayTracingPipelineShaderGroupHandleCaptureReplay_allocs = (C.VkBool32)(x.RayTracingPipelineShaderGroupHandleCaptureReplay), cgoAllocsUnknown
	allocsec379d85.Borrow(crayTracingPipelineShaderGroupHandleCaptureReplay_allocs)

	var crayTracingPipelineShaderGroupHandleCaptureReplayMixed_allocs *cgoAllocMap
	refec379d85.rayTracingPipelineShaderGroupHandleCaptureReplayMixed, crayTracingPipelineShaderGroupHandleCaptureReplayMixed_allocs = (C.VkBool32)(x.RayTracingPipelineShaderGroupHandleCaptureReplayMixed), cgoAllocsUnknown
	allocsec379d85.Borrow(crayTracingPipelineShaderGroupHandleCaptureReplayMixed_allocs)

	var crayTracingPipelineTraceRaysIndirect_allocs *cgoAllocMap
	refec379d85.rayTracingPipelineTraceRaysIndirect, crayTracingPipelineTraceRaysIndirect_allocs = (C.VkBool32)(x.RayTracingPipelineTraceRaysIndirect), cgoAllocsUnknown
	allocsec379d85.Borrow(crayTracingPipelineTraceRaysIndirect_allocs)

	var crayTraversalPrimitiveCulling_allocs *cgoAllocMap
	refec379d85.rayTraversalPrimitiveCulling, crayTraversalPrimitiveCulling_allocs = (C.VkBool32)(x.RayTraversalPrimitiveCulling), cgoAllocsUnknown
	allocsec379d85.Borrow(crayTraversalPrimitiveCulling_allocs)

	x.refec379d85 = refec379d85
	x.allocsec379d85 = allocsec379d85
	return refec379d85, allocsec379d85

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceRayTracingPipelineFeatures) PassValue() (C.VkPhysicalDeviceRayTracingPipelineFeaturesKHR, *cgoAllocMap) {
	if x.refec379d85 != nil {
		return *x.refec379d85, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceRayTracingPipelineFeatures) Deref() {
	if x.refec379d85 == nil {
		return
	}
	x.SType = (StructureType)(x.refec379d85.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refec379d85.pNext))
	x.RayTracingPipeline = (Bool32)(x.refec379d85.rayTracingPipeline)
	x.RayTracingPipelineShaderGroupHandleCaptureReplay = (Bool32)(x.refec379d85.rayTracingPipelineShaderGroupHandleCaptureReplay)
	x.RayTracingPipelineShaderGroupHandleCaptureReplayMixed = (Bool32)(x.refec379d85.rayTracingPipelineShaderGroupHandleCaptureReplayMixed)
	x.RayTracingPipelineTraceRaysIndirect = (Bool32)(x.refec379d85.rayTracingPipelineTraceRaysIndirect)
	x.RayTraversalPrimitiveCulling = (Bool32)(x.refec379d85.rayTraversalPrimitiveCulling)
}

// allocPhysicalDeviceRayTracingPipelinePropertiesMemory allocates memory for type C.VkPhysicalDeviceRayTracingPipelinePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceRayTracingPipelinePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceRayTracingPipelinePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceRayTracingPipelinePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceRayTracingPipelinePropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceRayTracingPipelineProperties) Ref() *C.VkPhysicalDeviceRayTracingPipelinePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref86a1fc2e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceRayTracingPipelineProperties) Free() {
	if x != nil && x.allocs86a1fc2e != nil {
		x.allocs86a1fc2e.(*cgoAllocMap).Free()
		x.ref86a1fc2e = nil
	}
}

// NewPhysicalDeviceRayTracingPipelinePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceRayTracingPipelinePropertiesRef(ref unsafe.Pointer) *PhysicalDeviceRayTracingPipelineProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceRayTracingPipelineProperties)
	obj.ref86a1fc2e = (*C.VkPhysicalDeviceRayTracingPipelinePropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceRayTracingPipelineProperties) PassRef() (*C.VkPhysicalDeviceRayTracingPipelinePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref86a1fc2e != nil {
		return x.ref86a1fc2e, nil
	}
	mem86a1fc2e := allocPhysicalDeviceRayTracingPipelinePropertiesMemory(1)
	ref86a1fc2e := (*C.VkPhysicalDeviceRayTracingPipelinePropertiesKHR)(mem86a1fc2e)
	allocs86a1fc2e := new(cgoAllocMap)
	allocs86a1fc2e.Add(mem86a1fc2e)

	var csType_allocs *cgoAllocMap
	ref86a1fc2e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs86a1fc2e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref86a1fc2e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs86a1fc2e.Borrow(cpNext_allocs)

	var cshaderGroupHandleSize_allocs *cgoAllocMap
	ref86a1fc2e.shaderGroupHandleSize, cshaderGroupHandleSize_allocs = (C.uint32_t)(x.ShaderGroupHandleSize), cgoAllocsUnknown
	allocs86a1fc2e.Borrow(cshaderGroupHandleSize_allocs)

	var cmaxRayRecursionDepth_allocs *cgoAllocMap
	ref86a1fc2e.maxRayRecursionDepth, cmaxRayRecursionDepth_allocs = (C.uint32_t)(x.MaxRayRecursionDepth), cgoAllocsUnknown
	allocs86a1fc2e.Borrow(cmaxRayRecursionDepth_allocs)

	var cmaxShaderGroupStride_allocs *cgoAllocMap
	ref86a1fc2e.maxShaderGroupStride, cmaxShaderGroupStride_allocs = (C.uint32_t)(x.MaxShaderGroupStride), cgoAllocsUnknown
	allocs86a1fc2e.Borrow(cmaxShaderGroupStride_allocs)

	var cshaderGroupBaseAlignment_allocs *cgoAllocMap
	ref86a1fc2e.shaderGroupBaseAlignment, cshaderGroupBaseAlignment_allocs = (C.uint32_t)(x.ShaderGroupBaseAlignment), cgoAllocsUnknown
	allocs86a1fc2e.Borrow(cshaderGroupBaseAlignment_allocs)

	var cshaderGroupHandleCaptureReplaySize_allocs *cgoAllocMap
	ref86a1fc2e.shaderGroupHandleCaptureReplaySize, cshaderGroupHandleCaptureReplaySize_allocs = (C.uint32_t)(x.ShaderGroupHandleCaptureReplaySize), cgoAllocsUnknown
	allocs86a1fc2e.Borrow(cshaderGroupHandleCaptureReplaySize_allocs)

	var cmaxRayDispatchInvocationCount_allocs *cgoAllocMap
	ref86a1fc2e.maxRayDispatchInvocationCount, cmaxRayDispatchInvocationCount_allocs = (C.uint32_t)(x.MaxRayDispatchInvocationCount), cgoAllocsUnknown
	allocs86a1fc2e.Borrow(cmaxRayDispatchInvocationCount_allocs)

	var cshaderGroupHandleAlignment_allocs *cgoAllocMap
	ref86a1fc2e.shaderGroupHandleAlignment, cshaderGroupHandleAlignment_allocs = (C.uint32_t)(x.ShaderGroupHandleAlignment), cgoAllocsUnknown
	allocs86a1fc2e.Borrow(cshaderGroupHandleAlignment_allocs)

	var cmaxRayHitAttributeSize_allocs *cgoAllocMap
	ref86a1fc2e.maxRayHitAttributeSize, cmaxRayHitAttributeSize_allocs = (C.uint32_t)(x.MaxRayHitAttributeSize), cgoAllocsUnknown
	allocs86a1fc2e.Borrow(cmaxRayHitAttributeSize_allocs)

	x.ref86a1fc2e = ref86a1fc2e
	x.allocs86a1fc2e = allocs86a1fc2e
	return ref86a1fc2e, allocs86a1fc2e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceRayTracingPipelineProperties) PassValue() (C.VkPhysicalDeviceRayTracingPipelinePropertiesKHR, *cgoAllocMap) {
	if x.ref86a1fc2e != nil {
		return *x.ref86a1fc2e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceRayTracingPipelineProperties) Deref() {
	if x.ref86a1fc2e == nil {
		return
	}
	x.SType = (StructureType)(x.ref86a1fc2e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref86a1fc2e.pNext))
	x.ShaderGroupHandleSize = (uint32)(x.ref86a1fc2e.shaderGroupHandleSize)
	x.MaxRayRecursionDepth = (uint32)(x.ref86a1fc2e.maxRayRecursionDepth)
	x.MaxShaderGroupStride = (uint32)(x.ref86a1fc2e.maxShaderGroupStride)
	x.ShaderGroupBaseAlignment = (uint32)(x.ref86a1fc2e.shaderGroupBaseAlignment)
	x.ShaderGroupHandleCaptureReplaySize = (uint32)(x.ref86a1fc2e.shaderGroupHandleCaptureReplaySize)
	x.MaxRayDispatchInvocationCount = (uint32)(x.ref86a1fc2e.maxRayDispatchInvocationCount)
	x.ShaderGroupHandleAlignment = (uint32)(x.ref86a1fc2e.shaderGroupHandleAlignment)
	x.MaxRayHitAttributeSize = (uint32)(x.ref86a1fc2e.maxRayHitAttributeSize)
}

// allocStridedDeviceAddressRegionMemory allocates memory for type C.VkStridedDeviceAddressRegionKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStridedDeviceAddressRegionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStridedDeviceAddressRegionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStridedDeviceAddressRegionValue = unsafe.Sizeof([1]C.VkStridedDeviceAddressRegionKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StridedDeviceAddressRegion) Ref() *C.VkStridedDeviceAddressRegionKHR {
	if x == nil {
		return nil
	}
	return x.reffeea9c37
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StridedDeviceAddressRegion) Free() {
	if x != nil && x.allocsfeea9c37 != nil {
		x.allocsfeea9c37.(*cgoAllocMap).Free()
		x.reffeea9c37 = nil
	}
}

// NewStridedDeviceAddressRegionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStridedDeviceAddressRegionRef(ref unsafe.Pointer) *StridedDeviceAddressRegion {
	if ref == nil {
		return nil
	}
	obj := new(StridedDeviceAddressRegion)
	obj.reffeea9c37 = (*C.VkStridedDeviceAddressRegionKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StridedDeviceAddressRegion) PassRef() (*C.VkStridedDeviceAddressRegionKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffeea9c37 != nil {
		return x.reffeea9c37, nil
	}
	memfeea9c37 := allocStridedDeviceAddressRegionMemory(1)
	reffeea9c37 := (*C.VkStridedDeviceAddressRegionKHR)(memfeea9c37)
	allocsfeea9c37 := new(cgoAllocMap)
	allocsfeea9c37.Add(memfeea9c37)

	var cdeviceAddress_allocs *cgoAllocMap
	reffeea9c37.deviceAddress, cdeviceAddress_allocs = (C.VkDeviceAddress)(x.DeviceAddress), cgoAllocsUnknown
	allocsfeea9c37.Borrow(cdeviceAddress_allocs)

	var cstride_allocs *cgoAllocMap
	reffeea9c37.stride, cstride_allocs = (C.VkDeviceSize)(x.Stride), cgoAllocsUnknown
	allocsfeea9c37.Borrow(cstride_allocs)

	var csize_allocs *cgoAllocMap
	reffeea9c37.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocsfeea9c37.Borrow(csize_allocs)

	x.reffeea9c37 = reffeea9c37
	x.allocsfeea9c37 = allocsfeea9c37
	return reffeea9c37, allocsfeea9c37

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StridedDeviceAddressRegion) PassValue() (C.VkStridedDeviceAddressRegionKHR, *cgoAllocMap) {
	if x.reffeea9c37 != nil {
		return *x.reffeea9c37, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StridedDeviceAddressRegion) Deref() {
	if x.reffeea9c37 == nil {
		return
	}
	x.DeviceAddress = (DeviceAddress)(x.reffeea9c37.deviceAddress)
	x.Stride = (DeviceSize)(x.reffeea9c37.stride)
	x.Size = (DeviceSize)(x.reffeea9c37.size)
}

// allocTraceRaysIndirectCommandMemory allocates memory for type C.VkTraceRaysIndirectCommandKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTraceRaysIndirectCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTraceRaysIndirectCommandValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTraceRaysIndirectCommandValue = unsafe.Sizeof([1]C.VkTraceRaysIndirectCommandKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TraceRaysIndirectCommand) Ref() *C.VkTraceRaysIndirectCommandKHR {
	if x == nil {
		return nil
	}
	return x.refdfb9305c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TraceRaysIndirectCommand) Free() {
	if x != nil && x.allocsdfb9305c != nil {
		x.allocsdfb9305c.(*cgoAllocMap).Free()
		x.refdfb9305c = nil
	}
}

// NewTraceRaysIndirectCommandRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTraceRaysIndirectCommandRef(ref unsafe.Pointer) *TraceRaysIndirectCommand {
	if ref == nil {
		return nil
	}
	obj := new(TraceRaysIndirectCommand)
	obj.refdfb9305c = (*C.VkTraceRaysIndirectCommandKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TraceRaysIndirectCommand) PassRef() (*C.VkTraceRaysIndirectCommandKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdfb9305c != nil {
		return x.refdfb9305c, nil
	}
	memdfb9305c := allocTraceRaysIndirectCommandMemory(1)
	refdfb9305c := (*C.VkTraceRaysIndirectCommandKHR)(memdfb9305c)
	allocsdfb9305c := new(cgoAllocMap)
	allocsdfb9305c.Add(memdfb9305c)

	var cwidth_allocs *cgoAllocMap
	refdfb9305c.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocsdfb9305c.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refdfb9305c.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocsdfb9305c.Borrow(cheight_allocs)

	var cdepth_allocs *cgoAllocMap
	refdfb9305c.depth, cdepth_allocs = (C.uint32_t)(x.Depth), cgoAllocsUnknown
	allocsdfb9305c.Borrow(cdepth_allocs)

	x.refdfb9305c = refdfb9305c
	x.allocsdfb9305c = allocsdfb9305c
	return refdfb9305c, allocsdfb9305c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TraceRaysIndirectCommand) PassValue() (C.VkTraceRaysIndirectCommandKHR, *cgoAllocMap) {
	if x.refdfb9305c != nil {
		return *x.refdfb9305c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TraceRaysIndirectCommand) Deref() {
	if x.refdfb9305c == nil {
		return
	}
	x.Width = (uint32)(x.refdfb9305c.width)
	x.Height = (uint32)(x.refdfb9305c.height)
	x.Depth = (uint32)(x.refdfb9305c.depth)
}

// allocPhysicalDeviceRayQueryFeaturesMemory allocates memory for type C.VkPhysicalDeviceRayQueryFeaturesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceRayQueryFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceRayQueryFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceRayQueryFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceRayQueryFeaturesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceRayQueryFeatures) Ref() *C.VkPhysicalDeviceRayQueryFeaturesKHR {
	if x == nil {
		return nil
	}
	return x.refa8125b88
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceRayQueryFeatures) Free() {
	if x != nil && x.allocsa8125b88 != nil {
		x.allocsa8125b88.(*cgoAllocMap).Free()
		x.refa8125b88 = nil
	}
}

// NewPhysicalDeviceRayQueryFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceRayQueryFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceRayQueryFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceRayQueryFeatures)
	obj.refa8125b88 = (*C.VkPhysicalDeviceRayQueryFeaturesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceRayQueryFeatures) PassRef() (*C.VkPhysicalDeviceRayQueryFeaturesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa8125b88 != nil {
		return x.refa8125b88, nil
	}
	mema8125b88 := allocPhysicalDeviceRayQueryFeaturesMemory(1)
	refa8125b88 := (*C.VkPhysicalDeviceRayQueryFeaturesKHR)(mema8125b88)
	allocsa8125b88 := new(cgoAllocMap)
	allocsa8125b88.Add(mema8125b88)

	var csType_allocs *cgoAllocMap
	refa8125b88.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa8125b88.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa8125b88.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa8125b88.Borrow(cpNext_allocs)

	var crayQuery_allocs *cgoAllocMap
	refa8125b88.rayQuery, crayQuery_allocs = (C.VkBool32)(x.RayQuery), cgoAllocsUnknown
	allocsa8125b88.Borrow(crayQuery_allocs)

	x.refa8125b88 = refa8125b88
	x.allocsa8125b88 = allocsa8125b88
	return refa8125b88, allocsa8125b88

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceRayQueryFeatures) PassValue() (C.VkPhysicalDeviceRayQueryFeaturesKHR, *cgoAllocMap) {
	if x.refa8125b88 != nil {
		return *x.refa8125b88, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceRayQueryFeatures) Deref() {
	if x.refa8125b88 == nil {
		return
	}
	x.SType = (StructureType)(x.refa8125b88.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa8125b88.pNext))
	x.RayQuery = (Bool32)(x.refa8125b88.rayQuery)
}

// allocXcbSurfaceCreateInfoMemory allocates memory for type C.VkXcbSurfaceCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXcbSurfaceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXcbSurfaceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfXcbSurfaceCreateInfoValue = unsafe.Sizeof([1]C.VkXcbSurfaceCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *XcbSurfaceCreateInfo) Ref() *C.VkXcbSurfaceCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref965c662d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *XcbSurfaceCreateInfo) Free() {
	if x != nil && x.allocs965c662d != nil {
		x.allocs965c662d.(*cgoAllocMap).Free()
		x.ref965c662d = nil
	}
}

// NewXcbSurfaceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXcbSurfaceCreateInfoRef(ref unsafe.Pointer) *XcbSurfaceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(XcbSurfaceCreateInfo)
	obj.ref965c662d = (*C.VkXcbSurfaceCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *XcbSurfaceCreateInfo) PassRef() (*C.VkXcbSurfaceCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref965c662d != nil {
		return x.ref965c662d, nil
	}
	mem965c662d := allocXcbSurfaceCreateInfoMemory(1)
	ref965c662d := (*C.VkXcbSurfaceCreateInfoKHR)(mem965c662d)
	allocs965c662d := new(cgoAllocMap)
	allocs965c662d.Add(mem965c662d)

	var csType_allocs *cgoAllocMap
	ref965c662d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs965c662d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref965c662d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs965c662d.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref965c662d.flags, cflags_allocs = (C.VkXcbSurfaceCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs965c662d.Borrow(cflags_allocs)

	var cwindow_allocs *cgoAllocMap
	ref965c662d.window, cwindow_allocs = (C.xcb_window_t)(x.Window), cgoAllocsUnknown
	allocs965c662d.Borrow(cwindow_allocs)

	x.ref965c662d = ref965c662d
	x.allocs965c662d = allocs965c662d
	return ref965c662d, allocs965c662d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x XcbSurfaceCreateInfo) PassValue() (C.VkXcbSurfaceCreateInfoKHR, *cgoAllocMap) {
	if x.ref965c662d != nil {
		return *x.ref965c662d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *XcbSurfaceCreateInfo) Deref() {
	if x.ref965c662d == nil {
		return
	}
	x.SType = (StructureType)(x.ref965c662d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref965c662d.pNext))
	x.Flags = (XcbSurfaceCreateFlags)(x.ref965c662d.flags)
	x.Window = (uint16)(x.ref965c662d.window)
}

// allocXlibSurfaceCreateInfoMemory allocates memory for type C.VkXlibSurfaceCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXlibSurfaceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXlibSurfaceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfXlibSurfaceCreateInfoValue = unsafe.Sizeof([1]C.VkXlibSurfaceCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *XlibSurfaceCreateInfo) Ref() *C.VkXlibSurfaceCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref5656fb22
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *XlibSurfaceCreateInfo) Free() {
	if x != nil && x.allocs5656fb22 != nil {
		x.allocs5656fb22.(*cgoAllocMap).Free()
		x.ref5656fb22 = nil
	}
}

// NewXlibSurfaceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXlibSurfaceCreateInfoRef(ref unsafe.Pointer) *XlibSurfaceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(XlibSurfaceCreateInfo)
	obj.ref5656fb22 = (*C.VkXlibSurfaceCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *XlibSurfaceCreateInfo) PassRef() (*C.VkXlibSurfaceCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5656fb22 != nil {
		return x.ref5656fb22, nil
	}
	mem5656fb22 := allocXlibSurfaceCreateInfoMemory(1)
	ref5656fb22 := (*C.VkXlibSurfaceCreateInfoKHR)(mem5656fb22)
	allocs5656fb22 := new(cgoAllocMap)
	allocs5656fb22.Add(mem5656fb22)

	var csType_allocs *cgoAllocMap
	ref5656fb22.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5656fb22.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5656fb22.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5656fb22.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref5656fb22.flags, cflags_allocs = (C.VkXlibSurfaceCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs5656fb22.Borrow(cflags_allocs)

	var cwindow_allocs *cgoAllocMap
	ref5656fb22.window, cwindow_allocs = (C.Window)(x.Window), cgoAllocsUnknown
	allocs5656fb22.Borrow(cwindow_allocs)

	x.ref5656fb22 = ref5656fb22
	x.allocs5656fb22 = allocs5656fb22
	return ref5656fb22, allocs5656fb22

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x XlibSurfaceCreateInfo) PassValue() (C.VkXlibSurfaceCreateInfoKHR, *cgoAllocMap) {
	if x.ref5656fb22 != nil {
		return *x.ref5656fb22, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *XlibSurfaceCreateInfo) Deref() {
	if x.ref5656fb22 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5656fb22.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5656fb22.pNext))
	x.Flags = (XlibSurfaceCreateFlags)(x.ref5656fb22.flags)
	x.Window = (uint32)(x.ref5656fb22.window)
}

// allocWaylandSurfaceCreateInfoMemory allocates memory for type C.VkWaylandSurfaceCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWaylandSurfaceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWaylandSurfaceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfWaylandSurfaceCreateInfoValue = unsafe.Sizeof([1]C.VkWaylandSurfaceCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *WaylandSurfaceCreateInfo) Ref() *C.VkWaylandSurfaceCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref3cb913b7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *WaylandSurfaceCreateInfo) Free() {
	if x != nil && x.allocs3cb913b7 != nil {
		x.allocs3cb913b7.(*cgoAllocMap).Free()
		x.ref3cb913b7 = nil
	}
}

// NewWaylandSurfaceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWaylandSurfaceCreateInfoRef(ref unsafe.Pointer) *WaylandSurfaceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(WaylandSurfaceCreateInfo)
	obj.ref3cb913b7 = (*C.VkWaylandSurfaceCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *WaylandSurfaceCreateInfo) PassRef() (*C.VkWaylandSurfaceCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3cb913b7 != nil {
		return x.ref3cb913b7, nil
	}
	mem3cb913b7 := allocWaylandSurfaceCreateInfoMemory(1)
	ref3cb913b7 := (*C.VkWaylandSurfaceCreateInfoKHR)(mem3cb913b7)
	allocs3cb913b7 := new(cgoAllocMap)
	allocs3cb913b7.Add(mem3cb913b7)

	var csType_allocs *cgoAllocMap
	ref3cb913b7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3cb913b7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3cb913b7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3cb913b7.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref3cb913b7.flags, cflags_allocs = (C.VkWaylandSurfaceCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs3cb913b7.Borrow(cflags_allocs)

	x.ref3cb913b7 = ref3cb913b7
	x.allocs3cb913b7 = allocs3cb913b7
	return ref3cb913b7, allocs3cb913b7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x WaylandSurfaceCreateInfo) PassValue() (C.VkWaylandSurfaceCreateInfoKHR, *cgoAllocMap) {
	if x.ref3cb913b7 != nil {
		return *x.ref3cb913b7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *WaylandSurfaceCreateInfo) Deref() {
	if x.ref3cb913b7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3cb913b7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3cb913b7.pNext))
	x.Flags = (WaylandSurfaceCreateFlags)(x.ref3cb913b7.flags)
}

// unpackArgSQueueFamilyProperties transforms a sliced Go data structure into plain C format.
func unpackArgSQueueFamilyProperties(x []QueueFamilyProperties) (unpacked *C.VkQueueFamilyProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocQueueFamilyPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkQueueFamilyProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkQueueFamilyProperties)(h.Data)
	return
}

// packSQueueFamilyProperties reads sliced Go data structure out from plain C format.
func packSQueueFamilyProperties(v []QueueFamilyProperties, ptr0 *C.VkQueueFamilyProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfQueueFamilyPropertiesValue]C.VkQueueFamilyProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewQueueFamilyPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSExtensionProperties transforms a sliced Go data structure into plain C format.
func unpackArgSExtensionProperties(x []ExtensionProperties) (unpacked *C.VkExtensionProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocExtensionPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkExtensionProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkExtensionProperties)(h.Data)
	return
}

// packSExtensionProperties reads sliced Go data structure out from plain C format.
func packSExtensionProperties(v []ExtensionProperties, ptr0 *C.VkExtensionProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfExtensionPropertiesValue]C.VkExtensionProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewExtensionPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSLayerProperties transforms a sliced Go data structure into plain C format.
func unpackArgSLayerProperties(x []LayerProperties) (unpacked *C.VkLayerProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocLayerPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkLayerProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkLayerProperties)(h.Data)
	return
}

// packSLayerProperties reads sliced Go data structure out from plain C format.
func packSLayerProperties(v []LayerProperties, ptr0 *C.VkLayerProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfLayerPropertiesValue]C.VkLayerProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewLayerPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSubmitInfo transforms a sliced Go data structure into plain C format.
func unpackArgSSubmitInfo(x []SubmitInfo) (unpacked *C.VkSubmitInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSubmitInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubmitInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubmitInfo)(h.Data)
	return
}

// packSSubmitInfo reads sliced Go data structure out from plain C format.
func packSSubmitInfo(v []SubmitInfo, ptr0 *C.VkSubmitInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubmitInfoValue]C.VkSubmitInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubmitInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMappedMemoryRange transforms a sliced Go data structure into plain C format.
func unpackArgSMappedMemoryRange(x []MappedMemoryRange) (unpacked *C.VkMappedMemoryRange, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocMappedMemoryRangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMappedMemoryRange)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMappedMemoryRange)(h.Data)
	return
}

// packSMappedMemoryRange reads sliced Go data structure out from plain C format.
func packSMappedMemoryRange(v []MappedMemoryRange, ptr0 *C.VkMappedMemoryRange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMappedMemoryRangeValue]C.VkMappedMemoryRange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMappedMemoryRangeRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSparseImageMemoryRequirements transforms a sliced Go data structure into plain C format.
func unpackArgSSparseImageMemoryRequirements(x []SparseImageMemoryRequirements) (unpacked *C.VkSparseImageMemoryRequirements, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryRequirementsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryRequirements)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryRequirements)(h.Data)
	return
}

// packSSparseImageMemoryRequirements reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryRequirements(v []SparseImageMemoryRequirements, ptr0 *C.VkSparseImageMemoryRequirements) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryRequirementsValue]C.VkSparseImageMemoryRequirements)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryRequirementsRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSparseImageFormatProperties transforms a sliced Go data structure into plain C format.
func unpackArgSSparseImageFormatProperties(x []SparseImageFormatProperties) (unpacked *C.VkSparseImageFormatProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageFormatPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageFormatProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageFormatProperties)(h.Data)
	return
}

// packSSparseImageFormatProperties reads sliced Go data structure out from plain C format.
func packSSparseImageFormatProperties(v []SparseImageFormatProperties, ptr0 *C.VkSparseImageFormatProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageFormatPropertiesValue]C.VkSparseImageFormatProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageFormatPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBindSparseInfo transforms a sliced Go data structure into plain C format.
func unpackArgSBindSparseInfo(x []BindSparseInfo) (unpacked *C.VkBindSparseInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocBindSparseInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBindSparseInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBindSparseInfo)(h.Data)
	return
}

// packSBindSparseInfo reads sliced Go data structure out from plain C format.
func packSBindSparseInfo(v []BindSparseInfo, ptr0 *C.VkBindSparseInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBindSparseInfoValue]C.VkBindSparseInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBindSparseInfoRef(unsafe.Pointer(&ptr1))
	}
}

// copyPFenceBytes copies the data from Go slice as *C.VkFence.
func copyPFenceBytes(slice *sliceHeader) (*C.VkFence, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfFenceValue) * slice.Len,
		Cap:  int(sizeOfFenceValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkFence)(mem0), allocs
}

// allocFenceMemory allocates memory for type C.VkFence in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFenceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFenceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFenceValue = unsafe.Sizeof([1]C.VkFence{})

// copyPPipelineCacheBytes copies the data from Go slice as *C.VkPipelineCache.
func copyPPipelineCacheBytes(slice *sliceHeader) (*C.VkPipelineCache, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPipelineCacheValue) * slice.Len,
		Cap:  int(sizeOfPipelineCacheValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkPipelineCache)(mem0), allocs
}

// allocPipelineCacheMemory allocates memory for type C.VkPipelineCache in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCacheMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCacheValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineCacheValue = unsafe.Sizeof([1]C.VkPipelineCache{})

// unpackArgSGraphicsPipelineCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSGraphicsPipelineCreateInfo(x []GraphicsPipelineCreateInfo) (unpacked *C.VkGraphicsPipelineCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocGraphicsPipelineCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkGraphicsPipelineCreateInfo)(h.Data)
	return
}

// packSGraphicsPipelineCreateInfo reads sliced Go data structure out from plain C format.
func packSGraphicsPipelineCreateInfo(v []GraphicsPipelineCreateInfo, ptr0 *C.VkGraphicsPipelineCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfGraphicsPipelineCreateInfoValue]C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewGraphicsPipelineCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSComputePipelineCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSComputePipelineCreateInfo(x []ComputePipelineCreateInfo) (unpacked *C.VkComputePipelineCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocComputePipelineCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkComputePipelineCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkComputePipelineCreateInfo)(h.Data)
	return
}

// packSComputePipelineCreateInfo reads sliced Go data structure out from plain C format.
func packSComputePipelineCreateInfo(v []ComputePipelineCreateInfo, ptr0 *C.VkComputePipelineCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfComputePipelineCreateInfoValue]C.VkComputePipelineCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewComputePipelineCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSWriteDescriptorSet transforms a sliced Go data structure into plain C format.
func unpackArgSWriteDescriptorSet(x []WriteDescriptorSet) (unpacked *C.VkWriteDescriptorSet, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocWriteDescriptorSetMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkWriteDescriptorSet)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkWriteDescriptorSet)(h.Data)
	return
}

// packSWriteDescriptorSet reads sliced Go data structure out from plain C format.
func packSWriteDescriptorSet(v []WriteDescriptorSet, ptr0 *C.VkWriteDescriptorSet) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfWriteDescriptorSetValue]C.VkWriteDescriptorSet)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewWriteDescriptorSetRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCopyDescriptorSet transforms a sliced Go data structure into plain C format.
func unpackArgSCopyDescriptorSet(x []CopyDescriptorSet) (unpacked *C.VkCopyDescriptorSet, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCopyDescriptorSetMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCopyDescriptorSet)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCopyDescriptorSet)(h.Data)
	return
}

// packSCopyDescriptorSet reads sliced Go data structure out from plain C format.
func packSCopyDescriptorSet(v []CopyDescriptorSet, ptr0 *C.VkCopyDescriptorSet) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCopyDescriptorSetValue]C.VkCopyDescriptorSet)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCopyDescriptorSetRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSViewport transforms a sliced Go data structure into plain C format.
func unpackArgSViewport(x []Viewport) (unpacked *C.VkViewport, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocViewportMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkViewport)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkViewport)(h.Data)
	return
}

// unpackArgSRect2D transforms a sliced Go data structure into plain C format.
func unpackArgSRect2D(x []Rect2D) (unpacked *C.VkRect2D, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRect2DMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRect2D)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRect2D)(h.Data)
	return
}

// copyPDescriptorSetBytes copies the data from Go slice as *C.VkDescriptorSet.
func copyPDescriptorSetBytes(slice *sliceHeader) (*C.VkDescriptorSet, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDescriptorSetValue) * slice.Len,
		Cap:  int(sizeOfDescriptorSetValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDescriptorSet)(mem0), allocs
}

// allocDescriptorSetMemory allocates memory for type C.VkDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorSetValue = unsafe.Sizeof([1]C.VkDescriptorSet{})

// copyPBufferBytes copies the data from Go slice as *C.VkBuffer.
func copyPBufferBytes(slice *sliceHeader) (*C.VkBuffer, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfBufferValue) * slice.Len,
		Cap:  int(sizeOfBufferValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkBuffer)(mem0), allocs
}

// allocBufferMemory allocates memory for type C.VkBuffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferValue = unsafe.Sizeof([1]C.VkBuffer{})

// copyPDeviceSizeBytes copies the data from Go slice as *C.VkDeviceSize.
func copyPDeviceSizeBytes(slice *sliceHeader) (*C.VkDeviceSize, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDeviceSizeValue) * slice.Len,
		Cap:  int(sizeOfDeviceSizeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDeviceSize)(mem0), allocs
}

// allocDeviceSizeMemory allocates memory for type C.VkDeviceSize in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceSizeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceSizeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceSizeValue = unsafe.Sizeof([1]C.VkDeviceSize{})

// unpackArgSBufferCopy transforms a sliced Go data structure into plain C format.
func unpackArgSBufferCopy(x []BufferCopy) (unpacked *C.VkBufferCopy, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocBufferCopyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferCopy)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferCopy)(h.Data)
	return
}

// packSBufferCopy reads sliced Go data structure out from plain C format.
func packSBufferCopy(v []BufferCopy, ptr0 *C.VkBufferCopy) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferCopyValue]C.VkBufferCopy)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferCopyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageCopy transforms a sliced Go data structure into plain C format.
func unpackArgSImageCopy(x []ImageCopy) (unpacked *C.VkImageCopy, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocImageCopyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageCopy)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageCopy)(h.Data)
	return
}

// packSImageCopy reads sliced Go data structure out from plain C format.
func packSImageCopy(v []ImageCopy, ptr0 *C.VkImageCopy) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageCopyValue]C.VkImageCopy)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageCopyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageBlit transforms a sliced Go data structure into plain C format.
func unpackArgSImageBlit(x []ImageBlit) (unpacked *C.VkImageBlit, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocImageBlitMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageBlit)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageBlit)(h.Data)
	return
}

// packSImageBlit reads sliced Go data structure out from plain C format.
func packSImageBlit(v []ImageBlit, ptr0 *C.VkImageBlit) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageBlitValue]C.VkImageBlit)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageBlitRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBufferImageCopy transforms a sliced Go data structure into plain C format.
func unpackArgSBufferImageCopy(x []BufferImageCopy) (unpacked *C.VkBufferImageCopy, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocBufferImageCopyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferImageCopy)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferImageCopy)(h.Data)
	return
}

// packSBufferImageCopy reads sliced Go data structure out from plain C format.
func packSBufferImageCopy(v []BufferImageCopy, ptr0 *C.VkBufferImageCopy) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferImageCopyValue]C.VkBufferImageCopy)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferImageCopyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageSubresourceRange transforms a sliced Go data structure into plain C format.
func unpackArgSImageSubresourceRange(x []ImageSubresourceRange) (unpacked *C.VkImageSubresourceRange, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocImageSubresourceRangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageSubresourceRange)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageSubresourceRange)(h.Data)
	return
}

// packSImageSubresourceRange reads sliced Go data structure out from plain C format.
func packSImageSubresourceRange(v []ImageSubresourceRange, ptr0 *C.VkImageSubresourceRange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageSubresourceRangeValue]C.VkImageSubresourceRange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageSubresourceRangeRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSClearAttachment transforms a sliced Go data structure into plain C format.
func unpackArgSClearAttachment(x []ClearAttachment) (unpacked *C.VkClearAttachment, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocClearAttachmentMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkClearAttachment)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkClearAttachment)(h.Data)
	return
}

// packSClearAttachment reads sliced Go data structure out from plain C format.
func packSClearAttachment(v []ClearAttachment, ptr0 *C.VkClearAttachment) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfClearAttachmentValue]C.VkClearAttachment)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewClearAttachmentRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSClearRect transforms a sliced Go data structure into plain C format.
func unpackArgSClearRect(x []ClearRect) (unpacked *C.VkClearRect, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocClearRectMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkClearRect)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkClearRect)(h.Data)
	return
}

// packSClearRect reads sliced Go data structure out from plain C format.
func packSClearRect(v []ClearRect, ptr0 *C.VkClearRect) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfClearRectValue]C.VkClearRect)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewClearRectRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageResolve transforms a sliced Go data structure into plain C format.
func unpackArgSImageResolve(x []ImageResolve) (unpacked *C.VkImageResolve, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocImageResolveMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageResolve)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageResolve)(h.Data)
	return
}

// packSImageResolve reads sliced Go data structure out from plain C format.
func packSImageResolve(v []ImageResolve, ptr0 *C.VkImageResolve) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageResolveValue]C.VkImageResolve)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageResolveRef(unsafe.Pointer(&ptr1))
	}
}

// copyPEventBytes copies the data from Go slice as *C.VkEvent.
func copyPEventBytes(slice *sliceHeader) (*C.VkEvent, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfEventValue) * slice.Len,
		Cap:  int(sizeOfEventValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkEvent)(mem0), allocs
}

// allocEventMemory allocates memory for type C.VkEvent in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfEventValue = unsafe.Sizeof([1]C.VkEvent{})

// unpackArgSMemoryBarrier transforms a sliced Go data structure into plain C format.
func unpackArgSMemoryBarrier(x []MemoryBarrier) (unpacked *C.VkMemoryBarrier, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocMemoryBarrierMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMemoryBarrier)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMemoryBarrier)(h.Data)
	return
}

// packSMemoryBarrier reads sliced Go data structure out from plain C format.
func packSMemoryBarrier(v []MemoryBarrier, ptr0 *C.VkMemoryBarrier) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMemoryBarrierValue]C.VkMemoryBarrier)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMemoryBarrierRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBufferMemoryBarrier transforms a sliced Go data structure into plain C format.
func unpackArgSBufferMemoryBarrier(x []BufferMemoryBarrier) (unpacked *C.VkBufferMemoryBarrier, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocBufferMemoryBarrierMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferMemoryBarrier)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferMemoryBarrier)(h.Data)
	return
}

// packSBufferMemoryBarrier reads sliced Go data structure out from plain C format.
func packSBufferMemoryBarrier(v []BufferMemoryBarrier, ptr0 *C.VkBufferMemoryBarrier) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferMemoryBarrierValue]C.VkBufferMemoryBarrier)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferMemoryBarrierRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageMemoryBarrier transforms a sliced Go data structure into plain C format.
func unpackArgSImageMemoryBarrier(x []ImageMemoryBarrier) (unpacked *C.VkImageMemoryBarrier, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocImageMemoryBarrierMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageMemoryBarrier)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageMemoryBarrier)(h.Data)
	return
}

// packSImageMemoryBarrier reads sliced Go data structure out from plain C format.
func packSImageMemoryBarrier(v []ImageMemoryBarrier, ptr0 *C.VkImageMemoryBarrier) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageMemoryBarrierValue]C.VkImageMemoryBarrier)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageMemoryBarrierRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSurfaceFormat transforms a sliced Go data structure into plain C format.
func unpackArgSSurfaceFormat(x []SurfaceFormat) (unpacked *C.VkSurfaceFormatKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSurfaceFormatMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSurfaceFormatKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSurfaceFormatKHR)(h.Data)
	return
}

// packSSurfaceFormat reads sliced Go data structure out from plain C format.
func packSSurfaceFormat(v []SurfaceFormat, ptr0 *C.VkSurfaceFormatKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSurfaceFormatValue]C.VkSurfaceFormatKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSurfaceFormatRef(unsafe.Pointer(&ptr1))
	}
}

// copyPPresentModeBytes copies the data from Go slice as *C.VkPresentModeKHR.
func copyPPresentModeBytes(slice *sliceHeader) (*C.VkPresentModeKHR, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPresentModeValue) * slice.Len,
		Cap:  int(sizeOfPresentModeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkPresentModeKHR)(mem0), allocs
}

// allocPresentModeMemory allocates memory for type C.VkPresentModeKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentModeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentModeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPresentModeValue = unsafe.Sizeof([1]C.VkPresentModeKHR{})

// copyPImageBytes copies the data from Go slice as *C.VkImage.
func copyPImageBytes(slice *sliceHeader) (*C.VkImage, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfImageValue) * slice.Len,
		Cap:  int(sizeOfImageValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkImage)(mem0), allocs
}

// allocImageMemory allocates memory for type C.VkImage in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageValue = unsafe.Sizeof([1]C.VkImage{})

// unpackArgSDisplayProperties transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayProperties(x []DisplayProperties) (unpacked *C.VkDisplayPropertiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayPropertiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayPropertiesKHR)(h.Data)
	return
}

// packSDisplayProperties reads sliced Go data structure out from plain C format.
func packSDisplayProperties(v []DisplayProperties, ptr0 *C.VkDisplayPropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPropertiesValue]C.VkDisplayPropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayPlaneProperties transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayPlaneProperties(x []DisplayPlaneProperties) (unpacked *C.VkDisplayPlanePropertiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayPlanePropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayPlanePropertiesKHR)(h.Data)
	return
}

// packSDisplayPlaneProperties reads sliced Go data structure out from plain C format.
func packSDisplayPlaneProperties(v []DisplayPlaneProperties, ptr0 *C.VkDisplayPlanePropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPlanePropertiesValue]C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPlanePropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// copyPDisplayBytes copies the data from Go slice as *C.VkDisplayKHR.
func copyPDisplayBytes(slice *sliceHeader) (*C.VkDisplayKHR, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDisplayValue) * slice.Len,
		Cap:  int(sizeOfDisplayValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDisplayKHR)(mem0), allocs
}

// allocDisplayMemory allocates memory for type C.VkDisplayKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayValue = unsafe.Sizeof([1]C.VkDisplayKHR{})

// unpackArgSDisplayModeProperties transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayModeProperties(x []DisplayModeProperties) (unpacked *C.VkDisplayModePropertiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayModePropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayModePropertiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayModePropertiesKHR)(h.Data)
	return
}

// packSDisplayModeProperties reads sliced Go data structure out from plain C format.
func packSDisplayModeProperties(v []DisplayModeProperties, ptr0 *C.VkDisplayModePropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayModePropertiesValue]C.VkDisplayModePropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayModePropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSwapchainCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSSwapchainCreateInfo(x []SwapchainCreateInfo) (unpacked *C.VkSwapchainCreateInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSwapchainCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSwapchainCreateInfoKHR)(h.Data)
	return
}

// packSSwapchainCreateInfo reads sliced Go data structure out from plain C format.
func packSSwapchainCreateInfo(v []SwapchainCreateInfo, ptr0 *C.VkSwapchainCreateInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSwapchainCreateInfoValue]C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSwapchainCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}
